"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["node_modules_tw-elements_dist_js_tw-elements_es_min_js"],{

/***/ "./node_modules/tw-elements/dist/js/tw-elements.es.min.js":
/*!****************************************************************!*\
  !*** ./node_modules/tw-elements/dist/js/tw-elements.es.min.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Alert: function() { return /* binding */ Lo; },\n/* harmony export */   Animate: function() { return /* binding */ pr; },\n/* harmony export */   Button: function() { return /* binding */ rc; },\n/* harmony export */   Carousel: function() { return /* binding */ Ut; },\n/* harmony export */   Chart: function() { return /* binding */ dh; },\n/* harmony export */   Chip: function() { return /* binding */ _i; },\n/* harmony export */   ChipsInput: function() { return /* binding */ GC; },\n/* harmony export */   Clipboard: function() { return /* binding */ wh; },\n/* harmony export */   Collapse: function() { return /* binding */ Zt; },\n/* harmony export */   Datatable: function() { return /* binding */ gh; },\n/* harmony export */   Datepicker: function() { return /* binding */ Nm; },\n/* harmony export */   Datetimepicker: function() { return /* binding */ Ih; },\n/* harmony export */   Dropdown: function() { return /* binding */ Dt; },\n/* harmony export */   InfiniteScroll: function() { return /* binding */ kh; },\n/* harmony export */   Input: function() { return /* binding */ V; },\n/* harmony export */   LazyLoad: function() { return /* binding */ Uo; },\n/* harmony export */   Lightbox: function() { return /* binding */ Zs; },\n/* harmony export */   LoadingManagement: function() { return /* binding */ xh; },\n/* harmony export */   Modal: function() { return /* binding */ No; },\n/* harmony export */   Offcanvas: function() { return /* binding */ Bs; },\n/* harmony export */   PerfectScrollbar: function() { return /* binding */ mh; },\n/* harmony export */   Popconfirm: function() { return /* binding */ vh; },\n/* harmony export */   Popover: function() { return /* binding */ Rc; },\n/* harmony export */   Rating: function() { return /* binding */ qC; },\n/* harmony export */   Ripple: function() { return /* binding */ Ze; },\n/* harmony export */   ScrollSpy: function() { return /* binding */ Hc; },\n/* harmony export */   Select: function() { return /* binding */ _r; },\n/* harmony export */   Sidenav: function() { return /* binding */ gi; },\n/* harmony export */   SmoothScroll: function() { return /* binding */ yh; },\n/* harmony export */   Stepper: function() { return /* binding */ XC; },\n/* harmony export */   Sticky: function() { return /* binding */ $h; },\n/* harmony export */   Tab: function() { return /* binding */ Vc; },\n/* harmony export */   Timepicker: function() { return /* binding */ ng; },\n/* harmony export */   Toast: function() { return /* binding */ Ro; },\n/* harmony export */   Tooltip: function() { return /* binding */ ii; },\n/* harmony export */   Touch: function() { return /* binding */ Ah; },\n/* harmony export */   Validation: function() { return /* binding */ Ch; },\n/* harmony export */   initTE: function() { return /* binding */ ZC; }\n/* harmony export */ });\n/*!\n* Tailwind Elements 1.0.0\n* \n* Tailwind Elements is an open-source UI kit of advanced components for TailwindCSS.\n* Copyright © 2023 MDBootstrap.com\n* \n* Unless a custom, individually assigned license has been granted, this program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.\n* In addition, a custom license may be available upon request, subject to the terms and conditions of that license. Please contact tailwind@mdbootstrap.com for more information on obtaining a custom license.\n* This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.\n* \n*/\nvar Hh = Object.defineProperty;\nvar Vh = (s, t, e) => t in s ? Hh(s, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : s[t] = e;\nvar yt = (s, t, e) => (Vh(s, typeof t != \"symbol\" ? t + \"\" : t, e), e);\nconst Tn = (() => {\n  const s = {};\n  let t = 1;\n  return {\n    set(e, i, n) {\n      typeof e[i] > \"u\" && (e[i] = {\n        key: i,\n        id: t\n      }, t++), s[e[i].id] = n;\n    },\n    get(e, i) {\n      if (!e || typeof e[i] > \"u\")\n        return null;\n      const n = e[i];\n      return n.key === i ? s[n.id] : null;\n    },\n    delete(e, i) {\n      if (typeof e[i] > \"u\")\n        return;\n      const n = e[i];\n      n.key === i && (delete s[n.id], delete e[i]);\n    }\n  };\n})(), y = {\n  setData(s, t, e) {\n    Tn.set(s, t, e);\n  },\n  getData(s, t) {\n    return Tn.get(s, t);\n  },\n  removeData(s, t) {\n    Tn.delete(s, t);\n  }\n}, Wh = 1e6, Fh = 1e3, xo = \"transitionend\", Yh = (s) => s == null ? `${s}` : {}.toString.call(s).match(/\\s([a-z]+)/i)[1].toLowerCase(), rt = (s) => {\n  do\n    s += Math.floor(Math.random() * Wh);\n  while (document.getElementById(s));\n  return s;\n}, Ul = (s) => {\n  let t = s.getAttribute(\"data-te-target\");\n  if (!t || t === \"#\") {\n    let e = s.getAttribute(\"href\");\n    if (!e || !e.includes(\"#\") && !e.startsWith(\".\"))\n      return null;\n    e.includes(\"#\") && !e.startsWith(\"#\") && (e = `#${e.split(\"#\")[1]}`), t = e && e !== \"#\" ? e.trim() : null;\n  }\n  return t;\n}, qo = (s) => {\n  const t = Ul(s);\n  return t && document.querySelector(t) ? t : null;\n}, Jt = (s) => {\n  const t = Ul(s);\n  return t ? document.querySelector(t) : null;\n}, jh = (s) => {\n  if (!s)\n    return 0;\n  let { transitionDuration: t, transitionDelay: e } = window.getComputedStyle(s);\n  const i = Number.parseFloat(t), n = Number.parseFloat(e);\n  return !i && !n ? 0 : (t = t.split(\",\")[0], e = e.split(\",\")[0], (Number.parseFloat(t) + Number.parseFloat(e)) * Fh);\n}, Xl = (s) => {\n  s.dispatchEvent(new Event(xo));\n}, je = (s) => !s || typeof s != \"object\" ? !1 : (typeof s.jquery < \"u\" && (s = s[0]), typeof s.nodeType < \"u\"), te = (s) => je(s) ? s.jquery ? s[0] : s : typeof s == \"string\" && s.length > 0 ? document.querySelector(s) : null, D = (s, t, e) => {\n  Object.keys(e).forEach((i) => {\n    const n = e[i], o = t[i], r = o && je(o) ? \"element\" : Yh(o);\n    if (!new RegExp(n).test(r))\n      throw new Error(\n        `${s.toUpperCase()}: Option \"${i}\" provided type \"${r}\" but expected type \"${n}\".`\n      );\n  });\n}, Nt = (s) => {\n  if (!s || s.getClientRects().length === 0)\n    return !1;\n  if (s.style && s.parentNode && s.parentNode.style) {\n    const t = getComputedStyle(s), e = getComputedStyle(s.parentNode);\n    return getComputedStyle(s).getPropertyValue(\"visibility\") === \"visible\" || t.display !== \"none\" && e.display !== \"none\" && t.visibility !== \"hidden\";\n  }\n  return !1;\n}, ge = (s) => !s || s.nodeType !== Node.ELEMENT_NODE || s.classList.contains(\"disabled\") ? !0 : typeof s.disabled < \"u\" ? s.disabled : s.hasAttribute(\"disabled\") && s.getAttribute(\"disabled\") !== \"false\", Gl = (s) => {\n  if (!document.documentElement.attachShadow)\n    return null;\n  if (typeof s.getRootNode == \"function\") {\n    const t = s.getRootNode();\n    return t instanceof ShadowRoot ? t : null;\n  }\n  return s instanceof ShadowRoot ? s : s.parentNode ? Gl(s.parentNode) : null;\n}, tn = () => function() {\n}, Je = (s) => {\n  s.offsetHeight;\n}, ql = () => {\n  const { jQuery: s } = window;\n  return s && !document.body.hasAttribute(\"data-te-no-jquery\") ? s : null;\n}, En = [], Zl = (s) => {\n  document.readyState === \"loading\" ? (En.length || document.addEventListener(\"DOMContentLoaded\", () => {\n    En.forEach((t) => t());\n  }), En.push(s)) : s();\n}, F = () => document.documentElement.dir === \"rtl\", Kh = (s) => Array.from(s), $ = (s) => document.createElement(s), me = (s) => {\n  typeof s == \"function\" && s();\n}, Ql = (s, t, e = !0) => {\n  if (!e) {\n    me(s);\n    return;\n  }\n  const i = 5, n = jh(t) + i;\n  let o = !1;\n  const r = ({ target: a }) => {\n    a === t && (o = !0, t.removeEventListener(xo, r), me(s));\n  };\n  t.addEventListener(xo, r), setTimeout(() => {\n    o || Xl(t);\n  }, n);\n}, Jl = (s, t, e, i) => {\n  let n = s.indexOf(t);\n  if (n === -1)\n    return s[!e && i ? s.length - 1 : 0];\n  const o = s.length;\n  return n += e ? 1 : -1, i && (n = (n + o) % o), s[Math.max(0, Math.min(n, o - 1))];\n}, zh = /[^.]*(?=\\..*)\\.|.*/, Uh = /\\..*/, Xh = /::\\d+$/, Cn = {};\nlet xr = 1;\nconst Gh = {\n  mouseenter: \"mouseover\",\n  mouseleave: \"mouseout\"\n}, qh = /^(mouseenter|mouseleave)/i, tc = /* @__PURE__ */ new Set([\n  \"click\",\n  \"dblclick\",\n  \"mouseup\",\n  \"mousedown\",\n  \"contextmenu\",\n  \"mousewheel\",\n  \"DOMMouseScroll\",\n  \"mouseover\",\n  \"mouseout\",\n  \"mousemove\",\n  \"selectstart\",\n  \"selectend\",\n  \"keydown\",\n  \"keypress\",\n  \"keyup\",\n  \"orientationchange\",\n  \"touchstart\",\n  \"touchmove\",\n  \"touchend\",\n  \"touchcancel\",\n  \"pointerdown\",\n  \"pointermove\",\n  \"pointerup\",\n  \"pointerleave\",\n  \"pointercancel\",\n  \"gesturestart\",\n  \"gesturechange\",\n  \"gestureend\",\n  \"focus\",\n  \"blur\",\n  \"change\",\n  \"reset\",\n  \"select\",\n  \"submit\",\n  \"focusin\",\n  \"focusout\",\n  \"load\",\n  \"unload\",\n  \"beforeunload\",\n  \"resize\",\n  \"move\",\n  \"DOMContentLoaded\",\n  \"readystatechange\",\n  \"error\",\n  \"abort\",\n  \"scroll\"\n]);\nfunction ec(s, t) {\n  return t && `${t}::${xr++}` || s.uidEvent || xr++;\n}\nfunction ic(s) {\n  const t = ec(s);\n  return s.uidEvent = t, Cn[t] = Cn[t] || {}, Cn[t];\n}\nfunction Zh(s, t) {\n  return function e(i) {\n    return i.delegateTarget = s, e.oneOff && c.off(s, i.type, t), t.apply(s, [i]);\n  };\n}\nfunction Qh(s, t, e) {\n  return function i(n) {\n    const o = s.querySelectorAll(t);\n    for (let { target: r } = n; r && r !== this; r = r.parentNode)\n      for (let a = o.length; a--; \"\")\n        if (o[a] === r)\n          return n.delegateTarget = r, i.oneOff && c.off(s, n.type, e), e.apply(r, [n]);\n    return null;\n  };\n}\nfunction sc(s, t, e = null) {\n  const i = Object.keys(s);\n  for (let n = 0, o = i.length; n < o; n++) {\n    const r = s[i[n]];\n    if (r.originalHandler === t && r.delegationSelector === e)\n      return r;\n  }\n  return null;\n}\nfunction nc(s, t, e) {\n  const i = typeof t == \"string\", n = i ? e : t;\n  let o = oc(s);\n  return tc.has(o) || (o = s), [i, n, o];\n}\nfunction Or(s, t, e, i, n) {\n  if (typeof t != \"string\" || !s)\n    return;\n  if (e || (e = i, i = null), qh.test(t)) {\n    const g = (m) => function(b) {\n      if (!b.relatedTarget || b.relatedTarget !== b.delegateTarget && !b.delegateTarget.contains(b.relatedTarget))\n        return m.call(this, b);\n    };\n    i ? i = g(i) : e = g(e);\n  }\n  const [o, r, a] = nc(\n    t,\n    e,\n    i\n  ), l = ic(s), p = l[a] || (l[a] = {}), u = sc(\n    p,\n    r,\n    o ? e : null\n  );\n  if (u) {\n    u.oneOff = u.oneOff && n;\n    return;\n  }\n  const _ = ec(\n    r,\n    t.replace(zh, \"\")\n  ), f = o ? Qh(s, e, i) : Zh(s, e);\n  f.delegationSelector = o ? e : null, f.originalHandler = r, f.oneOff = n, f.uidEvent = _, p[_] = f, s.addEventListener(a, f, o);\n}\nfunction Oo(s, t, e, i, n) {\n  const o = sc(t[e], i, n);\n  o && (s.removeEventListener(e, o, !!n), delete t[e][o.uidEvent]);\n}\nfunction Jh(s, t, e, i) {\n  const n = t[e] || {};\n  Object.keys(n).forEach((o) => {\n    if (o.includes(i)) {\n      const r = n[o];\n      Oo(\n        s,\n        t,\n        e,\n        r.originalHandler,\n        r.delegationSelector\n      );\n    }\n  });\n}\nfunction oc(s) {\n  return s = s.replace(Uh, \"\"), Gh[s] || s;\n}\nconst c = {\n  on(s, t, e, i) {\n    Or(s, t, e, i, !1);\n  },\n  one(s, t, e, i) {\n    Or(s, t, e, i, !0);\n  },\n  off(s, t, e, i) {\n    if (typeof t != \"string\" || !s)\n      return;\n    const [n, o, r] = nc(\n      t,\n      e,\n      i\n    ), a = r !== t, l = ic(s), p = t.startsWith(\".\");\n    if (typeof o < \"u\") {\n      if (!l || !l[r])\n        return;\n      Oo(\n        s,\n        l,\n        r,\n        o,\n        n ? e : null\n      );\n      return;\n    }\n    p && Object.keys(l).forEach((_) => {\n      Jh(\n        s,\n        l,\n        _,\n        t.slice(1)\n      );\n    });\n    const u = l[r] || {};\n    Object.keys(u).forEach((_) => {\n      const f = _.replace(Xh, \"\");\n      if (!a || t.includes(f)) {\n        const g = u[_];\n        Oo(\n          s,\n          l,\n          r,\n          g.originalHandler,\n          g.delegationSelector\n        );\n      }\n    });\n  },\n  trigger(s, t, e) {\n    if (typeof t != \"string\" || !s)\n      return null;\n    const i = ql(), n = oc(t), o = t !== n, r = tc.has(n);\n    let a, l = !0, p = !0, u = !1, _ = null;\n    return o && i && (a = i.Event(t, e), i(s).trigger(a), l = !a.isPropagationStopped(), p = !a.isImmediatePropagationStopped(), u = a.isDefaultPrevented()), r ? (_ = document.createEvent(\"HTMLEvents\"), _.initEvent(n, l, !0)) : _ = new CustomEvent(t, {\n      bubbles: l,\n      cancelable: !0\n    }), typeof e < \"u\" && Object.keys(e).forEach((f) => {\n      Object.defineProperty(_, f, {\n        get() {\n          return e[f];\n        }\n      });\n    }), u && _.preventDefault(), p && s.dispatchEvent(_), _.defaultPrevented && typeof a < \"u\" && a.preventDefault(), _;\n  }\n}, re = {\n  on(s, t, e, i) {\n    const n = t.split(\" \");\n    for (let o = 0; o < n.length; o++)\n      c.on(s, n[o], e, i);\n  },\n  off(s, t, e, i) {\n    const n = t.split(\" \");\n    for (let o = 0; o < n.length; o++)\n      c.off(s, n[o], e, i);\n  }\n}, td = \"5.1.3\";\nclass gt {\n  constructor(t) {\n    t = te(t), t && (this._element = t, y.setData(this._element, this.constructor.DATA_KEY, this));\n  }\n  dispose() {\n    y.removeData(this._element, this.constructor.DATA_KEY), c.off(this._element, this.constructor.EVENT_KEY), Object.getOwnPropertyNames(this).forEach((t) => {\n      this[t] = null;\n    });\n  }\n  _queueCallback(t, e, i = !0) {\n    Ql(t, e, i);\n  }\n  /** Static */\n  static getInstance(t) {\n    return y.getData(te(t), this.DATA_KEY);\n  }\n  static getOrCreateInstance(t, e = {}) {\n    return this.getInstance(t) || new this(t, typeof e == \"object\" ? e : null);\n  }\n  static get VERSION() {\n    return td;\n  }\n  static get NAME() {\n    throw new Error(\n      'You have to implement the static method \"NAME\", for each component!'\n    );\n  }\n  static get DATA_KEY() {\n    return `te.${this.NAME}`;\n  }\n  static get EVENT_KEY() {\n    return `.${this.DATA_KEY}`;\n  }\n}\nconst ed = \"button\", id = \"active\";\nclass rc extends gt {\n  // Getters\n  static get NAME() {\n    return ed;\n  }\n  // Public\n  toggle() {\n    this._element.setAttribute(\n      \"aria-pressed\",\n      this._element.classList.toggle(id)\n    );\n  }\n  // Static\n  static jQueryInterface(t) {\n    return this.each(function() {\n      const e = rc.getOrCreateInstance(this);\n      t === \"toggle\" && e[t]();\n    });\n  }\n}\nvar Q = \"top\", dt = \"bottom\", ut = \"right\", J = \"left\", Hi = \"auto\", ti = [Q, dt, ut, J], Te = \"start\", Ke = \"end\", ac = \"clippingParents\", Zo = \"viewport\", $e = \"popper\", lc = \"reference\", So = /* @__PURE__ */ ti.reduce(function(s, t) {\n  return s.concat([t + \"-\" + Te, t + \"-\" + Ke]);\n}, []), Qo = /* @__PURE__ */ [].concat(ti, [Hi]).reduce(function(s, t) {\n  return s.concat([t, t + \"-\" + Te, t + \"-\" + Ke]);\n}, []), cc = \"beforeRead\", hc = \"read\", dc = \"afterRead\", uc = \"beforeMain\", pc = \"main\", _c = \"afterMain\", fc = \"beforeWrite\", mc = \"write\", gc = \"afterWrite\", en = [cc, hc, dc, uc, pc, _c, fc, mc, gc];\nfunction Mt(s) {\n  return s ? (s.nodeName || \"\").toLowerCase() : null;\n}\nfunction pt(s) {\n  if (s == null)\n    return window;\n  if (s.toString() !== \"[object Window]\") {\n    var t = s.ownerDocument;\n    return t && t.defaultView || window;\n  }\n  return s;\n}\nfunction Ee(s) {\n  var t = pt(s).Element;\n  return s instanceof t || s instanceof Element;\n}\nfunction ht(s) {\n  var t = pt(s).HTMLElement;\n  return s instanceof t || s instanceof HTMLElement;\n}\nfunction Jo(s) {\n  if (typeof ShadowRoot > \"u\")\n    return !1;\n  var t = pt(s).ShadowRoot;\n  return s instanceof t || s instanceof ShadowRoot;\n}\nfunction sd(s) {\n  var t = s.state;\n  Object.keys(t.elements).forEach(function(e) {\n    var i = t.styles[e] || {}, n = t.attributes[e] || {}, o = t.elements[e];\n    !ht(o) || !Mt(o) || (Object.assign(o.style, i), Object.keys(n).forEach(function(r) {\n      var a = n[r];\n      a === !1 ? o.removeAttribute(r) : o.setAttribute(r, a === !0 ? \"\" : a);\n    }));\n  });\n}\nfunction nd(s) {\n  var t = s.state, e = {\n    popper: {\n      position: t.options.strategy,\n      left: \"0\",\n      top: \"0\",\n      margin: \"0\"\n    },\n    arrow: {\n      position: \"absolute\"\n    },\n    reference: {}\n  };\n  return Object.assign(t.elements.popper.style, e.popper), t.styles = e, t.elements.arrow && Object.assign(t.elements.arrow.style, e.arrow), function() {\n    Object.keys(t.elements).forEach(function(i) {\n      var n = t.elements[i], o = t.attributes[i] || {}, r = Object.keys(t.styles.hasOwnProperty(i) ? t.styles[i] : e[i]), a = r.reduce(function(l, p) {\n        return l[p] = \"\", l;\n      }, {});\n      !ht(n) || !Mt(n) || (Object.assign(n.style, a), Object.keys(o).forEach(function(l) {\n        n.removeAttribute(l);\n      }));\n    });\n  };\n}\nconst tr = {\n  name: \"applyStyles\",\n  enabled: !0,\n  phase: \"write\",\n  fn: sd,\n  effect: nd,\n  requires: [\"computeStyles\"]\n};\nfunction Tt(s) {\n  return s.split(\"-\")[0];\n}\nvar be = Math.max, sn = Math.min, ze = Math.round;\nfunction Io() {\n  var s = navigator.userAgentData;\n  return s != null && s.brands && Array.isArray(s.brands) ? s.brands.map(function(t) {\n    return t.brand + \"/\" + t.version;\n  }).join(\" \") : navigator.userAgent;\n}\nfunction bc() {\n  return !/^((?!chrome|android).)*safari/i.test(Io());\n}\nfunction Ue(s, t, e) {\n  t === void 0 && (t = !1), e === void 0 && (e = !1);\n  var i = s.getBoundingClientRect(), n = 1, o = 1;\n  t && ht(s) && (n = s.offsetWidth > 0 && ze(i.width) / s.offsetWidth || 1, o = s.offsetHeight > 0 && ze(i.height) / s.offsetHeight || 1);\n  var r = Ee(s) ? pt(s) : window, a = r.visualViewport, l = !bc() && e, p = (i.left + (l && a ? a.offsetLeft : 0)) / n, u = (i.top + (l && a ? a.offsetTop : 0)) / o, _ = i.width / n, f = i.height / o;\n  return {\n    width: _,\n    height: f,\n    top: u,\n    right: p + _,\n    bottom: u + f,\n    left: p,\n    x: p,\n    y: u\n  };\n}\nfunction er(s) {\n  var t = Ue(s), e = s.offsetWidth, i = s.offsetHeight;\n  return Math.abs(t.width - e) <= 1 && (e = t.width), Math.abs(t.height - i) <= 1 && (i = t.height), {\n    x: s.offsetLeft,\n    y: s.offsetTop,\n    width: e,\n    height: i\n  };\n}\nfunction vc(s, t) {\n  var e = t.getRootNode && t.getRootNode();\n  if (s.contains(t))\n    return !0;\n  if (e && Jo(e)) {\n    var i = t;\n    do {\n      if (i && s.isSameNode(i))\n        return !0;\n      i = i.parentNode || i.host;\n    } while (i);\n  }\n  return !1;\n}\nfunction Ct(s) {\n  return pt(s).getComputedStyle(s);\n}\nfunction od(s) {\n  return [\"table\", \"td\", \"th\"].indexOf(Mt(s)) >= 0;\n}\nfunction ee(s) {\n  return ((Ee(s) ? s.ownerDocument : (\n    // $FlowFixMe[prop-missing]\n    s.document\n  )) || window.document).documentElement;\n}\nfunction rn(s) {\n  return Mt(s) === \"html\" ? s : (\n    // this is a quicker (but less type safe) way to save quite some bytes from the bundle\n    // $FlowFixMe[incompatible-return]\n    // $FlowFixMe[prop-missing]\n    s.assignedSlot || // step into the shadow DOM of the parent of a slotted node\n    s.parentNode || // DOM Element detected\n    (Jo(s) ? s.host : null) || // ShadowRoot detected\n    // $FlowFixMe[incompatible-call]: HTMLElement is a Node\n    ee(s)\n  );\n}\nfunction Sr(s) {\n  return !ht(s) || // https://github.com/popperjs/popper-core/issues/837\n  Ct(s).position === \"fixed\" ? null : s.offsetParent;\n}\nfunction rd(s) {\n  var t = /firefox/i.test(Io()), e = /Trident/i.test(Io());\n  if (e && ht(s)) {\n    var i = Ct(s);\n    if (i.position === \"fixed\")\n      return null;\n  }\n  var n = rn(s);\n  for (Jo(n) && (n = n.host); ht(n) && [\"html\", \"body\"].indexOf(Mt(n)) < 0; ) {\n    var o = Ct(n);\n    if (o.transform !== \"none\" || o.perspective !== \"none\" || o.contain === \"paint\" || [\"transform\", \"perspective\"].indexOf(o.willChange) !== -1 || t && o.willChange === \"filter\" || t && o.filter && o.filter !== \"none\")\n      return n;\n    n = n.parentNode;\n  }\n  return null;\n}\nfunction Vi(s) {\n  for (var t = pt(s), e = Sr(s); e && od(e) && Ct(e).position === \"static\"; )\n    e = Sr(e);\n  return e && (Mt(e) === \"html\" || Mt(e) === \"body\" && Ct(e).position === \"static\") ? t : e || rd(s) || t;\n}\nfunction ir(s) {\n  return [\"top\", \"bottom\"].indexOf(s) >= 0 ? \"x\" : \"y\";\n}\nfunction Si(s, t, e) {\n  return be(s, sn(t, e));\n}\nfunction ad(s, t, e) {\n  var i = Si(s, t, e);\n  return i > e ? e : i;\n}\nfunction Tc() {\n  return {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0\n  };\n}\nfunction Ec(s) {\n  return Object.assign({}, Tc(), s);\n}\nfunction Cc(s, t) {\n  return t.reduce(function(e, i) {\n    return e[i] = s, e;\n  }, {});\n}\nvar ld = function(t, e) {\n  return t = typeof t == \"function\" ? t(Object.assign({}, e.rects, {\n    placement: e.placement\n  })) : t, Ec(typeof t != \"number\" ? t : Cc(t, ti));\n};\nfunction cd(s) {\n  var t, e = s.state, i = s.name, n = s.options, o = e.elements.arrow, r = e.modifiersData.popperOffsets, a = Tt(e.placement), l = ir(a), p = [J, ut].indexOf(a) >= 0, u = p ? \"height\" : \"width\";\n  if (!(!o || !r)) {\n    var _ = ld(n.padding, e), f = er(o), g = l === \"y\" ? Q : J, m = l === \"y\" ? dt : ut, b = e.rects.reference[u] + e.rects.reference[l] - r[l] - e.rects.popper[u], v = r[l] - e.rects.reference[l], C = Vi(o), w = C ? l === \"y\" ? C.clientHeight || 0 : C.clientWidth || 0 : 0, E = b / 2 - v / 2, T = _[g], A = w - f[u] - _[m], k = w / 2 - f[u] / 2 + E, I = Si(T, k, A), O = l;\n    e.modifiersData[i] = (t = {}, t[O] = I, t.centerOffset = I - k, t);\n  }\n}\nfunction hd(s) {\n  var t = s.state, e = s.options, i = e.element, n = i === void 0 ? \"[data-popper-arrow]\" : i;\n  if (n != null && !(typeof n == \"string\" && (n = t.elements.popper.querySelector(n), !n))) {\n    if ({}.NODE_ENV !== \"production\" && (ht(n) || console.error(['Popper: \"arrow\" element must be an HTMLElement (not an SVGElement).', \"To use an SVG arrow, wrap it in an HTMLElement that will be used as\", \"the arrow.\"].join(\" \"))), !vc(t.elements.popper, n)) {\n      ({}).NODE_ENV !== \"production\" && console.error(['Popper: \"arrow\" modifier\\'s `element` must be a child of the popper', \"element.\"].join(\" \"));\n      return;\n    }\n    t.elements.arrow = n;\n  }\n}\nconst Ac = {\n  name: \"arrow\",\n  enabled: !0,\n  phase: \"main\",\n  fn: cd,\n  effect: hd,\n  requires: [\"popperOffsets\"],\n  requiresIfExists: [\"preventOverflow\"]\n};\nfunction Xe(s) {\n  return s.split(\"-\")[1];\n}\nvar dd = {\n  top: \"auto\",\n  right: \"auto\",\n  bottom: \"auto\",\n  left: \"auto\"\n};\nfunction ud(s, t) {\n  var e = s.x, i = s.y, n = t.devicePixelRatio || 1;\n  return {\n    x: ze(e * n) / n || 0,\n    y: ze(i * n) / n || 0\n  };\n}\nfunction Ir(s) {\n  var t, e = s.popper, i = s.popperRect, n = s.placement, o = s.variation, r = s.offsets, a = s.position, l = s.gpuAcceleration, p = s.adaptive, u = s.roundOffsets, _ = s.isFixed, f = r.x, g = f === void 0 ? 0 : f, m = r.y, b = m === void 0 ? 0 : m, v = typeof u == \"function\" ? u({\n    x: g,\n    y: b\n  }) : {\n    x: g,\n    y: b\n  };\n  g = v.x, b = v.y;\n  var C = r.hasOwnProperty(\"x\"), w = r.hasOwnProperty(\"y\"), E = J, T = Q, A = window;\n  if (p) {\n    var k = Vi(e), I = \"clientHeight\", O = \"clientWidth\";\n    if (k === pt(e) && (k = ee(e), Ct(k).position !== \"static\" && a === \"absolute\" && (I = \"scrollHeight\", O = \"scrollWidth\")), k = k, n === Q || (n === J || n === ut) && o === Ke) {\n      T = dt;\n      var x = _ && k === A && A.visualViewport ? A.visualViewport.height : (\n        // $FlowFixMe[prop-missing]\n        k[I]\n      );\n      b -= x - i.height, b *= l ? 1 : -1;\n    }\n    if (n === J || (n === Q || n === dt) && o === Ke) {\n      E = ut;\n      var L = _ && k === A && A.visualViewport ? A.visualViewport.width : (\n        // $FlowFixMe[prop-missing]\n        k[O]\n      );\n      g -= L - i.width, g *= l ? 1 : -1;\n    }\n  }\n  var S = Object.assign({\n    position: a\n  }, p && dd), N = u === !0 ? ud({\n    x: g,\n    y: b\n  }, pt(e)) : {\n    x: g,\n    y: b\n  };\n  if (g = N.x, b = N.y, l) {\n    var P;\n    return Object.assign({}, S, (P = {}, P[T] = w ? \"0\" : \"\", P[E] = C ? \"0\" : \"\", P.transform = (A.devicePixelRatio || 1) <= 1 ? \"translate(\" + g + \"px, \" + b + \"px)\" : \"translate3d(\" + g + \"px, \" + b + \"px, 0)\", P));\n  }\n  return Object.assign({}, S, (t = {}, t[T] = w ? b + \"px\" : \"\", t[E] = C ? g + \"px\" : \"\", t.transform = \"\", t));\n}\nfunction pd(s) {\n  var t = s.state, e = s.options, i = e.gpuAcceleration, n = i === void 0 ? !0 : i, o = e.adaptive, r = o === void 0 ? !0 : o, a = e.roundOffsets, l = a === void 0 ? !0 : a;\n  if ({}.NODE_ENV !== \"production\") {\n    var p = Ct(t.elements.popper).transitionProperty || \"\";\n    r && [\"transform\", \"top\", \"right\", \"bottom\", \"left\"].some(function(_) {\n      return p.indexOf(_) >= 0;\n    }) && console.warn([\"Popper: Detected CSS transitions on at least one of the following\", 'CSS properties: \"transform\", \"top\", \"right\", \"bottom\", \"left\".', `\n\n`, 'Disable the \"computeStyles\" modifier\\'s `adaptive` option to allow', \"for smooth transitions, or remove these properties from the CSS\", \"transition declaration on the popper element if only transitioning\", \"opacity or background-color for example.\", `\n\n`, \"We recommend using the popper element as a wrapper around an inner\", \"element that can have any CSS property transitioned for animations.\"].join(\" \"));\n  }\n  var u = {\n    placement: Tt(t.placement),\n    variation: Xe(t.placement),\n    popper: t.elements.popper,\n    popperRect: t.rects.popper,\n    gpuAcceleration: n,\n    isFixed: t.options.strategy === \"fixed\"\n  };\n  t.modifiersData.popperOffsets != null && (t.styles.popper = Object.assign({}, t.styles.popper, Ir(Object.assign({}, u, {\n    offsets: t.modifiersData.popperOffsets,\n    position: t.options.strategy,\n    adaptive: r,\n    roundOffsets: l\n  })))), t.modifiersData.arrow != null && (t.styles.arrow = Object.assign({}, t.styles.arrow, Ir(Object.assign({}, u, {\n    offsets: t.modifiersData.arrow,\n    position: \"absolute\",\n    adaptive: !1,\n    roundOffsets: l\n  })))), t.attributes.popper = Object.assign({}, t.attributes.popper, {\n    \"data-popper-placement\": t.placement\n  });\n}\nconst sr = {\n  name: \"computeStyles\",\n  enabled: !0,\n  phase: \"beforeWrite\",\n  fn: pd,\n  data: {}\n};\nvar ts = {\n  passive: !0\n};\nfunction _d(s) {\n  var t = s.state, e = s.instance, i = s.options, n = i.scroll, o = n === void 0 ? !0 : n, r = i.resize, a = r === void 0 ? !0 : r, l = pt(t.elements.popper), p = [].concat(t.scrollParents.reference, t.scrollParents.popper);\n  return o && p.forEach(function(u) {\n    u.addEventListener(\"scroll\", e.update, ts);\n  }), a && l.addEventListener(\"resize\", e.update, ts), function() {\n    o && p.forEach(function(u) {\n      u.removeEventListener(\"scroll\", e.update, ts);\n    }), a && l.removeEventListener(\"resize\", e.update, ts);\n  };\n}\nconst nr = {\n  name: \"eventListeners\",\n  enabled: !0,\n  phase: \"write\",\n  fn: function() {\n  },\n  effect: _d,\n  data: {}\n};\nvar fd = {\n  left: \"right\",\n  right: \"left\",\n  bottom: \"top\",\n  top: \"bottom\"\n};\nfunction Ms(s) {\n  return s.replace(/left|right|bottom|top/g, function(t) {\n    return fd[t];\n  });\n}\nvar md = {\n  start: \"end\",\n  end: \"start\"\n};\nfunction Dr(s) {\n  return s.replace(/start|end/g, function(t) {\n    return md[t];\n  });\n}\nfunction or(s) {\n  var t = pt(s), e = t.pageXOffset, i = t.pageYOffset;\n  return {\n    scrollLeft: e,\n    scrollTop: i\n  };\n}\nfunction rr(s) {\n  return Ue(ee(s)).left + or(s).scrollLeft;\n}\nfunction gd(s, t) {\n  var e = pt(s), i = ee(s), n = e.visualViewport, o = i.clientWidth, r = i.clientHeight, a = 0, l = 0;\n  if (n) {\n    o = n.width, r = n.height;\n    var p = bc();\n    (p || !p && t === \"fixed\") && (a = n.offsetLeft, l = n.offsetTop);\n  }\n  return {\n    width: o,\n    height: r,\n    x: a + rr(s),\n    y: l\n  };\n}\nfunction bd(s) {\n  var t, e = ee(s), i = or(s), n = (t = s.ownerDocument) == null ? void 0 : t.body, o = be(e.scrollWidth, e.clientWidth, n ? n.scrollWidth : 0, n ? n.clientWidth : 0), r = be(e.scrollHeight, e.clientHeight, n ? n.scrollHeight : 0, n ? n.clientHeight : 0), a = -i.scrollLeft + rr(s), l = -i.scrollTop;\n  return Ct(n || e).direction === \"rtl\" && (a += be(e.clientWidth, n ? n.clientWidth : 0) - o), {\n    width: o,\n    height: r,\n    x: a,\n    y: l\n  };\n}\nfunction ar(s) {\n  var t = Ct(s), e = t.overflow, i = t.overflowX, n = t.overflowY;\n  return /auto|scroll|overlay|hidden/.test(e + n + i);\n}\nfunction yc(s) {\n  return [\"html\", \"body\", \"#document\"].indexOf(Mt(s)) >= 0 ? s.ownerDocument.body : ht(s) && ar(s) ? s : yc(rn(s));\n}\nfunction Ii(s, t) {\n  var e;\n  t === void 0 && (t = []);\n  var i = yc(s), n = i === ((e = s.ownerDocument) == null ? void 0 : e.body), o = pt(i), r = n ? [o].concat(o.visualViewport || [], ar(i) ? i : []) : i, a = t.concat(r);\n  return n ? a : (\n    // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here\n    a.concat(Ii(rn(r)))\n  );\n}\nfunction Do(s) {\n  return Object.assign({}, s, {\n    left: s.x,\n    top: s.y,\n    right: s.x + s.width,\n    bottom: s.y + s.height\n  });\n}\nfunction vd(s, t) {\n  var e = Ue(s, !1, t === \"fixed\");\n  return e.top = e.top + s.clientTop, e.left = e.left + s.clientLeft, e.bottom = e.top + s.clientHeight, e.right = e.left + s.clientWidth, e.width = s.clientWidth, e.height = s.clientHeight, e.x = e.left, e.y = e.top, e;\n}\nfunction $r(s, t, e) {\n  return t === Zo ? Do(gd(s, e)) : Ee(t) ? vd(t, e) : Do(bd(ee(s)));\n}\nfunction Td(s) {\n  var t = Ii(rn(s)), e = [\"absolute\", \"fixed\"].indexOf(Ct(s).position) >= 0, i = e && ht(s) ? Vi(s) : s;\n  return Ee(i) ? t.filter(function(n) {\n    return Ee(n) && vc(n, i) && Mt(n) !== \"body\";\n  }) : [];\n}\nfunction Ed(s, t, e, i) {\n  var n = t === \"clippingParents\" ? Td(s) : [].concat(t), o = [].concat(n, [e]), r = o[0], a = o.reduce(function(l, p) {\n    var u = $r(s, p, i);\n    return l.top = be(u.top, l.top), l.right = sn(u.right, l.right), l.bottom = sn(u.bottom, l.bottom), l.left = be(u.left, l.left), l;\n  }, $r(s, r, i));\n  return a.width = a.right - a.left, a.height = a.bottom - a.top, a.x = a.left, a.y = a.top, a;\n}\nfunction wc(s) {\n  var t = s.reference, e = s.element, i = s.placement, n = i ? Tt(i) : null, o = i ? Xe(i) : null, r = t.x + t.width / 2 - e.width / 2, a = t.y + t.height / 2 - e.height / 2, l;\n  switch (n) {\n    case Q:\n      l = {\n        x: r,\n        y: t.y - e.height\n      };\n      break;\n    case dt:\n      l = {\n        x: r,\n        y: t.y + t.height\n      };\n      break;\n    case ut:\n      l = {\n        x: t.x + t.width,\n        y: a\n      };\n      break;\n    case J:\n      l = {\n        x: t.x - e.width,\n        y: a\n      };\n      break;\n    default:\n      l = {\n        x: t.x,\n        y: t.y\n      };\n  }\n  var p = n ? ir(n) : null;\n  if (p != null) {\n    var u = p === \"y\" ? \"height\" : \"width\";\n    switch (o) {\n      case Te:\n        l[p] = l[p] - (t[u] / 2 - e[u] / 2);\n        break;\n      case Ke:\n        l[p] = l[p] + (t[u] / 2 - e[u] / 2);\n        break;\n    }\n  }\n  return l;\n}\nfunction Ge(s, t) {\n  t === void 0 && (t = {});\n  var e = t, i = e.placement, n = i === void 0 ? s.placement : i, o = e.strategy, r = o === void 0 ? s.strategy : o, a = e.boundary, l = a === void 0 ? ac : a, p = e.rootBoundary, u = p === void 0 ? Zo : p, _ = e.elementContext, f = _ === void 0 ? $e : _, g = e.altBoundary, m = g === void 0 ? !1 : g, b = e.padding, v = b === void 0 ? 0 : b, C = Ec(typeof v != \"number\" ? v : Cc(v, ti)), w = f === $e ? lc : $e, E = s.rects.popper, T = s.elements[m ? w : f], A = Ed(Ee(T) ? T : T.contextElement || ee(s.elements.popper), l, u, r), k = Ue(s.elements.reference), I = wc({\n    reference: k,\n    element: E,\n    strategy: \"absolute\",\n    placement: n\n  }), O = Do(Object.assign({}, E, I)), x = f === $e ? O : k, L = {\n    top: A.top - x.top + C.top,\n    bottom: x.bottom - A.bottom + C.bottom,\n    left: A.left - x.left + C.left,\n    right: x.right - A.right + C.right\n  }, S = s.modifiersData.offset;\n  if (f === $e && S) {\n    var N = S[n];\n    Object.keys(L).forEach(function(P) {\n      var tt = [ut, dt].indexOf(P) >= 0 ? 1 : -1, et = [Q, dt].indexOf(P) >= 0 ? \"y\" : \"x\";\n      L[P] += N[et] * tt;\n    });\n  }\n  return L;\n}\nfunction Cd(s, t) {\n  t === void 0 && (t = {});\n  var e = t, i = e.placement, n = e.boundary, o = e.rootBoundary, r = e.padding, a = e.flipVariations, l = e.allowedAutoPlacements, p = l === void 0 ? Qo : l, u = Xe(i), _ = u ? a ? So : So.filter(function(m) {\n    return Xe(m) === u;\n  }) : ti, f = _.filter(function(m) {\n    return p.indexOf(m) >= 0;\n  });\n  f.length === 0 && (f = _, {}.NODE_ENV !== \"production\" && console.error([\"Popper: The `allowedAutoPlacements` option did not allow any\", \"placements. Ensure the `placement` option matches the variation\", \"of the allowed placements.\", 'For example, \"auto\" cannot be used to allow \"bottom-start\".', 'Use \"auto-start\" instead.'].join(\" \")));\n  var g = f.reduce(function(m, b) {\n    return m[b] = Ge(s, {\n      placement: b,\n      boundary: n,\n      rootBoundary: o,\n      padding: r\n    })[Tt(b)], m;\n  }, {});\n  return Object.keys(g).sort(function(m, b) {\n    return g[m] - g[b];\n  });\n}\nfunction Ad(s) {\n  if (Tt(s) === Hi)\n    return [];\n  var t = Ms(s);\n  return [Dr(s), t, Dr(t)];\n}\nfunction yd(s) {\n  var t = s.state, e = s.options, i = s.name;\n  if (!t.modifiersData[i]._skip) {\n    for (var n = e.mainAxis, o = n === void 0 ? !0 : n, r = e.altAxis, a = r === void 0 ? !0 : r, l = e.fallbackPlacements, p = e.padding, u = e.boundary, _ = e.rootBoundary, f = e.altBoundary, g = e.flipVariations, m = g === void 0 ? !0 : g, b = e.allowedAutoPlacements, v = t.options.placement, C = Tt(v), w = C === v, E = l || (w || !m ? [Ms(v)] : Ad(v)), T = [v].concat(E).reduce(function(ye, Ht) {\n      return ye.concat(Tt(Ht) === Hi ? Cd(t, {\n        placement: Ht,\n        boundary: u,\n        rootBoundary: _,\n        padding: p,\n        flipVariations: m,\n        allowedAutoPlacements: b\n      }) : Ht);\n    }, []), A = t.rects.reference, k = t.rects.popper, I = /* @__PURE__ */ new Map(), O = !0, x = T[0], L = 0; L < T.length; L++) {\n      var S = T[L], N = Tt(S), P = Xe(S) === Te, tt = [Q, dt].indexOf(N) >= 0, et = tt ? \"width\" : \"height\", U = Ge(t, {\n        placement: S,\n        boundary: u,\n        rootBoundary: _,\n        altBoundary: f,\n        padding: p\n      }), bt = tt ? P ? ut : J : P ? dt : Q;\n      A[et] > k[et] && (bt = Ms(bt));\n      var Gi = Ms(bt), se = [];\n      if (o && se.push(U[N] <= 0), a && se.push(U[bt] <= 0, U[Gi] <= 0), se.every(function(ye) {\n        return ye;\n      })) {\n        x = S, O = !1;\n        break;\n      }\n      I.set(S, se);\n    }\n    if (O)\n      for (var qi = m ? 3 : 1, mn = function(Ht) {\n        var ri = T.find(function(Qi) {\n          var ne = I.get(Qi);\n          if (ne)\n            return ne.slice(0, Ht).every(function(gn) {\n              return gn;\n            });\n        });\n        if (ri)\n          return x = ri, \"break\";\n      }, oi = qi; oi > 0; oi--) {\n        var Zi = mn(oi);\n        if (Zi === \"break\")\n          break;\n      }\n    t.placement !== x && (t.modifiersData[i]._skip = !0, t.placement = x, t.reset = !0);\n  }\n}\nconst kc = {\n  name: \"flip\",\n  enabled: !0,\n  phase: \"main\",\n  fn: yd,\n  requiresIfExists: [\"offset\"],\n  data: {\n    _skip: !1\n  }\n};\nfunction Lr(s, t, e) {\n  return e === void 0 && (e = {\n    x: 0,\n    y: 0\n  }), {\n    top: s.top - t.height - e.y,\n    right: s.right - t.width + e.x,\n    bottom: s.bottom - t.height + e.y,\n    left: s.left - t.width - e.x\n  };\n}\nfunction Nr(s) {\n  return [Q, ut, dt, J].some(function(t) {\n    return s[t] >= 0;\n  });\n}\nfunction wd(s) {\n  var t = s.state, e = s.name, i = t.rects.reference, n = t.rects.popper, o = t.modifiersData.preventOverflow, r = Ge(t, {\n    elementContext: \"reference\"\n  }), a = Ge(t, {\n    altBoundary: !0\n  }), l = Lr(r, i), p = Lr(a, n, o), u = Nr(l), _ = Nr(p);\n  t.modifiersData[e] = {\n    referenceClippingOffsets: l,\n    popperEscapeOffsets: p,\n    isReferenceHidden: u,\n    hasPopperEscaped: _\n  }, t.attributes.popper = Object.assign({}, t.attributes.popper, {\n    \"data-popper-reference-hidden\": u,\n    \"data-popper-escaped\": _\n  });\n}\nconst xc = {\n  name: \"hide\",\n  enabled: !0,\n  phase: \"main\",\n  requiresIfExists: [\"preventOverflow\"],\n  fn: wd\n};\nfunction kd(s, t, e) {\n  var i = Tt(s), n = [J, Q].indexOf(i) >= 0 ? -1 : 1, o = typeof e == \"function\" ? e(Object.assign({}, t, {\n    placement: s\n  })) : e, r = o[0], a = o[1];\n  return r = r || 0, a = (a || 0) * n, [J, ut].indexOf(i) >= 0 ? {\n    x: a,\n    y: r\n  } : {\n    x: r,\n    y: a\n  };\n}\nfunction xd(s) {\n  var t = s.state, e = s.options, i = s.name, n = e.offset, o = n === void 0 ? [0, 0] : n, r = Qo.reduce(function(u, _) {\n    return u[_] = kd(_, t.rects, o), u;\n  }, {}), a = r[t.placement], l = a.x, p = a.y;\n  t.modifiersData.popperOffsets != null && (t.modifiersData.popperOffsets.x += l, t.modifiersData.popperOffsets.y += p), t.modifiersData[i] = r;\n}\nconst Oc = {\n  name: \"offset\",\n  enabled: !0,\n  phase: \"main\",\n  requires: [\"popperOffsets\"],\n  fn: xd\n};\nfunction Od(s) {\n  var t = s.state, e = s.name;\n  t.modifiersData[e] = wc({\n    reference: t.rects.reference,\n    element: t.rects.popper,\n    strategy: \"absolute\",\n    placement: t.placement\n  });\n}\nconst lr = {\n  name: \"popperOffsets\",\n  enabled: !0,\n  phase: \"read\",\n  fn: Od,\n  data: {}\n};\nfunction Sd(s) {\n  return s === \"x\" ? \"y\" : \"x\";\n}\nfunction Id(s) {\n  var t = s.state, e = s.options, i = s.name, n = e.mainAxis, o = n === void 0 ? !0 : n, r = e.altAxis, a = r === void 0 ? !1 : r, l = e.boundary, p = e.rootBoundary, u = e.altBoundary, _ = e.padding, f = e.tether, g = f === void 0 ? !0 : f, m = e.tetherOffset, b = m === void 0 ? 0 : m, v = Ge(t, {\n    boundary: l,\n    rootBoundary: p,\n    padding: _,\n    altBoundary: u\n  }), C = Tt(t.placement), w = Xe(t.placement), E = !w, T = ir(C), A = Sd(T), k = t.modifiersData.popperOffsets, I = t.rects.reference, O = t.rects.popper, x = typeof b == \"function\" ? b(Object.assign({}, t.rects, {\n    placement: t.placement\n  })) : b, L = typeof x == \"number\" ? {\n    mainAxis: x,\n    altAxis: x\n  } : Object.assign({\n    mainAxis: 0,\n    altAxis: 0\n  }, x), S = t.modifiersData.offset ? t.modifiersData.offset[t.placement] : null, N = {\n    x: 0,\n    y: 0\n  };\n  if (k) {\n    if (o) {\n      var P, tt = T === \"y\" ? Q : J, et = T === \"y\" ? dt : ut, U = T === \"y\" ? \"height\" : \"width\", bt = k[T], Gi = bt + v[tt], se = bt - v[et], qi = g ? -O[U] / 2 : 0, mn = w === Te ? I[U] : O[U], oi = w === Te ? -O[U] : -I[U], Zi = t.elements.arrow, ye = g && Zi ? er(Zi) : {\n        width: 0,\n        height: 0\n      }, Ht = t.modifiersData[\"arrow#persistent\"] ? t.modifiersData[\"arrow#persistent\"].padding : Tc(), ri = Ht[tt], Qi = Ht[et], ne = Si(0, I[U], ye[U]), gn = E ? I[U] / 2 - qi - ne - ri - L.mainAxis : mn - ne - ri - L.mainAxis, Lh = E ? -I[U] / 2 + qi + ne + Qi + L.mainAxis : oi + ne + Qi + L.mainAxis, bn = t.elements.arrow && Vi(t.elements.arrow), Nh = bn ? T === \"y\" ? bn.clientTop || 0 : bn.clientLeft || 0 : 0, br = (P = S == null ? void 0 : S[T]) != null ? P : 0, Mh = bt + gn - br - Nh, Rh = bt + Lh - br, vr = Si(g ? sn(Gi, Mh) : Gi, bt, g ? be(se, Rh) : se);\n      k[T] = vr, N[T] = vr - bt;\n    }\n    if (a) {\n      var Tr, Ph = T === \"x\" ? Q : J, Bh = T === \"x\" ? dt : ut, oe = k[A], Ji = A === \"y\" ? \"height\" : \"width\", Er = oe + v[Ph], Cr = oe - v[Bh], vn = [Q, J].indexOf(C) !== -1, Ar = (Tr = S == null ? void 0 : S[A]) != null ? Tr : 0, yr = vn ? Er : oe - I[Ji] - O[Ji] - Ar + L.altAxis, wr = vn ? oe + I[Ji] + O[Ji] - Ar - L.altAxis : Cr, kr = g && vn ? ad(yr, oe, wr) : Si(g ? yr : Er, oe, g ? wr : Cr);\n      k[A] = kr, N[A] = kr - oe;\n    }\n    t.modifiersData[i] = N;\n  }\n}\nconst Sc = {\n  name: \"preventOverflow\",\n  enabled: !0,\n  phase: \"main\",\n  fn: Id,\n  requiresIfExists: [\"offset\"]\n};\nfunction Dd(s) {\n  return {\n    scrollLeft: s.scrollLeft,\n    scrollTop: s.scrollTop\n  };\n}\nfunction $d(s) {\n  return s === pt(s) || !ht(s) ? or(s) : Dd(s);\n}\nfunction Ld(s) {\n  var t = s.getBoundingClientRect(), e = ze(t.width) / s.offsetWidth || 1, i = ze(t.height) / s.offsetHeight || 1;\n  return e !== 1 || i !== 1;\n}\nfunction Nd(s, t, e) {\n  e === void 0 && (e = !1);\n  var i = ht(t), n = ht(t) && Ld(t), o = ee(t), r = Ue(s, n, e), a = {\n    scrollLeft: 0,\n    scrollTop: 0\n  }, l = {\n    x: 0,\n    y: 0\n  };\n  return (i || !i && !e) && ((Mt(t) !== \"body\" || // https://github.com/popperjs/popper-core/issues/1078\n  ar(o)) && (a = $d(t)), ht(t) ? (l = Ue(t, !0), l.x += t.clientLeft, l.y += t.clientTop) : o && (l.x = rr(o))), {\n    x: r.left + a.scrollLeft - l.x,\n    y: r.top + a.scrollTop - l.y,\n    width: r.width,\n    height: r.height\n  };\n}\nfunction Md(s) {\n  var t = /* @__PURE__ */ new Map(), e = /* @__PURE__ */ new Set(), i = [];\n  s.forEach(function(o) {\n    t.set(o.name, o);\n  });\n  function n(o) {\n    e.add(o.name);\n    var r = [].concat(o.requires || [], o.requiresIfExists || []);\n    r.forEach(function(a) {\n      if (!e.has(a)) {\n        var l = t.get(a);\n        l && n(l);\n      }\n    }), i.push(o);\n  }\n  return s.forEach(function(o) {\n    e.has(o.name) || n(o);\n  }), i;\n}\nfunction Rd(s) {\n  var t = Md(s);\n  return en.reduce(function(e, i) {\n    return e.concat(t.filter(function(n) {\n      return n.phase === i;\n    }));\n  }, []);\n}\nfunction Pd(s) {\n  var t;\n  return function() {\n    return t || (t = new Promise(function(e) {\n      Promise.resolve().then(function() {\n        t = void 0, e(s());\n      });\n    })), t;\n  };\n}\nfunction Vt(s) {\n  for (var t = arguments.length, e = new Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++)\n    e[i - 1] = arguments[i];\n  return [].concat(e).reduce(function(n, o) {\n    return n.replace(/%s/, o);\n  }, s);\n}\nvar ae = 'Popper: modifier \"%s\" provided an invalid %s property, expected %s but got %s', Bd = 'Popper: modifier \"%s\" requires \"%s\", but \"%s\" modifier is not available', Mr = [\"name\", \"enabled\", \"phase\", \"fn\", \"effect\", \"requires\", \"options\"];\nfunction Hd(s) {\n  s.forEach(function(t) {\n    [].concat(Object.keys(t), Mr).filter(function(e, i, n) {\n      return n.indexOf(e) === i;\n    }).forEach(function(e) {\n      switch (e) {\n        case \"name\":\n          typeof t.name != \"string\" && console.error(Vt(ae, String(t.name), '\"name\"', '\"string\"', '\"' + String(t.name) + '\"'));\n          break;\n        case \"enabled\":\n          typeof t.enabled != \"boolean\" && console.error(Vt(ae, t.name, '\"enabled\"', '\"boolean\"', '\"' + String(t.enabled) + '\"'));\n          break;\n        case \"phase\":\n          en.indexOf(t.phase) < 0 && console.error(Vt(ae, t.name, '\"phase\"', \"either \" + en.join(\", \"), '\"' + String(t.phase) + '\"'));\n          break;\n        case \"fn\":\n          typeof t.fn != \"function\" && console.error(Vt(ae, t.name, '\"fn\"', '\"function\"', '\"' + String(t.fn) + '\"'));\n          break;\n        case \"effect\":\n          t.effect != null && typeof t.effect != \"function\" && console.error(Vt(ae, t.name, '\"effect\"', '\"function\"', '\"' + String(t.fn) + '\"'));\n          break;\n        case \"requires\":\n          t.requires != null && !Array.isArray(t.requires) && console.error(Vt(ae, t.name, '\"requires\"', '\"array\"', '\"' + String(t.requires) + '\"'));\n          break;\n        case \"requiresIfExists\":\n          Array.isArray(t.requiresIfExists) || console.error(Vt(ae, t.name, '\"requiresIfExists\"', '\"array\"', '\"' + String(t.requiresIfExists) + '\"'));\n          break;\n        case \"options\":\n        case \"data\":\n          break;\n        default:\n          console.error('PopperJS: an invalid property has been provided to the \"' + t.name + '\" modifier, valid properties are ' + Mr.map(function(i) {\n            return '\"' + i + '\"';\n          }).join(\", \") + '; but \"' + e + '\" was provided.');\n      }\n      t.requires && t.requires.forEach(function(i) {\n        s.find(function(n) {\n          return n.name === i;\n        }) == null && console.error(Vt(Bd, String(t.name), i, i));\n      });\n    });\n  });\n}\nfunction Vd(s, t) {\n  var e = /* @__PURE__ */ new Set();\n  return s.filter(function(i) {\n    var n = t(i);\n    if (!e.has(n))\n      return e.add(n), !0;\n  });\n}\nfunction Wd(s) {\n  var t = s.reduce(function(e, i) {\n    var n = e[i.name];\n    return e[i.name] = n ? Object.assign({}, n, i, {\n      options: Object.assign({}, n.options, i.options),\n      data: Object.assign({}, n.data, i.data)\n    }) : i, e;\n  }, {});\n  return Object.keys(t).map(function(e) {\n    return t[e];\n  });\n}\nvar Rr = \"Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.\", Fd = \"Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.\", Pr = {\n  placement: \"bottom\",\n  modifiers: [],\n  strategy: \"absolute\"\n};\nfunction Br() {\n  for (var s = arguments.length, t = new Array(s), e = 0; e < s; e++)\n    t[e] = arguments[e];\n  return !t.some(function(i) {\n    return !(i && typeof i.getBoundingClientRect == \"function\");\n  });\n}\nfunction an(s) {\n  s === void 0 && (s = {});\n  var t = s, e = t.defaultModifiers, i = e === void 0 ? [] : e, n = t.defaultOptions, o = n === void 0 ? Pr : n;\n  return function(a, l, p) {\n    p === void 0 && (p = o);\n    var u = {\n      placement: \"bottom\",\n      orderedModifiers: [],\n      options: Object.assign({}, Pr, o),\n      modifiersData: {},\n      elements: {\n        reference: a,\n        popper: l\n      },\n      attributes: {},\n      styles: {}\n    }, _ = [], f = !1, g = {\n      state: u,\n      setOptions: function(C) {\n        var w = typeof C == \"function\" ? C(u.options) : C;\n        b(), u.options = Object.assign({}, o, u.options, w), u.scrollParents = {\n          reference: Ee(a) ? Ii(a) : a.contextElement ? Ii(a.contextElement) : [],\n          popper: Ii(l)\n        };\n        var E = Rd(Wd([].concat(i, u.options.modifiers)));\n        if (u.orderedModifiers = E.filter(function(S) {\n          return S.enabled;\n        }), {}.NODE_ENV !== \"production\") {\n          var T = Vd([].concat(E, u.options.modifiers), function(S) {\n            var N = S.name;\n            return N;\n          });\n          if (Hd(T), Tt(u.options.placement) === Hi) {\n            var A = u.orderedModifiers.find(function(S) {\n              var N = S.name;\n              return N === \"flip\";\n            });\n            A || console.error(['Popper: \"auto\" placements require the \"flip\" modifier be', \"present and enabled to work.\"].join(\" \"));\n          }\n          var k = Ct(l), I = k.marginTop, O = k.marginRight, x = k.marginBottom, L = k.marginLeft;\n          [I, O, x, L].some(function(S) {\n            return parseFloat(S);\n          }) && console.warn(['Popper: CSS \"margin\" styles cannot be used to apply padding', \"between the popper and its reference element or boundary.\", \"To replicate margin, use the `offset` modifier, as well as\", \"the `padding` option in the `preventOverflow` and `flip`\", \"modifiers.\"].join(\" \"));\n        }\n        return m(), g.update();\n      },\n      // Sync update – it will always be executed, even if not necessary. This\n      // is useful for low frequency updates where sync behavior simplifies the\n      // logic.\n      // For high frequency updates (e.g. `resize` and `scroll` events), always\n      // prefer the async Popper#update method\n      forceUpdate: function() {\n        if (!f) {\n          var C = u.elements, w = C.reference, E = C.popper;\n          if (!Br(w, E)) {\n            ({}).NODE_ENV !== \"production\" && console.error(Rr);\n            return;\n          }\n          u.rects = {\n            reference: Nd(w, Vi(E), u.options.strategy === \"fixed\"),\n            popper: er(E)\n          }, u.reset = !1, u.placement = u.options.placement, u.orderedModifiers.forEach(function(S) {\n            return u.modifiersData[S.name] = Object.assign({}, S.data);\n          });\n          for (var T = 0, A = 0; A < u.orderedModifiers.length; A++) {\n            if ({}.NODE_ENV !== \"production\" && (T += 1, T > 100)) {\n              console.error(Fd);\n              break;\n            }\n            if (u.reset === !0) {\n              u.reset = !1, A = -1;\n              continue;\n            }\n            var k = u.orderedModifiers[A], I = k.fn, O = k.options, x = O === void 0 ? {} : O, L = k.name;\n            typeof I == \"function\" && (u = I({\n              state: u,\n              options: x,\n              name: L,\n              instance: g\n            }) || u);\n          }\n        }\n      },\n      // Async and optimistically optimized update – it will not be executed if\n      // not necessary (debounced to run at most once-per-tick)\n      update: Pd(function() {\n        return new Promise(function(v) {\n          g.forceUpdate(), v(u);\n        });\n      }),\n      destroy: function() {\n        b(), f = !0;\n      }\n    };\n    if (!Br(a, l))\n      return {}.NODE_ENV !== \"production\" && console.error(Rr), g;\n    g.setOptions(p).then(function(v) {\n      !f && p.onFirstUpdate && p.onFirstUpdate(v);\n    });\n    function m() {\n      u.orderedModifiers.forEach(function(v) {\n        var C = v.name, w = v.options, E = w === void 0 ? {} : w, T = v.effect;\n        if (typeof T == \"function\") {\n          var A = T({\n            state: u,\n            name: C,\n            instance: g,\n            options: E\n          }), k = function() {\n          };\n          _.push(A || k);\n        }\n      });\n    }\n    function b() {\n      _.forEach(function(v) {\n        return v();\n      }), _ = [];\n    }\n    return g;\n  };\n}\nvar Yd = /* @__PURE__ */ an(), jd = [nr, lr, sr, tr], Kd = /* @__PURE__ */ an({\n  defaultModifiers: jd\n}), zd = [nr, lr, sr, tr, Oc, kc, Sc, Ac, xc], Ce = /* @__PURE__ */ an({\n  defaultModifiers: zd\n});\nconst Ic = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  afterMain: _c,\n  afterRead: dc,\n  afterWrite: gc,\n  applyStyles: tr,\n  arrow: Ac,\n  auto: Hi,\n  basePlacements: ti,\n  beforeMain: uc,\n  beforeRead: cc,\n  beforeWrite: fc,\n  bottom: dt,\n  clippingParents: ac,\n  computeStyles: sr,\n  createPopper: Ce,\n  createPopperBase: Yd,\n  createPopperLite: Kd,\n  detectOverflow: Ge,\n  end: Ke,\n  eventListeners: nr,\n  flip: kc,\n  hide: xc,\n  left: J,\n  main: pc,\n  modifierPhases: en,\n  offset: Oc,\n  placements: Qo,\n  popper: $e,\n  popperGenerator: an,\n  popperOffsets: lr,\n  preventOverflow: Sc,\n  read: hc,\n  reference: lc,\n  right: ut,\n  start: Te,\n  top: Q,\n  variationPlacements: So,\n  viewport: Zo,\n  write: mc\n}, Symbol.toStringTag, { value: \"Module\" }));\nfunction An(s) {\n  return s === \"true\" ? !0 : s === \"false\" ? !1 : s === Number(s).toString() ? Number(s) : s === \"\" || s === \"null\" ? null : s;\n}\nfunction yn(s) {\n  return s.replace(/[A-Z]/g, (t) => `-${t.toLowerCase()}`);\n}\nconst h = {\n  setDataAttribute(s, t, e) {\n    s.setAttribute(`data-te-${yn(t)}`, e);\n  },\n  removeDataAttribute(s, t) {\n    s.removeAttribute(`data-te-${yn(t)}`);\n  },\n  getDataAttributes(s) {\n    if (!s)\n      return {};\n    const t = {};\n    return Object.keys(s.dataset).filter((e) => e.startsWith(\"te\")).forEach((e) => {\n      if (e.startsWith(\"teClass\"))\n        return;\n      let i = e.replace(/^te/, \"\");\n      i = i.charAt(0).toLowerCase() + i.slice(1, i.length), t[i] = An(s.dataset[e]);\n    }), t;\n  },\n  getDataClassAttributes(s) {\n    if (!s)\n      return {};\n    const t = {\n      ...s.dataset\n    };\n    return Object.keys(t).filter((e) => e.startsWith(\"teClass\")).forEach((e) => {\n      let i = e.replace(/^teClass/, \"\");\n      i = i.charAt(0).toLowerCase() + i.slice(1, i.length), t[i] = An(t[e]);\n    }), t;\n  },\n  getDataAttribute(s, t) {\n    return An(\n      s.getAttribute(`data-te-${yn(t)}`)\n    );\n  },\n  offset(s) {\n    const t = s.getBoundingClientRect();\n    return {\n      top: t.top + document.body.scrollTop,\n      left: t.left + document.body.scrollLeft\n    };\n  },\n  position(s) {\n    return {\n      top: s.offsetTop,\n      left: s.offsetLeft\n    };\n  },\n  style(s, t) {\n    Object.assign(s.style, t);\n  },\n  toggleClass(s, t) {\n    s && wn(t).forEach((e) => {\n      s.classList.contains(e) ? s.classList.remove(e) : s.classList.add(e);\n    });\n  },\n  addClass(s, t) {\n    wn(t).forEach(\n      (e) => !s.classList.contains(e) && s.classList.add(e)\n    );\n  },\n  addStyle(s, t) {\n    Object.keys(t).forEach((e) => {\n      s.style[e] = t[e];\n    });\n  },\n  removeClass(s, t) {\n    wn(t).forEach(\n      (e) => s.classList.contains(e) && s.classList.remove(e)\n    );\n  },\n  hasClass(s, t) {\n    return s.classList.contains(t);\n  },\n  maxOffset(s) {\n    const t = s.getBoundingClientRect();\n    return {\n      top: t.top + Math.max(\n        document.body.scrollTop,\n        document.documentElement.scrollTop,\n        window.scrollY\n      ),\n      left: t.left + Math.max(\n        document.body.scrollLeft,\n        document.documentElement.scrollLeft,\n        window.scrollX\n      )\n    };\n  }\n};\nfunction wn(s) {\n  return typeof s == \"string\" ? s.split(\" \") : Array.isArray(s) ? s : !1;\n}\nconst Ud = 3, d = {\n  closest(s, t) {\n    return s.closest(t);\n  },\n  matches(s, t) {\n    return s.matches(t);\n  },\n  find(s, t = document.documentElement) {\n    return [].concat(\n      ...Element.prototype.querySelectorAll.call(t, s)\n    );\n  },\n  findOne(s, t = document.documentElement) {\n    return Element.prototype.querySelector.call(t, s);\n  },\n  children(s, t) {\n    return [].concat(...s.children).filter((i) => i.matches(t));\n  },\n  parents(s, t) {\n    const e = [];\n    let i = s.parentNode;\n    for (; i && i.nodeType === Node.ELEMENT_NODE && i.nodeType !== Ud; )\n      this.matches(i, t) && e.push(i), i = i.parentNode;\n    return e;\n  },\n  prev(s, t) {\n    let e = s.previousElementSibling;\n    for (; e; ) {\n      if (e.matches(t))\n        return [e];\n      e = e.previousElementSibling;\n    }\n    return [];\n  },\n  next(s, t) {\n    let e = s.nextElementSibling;\n    for (; e; ) {\n      if (this.matches(e, t))\n        return [e];\n      e = e.nextElementSibling;\n    }\n    return [];\n  },\n  focusableChildren(s) {\n    const t = [\n      \"a\",\n      \"button\",\n      \"input\",\n      \"textarea\",\n      \"select\",\n      \"details\",\n      \"[tabindex]\",\n      '[contenteditable=\"true\"]'\n    ].map((e) => `${e}:not([tabindex^=\"-\"])`).join(\", \");\n    return this.find(t, s).filter(\n      (e) => !ge(e) && Nt(e)\n    );\n  }\n}, kn = \"dropdown\", Xd = \"te.dropdown\", Ae = `.${Xd}`, cr = \".data-api\", Rs = \"Escape\", Hr = \"Space\", Vr = \"Tab\", $o = \"ArrowUp\", Ps = \"ArrowDown\", Gd = 2, qd = new RegExp(\n  `${$o}|${Ps}|${Rs}`\n), Zd = `hide${Ae}`, Qd = `hidden${Ae}`, Jd = `show${Ae}`, tu = `shown${Ae}`, eu = `click${Ae}${cr}`, Wr = `keydown${Ae}${cr}`, iu = `keyup${Ae}${cr}`, Wt = \"show\", su = \"dropup\", nu = \"dropend\", ou = \"dropstart\", ru = \"[data-te-navbar-ref]\", es = \"[data-te-dropdown-toggle-ref]\", xn = \"[data-te-dropdown-menu-ref]\", au = \"[data-te-navbar-nav-ref]\", lu = \"[data-te-dropdown-menu-ref] [data-te-dropdown-item-ref]:not(.disabled):not(:disabled)\", cu = F() ? \"top-end\" : \"top-start\", hu = F() ? \"top-start\" : \"top-end\", du = F() ? \"bottom-end\" : \"bottom-start\", uu = F() ? \"bottom-start\" : \"bottom-end\", pu = F() ? \"left-start\" : \"right-start\", _u = F() ? \"right-start\" : \"left-start\", fu = [{ opacity: \"0\" }, { opacity: \"1\" }], mu = [{ opacity: \"1\" }, { opacity: \"0\" }], is = {\n  duration: 550,\n  iterations: 1,\n  easing: \"ease\",\n  fill: \"both\"\n}, gu = {\n  offset: [0, 2],\n  boundary: \"clippingParents\",\n  reference: \"toggle\",\n  display: \"dynamic\",\n  popperConfig: null,\n  autoClose: !0,\n  dropdownAnimation: \"on\"\n}, bu = {\n  offset: \"(array|string|function)\",\n  boundary: \"(string|element)\",\n  reference: \"(string|element|object)\",\n  display: \"string\",\n  popperConfig: \"(null|object|function)\",\n  autoClose: \"(boolean|string)\",\n  dropdownAnimation: \"string\"\n};\nclass Dt extends gt {\n  constructor(t, e) {\n    super(t), this._popper = null, this._config = this._getConfig(e), this._menu = this._getMenuElement(), this._inNavbar = this._detectNavbar(), this._fadeOutAnimate = null;\n    const i = window.matchMedia(\n      \"(prefers-reduced-motion: reduce)\"\n    ).matches;\n    this._animationCanPlay = this._config.dropdownAnimation === \"on\" && !i, this._didInit = !1, this._init();\n  }\n  // Getters\n  static get Default() {\n    return gu;\n  }\n  static get DefaultType() {\n    return bu;\n  }\n  static get NAME() {\n    return kn;\n  }\n  // Public\n  toggle() {\n    return this._isShown() ? this.hide() : this.show();\n  }\n  show() {\n    if (ge(this._element) || this._isShown(this._menu))\n      return;\n    const t = {\n      relatedTarget: this._element\n    };\n    if (c.trigger(\n      this._element,\n      Jd,\n      t\n    ).defaultPrevented)\n      return;\n    const i = Dt.getParentFromElement(this._element);\n    this._inNavbar ? h.setDataAttribute(this._menu, \"popper\", \"none\") : this._createPopper(i), \"ontouchstart\" in document.documentElement && !i.closest(au) && [].concat(...document.body.children).forEach((n) => c.on(n, \"mouseover\", tn)), this._element.focus(), this._element.setAttribute(\"aria-expanded\", !0), this._menu.setAttribute(`data-te-dropdown-${Wt}`, \"\"), this._animationCanPlay && this._menu.animate(fu, is), this._element.setAttribute(`data-te-dropdown-${Wt}`, \"\"), setTimeout(\n      () => {\n        c.trigger(this._element, tu, t);\n      },\n      this._animationCanPlay ? is.duration : 0\n    );\n  }\n  hide() {\n    if (ge(this._element) || !this._isShown(this._menu))\n      return;\n    const t = {\n      relatedTarget: this._element\n    };\n    this._completeHide(t);\n  }\n  dispose() {\n    this._popper && this._popper.destroy(), super.dispose();\n  }\n  update() {\n    this._inNavbar = this._detectNavbar(), this._popper && this._popper.update();\n  }\n  // Private\n  _init() {\n    this._didInit || (c.on(\n      document,\n      Wr,\n      es,\n      Dt.dataApiKeydownHandler\n    ), c.on(\n      document,\n      Wr,\n      xn,\n      Dt.dataApiKeydownHandler\n    ), c.on(document, eu, Dt.clearMenus), c.on(document, iu, Dt.clearMenus), this._didInit = !0);\n  }\n  _completeHide(t) {\n    this._fadeOutAnimate && this._fadeOutAnimate.playState === \"running\" || c.trigger(\n      this._element,\n      Zd,\n      t\n    ).defaultPrevented || (\"ontouchstart\" in document.documentElement && [].concat(...document.body.children).forEach((i) => c.off(i, \"mouseover\", tn)), this._animationCanPlay && (this._fadeOutAnimate = this._menu.animate(\n      mu,\n      is\n    )), setTimeout(\n      () => {\n        this._popper && this._popper.destroy(), this._menu.removeAttribute(`data-te-dropdown-${Wt}`), this._element.removeAttribute(`data-te-dropdown-${Wt}`), this._element.setAttribute(\"aria-expanded\", \"false\"), h.removeDataAttribute(this._menu, \"popper\"), c.trigger(this._element, Qd, t);\n      },\n      this._animationCanPlay ? is.duration : 0\n    ));\n  }\n  _getConfig(t) {\n    if (t = {\n      ...this.constructor.Default,\n      ...h.getDataAttributes(this._element),\n      ...t\n    }, D(kn, t, this.constructor.DefaultType), typeof t.reference == \"object\" && !je(t.reference) && typeof t.reference.getBoundingClientRect != \"function\")\n      throw new TypeError(\n        `${kn.toUpperCase()}: Option \"reference\" provided type \"object\" without a required \"getBoundingClientRect\" method.`\n      );\n    return t;\n  }\n  _createPopper(t) {\n    if (typeof Ic > \"u\")\n      throw new TypeError(\n        \"Bootstrap's dropdowns require Popper (https://popper.js.org)\"\n      );\n    let e = this._element;\n    this._config.reference === \"parent\" ? e = t : je(this._config.reference) ? e = te(this._config.reference) : typeof this._config.reference == \"object\" && (e = this._config.reference);\n    const i = this._getPopperConfig(), n = i.modifiers.find(\n      (o) => o.name === \"applyStyles\" && o.enabled === !1\n    );\n    this._popper = Ce(\n      e,\n      this._menu,\n      i\n    ), n && h.setDataAttribute(this._menu, \"popper\", \"static\");\n  }\n  _isShown(t = this._element) {\n    return t.dataset[`teDropdown${Wt.charAt(0).toUpperCase() + Wt.slice(1)}`] === \"\";\n  }\n  _getMenuElement() {\n    return d.next(this._element, xn)[0];\n  }\n  _getPlacement() {\n    const t = this._element.parentNode;\n    if (t.dataset.teDropdownPosition === nu)\n      return pu;\n    if (t.dataset.teDropdownPosition === ou)\n      return _u;\n    const e = t.dataset.teDropdownAlignment === \"end\";\n    return t.dataset.teDropdownPosition === su ? e ? hu : cu : e ? uu : du;\n  }\n  _detectNavbar() {\n    return this._element.closest(ru) !== null;\n  }\n  _getOffset() {\n    const { offset: t } = this._config;\n    return typeof t == \"string\" ? t.split(\",\").map((e) => Number.parseInt(e, 10)) : typeof t == \"function\" ? (e) => t(e, this._element) : t;\n  }\n  _getPopperConfig() {\n    const t = {\n      placement: this._getPlacement(),\n      modifiers: [\n        {\n          name: \"preventOverflow\",\n          options: {\n            boundary: this._config.boundary\n          }\n        },\n        {\n          name: \"offset\",\n          options: {\n            offset: this._getOffset()\n          }\n        }\n      ]\n    };\n    return this._config.display === \"static\" && (t.modifiers = [\n      {\n        name: \"applyStyles\",\n        enabled: !1\n      }\n    ]), {\n      ...t,\n      ...typeof this._config.popperConfig == \"function\" ? this._config.popperConfig(t) : this._config.popperConfig\n    };\n  }\n  _selectMenuItem({ key: t, target: e }) {\n    const i = d.find(\n      lu,\n      this._menu\n    ).filter(Nt);\n    i.length && Jl(\n      i,\n      e,\n      t === Ps,\n      !i.includes(e)\n    ).focus();\n  }\n  // Static\n  static jQueryInterface(t) {\n    return this.each(function() {\n      const e = Dt.getOrCreateInstance(this, t);\n      if (typeof t == \"string\") {\n        if (typeof e[t] > \"u\")\n          throw new TypeError(`No method named \"${t}\"`);\n        e[t]();\n      }\n    });\n  }\n  static clearMenus(t) {\n    if (t && (t.button === Gd || t.type === \"keyup\" && t.key !== Vr))\n      return;\n    const e = d.find(es);\n    for (let i = 0, n = e.length; i < n; i++) {\n      const o = Dt.getInstance(e[i]);\n      if (!o || o._config.autoClose === !1 || !o._isShown())\n        continue;\n      const r = {\n        relatedTarget: o._element\n      };\n      if (t) {\n        const a = t.composedPath(), l = a.includes(o._menu);\n        if (a.includes(o._element) || o._config.autoClose === \"inside\" && !l || o._config.autoClose === \"outside\" && l || o._menu.contains(t.target) && (t.type === \"keyup\" && t.key === Vr || /input|select|option|textarea|form/i.test(t.target.tagName)))\n          continue;\n        t.type === \"click\" && (r.clickEvent = t);\n      }\n      o._completeHide(r);\n    }\n  }\n  static getParentFromElement(t) {\n    return Jt(t) || t.parentNode;\n  }\n  static dataApiKeydownHandler(t) {\n    if (/input|textarea/i.test(t.target.tagName) ? t.key === Hr || t.key !== Rs && (t.key !== Ps && t.key !== $o || t.target.closest(xn)) : !qd.test(t.key))\n      return;\n    const e = this.dataset[`teDropdown${Wt.charAt(0).toUpperCase() + Wt.slice(1)}`] === \"\";\n    if (!e && t.key === Rs || (t.preventDefault(), t.stopPropagation(), ge(this)))\n      return;\n    const i = this.matches(es) ? this : d.prev(this, es)[0], n = Dt.getOrCreateInstance(i);\n    if (t.key === Rs) {\n      n.hide();\n      return;\n    }\n    if (t.key === $o || t.key === Ps) {\n      e || n.show(), n._selectMenuItem(t);\n      return;\n    }\n    (!e || t.key === Hr) && Dt.clearMenus();\n  }\n}\nconst On = \"collapse\", Dc = \"te.collapse\", ln = `.${Dc}`, Fr = {\n  toggle: !0,\n  parent: null\n}, vu = {\n  toggle: \"boolean\",\n  parent: \"(null|element)\"\n}, Tu = `show${ln}`, Eu = `shown${ln}`, Cu = `hide${ln}`, Au = `hidden${ln}`, Sn = \"data-te-collapse-show\", Yr = \"data-te-collapse-collapsed\", ss = \"data-te-collapse-collapsing\", yu = \"data-te-collapse-horizontal\", Me = \"data-te-collapse-item\", jr = `:scope [${Me}] [${Me}]`, wu = \"width\", ku = \"height\", xu = \"[data-te-collapse-item][data-te-collapse-show], [data-te-collapse-item][data-te-collapse-collapsing]\", Kr = \"[data-te-collapse-init]\", Ou = {\n  visible: \"!visible\",\n  hidden: \"hidden\",\n  baseTransition: \"overflow-hidden duration-[350ms] ease-[cubic-bezier(0.25,0.1,0.25,1.0)] motion-reduce:transition-none\",\n  collapsing: \"h-0 transition-[height] overflow-hidden duration-[350ms] ease-[cubic-bezier(0.25,0.1,0.25,1.0)] motion-reduce:transition-none\",\n  collapsingHorizontal: \"w-0 h-auto transition-[width] overflow-hidden duration-[350ms] ease-[cubic-bezier(0.25,0.1,0.25,1.0)] motion-reduce:transition-none\"\n}, Su = {\n  visible: \"string\",\n  hidden: \"string\",\n  baseTransition: \"string\",\n  collapsing: \"string\",\n  collapsingHorizontal: \"string\"\n};\nclass Zt extends gt {\n  constructor(t, e, i) {\n    super(t), this._isTransitioning = !1, this._config = this._getConfig(e), this._classes = this._getClasses(i), this._triggerArray = [];\n    const n = d.find(Kr);\n    for (let o = 0, r = n.length; o < r; o++) {\n      const a = n[o], l = qo(a), p = d.find(l).filter(\n        (u) => u === this._element\n      );\n      l !== null && p.length && (this._selector = l, this._triggerArray.push(a));\n    }\n    this._initializeChildren(), this._config.parent || this._addAriaAndCollapsedClass(this._triggerArray, this._isShown()), this._config.toggle && this.toggle();\n  }\n  // Getters\n  static get Default() {\n    return Fr;\n  }\n  static get NAME() {\n    return On;\n  }\n  // Public\n  toggle() {\n    this._isShown() ? this.hide() : this.show();\n  }\n  show() {\n    if (this._isTransitioning || this._isShown())\n      return;\n    let t = [], e;\n    if (this._config.parent) {\n      const u = d.find(\n        jr,\n        this._config.parent\n      );\n      t = d.find(\n        xu,\n        this._config.parent\n      ).filter((_) => !u.includes(_));\n    }\n    const i = d.findOne(this._selector);\n    if (t.length) {\n      const u = t.find((_) => i !== _);\n      if (e = u ? Zt.getInstance(u) : null, e && e._isTransitioning)\n        return;\n    }\n    if (c.trigger(this._element, Tu).defaultPrevented)\n      return;\n    t.forEach((u) => {\n      i !== u && Zt.getOrCreateInstance(u, { toggle: !1 }).hide(), e || y.setData(u, Dc, null);\n    });\n    const o = this._getDimension(), r = o === \"height\" ? this._classes.collapsing : this._classes.collapsingHorizontal;\n    h.removeClass(this._element, this._classes.visible), h.removeClass(this._element, this._classes.hidden), h.addClass(this._element, r), this._element.removeAttribute(Me), this._element.setAttribute(ss, \"\"), this._element.style[o] = 0, this._addAriaAndCollapsedClass(this._triggerArray, !0), this._isTransitioning = !0;\n    const a = () => {\n      this._isTransitioning = !1, h.removeClass(this._element, this._classes.hidden), h.removeClass(this._element, r), h.addClass(this._element, this._classes.visible), this._element.removeAttribute(ss), this._element.setAttribute(Me, \"\"), this._element.setAttribute(Sn, \"\"), this._element.style[o] = \"\", c.trigger(this._element, Eu);\n    }, p = `scroll${o[0].toUpperCase() + o.slice(1)}`;\n    this._queueCallback(a, this._element, !0), this._element.style[o] = `${this._element[p]}px`;\n  }\n  hide() {\n    if (this._isTransitioning || !this._isShown() || c.trigger(this._element, Cu).defaultPrevented)\n      return;\n    const e = this._getDimension(), i = e === \"height\" ? this._classes.collapsing : this._classes.collapsingHorizontal;\n    this._element.style[e] = `${this._element.getBoundingClientRect()[e]}px`, Je(this._element), h.addClass(this._element, i), h.removeClass(this._element, this._classes.visible), h.removeClass(this._element, this._classes.hidden), this._element.setAttribute(ss, \"\"), this._element.removeAttribute(Me), this._element.removeAttribute(Sn);\n    const n = this._triggerArray.length;\n    for (let r = 0; r < n; r++) {\n      const a = this._triggerArray[r], l = Jt(a);\n      l && !this._isShown(l) && this._addAriaAndCollapsedClass([a], !1);\n    }\n    this._isTransitioning = !0;\n    const o = () => {\n      this._isTransitioning = !1, h.removeClass(this._element, i), h.addClass(this._element, this._classes.visible), h.addClass(this._element, this._classes.hidden), this._element.removeAttribute(ss), this._element.setAttribute(Me, \"\"), c.trigger(this._element, Au);\n    };\n    this._element.style[e] = \"\", this._queueCallback(o, this._element, !0);\n  }\n  _isShown(t = this._element) {\n    return t.hasAttribute(Sn);\n  }\n  // Private\n  _getConfig(t) {\n    return t = {\n      ...Fr,\n      ...h.getDataAttributes(this._element),\n      ...t\n    }, t.toggle = !!t.toggle, t.parent = te(t.parent), D(On, t, vu), t;\n  }\n  _getClasses(t) {\n    const e = h.getDataClassAttributes(this._element);\n    return t = {\n      ...Ou,\n      ...e,\n      ...t\n    }, D(On, t, Su), t;\n  }\n  _getDimension() {\n    return this._element.hasAttribute(yu) ? wu : ku;\n  }\n  _initializeChildren() {\n    if (!this._config.parent)\n      return;\n    const t = d.find(\n      jr,\n      this._config.parent\n    );\n    d.find(Kr, this._config.parent).filter((e) => !t.includes(e)).forEach((e) => {\n      const i = Jt(e);\n      i && this._addAriaAndCollapsedClass([e], this._isShown(i));\n    });\n  }\n  _addAriaAndCollapsedClass(t, e) {\n    t.length && t.forEach((i) => {\n      e ? i.removeAttribute(Yr) : i.setAttribute(`${Yr}`, \"\"), i.setAttribute(\"aria-expanded\", e);\n    });\n  }\n  // Static\n  static jQueryInterface(t) {\n    return this.each(function() {\n      const e = {};\n      typeof t == \"string\" && /show|hide/.test(t) && (e.toggle = !1);\n      const i = Zt.getOrCreateInstance(this, e);\n      if (typeof t == \"string\") {\n        if (typeof i[t] > \"u\")\n          throw new TypeError(`No method named \"${t}\"`);\n        i[t]();\n      }\n    });\n  }\n}\nconst zr = \".fixed-top, .fixed-bottom, .is-fixed, .sticky-top\", Ur = \".sticky-top\";\nclass qe {\n  constructor() {\n    this._element = document.body;\n  }\n  getWidth() {\n    const t = document.documentElement.clientWidth;\n    return Math.abs(window.innerWidth - t);\n  }\n  hide() {\n    const t = this.getWidth();\n    this._disableOverFlow(), this._setElementAttributes(\n      this._element,\n      \"paddingRight\",\n      (e) => e + t\n    ), this._setElementAttributes(\n      zr,\n      \"paddingRight\",\n      (e) => e + t\n    ), this._setElementAttributes(\n      Ur,\n      \"marginRight\",\n      (e) => e - t\n    );\n  }\n  _disableOverFlow() {\n    this._saveInitialAttribute(this._element, \"overflow\"), this._element.style.overflow = \"hidden\";\n  }\n  _setElementAttributes(t, e, i) {\n    const n = this.getWidth(), o = (r) => {\n      if (r !== this._element && window.innerWidth > r.clientWidth + n)\n        return;\n      this._saveInitialAttribute(r, e);\n      const a = window.getComputedStyle(r)[e];\n      r.style[e] = `${i(\n        Number.parseFloat(a)\n      )}px`;\n    };\n    this._applyManipulationCallback(t, o);\n  }\n  reset() {\n    this._resetElementAttributes(this._element, \"overflow\"), this._resetElementAttributes(this._element, \"paddingRight\"), this._resetElementAttributes(zr, \"paddingRight\"), this._resetElementAttributes(Ur, \"marginRight\");\n  }\n  _saveInitialAttribute(t, e) {\n    const i = t.style[e];\n    i && h.setDataAttribute(t, e, i);\n  }\n  _resetElementAttributes(t, e) {\n    const i = (n) => {\n      const o = h.getDataAttribute(n, e);\n      typeof o > \"u\" ? n.style.removeProperty(e) : (h.removeDataAttribute(n, e), n.style[e] = o);\n    };\n    this._applyManipulationCallback(t, i);\n  }\n  _applyManipulationCallback(t, e) {\n    je(t) ? e(t) : d.find(t, this._element).forEach(e);\n  }\n  isOverflowing() {\n    return this.getWidth() > 0;\n  }\n}\nconst Iu = {\n  isVisible: !0,\n  // if false, we use the backdrop helper without adding any element to the dom\n  isAnimated: !1,\n  rootElement: \"body\",\n  // give the choice to place backdrop under different elements\n  clickCallback: null,\n  backdropClasses: null\n}, Du = {\n  isVisible: \"boolean\",\n  isAnimated: \"boolean\",\n  rootElement: \"(element|string)\",\n  clickCallback: \"(function|null)\",\n  backdropClasses: \"(array|null)\"\n}, $c = \"backdrop\", Xr = `mousedown.te.${$c}`;\nclass hr {\n  constructor(t) {\n    this._config = this._getConfig(t), this._isAppended = !1, this._element = null;\n  }\n  show(t) {\n    if (!this._config.isVisible) {\n      me(t);\n      return;\n    }\n    this._append(), this._config.isAnimated && Je(this._getElement());\n    const e = this._config.backdropClasses || [\n      \"opacity-50\",\n      \"transition-all\",\n      \"duration-300\",\n      \"ease-in-out\",\n      \"fixed\",\n      \"top-0\",\n      \"left-0\",\n      \"z-[1040]\",\n      \"bg-black\",\n      \"w-screen\",\n      \"h-screen\"\n    ];\n    h.removeClass(this._getElement(), \"opacity-0\"), h.addClass(this._getElement(), e), this._element.setAttribute(\"data-te-backdrop-show\", \"\"), this._emulateAnimation(() => {\n      me(t);\n    });\n  }\n  hide(t) {\n    if (!this._config.isVisible) {\n      me(t);\n      return;\n    }\n    this._element.removeAttribute(\"data-te-backdrop-show\"), this._getElement().classList.add(\"opacity-0\"), this._getElement().classList.remove(\"opacity-50\"), this._emulateAnimation(() => {\n      this.dispose(), me(t);\n    });\n  }\n  // Private\n  _getElement() {\n    if (!this._element) {\n      const t = document.createElement(\"div\");\n      t.className = this._config.className, this._config.isAnimated && t.classList.add(\"opacity-50\"), this._element = t;\n    }\n    return this._element;\n  }\n  _getConfig(t) {\n    return t = {\n      ...Iu,\n      ...typeof t == \"object\" ? t : {}\n    }, t.rootElement = te(t.rootElement), D($c, t, Du), t;\n  }\n  _append() {\n    this._isAppended || (this._config.rootElement.append(this._getElement()), c.on(this._getElement(), Xr, () => {\n      me(this._config.clickCallback);\n    }), this._isAppended = !0);\n  }\n  dispose() {\n    this._isAppended && (c.off(this._element, Xr), this._element.remove(), this._isAppended = !1);\n  }\n  _emulateAnimation(t) {\n    Ql(\n      t,\n      this._getElement(),\n      this._config.isAnimated\n    );\n  }\n}\nclass Wi {\n  constructor(t, e = {}, i) {\n    this._element = t, this._toggler = i, this._event = e.event || \"blur\", this._condition = e.condition || (() => !0), this._selector = e.selector || 'button, a, input, select, textarea, [tabindex]:not([tabindex=\"-1\"])', this._onlyVisible = e.onlyVisible || !1, this._focusableElements = [], this._firstElement = null, this._lastElement = null, this.handler = (n) => {\n      this._condition(n) && !n.shiftKey && n.target === this._lastElement ? (n.preventDefault(), this._firstElement.focus()) : this._condition(n) && n.shiftKey && n.target === this._firstElement && (n.preventDefault(), this._lastElement.focus());\n    };\n  }\n  trap() {\n    this._setElements(), this._init(), this._setFocusTrap();\n  }\n  disable() {\n    this._focusableElements.forEach((t) => {\n      t.removeEventListener(this._event, this.handler);\n    }), this._toggler && this._toggler.focus();\n  }\n  update() {\n    this._setElements(), this._setFocusTrap();\n  }\n  _init() {\n    const t = (e) => {\n      !this._firstElement || e.key !== \"Tab\" || this._focusableElements.includes(e.target) || (e.preventDefault(), this._firstElement.focus(), window.removeEventListener(\"keydown\", t));\n    };\n    window.addEventListener(\"keydown\", t);\n  }\n  _filterVisible(t) {\n    return t.filter((e) => {\n      if (!Nt(e))\n        return !1;\n      const i = d.parents(e, \"*\");\n      for (let n = 0; n < i.length; n++) {\n        const o = window.getComputedStyle(i[n]);\n        if (o && (o.display === \"none\" || o.visibility === \"hidden\"))\n          return !1;\n      }\n      return !0;\n    });\n  }\n  _setElements() {\n    this._focusableElements = d.focusableChildren(this._element), this._onlyVisible && (this._focusableElements = this._filterVisible(this._focusableElements)), this._firstElement = this._focusableElements[0], this._lastElement = this._focusableElements[this._focusableElements.length - 1];\n  }\n  _setFocusTrap() {\n    this._focusableElements.forEach((t, e) => {\n      e === this._focusableElements.length - 1 || e === 0 ? t.addEventListener(this._event, this.handler) : t.removeEventListener(this._event, this.handler);\n    });\n  }\n}\nlet Gr = [];\nconst cn = (s, t = \"hide\") => {\n  const e = `click.dismiss${s.EVENT_KEY}`, i = s.NAME;\n  Gr.includes(i) || (Gr.push(i), c.on(\n    document,\n    e,\n    `[data-te-${i}-dismiss]`,\n    function(n) {\n      if ([\"A\", \"AREA\"].includes(this.tagName) && n.preventDefault(), ge(this))\n        return;\n      const o = Jt(this) || this.closest(`.${i}`) || this.closest(`[data-te-${i}-init]`);\n      if (!o)\n        return;\n      s.getOrCreateInstance(o)[t]();\n    }\n  ));\n}, qr = \"offcanvas\", $u = \"te.offcanvas\", ei = `.${$u}`, Lu = \".data-api\", Nu = `load${ei}${Lu}`, Mu = \"Escape\", Zr = {\n  backdrop: !0,\n  keyboard: !0,\n  scroll: !1\n}, Ru = {\n  backdrop: \"boolean\",\n  keyboard: \"boolean\",\n  scroll: \"boolean\"\n}, Qr = \"show\", Pu = \"[data-te-offcanvas-init][data-te-offcanvas-show]\", Bu = `show${ei}`, Hu = `shown${ei}`, Vu = `hide${ei}`, Wu = `hidden${ei}`, Fu = `keydown.dismiss${ei}`;\nclass Bs extends gt {\n  constructor(t, e) {\n    super(t), this._config = this._getConfig(e), this._isShown = !1, this._backdrop = this._initializeBackDrop(), this._focustrap = this._initializeFocusTrap(), this._addEventListeners(), this._didInit = !1, this._init();\n  }\n  // Getters\n  static get NAME() {\n    return qr;\n  }\n  static get Default() {\n    return Zr;\n  }\n  // Public\n  toggle(t) {\n    return this._isShown ? this.hide() : this.show(t);\n  }\n  show(t) {\n    if (this._isShown || c.trigger(this._element, Bu, {\n      relatedTarget: t\n    }).defaultPrevented)\n      return;\n    this._isShown = !0, this._element.style.visibility = \"visible\", this._backdrop.show(), this._config.scroll || new qe().hide(), this._element.removeAttribute(\"aria-hidden\"), this._element.setAttribute(\"aria-modal\", !0), this._element.setAttribute(\"role\", \"dialog\"), this._element.setAttribute(`data-te-offcanvas-${Qr}`, \"\");\n    const i = () => {\n      this._config.scroll || this._focustrap.trap(), c.trigger(this._element, Hu, { relatedTarget: t });\n    };\n    this._queueCallback(i, this._element, !0);\n  }\n  hide() {\n    if (!this._isShown || c.trigger(this._element, Vu).defaultPrevented)\n      return;\n    this._focustrap.disable(), this._element.blur(), this._isShown = !1, this._element.removeAttribute(`data-te-offcanvas-${Qr}`), this._backdrop.hide();\n    const e = () => {\n      this._element.setAttribute(\"aria-hidden\", !0), this._element.removeAttribute(\"aria-modal\"), this._element.removeAttribute(\"role\"), this._element.style.visibility = \"hidden\", this._config.scroll || new qe().reset(), c.trigger(this._element, Wu);\n    };\n    this._queueCallback(e, this._element, !0);\n  }\n  dispose() {\n    this._backdrop.dispose(), this._focustrap.disable(), super.dispose();\n  }\n  // Private\n  _init() {\n    this._didInit || (c.on(\n      window,\n      Nu,\n      () => d.find(Pu).forEach(\n        (t) => Bs.getOrCreateInstance(t).show()\n      )\n    ), this._didInit = !0, cn(Bs));\n  }\n  _getConfig(t) {\n    return t = {\n      ...Zr,\n      ...h.getDataAttributes(this._element),\n      ...typeof t == \"object\" ? t : {}\n    }, D(qr, t, Ru), t;\n  }\n  _initializeBackDrop() {\n    return new hr({\n      isVisible: this._config.backdrop,\n      isAnimated: !0,\n      rootElement: this._element.parentNode,\n      clickCallback: () => this.hide()\n    });\n  }\n  _initializeFocusTrap() {\n    return new Wi(this._element, {\n      event: \"keydown\",\n      condition: (t) => t.key === \"Tab\"\n    });\n  }\n  _addEventListeners() {\n    c.on(this._element, Fu, (t) => {\n      this._config.keyboard && t.key === Mu && this.hide();\n    });\n  }\n  // Static\n  static jQueryInterface(t) {\n    return this.each(function() {\n      const e = Bs.getOrCreateInstance(this, t);\n      if (typeof t == \"string\") {\n        if (e[t] === void 0 || t.startsWith(\"_\") || t === \"constructor\")\n          throw new TypeError(`No method named \"${t}\"`);\n        e[t](this);\n      }\n    });\n  }\n}\nconst In = \"alert\", Yu = \"te.alert\", Lc = `.${Yu}`, ju = `close${Lc}`, Ku = `closed${Lc}`, ai = \"data-te-alert-show\", zu = {\n  animation: \"boolean\",\n  autohide: \"boolean\",\n  delay: \"number\"\n}, Jr = {\n  animation: !0,\n  autohide: !0,\n  delay: 1e3\n}, Uu = {\n  fadeIn: \"animate-[fade-in_0.3s_both] p-[auto] motion-reduce:transition-none motion-reduce:animate-none\",\n  fadeOut: \"animate-[fade-out_0.3s_both] p-[auto] motion-reduce:transition-none motion-reduce:animate-none\"\n}, Xu = {\n  fadeIn: \"string\",\n  fadeOut: \"string\"\n};\nclass Lo extends gt {\n  constructor(t, e, i) {\n    super(t), this._element = t, this._config = this._getConfig(e), this._classes = this._getClasses(i), this._didInit = !1, this._init();\n  }\n  // Getters\n  static get DefaultType() {\n    return zu;\n  }\n  static get Default() {\n    return Jr;\n  }\n  static get NAME() {\n    return In;\n  }\n  // Public\n  close() {\n    if (c.trigger(this._element, ju).defaultPrevented)\n      return;\n    let e = 0;\n    this._config.animation && (e = 300, h.addClass(this._element, this._classes.fadeOut)), this._element.removeAttribute(ai), setTimeout(() => {\n      this._queueCallback(\n        () => this._destroyElement(),\n        this._element,\n        this._config.animation\n      );\n    }, e);\n  }\n  show() {\n    if (this._element) {\n      if (this._config.autohide && this._setupAutohide(), !this._element.hasAttribute(ai) && (h.removeClass(this._element, \"hidden\"), h.addClass(this._element, \"block\"), Nt(this._element))) {\n        const t = (e) => {\n          h.removeClass(this._element, \"hidden\"), h.addClass(this._element, \"block\"), c.off(e.target, \"animationend\", t);\n        };\n        this._element.setAttribute(ai, \"\"), c.on(this._element, \"animationend\", t);\n      }\n      this._config.animation && (h.removeClass(this._element, this._classes.fadeOut), h.addClass(this._element, this._classes.fadeIn));\n    }\n  }\n  hide() {\n    if (this._element && this._element.hasAttribute(ai)) {\n      this._element.removeAttribute(ai);\n      const t = (e) => {\n        h.addClass(this._element, \"hidden\"), h.removeClass(this._element, \"block\"), this._timeout !== null && (clearTimeout(this._timeout), this._timeout = null), c.off(e.target, \"animationend\", t);\n      };\n      c.on(this._element, \"animationend\", t), h.removeClass(this._element, this._classes.fadeIn), h.addClass(this._element, this._classes.fadeOut);\n    }\n  }\n  // Private\n  _init() {\n    this._didInit || (cn(Lo, \"close\"), this._didInit = !0);\n  }\n  _getConfig(t) {\n    return t = {\n      ...Jr,\n      ...h.getDataAttributes(this._element),\n      ...typeof t == \"object\" && t ? t : {}\n    }, D(In, t, this.constructor.DefaultType), t;\n  }\n  _getClasses(t) {\n    const e = h.getDataClassAttributes(this._element);\n    return t = {\n      ...Uu,\n      ...e,\n      ...t\n    }, D(In, t, Xu), t;\n  }\n  _setupAutohide() {\n    this._timeout = setTimeout(() => {\n      this.hide();\n    }, this._config.delay);\n  }\n  _destroyElement() {\n    this._element.remove(), c.trigger(this._element, Ku), this.dispose();\n  }\n  // Static\n  static jQueryInterface(t) {\n    return this.each(function() {\n      const e = Lo.getOrCreateInstance(this);\n      if (typeof t == \"string\") {\n        if (e[t] === void 0 || t.startsWith(\"_\") || t === \"constructor\")\n          throw new TypeError(`No method named \"${t}\"`);\n        e[t](this);\n      }\n    });\n  }\n}\nconst Dn = \"carousel\", Gu = \"te.carousel\", _t = `.${Gu}`, Nc = \".data-api\", qu = \"ArrowLeft\", Zu = \"ArrowRight\", Qu = 500, Ju = 40, ta = {\n  interval: 5e3,\n  keyboard: !0,\n  ride: !1,\n  pause: \"hover\",\n  wrap: !0,\n  touch: !0\n}, tp = {\n  interval: \"(number|boolean)\",\n  keyboard: \"boolean\",\n  ride: \"(boolean|string)\",\n  pause: \"(string|boolean)\",\n  wrap: \"boolean\",\n  touch: \"boolean\"\n}, ep = {\n  pointer: \"touch-pan-y\",\n  block: \"!block\",\n  visible: \"data-[te-carousel-fade]:opacity-100 data-[te-carousel-fade]:z-[1]\",\n  invisible: \"data-[te-carousel-fade]:z-0 data-[te-carousel-fade]:opacity-0 data-[te-carousel-fade]:duration-[600ms] data-[te-carousel-fade]:delay-600\",\n  slideRight: \"translate-x-full\",\n  slideLeft: \"-translate-x-full\"\n}, ip = {\n  pointer: \"string\",\n  block: \"string\",\n  visible: \"string\",\n  invisible: \"string\",\n  slideRight: \"string\",\n  slideLeft: \"string\"\n}, le = \"next\", ce = \"prev\", _e = \"left\", mi = \"right\", sp = {\n  [qu]: mi,\n  [Zu]: _e\n}, np = `slide${_t}`, $n = `slid${_t}`, op = `keydown${_t}`, rp = `mouseenter${_t}`, ap = `mouseleave${_t}`, lp = `touchstart${_t}`, cp = `touchmove${_t}`, hp = `touchend${_t}`, dp = `pointerdown${_t}`, up = `pointerup${_t}`, pp = `dragstart${_t}`, _p = `load${_t}${Nc}`, fp = `click${_t}${Nc}`, ea = \"data-te-carousel-init\", he = \"data-te-carousel-active\", mp = \"data-te-carousel-item-end\", Ln = \"data-te-carousel-item-start\", gp = \"data-te-carousel-item-next\", bp = \"data-te-carousel-item-prev\", vp = \"data-te-carousel-pointer-event\", Tp = \"[data-te-carousel-init]\", Mc = \"[data-te-carousel-active]\", dr = \"[data-te-carousel-item]\", we = `${Mc}${dr}`, Ep = `${dr} img`, Cp = \"[data-te-carousel-item-next], [data-te-carousel-item-prev]\", Ap = \"[data-te-carousel-indicators]\", yp = \"[data-te-target]\", wp = \"[data-te-slide], [data-te-slide-to]\", kp = \"touch\", xp = \"pen\";\nclass Ut extends gt {\n  constructor(t, e, i) {\n    super(t), this._items = null, this._interval = null, this._activeElement = null, this._isPaused = !1, this._isSliding = !1, this.touchTimeout = null, this.touchStartX = 0, this.touchDeltaX = 0, this._config = this._getConfig(e), this._classes = this._getClasses(i), this._indicatorsElement = d.findOne(\n      Ap,\n      this._element\n    ), this._touchSupported = \"ontouchstart\" in document.documentElement || navigator.maxTouchPoints > 0, this._pointerEvent = !!window.PointerEvent, this._setActiveElementClass(), this._addEventListeners(), this._didInit = !1, this._init(), this._config.ride === \"carousel\" && this.cycle();\n  }\n  // Getters\n  static get Default() {\n    return ta;\n  }\n  static get NAME() {\n    return Dn;\n  }\n  // Public\n  next() {\n    this._slide(le);\n  }\n  nextWhenVisible() {\n    !document.hidden && Nt(this._element) && this.next();\n  }\n  prev() {\n    this._slide(ce);\n  }\n  pause(t) {\n    t || (this._isPaused = !0), d.findOne(Cp, this._element) && (Xl(this._element), this.cycle(!0)), clearInterval(this._interval), this._interval = null;\n  }\n  cycle(t) {\n    t || (this._isPaused = !1), this._interval && (clearInterval(this._interval), this._interval = null), this._config && this._config.interval && !this._isPaused && (this._updateInterval(), this._interval = setInterval(\n      (document.visibilityState ? this.nextWhenVisible : this.next).bind(\n        this\n      ),\n      this._config.interval\n    ));\n  }\n  to(t) {\n    this._activeElement = d.findOne(\n      we,\n      this._element\n    );\n    const e = this._getItemIndex(this._activeElement);\n    if (t > this._items.length - 1 || t < 0)\n      return;\n    if (this._isSliding) {\n      c.one(this._element, $n, () => this.to(t));\n      return;\n    }\n    if (e === t) {\n      this.pause(), this.cycle();\n      return;\n    }\n    const i = t > e ? le : ce;\n    this._slide(i, this._items[t]);\n  }\n  // Private\n  _init() {\n    this._didInit || (c.on(\n      document,\n      fp,\n      wp,\n      Ut.dataApiClickHandler\n    ), c.on(window, _p, () => {\n      const t = d.find(Tp);\n      for (let e = 0, i = t.length; e < i; e++)\n        Ut.carouselInterface(\n          t[e],\n          Ut.getInstance(t[e])\n        );\n    }), this._didInit = !0);\n  }\n  _getConfig(t) {\n    return t = {\n      ...ta,\n      ...h.getDataAttributes(this._element),\n      ...typeof t == \"object\" ? t : {}\n    }, D(Dn, t, tp), t;\n  }\n  _getClasses(t) {\n    const e = h.getDataClassAttributes(this._element);\n    return t = {\n      ...ep,\n      ...e,\n      ...t\n    }, D(Dn, t, ip), t;\n  }\n  _enableCycle() {\n    if (this._config.ride) {\n      if (this._isSliding) {\n        c.one(this._element, $n, () => this.cycle());\n        return;\n      }\n      this.cycle();\n    }\n  }\n  _applyInitialClasses() {\n    const t = d.findOne(\n      we,\n      this._element\n    );\n    t.classList.add(\n      this._classes.block,\n      ...this._classes.visible.split(\" \")\n    ), this._setActiveIndicatorElement(t);\n  }\n  _handleSwipe() {\n    const t = Math.abs(this.touchDeltaX);\n    if (t <= Ju)\n      return;\n    const e = t / this.touchDeltaX;\n    this.touchDeltaX = 0, e && this._slide(e > 0 ? mi : _e);\n  }\n  _setActiveElementClass() {\n    this._activeElement = d.findOne(\n      we,\n      this._element\n    ), h.addClass(this._activeElement, \"hidden\");\n  }\n  _addEventListeners() {\n    this._config.keyboard && c.on(\n      this._element,\n      op,\n      (t) => this._keydown(t)\n    ), this._config.pause === \"hover\" && (c.on(\n      this._element,\n      rp,\n      (t) => this.pause(t)\n    ), c.on(\n      this._element,\n      ap,\n      (t) => this._enableCycle(t)\n    )), this._config.touch && this._touchSupported && this._addTouchEventListeners(), this._applyInitialClasses();\n  }\n  _addTouchEventListeners() {\n    const t = (o) => this._pointerEvent && (o.pointerType === xp || o.pointerType === kp), e = (o) => {\n      t(o) ? this.touchStartX = o.clientX : this._pointerEvent || (this.touchStartX = o.touches[0].clientX);\n    }, i = (o) => {\n      this.touchDeltaX = o.touches && o.touches.length > 1 ? 0 : o.touches[0].clientX - this.touchStartX;\n    }, n = (o) => {\n      t(o) && (this.touchDeltaX = o.clientX - this.touchStartX), this._handleSwipe(), this._config.pause === \"hover\" && (this.pause(), this.touchTimeout && clearTimeout(this.touchTimeout), this.touchTimeout = setTimeout(\n        (r) => this._enableCycle(r),\n        Qu + this._config.interval\n      ));\n    };\n    d.find(Ep, this._element).forEach(\n      (o) => {\n        c.on(\n          o,\n          pp,\n          (r) => r.preventDefault()\n        );\n      }\n    ), this._pointerEvent ? (c.on(\n      this._element,\n      dp,\n      (o) => e(o)\n    ), c.on(this._element, up, (o) => n(o)), this._element.classList.add(this._classes.pointer), this._element.setAttribute(`${vp}`, \"\")) : (c.on(this._element, lp, (o) => e(o)), c.on(this._element, cp, (o) => i(o)), c.on(this._element, hp, (o) => n(o)));\n  }\n  _keydown(t) {\n    if (/input|textarea/i.test(t.target.tagName))\n      return;\n    const e = sp[t.key];\n    e && (t.preventDefault(), this._slide(e));\n  }\n  _getItemIndex(t) {\n    return this._items = t && t.parentNode ? d.find(dr, t.parentNode) : [], this._items.indexOf(t);\n  }\n  _getItemByOrder(t, e) {\n    const i = t === le;\n    return Jl(\n      this._items,\n      e,\n      i,\n      this._config.wrap\n    );\n  }\n  _triggerSlideEvent(t, e) {\n    const i = this._getItemIndex(t), n = this._getItemIndex(\n      d.findOne(we, this._element)\n    );\n    return c.trigger(this._element, np, {\n      relatedTarget: t,\n      direction: e,\n      from: n,\n      to: i\n    });\n  }\n  _setActiveIndicatorElement(t) {\n    if (this._indicatorsElement) {\n      const e = d.findOne(\n        Mc,\n        this._indicatorsElement\n      );\n      e.removeAttribute(he), e.removeAttribute(\"aria-current\"), e.classList.remove(\"!opacity-100\");\n      const i = d.find(\n        yp,\n        this._indicatorsElement\n      );\n      for (let n = 0; n < i.length; n++)\n        if (Number.parseInt(\n          i[n].getAttribute(\"data-te-slide-to\"),\n          10\n        ) === this._getItemIndex(t)) {\n          i[n].setAttribute(`${he}`, \"\"), i[n].setAttribute(\"aria-current\", \"true\"), i[n].classList.add(\"!opacity-100\");\n          break;\n        }\n    }\n  }\n  _updateInterval() {\n    const t = this._activeElement || d.findOne(we, this._element);\n    if (!t)\n      return;\n    const e = Number.parseInt(\n      t.getAttribute(\"data-te-interval\"),\n      10\n    );\n    e ? (this._config.defaultInterval = this._config.defaultInterval || this._config.interval, this._config.interval = e) : this._config.interval = this._config.defaultInterval || this._config.interval;\n  }\n  _slide(t, e) {\n    const i = this._directionToOrder(t), n = d.findOne(\n      we,\n      this._element\n    ), o = this._getItemIndex(n), r = e || this._getItemByOrder(i, n), a = this._getItemIndex(r), l = !!this._interval, p = i === le, u = p ? Ln : mp, _ = p ? gp : bp, f = this._orderToDirection(i), g = u === Ln ? this._classes.slideLeft : this._classes.slideRight, m = u !== Ln ? this._classes.slideLeft : this._classes.slideRight;\n    if (r && r.hasAttribute(he)) {\n      this._isSliding = !1;\n      return;\n    }\n    if (this._isSliding || this._triggerSlideEvent(r, f).defaultPrevented || !n || !r)\n      return;\n    this._isSliding = !0, l && this.pause(), this._setActiveIndicatorElement(r), this._activeElement = r;\n    const v = () => {\n      c.trigger(this._element, $n, {\n        relatedTarget: r,\n        direction: f,\n        from: o,\n        to: a\n      });\n    };\n    if (this._element.hasAttribute(ea)) {\n      r.setAttribute(`${_}`, \"\"), r.classList.add(this._classes.block, m), Je(r), n.setAttribute(`${u}`, \"\"), n.classList.add(\n        g,\n        ...this._classes.invisible.split(\" \")\n      ), n.classList.remove(...this._classes.visible.split(\" \")), r.setAttribute(`${u}`, \"\"), r.classList.add(...this._classes.visible.split(\" \")), r.classList.remove(\n        this._classes.slideRight,\n        this._classes.slideLeft\n      );\n      const C = () => {\n        r.removeAttribute(u), r.removeAttribute(_), r.setAttribute(`${he}`, \"\"), n.removeAttribute(he), n.classList.remove(\n          g,\n          ...this._classes.invisible.split(\" \"),\n          this._classes.block\n        ), n.removeAttribute(_), n.removeAttribute(u), this._isSliding = !1, setTimeout(v, 0);\n      };\n      this._queueCallback(C, n, !0);\n    } else\n      n.removeAttribute(he), n.classList.remove(this._classes.block), r.setAttribute(`${he}`, \"\"), r.classList.add(this._classes.block), this._isSliding = !1, v();\n    l && this.cycle();\n  }\n  _directionToOrder(t) {\n    return [mi, _e].includes(t) ? F() ? t === _e ? ce : le : t === _e ? le : ce : t;\n  }\n  _orderToDirection(t) {\n    return [le, ce].includes(t) ? F() ? t === ce ? _e : mi : t === ce ? mi : _e : t;\n  }\n  // Static\n  static carouselInterface(t, e) {\n    const i = Ut.getOrCreateInstance(t, e);\n    let { _config: n } = i;\n    typeof e == \"object\" && (n = {\n      ...n,\n      ...e\n    });\n    const o = typeof e == \"string\" ? e : e.slide;\n    if (typeof e == \"number\") {\n      i.to(e);\n      return;\n    }\n    if (typeof o == \"string\") {\n      if (typeof i[o] > \"u\")\n        throw new TypeError(`No method named \"${o}\"`);\n      i[o]();\n    } else\n      n.interval && n.ride === !0 && i.pause();\n  }\n  static jQueryInterface(t) {\n    return this.each(function() {\n      Ut.carouselInterface(this, t);\n    });\n  }\n  static dataApiClickHandler(t) {\n    const e = Jt(this);\n    if (!e || !e.hasAttribute(ea))\n      return;\n    const i = {\n      ...h.getDataAttributes(e),\n      ...h.getDataAttributes(this)\n    }, n = this.getAttribute(\"data-te-slide-to\");\n    n && (i.interval = !1), Ut.carouselInterface(e, i), n && Ut.getInstance(e).to(n), t.preventDefault();\n  }\n}\nconst Nn = \"modal\", Op = \"te.modal\", At = `.${Op}`, ia = \"Escape\", sa = {\n  backdrop: !0,\n  keyboard: !0,\n  focus: !0,\n  modalNonInvasive: !1\n}, Sp = {\n  backdrop: \"(boolean|string)\",\n  keyboard: \"boolean\",\n  focus: \"boolean\",\n  modalNonInvasive: \"boolean\"\n}, Ip = {\n  show: \"transform-none\",\n  static: \"scale-[1.02]\",\n  staticProperties: \"transition-scale duration-300 ease-in-out\"\n}, Dp = {\n  show: \"string\",\n  static: \"string\",\n  staticProperties: \"string\"\n}, $p = `hide${At}`, Lp = `hidePrevented${At}`, Np = `hidden${At}`, Mp = `show${At}`, Rp = `shown${At}`, na = `resize${At}`, oa = `click.dismiss${At}`, ra = `keydown.dismiss${At}`, Pp = `mouseup.dismiss${At}`, aa = `mousedown.dismiss${At}`, la = \"data-te-modal-open\", ca = \"data-te-open\", li = \"[data-te-modal-dialog-ref]\", Bp = \"[data-te-modal-body-ref]\";\nclass No extends gt {\n  constructor(t, e, i) {\n    super(t), this._config = this._getConfig(e), this._classes = this._getClasses(i), this._dialog = d.findOne(li, this._element), this._backdrop = this._config.modalNonInvasive ? null : this._initializeBackDrop(), this._focustrap = this._initializeFocusTrap(), this._isShown = !1, this._ignoreBackdropClick = !1, this._isTransitioning = !1, this._scrollBar = new qe(), this._didInit = !1, this._init();\n  }\n  // Getters\n  static get Default() {\n    return sa;\n  }\n  static get NAME() {\n    return Nn;\n  }\n  // Public\n  toggle(t) {\n    return this._isShown ? this.hide() : this.show(t);\n  }\n  show(t) {\n    this._isShown || this._isTransitioning || c.trigger(this._element, Mp, {\n      relatedTarget: t\n    }).defaultPrevented || (this._isShown = !0, this._isAnimated() && (this._isTransitioning = !0), !this._config.modalNonInvasive && this._scrollBar.hide(), document.body.setAttribute(la, \"true\"), this._adjustDialog(), this._setEscapeEvent(), this._setResizeEvent(), c.on(this._dialog, aa, () => {\n      c.one(this._element, Pp, (i) => {\n        i.target === this._element && (this._ignoreBackdropClick = !0);\n      });\n    }), this._showElement(t), !this._config.modalNonInvasive && this._showBackdrop());\n  }\n  hide() {\n    if (!this._isShown || this._isTransitioning || c.trigger(this._element, $p).defaultPrevented)\n      return;\n    this._isShown = !1;\n    const e = this._isAnimated();\n    e && (this._isTransitioning = !0), this._setEscapeEvent(), this._setResizeEvent(), this._focustrap.disable(), d.findOne(li, this._element).classList.remove(this._classes.show), c.off(this._element, oa), c.off(this._dialog, aa), this._queueCallback(() => this._hideModal(), this._element, e), this._element.removeAttribute(ca);\n  }\n  dispose() {\n    [window, this._dialog].forEach(\n      (t) => c.off(t, At)\n    ), this._backdrop && this._backdrop.dispose(), this._focustrap.disable(), super.dispose();\n  }\n  handleUpdate() {\n    this._adjustDialog();\n  }\n  // Private\n  _init() {\n    this._didInit || (cn(No), this._didInit = !0);\n  }\n  _initializeBackDrop() {\n    return new hr({\n      isVisible: !!this._config.backdrop,\n      // 'static' option will be translated to true, and booleans will keep their value\n      isAnimated: this._isAnimated()\n    });\n  }\n  _initializeFocusTrap() {\n    return new Wi(this._element, {\n      event: \"keydown\",\n      condition: (t) => t.key === \"Tab\"\n    });\n  }\n  _getConfig(t) {\n    return t = {\n      ...sa,\n      ...h.getDataAttributes(this._element),\n      ...typeof t == \"object\" ? t : {}\n    }, D(Nn, t, Sp), t;\n  }\n  _getClasses(t) {\n    const e = h.getDataClassAttributes(this._element);\n    return t = {\n      ...Ip,\n      ...e,\n      ...t\n    }, D(Nn, t, Dp), t;\n  }\n  _showElement(t) {\n    const e = this._isAnimated(), i = d.findOne(Bp, this._dialog);\n    (!this._element.parentNode || this._element.parentNode.nodeType !== Node.ELEMENT_NODE) && document.body.append(this._element), this._element.style.display = \"block\", this._element.classList.remove(\"hidden\"), this._element.removeAttribute(\"aria-hidden\"), this._element.setAttribute(\"aria-modal\", !0), this._element.setAttribute(\"role\", \"dialog\"), this._element.setAttribute(`${ca}`, \"true\"), this._element.scrollTop = 0;\n    const n = d.findOne(li, this._element);\n    n.classList.add(this._classes.show), n.classList.remove(\"opacity-0\"), n.classList.add(\"opacity-100\"), i && (i.scrollTop = 0), e && Je(this._element);\n    const o = () => {\n      this._config.focus && this._focustrap.trap(), this._isTransitioning = !1, c.trigger(this._element, Rp, {\n        relatedTarget: t\n      });\n    };\n    this._queueCallback(o, this._dialog, e);\n  }\n  _setEscapeEvent() {\n    this._isShown ? c.on(document, ra, (t) => {\n      this._config.keyboard && t.key === ia ? (t.preventDefault(), this.hide()) : !this._config.keyboard && t.key === ia && this._triggerBackdropTransition();\n    }) : c.off(this._element, ra);\n  }\n  _setResizeEvent() {\n    this._isShown ? c.on(window, na, () => this._adjustDialog()) : c.off(window, na);\n  }\n  _hideModal() {\n    const t = d.findOne(li, this._element);\n    t.classList.remove(this._classes.show), t.classList.remove(\"opacity-100\"), t.classList.add(\"opacity-0\"), setTimeout(() => {\n      this._element.style.display = \"none\";\n    }, 300), this._element.setAttribute(\"aria-hidden\", !0), this._element.removeAttribute(\"aria-modal\"), this._element.removeAttribute(\"role\"), this._isTransitioning = !1, this._backdrop && this._backdrop.hide(() => {\n      document.body.removeAttribute(la), this._resetAdjustments(), !this._config.modalNonInvasive && this._scrollBar.reset(), c.trigger(this._element, Np);\n    });\n  }\n  _showBackdrop(t) {\n    c.on(this._element, oa, (e) => {\n      if (this._ignoreBackdropClick) {\n        this._ignoreBackdropClick = !1;\n        return;\n      }\n      e.target === e.currentTarget && (this._config.backdrop === !0 ? this.hide() : this._config.backdrop === \"static\" && this._triggerBackdropTransition());\n    }), this._backdrop && this._backdrop.show(t);\n  }\n  _isAnimated() {\n    return !!d.findOne(li, this._element);\n  }\n  _triggerBackdropTransition() {\n    if (c.trigger(this._element, Lp).defaultPrevented)\n      return;\n    const { classList: e, scrollHeight: i, style: n } = this._element, o = i > document.documentElement.clientHeight;\n    !o && n.overflowY === \"hidden\" || e.contains(this._classes.static) || (o || (n.overflowY = \"hidden\"), e.add(...this._classes.static.split(\" \")), e.add(...this._classes.staticProperties.split(\" \")), this._queueCallback(() => {\n      e.remove(this._classes.static), setTimeout(() => {\n        e.remove(...this._classes.staticProperties.split(\" \"));\n      }, 300), o || this._queueCallback(() => {\n        n.overflowY = \"\";\n      }, this._dialog);\n    }, this._dialog), this._element.focus());\n  }\n  // ----------------------------------------------------------------------\n  // the following methods are used to handle overflowing modals\n  // ----------------------------------------------------------------------\n  _adjustDialog() {\n    const t = this._element.scrollHeight > document.documentElement.clientHeight, e = this._scrollBar.getWidth(), i = e > 0;\n    (!i && t && !F() || i && !t && F()) && (this._element.style.paddingLeft = `${e}px`), (i && !t && !F() || !i && t && F()) && (this._element.style.paddingRight = `${e}px`);\n  }\n  _resetAdjustments() {\n    this._element.style.paddingLeft = \"\", this._element.style.paddingRight = \"\";\n  }\n  // Static\n  static jQueryInterface(t, e) {\n    return this.each(function() {\n      const i = No.getOrCreateInstance(this, t);\n      if (typeof t == \"string\") {\n        if (typeof i[t] > \"u\")\n          throw new TypeError(`No method named \"${t}\"`);\n        i[t](e);\n      }\n    });\n  }\n}\nconst Hp = /* @__PURE__ */ new Set([\n  \"background\",\n  \"cite\",\n  \"href\",\n  \"itemtype\",\n  \"longdesc\",\n  \"poster\",\n  \"src\",\n  \"xlink:href\"\n]), Vp = /^aria-[\\w-]*$/i, Wp = /^(?:(?:https?|mailto|ftp|tel|file|sms):|[^#&/:?]*(?:[#/?]|$))/i, Fp = /^data:(?:image\\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\\/(?:mpeg|mp4|ogg|webm)|audio\\/(?:mp3|oga|ogg|opus));base64,[\\d+/a-z]+=*$/i, Yp = (s, t) => {\n  const e = s.nodeName.toLowerCase();\n  if (t.includes(e))\n    return Hp.has(e) ? !!(Wp.test(s.nodeValue) || Fp.test(s.nodeValue)) : !0;\n  const i = t.filter(\n    (n) => n instanceof RegExp\n  );\n  for (let n = 0, o = i.length; n < o; n++)\n    if (i[n].test(e))\n      return !0;\n  return !1;\n}, jp = {\n  // Global attributes allowed on any supplied element below.\n  \"*\": [\"class\", \"dir\", \"id\", \"lang\", \"role\", Vp],\n  a: [\"target\", \"href\", \"title\", \"rel\"],\n  area: [],\n  b: [],\n  br: [],\n  col: [],\n  code: [],\n  div: [],\n  em: [],\n  hr: [],\n  h1: [],\n  h2: [],\n  h3: [],\n  h4: [],\n  h5: [],\n  h6: [],\n  i: [],\n  img: [\"src\", \"srcset\", \"alt\", \"title\", \"width\", \"height\"],\n  li: [],\n  ol: [],\n  p: [],\n  pre: [],\n  s: [],\n  small: [],\n  span: [],\n  sub: [],\n  sup: [],\n  strong: [],\n  u: [],\n  ul: []\n};\nfunction ha(s, t, e) {\n  if (!s.length)\n    return s;\n  if (e && typeof e == \"function\")\n    return e(s);\n  const n = new window.DOMParser().parseFromString(s, \"text/html\"), o = [].concat(...n.body.querySelectorAll(\"*\"));\n  for (let r = 0, a = o.length; r < a; r++) {\n    const l = o[r], p = l.nodeName.toLowerCase();\n    if (!Object.keys(t).includes(p)) {\n      l.remove();\n      continue;\n    }\n    const u = [].concat(...l.attributes), _ = [].concat(\n      t[\"*\"] || [],\n      t[p] || []\n    );\n    u.forEach((f) => {\n      Yp(f, _) || l.removeAttribute(f.nodeName);\n    });\n  }\n  return n.body.innerHTML;\n}\nconst da = \"tooltip\", Kp = \"te.tooltip\", wt = `.${Kp}`, zp = \"te-tooltip\", Up = /* @__PURE__ */ new Set([\"sanitize\", \"allowList\", \"sanitizeFn\"]), Xp = {\n  animation: \"boolean\",\n  template: \"string\",\n  title: \"(string|element|function)\",\n  trigger: \"string\",\n  delay: \"(number|object)\",\n  html: \"boolean\",\n  selector: \"(string|boolean)\",\n  placement: \"(string|function)\",\n  offset: \"(array|string|function)\",\n  container: \"(string|element|boolean)\",\n  fallbackPlacements: \"array\",\n  boundary: \"(string|element)\",\n  customClass: \"(string|function)\",\n  sanitize: \"boolean\",\n  sanitizeFn: \"(null|function)\",\n  allowList: \"object\",\n  popperConfig: \"(null|object|function)\"\n}, Gp = {\n  AUTO: \"auto\",\n  TOP: \"top\",\n  RIGHT: F() ? \"left\" : \"right\",\n  BOTTOM: \"bottom\",\n  LEFT: F() ? \"right\" : \"left\"\n}, qp = {\n  animation: !0,\n  template: '<div class=\"opacity-0 transition-opacity duration-300 ease-in-out absolute z-[1080] block m-0 text-sm not-italic font-normal text-left no-underline underline-offset-auto normal-case leading-6 tracking-normal break-normal whitespace-normal\" role=\"tooltip\"><div data-te-tooltip-inner-ref class=\"tooltip-inner max-w-[200px] text-sm py-1.5 px-4 text-white text-center bg-[#6d6d6d] rounded\"></div></div>',\n  trigger: \"hover focus\",\n  title: \"\",\n  delay: 0,\n  html: !1,\n  selector: !1,\n  placement: \"top\",\n  offset: [0, 0],\n  container: !1,\n  fallbackPlacements: [\"top\", \"right\", \"bottom\", \"left\"],\n  boundary: \"clippingParents\",\n  customClass: \"\",\n  sanitize: !0,\n  sanitizeFn: null,\n  allowList: jp,\n  popperConfig: { hide: !0 }\n}, Zp = {\n  HIDE: `hide${wt}`,\n  HIDDEN: `hidden${wt}`,\n  SHOW: `show${wt}`,\n  SHOWN: `shown${wt}`,\n  INSERTED: `inserted${wt}`,\n  CLICK: `click${wt}`,\n  FOCUSIN: `focusin${wt}`,\n  FOCUSOUT: `focusout${wt}`,\n  MOUSEENTER: `mouseenter${wt}`,\n  MOUSELEAVE: `mouseleave${wt}`\n}, Qp = \"fade\", Jp = \"modal\", Mn = \"show\", ci = \"show\", Rn = \"out\", ua = \".tooltip-inner\", pa = `.${Jp}`, _a = \"hide.te.modal\", hi = \"hover\", Pn = \"focus\", t_ = \"click\", e_ = \"manual\";\nclass ii extends gt {\n  constructor(t, e) {\n    if (typeof Ic > \"u\")\n      throw new TypeError(\n        \"Bootstrap's tooltips require Popper (https://popper.js.org)\"\n      );\n    super(t), this._isEnabled = !0, this._timeout = 0, this._hoverState = \"\", this._activeTrigger = {}, this._popper = null, this._config = this._getConfig(e), this.tip = null, this._setListeners();\n  }\n  // Getters\n  static get Default() {\n    return qp;\n  }\n  static get NAME() {\n    return da;\n  }\n  static get Event() {\n    return Zp;\n  }\n  static get DefaultType() {\n    return Xp;\n  }\n  // Public\n  enable() {\n    this._isEnabled = !0;\n  }\n  disable() {\n    this._isEnabled = !1;\n  }\n  toggleEnabled() {\n    this._isEnabled = !this._isEnabled;\n  }\n  toggle(t) {\n    if (this._isEnabled)\n      if (t) {\n        const e = this._initializeOnDelegatedTarget(t);\n        e._activeTrigger.click = !e._activeTrigger.click, e._isWithActiveTrigger() ? e._enter(null, e) : e._leave(null, e);\n      } else {\n        if (this.getTipElement().classList.contains(Mn)) {\n          this._leave(null, this);\n          return;\n        }\n        this._enter(null, this);\n      }\n  }\n  dispose() {\n    clearTimeout(this._timeout), c.off(\n      this._element.closest(pa),\n      _a,\n      this._hideModalHandler\n    ), this.tip && this.tip.remove(), this._disposePopper(), super.dispose();\n  }\n  show() {\n    if (this._element.style.display === \"none\")\n      throw new Error(\"Please use show on visible elements\");\n    if (!(this.isWithContent() && this._isEnabled))\n      return;\n    const t = c.trigger(\n      this._element,\n      this.constructor.Event.SHOW\n    ), e = Gl(this._element), i = e === null ? this._element.ownerDocument.documentElement.contains(this._element) : e.contains(this._element);\n    if (t.defaultPrevented || !i)\n      return;\n    this.constructor.NAME === \"tooltip\" && this.tip && this.getTitle() !== this.tip.querySelector(ua).innerHTML && (this._disposePopper(), this.tip.remove(), this.tip = null);\n    const n = this.getTipElement(), o = rt(this.constructor.NAME);\n    n.setAttribute(\"id\", o), this._element.setAttribute(\"aria-describedby\", o), this._config.animation && setTimeout(() => {\n      this.tip.classList.add(\"opacity-100\"), this.tip.classList.remove(\"opacity-0\");\n    }, 100);\n    const r = typeof this._config.placement == \"function\" ? this._config.placement.call(this, n, this._element) : this._config.placement, a = this._getAttachment(r);\n    this._addAttachmentClass(a);\n    const { container: l } = this._config;\n    if (y.setData(n, this.constructor.DATA_KEY, this), this._element.ownerDocument.documentElement.contains(this.tip) || (l.append(n), c.trigger(this._element, this.constructor.Event.INSERTED)), this._popper ? this._popper.update() : this._popper = Ce(\n      this._element,\n      n,\n      this._getPopperConfig(a)\n    ), n.getAttribute(\"id\").includes(\"tooltip\"))\n      switch (r) {\n        case \"bottom\":\n          n.classList.add(\"py-[0.4rem]\");\n          break;\n        case \"left\":\n          n.classList.add(\"px-[0.4rem]\");\n          break;\n        case \"right\":\n          n.classList.add(\"px-[0.4rem]\");\n          break;\n        default:\n          n.classList.add(\"py-[0.4rem]\");\n          break;\n      }\n    const u = this._resolvePossibleFunction(this._config.customClass);\n    u && n.classList.add(...u.split(\" \")), \"ontouchstart\" in document.documentElement && [].concat(...document.body.children).forEach((g) => {\n      c.on(g, \"mouseover\", tn);\n    });\n    const _ = () => {\n      const g = this._hoverState;\n      this._hoverState = null, c.trigger(this._element, this.constructor.Event.SHOWN), g === Rn && this._leave(null, this);\n    }, f = this.tip.classList.contains(\"transition-opacity\");\n    this._queueCallback(_, this.tip, f);\n  }\n  hide() {\n    if (!this._popper)\n      return;\n    const t = this.getTipElement(), e = () => {\n      this._isWithActiveTrigger() || (this._hoverState !== ci && t.remove(), this._cleanTipClass(), this._element.removeAttribute(\"aria-describedby\"), c.trigger(this._element, this.constructor.Event.HIDDEN), this._disposePopper());\n    };\n    if (c.trigger(\n      this._element,\n      this.constructor.Event.HIDE\n    ).defaultPrevented)\n      return;\n    t.classList.add(\"opacity-0\"), t.classList.remove(\"opacity-100\"), \"ontouchstart\" in document.documentElement && [].concat(...document.body.children).forEach((o) => c.off(o, \"mouseover\", tn)), this._activeTrigger[t_] = !1, this._activeTrigger[Pn] = !1, this._activeTrigger[hi] = !1;\n    const n = this.tip.classList.contains(\"opacity-0\");\n    this._queueCallback(e, this.tip, n), this._hoverState = \"\";\n  }\n  update() {\n    this._popper !== null && this._popper.update();\n  }\n  // Protected\n  isWithContent() {\n    return !!this.getTitle();\n  }\n  getTipElement() {\n    if (this.tip)\n      return this.tip;\n    const t = document.createElement(\"div\");\n    t.innerHTML = this._config.template;\n    const e = t.children[0];\n    return this.setContent(e), e.classList.remove(Qp, Mn), this.tip = e, this.tip;\n  }\n  setContent(t) {\n    this._sanitizeAndSetContent(t, this.getTitle(), ua);\n  }\n  _sanitizeAndSetContent(t, e, i) {\n    const n = d.findOne(i, t);\n    if (!e && n) {\n      n.remove();\n      return;\n    }\n    this.setElementContent(n, e);\n  }\n  setElementContent(t, e) {\n    if (t !== null) {\n      if (je(e)) {\n        e = te(e), this._config.html ? e.parentNode !== t && (t.innerHTML = \"\", t.append(e)) : t.textContent = e.textContent;\n        return;\n      }\n      this._config.html ? (this._config.sanitize && (e = ha(\n        e,\n        this._config.allowList,\n        this._config.sanitizeFn\n      )), t.innerHTML = e) : t.textContent = e;\n    }\n  }\n  getTitle() {\n    const t = this._element.getAttribute(\"data-te-original-title\") || this._config.title;\n    return this._resolvePossibleFunction(t);\n  }\n  updateAttachment(t) {\n    return t === \"right\" ? \"end\" : t === \"left\" ? \"start\" : t;\n  }\n  // Private\n  _initializeOnDelegatedTarget(t, e) {\n    return e || this.constructor.getOrCreateInstance(\n      t.delegateTarget,\n      this._getDelegateConfig()\n    );\n  }\n  _getOffset() {\n    const { offset: t } = this._config;\n    return typeof t == \"string\" ? t.split(\",\").map((e) => Number.parseInt(e, 10)) : typeof t == \"function\" ? (e) => t(e, this._element) : t;\n  }\n  _resolvePossibleFunction(t) {\n    return typeof t == \"function\" ? t.call(this._element) : t;\n  }\n  _getPopperConfig(t) {\n    const e = {\n      placement: t,\n      modifiers: [\n        {\n          name: \"flip\",\n          options: {\n            fallbackPlacements: this._config.fallbackPlacements\n          }\n        },\n        {\n          name: \"offset\",\n          options: {\n            offset: this._getOffset()\n          }\n        },\n        {\n          name: \"preventOverflow\",\n          options: {\n            boundary: this._config.boundary\n          }\n        },\n        {\n          name: \"arrow\",\n          options: {\n            element: `.${this.constructor.NAME}-arrow`\n          }\n        },\n        {\n          name: \"onChange\",\n          enabled: !0,\n          phase: \"afterWrite\",\n          fn: (i) => this._handlePopperPlacementChange(i)\n        }\n      ],\n      onFirstUpdate: (i) => {\n        i.options.placement !== i.placement && this._handlePopperPlacementChange(i);\n      }\n    };\n    return {\n      ...e,\n      ...typeof this._config.popperConfig == \"function\" ? this._config.popperConfig(e) : this._config.popperConfig\n    };\n  }\n  _addAttachmentClass(t) {\n    this.getTipElement().classList.add(\n      `${this._getBasicClassPrefix()}-${this.updateAttachment(t)}`\n    );\n  }\n  _getAttachment(t) {\n    return Gp[t.toUpperCase()];\n  }\n  _setListeners() {\n    this._config.trigger.split(\" \").forEach((e) => {\n      if (e === \"click\")\n        c.on(\n          this._element,\n          this.constructor.Event.CLICK,\n          this._config.selector,\n          (i) => this.toggle(i)\n        );\n      else if (e !== e_) {\n        const i = e === hi ? this.constructor.Event.MOUSEENTER : this.constructor.Event.FOCUSIN, n = e === hi ? this.constructor.Event.MOUSELEAVE : this.constructor.Event.FOCUSOUT;\n        c.on(\n          this._element,\n          i,\n          this._config.selector,\n          (o) => this._enter(o)\n        ), c.on(\n          this._element,\n          n,\n          this._config.selector,\n          (o) => this._leave(o)\n        );\n      }\n    }), this._hideModalHandler = () => {\n      this._element && this.hide();\n    }, c.on(\n      this._element.closest(pa),\n      _a,\n      this._hideModalHandler\n    ), this._config.selector ? this._config = {\n      ...this._config,\n      trigger: \"manual\",\n      selector: \"\"\n    } : this._fixTitle();\n  }\n  _fixTitle() {\n    const t = this._element.getAttribute(\"title\"), e = typeof this._element.getAttribute(\n      \"data-te-original-title\"\n    );\n    (t || e !== \"string\") && (this._element.setAttribute(\"data-te-original-title\", t || \"\"), t && !this._element.getAttribute(\"aria-label\") && !this._element.textContent && this._element.setAttribute(\"aria-label\", t), this._element.setAttribute(\"title\", \"\"));\n  }\n  _enter(t, e) {\n    if (e = this._initializeOnDelegatedTarget(t, e), t && (e._activeTrigger[t.type === \"focusin\" ? Pn : hi] = !0), e.getTipElement().classList.contains(Mn) || e._hoverState === ci) {\n      e._hoverState = ci;\n      return;\n    }\n    if (clearTimeout(e._timeout), e._hoverState = ci, !e._config.delay || !e._config.delay.show) {\n      e.show();\n      return;\n    }\n    e._timeout = setTimeout(() => {\n      e._hoverState === ci && e.show();\n    }, e._config.delay.show);\n  }\n  _leave(t, e) {\n    if (e = this._initializeOnDelegatedTarget(t, e), t && (e._activeTrigger[t.type === \"focusout\" ? Pn : hi] = e._element.contains(t.relatedTarget)), !e._isWithActiveTrigger()) {\n      if (clearTimeout(e._timeout), e._hoverState = Rn, !e._config.delay || !e._config.delay.hide) {\n        e.hide();\n        return;\n      }\n      e._timeout = setTimeout(() => {\n        e._hoverState === Rn && e.hide();\n      }, e._config.delay.hide);\n    }\n  }\n  _isWithActiveTrigger() {\n    for (const t in this._activeTrigger)\n      if (this._activeTrigger[t])\n        return !0;\n    return !1;\n  }\n  _getConfig(t) {\n    const e = h.getDataAttributes(this._element);\n    return Object.keys(e).forEach((i) => {\n      Up.has(i) && delete e[i];\n    }), t = {\n      ...this.constructor.Default,\n      ...e,\n      ...typeof t == \"object\" && t ? t : {}\n    }, t.container = t.container === !1 ? document.body : te(t.container), typeof t.delay == \"number\" && (t.delay = {\n      show: t.delay,\n      hide: t.delay\n    }), typeof t.title == \"number\" && (t.title = t.title.toString()), typeof t.content == \"number\" && (t.content = t.content.toString()), D(da, t, this.constructor.DefaultType), t.sanitize && (t.template = ha(\n      t.template,\n      t.allowList,\n      t.sanitizeFn\n    )), t;\n  }\n  _getDelegateConfig() {\n    const t = {};\n    for (const e in this._config)\n      this.constructor.Default[e] !== this._config[e] && (t[e] = this._config[e]);\n    return t;\n  }\n  _cleanTipClass() {\n    const t = this.getTipElement(), e = new RegExp(\n      `(^|\\\\s)${this._getBasicClassPrefix()}\\\\S+`,\n      \"g\"\n    ), i = t.getAttribute(\"class\").match(e);\n    i !== null && i.length > 0 && i.map((n) => n.trim()).forEach((n) => t.classList.remove(n));\n  }\n  _getBasicClassPrefix() {\n    return zp;\n  }\n  _handlePopperPlacementChange(t) {\n    const { state: e } = t;\n    e && (this.tip = e.elements.popper, this._cleanTipClass(), this._addAttachmentClass(this._getAttachment(e.placement)));\n  }\n  _disposePopper() {\n    this._popper && (this._popper.destroy(), this._popper = null);\n  }\n  // Static\n  static jQueryInterface(t) {\n    return this.each(function() {\n      const e = ii.getOrCreateInstance(this, t);\n      if (typeof t == \"string\") {\n        if (typeof e[t] > \"u\")\n          throw new TypeError(`No method named \"${t}\"`);\n        e[t]();\n      }\n    });\n  }\n}\nconst i_ = \"popover\", s_ = \"te.popover\", kt = `.${s_}`, n_ = \"te-popover\", o_ = {\n  ...ii.Default,\n  placement: \"right\",\n  offset: [0, 8],\n  trigger: \"click\",\n  content: \"\",\n  template: '<div class=\"opacity-0 transition-opacity duration-150 ease-in-out absolute top-0 left-0 z-[1070] block max-w-[267px] break-words bg-white bg-clip-padding border border-neutral-100 rounded-lg shadow-[0_0px_3px_0_rgba(0,0,0,0.07),0_2px_2px_0_rgba(0,0,0,0.04)] text-sm not-italic font-normal text-left no-underline underline-offset-auto normal-case leading-6 tracking-normal break-normal whitespace-normal dark:bg-neutral-700 dark:border-0 dark:text-white data-[popper-reference-hidden]:hidden\" role=\"tooltip\"><h3 class=\"popover-header py-2 px-4 mb-0 border-b-2 border-neutral-100 rounded-t-lg font-medium empty:hidden dark:border-neutral-500\"></h3><div class=\"popover-body p-4 text-[#212529] dark:text-white\"></div></div>'\n}, r_ = {\n  ...ii.DefaultType,\n  content: \"(string|element|function)\"\n}, a_ = {\n  HIDE: `hide${kt}`,\n  HIDDEN: `hidden${kt}`,\n  SHOW: `show${kt}`,\n  SHOWN: `shown${kt}`,\n  INSERTED: `inserted${kt}`,\n  CLICK: `click${kt}`,\n  FOCUSIN: `focusin${kt}`,\n  FOCUSOUT: `focusout${kt}`,\n  MOUSEENTER: `mouseenter${kt}`,\n  MOUSELEAVE: `mouseleave${kt}`\n}, l_ = \".popover-header\", c_ = \".popover-body\";\nclass Rc extends ii {\n  // Getters\n  static get Default() {\n    return o_;\n  }\n  static get NAME() {\n    return i_;\n  }\n  static get Event() {\n    return a_;\n  }\n  static get DefaultType() {\n    return r_;\n  }\n  // Overrides\n  isWithContent() {\n    return this.getTitle() || this._getContent();\n  }\n  setContent(t) {\n    this._sanitizeAndSetContent(t, this.getTitle(), l_), this._sanitizeAndSetContent(t, this._getContent(), c_);\n  }\n  // Private\n  _getContent() {\n    return this._resolvePossibleFunction(this._config.content);\n  }\n  _getBasicClassPrefix() {\n    return n_;\n  }\n  // Static\n  static jQueryInterface(t) {\n    return this.each(function() {\n      const e = Rc.getOrCreateInstance(this, t);\n      if (typeof t == \"string\") {\n        if (typeof e[t] > \"u\")\n          throw new TypeError(`No method named \"${t}\"`);\n        e[t]();\n      }\n    });\n  }\n}\nconst Bn = \"scrollspy\", h_ = \"te.scrollspy\", ur = `.${h_}`, fa = {\n  offset: 10,\n  method: \"auto\",\n  target: \"\"\n}, d_ = {\n  offset: \"number\",\n  method: \"string\",\n  target: \"(string|element)\"\n}, u_ = {\n  active: \"!text-primary dark:!text-primary-400 font-semibold border-l-[0.125rem] border-solid border-primary dark:border-primary-400\"\n}, p_ = {\n  active: \"string\"\n}, __ = `activate${ur}`, f_ = `scroll${ur}`, Hn = \"data-te-nav-link-active\", Pc = \"[data-te-dropdown-item-ref]\", m_ = \"[data-te-nav-list-ref]\", Mo = \"[data-te-nav-link-ref]\", g_ = \"[data-te-nav-item-ref]\", Bc = \"[data-te-list-group-item-ref]\", Vn = `${Mo}, ${Bc}, ${Pc}`, b_ = \"[data-te-dropdown-ref]\", v_ = \"[data-te-dropdown-toggle-ref]\", T_ = \"maxOffset\", ma = \"position\";\nclass Hc extends gt {\n  constructor(t, e, i) {\n    super(t), this._scrollElement = this._element.tagName === \"BODY\" ? window : this._element, this._config = this._getConfig(e), this._classes = this._getClasses(i), this._offsets = [], this._targets = [], this._activeTarget = null, this._scrollHeight = 0, c.on(this._scrollElement, f_, () => this._process()), this.refresh(), this._process();\n  }\n  // Getters\n  static get Default() {\n    return fa;\n  }\n  static get NAME() {\n    return Bn;\n  }\n  // Public\n  refresh() {\n    const t = this._scrollElement === this._scrollElement.window ? T_ : ma, e = this._config.method === \"auto\" ? t : this._config.method, i = e === ma ? this._getScrollTop() : 0;\n    this._offsets = [], this._targets = [], this._scrollHeight = this._getScrollHeight(), d.find(\n      Vn,\n      this._config.target\n    ).map((o) => {\n      const r = qo(o), a = r ? d.findOne(r) : null;\n      if (a) {\n        const l = a.getBoundingClientRect();\n        if (l.width || l.height)\n          return [\n            h[e](a).top + i,\n            r\n          ];\n      }\n      return null;\n    }).filter((o) => o).sort((o, r) => o[0] - r[0]).forEach((o) => {\n      this._offsets.push(o[0]), this._targets.push(o[1]);\n    });\n  }\n  dispose() {\n    c.off(this._scrollElement, ur), super.dispose();\n  }\n  // Private\n  _getConfig(t) {\n    return t = {\n      ...fa,\n      ...h.getDataAttributes(this._element),\n      ...typeof t == \"object\" && t ? t : {}\n    }, t.target = te(t.target) || document.documentElement, D(Bn, t, d_), t;\n  }\n  _getClasses(t) {\n    const e = h.getDataClassAttributes(this._element);\n    return t = {\n      ...u_,\n      ...e,\n      ...t\n    }, D(Bn, t, p_), t;\n  }\n  _getScrollTop() {\n    return this._scrollElement === window ? this._scrollElement.pageYOffset : this._scrollElement.scrollTop;\n  }\n  _getScrollHeight() {\n    return this._scrollElement.scrollHeight || Math.max(\n      document.body.scrollHeight,\n      document.documentElement.scrollHeight\n    );\n  }\n  _getOffsetHeight() {\n    return this._scrollElement === window ? window.innerHeight : this._scrollElement.getBoundingClientRect().height;\n  }\n  _process() {\n    const t = this._getScrollTop() + this._config.offset, e = this._getScrollHeight(), i = this._config.offset + e - this._getOffsetHeight();\n    if (this._scrollHeight !== e && this.refresh(), t >= i) {\n      const n = this._targets[this._targets.length - 1];\n      this._activeTarget !== n && this._activate(n);\n      return;\n    }\n    if (this._activeTarget && t < this._offsets[0] && this._offsets[0] > 0) {\n      this._activeTarget = null, this._clear();\n      return;\n    }\n    for (let n = this._offsets.length; n--; )\n      this._activeTarget !== this._targets[n] && t >= this._offsets[n] && (typeof this._offsets[n + 1] > \"u\" || t < this._offsets[n + 1]) && this._activate(this._targets[n]);\n  }\n  _activate(t) {\n    this._activeTarget = t, this._clear();\n    const e = Vn.split(\",\").map(\n      (n) => `${n}[data-te-target=\"${t}\"],${n}[href=\"${t}\"]`\n    ), i = d.findOne(e.join(\",\"), this._config.target);\n    i.classList.add(...this._classes.active.split(\" \")), i.setAttribute(Hn, \"\"), i.getAttribute(Pc) ? d.findOne(\n      v_,\n      i.closest(b_)\n    ).classList.add(...this._classes.active.split(\" \")) : d.parents(i, m_).forEach(\n      (n) => {\n        d.prev(\n          n,\n          `${Mo}, ${Bc}`\n        ).forEach((o) => {\n          o.classList.add(...this._classes.active.split(\" \")), o.setAttribute(Hn, \"\");\n        }), d.prev(n, g_).forEach(\n          (o) => {\n            d.children(o, Mo).forEach(\n              (r) => r.classList.add(...this._classes.active.split(\" \"))\n            );\n          }\n        );\n      }\n    ), c.trigger(this._scrollElement, __, {\n      relatedTarget: t\n    });\n  }\n  _clear() {\n    d.find(Vn, this._config.target).filter(\n      (t) => t.classList.contains(...this._classes.active.split(\" \"))\n    ).forEach((t) => {\n      t.classList.remove(...this._classes.active.split(\" \")), t.removeAttribute(Hn);\n    });\n  }\n  // Static\n  static jQueryInterface(t) {\n    return this.each(function() {\n      const e = Hc.getOrCreateInstance(this, t);\n      if (typeof t == \"string\") {\n        if (typeof e[t] > \"u\")\n          throw new TypeError(`No method named \"${t}\"`);\n        e[t]();\n      }\n    });\n  }\n}\nconst ga = \"tab\", E_ = \"te.tab\", hn = `.${E_}`, C_ = `hide${hn}`, A_ = `hidden${hn}`, y_ = `show${hn}`, w_ = `shown${hn}`, k_ = \"data-te-dropdown-menu-ref\", Le = \"data-te-tab-active\", Hs = \"data-te-nav-active\", x_ = \"[data-te-dropdown-ref]\", O_ = \"[data-te-nav-ref]\", ba = `[${Le}]`, S_ = `[${Hs}]`, va = \":scope > li > .active\", I_ = \"[data-te-dropdown-toggle-ref]\", D_ = \":scope > [data-te-dropdown-menu-ref] [data-te-dropdown-show]\", $_ = {\n  show: \"opacity-100\",\n  hide: \"opacity-0\"\n}, L_ = {\n  show: \"string\",\n  hide: \"string\"\n};\nclass Vc extends gt {\n  constructor(t, e) {\n    super(t), this._classes = this._getClasses(e);\n  }\n  // Getters\n  static get NAME() {\n    return ga;\n  }\n  // Public\n  show() {\n    if (this._element.parentNode && this._element.parentNode.nodeType === Node.ELEMENT_NODE && this._element.getAttribute(Hs) === \"\")\n      return;\n    let t;\n    const e = Jt(this._element), i = this._element.closest(O_), n = d.findOne(\n      S_,\n      i\n    );\n    if (i) {\n      const l = i.nodeName === \"UL\" || i.nodeName === \"OL\" ? va : ba;\n      t = d.find(l, i), t = t[t.length - 1];\n    }\n    const o = t ? c.trigger(t, C_, {\n      relatedTarget: this._element\n    }) : null;\n    if (c.trigger(this._element, y_, {\n      relatedTarget: t\n    }).defaultPrevented || o !== null && o.defaultPrevented)\n      return;\n    this._activate(\n      this._element,\n      i,\n      null,\n      n,\n      this._element\n    );\n    const a = () => {\n      c.trigger(t, A_, {\n        relatedTarget: this._element\n      }), c.trigger(this._element, w_, {\n        relatedTarget: t\n      });\n    };\n    e ? this._activate(\n      e,\n      e.parentNode,\n      a,\n      n,\n      this._element\n    ) : a();\n  }\n  // Private\n  _getClasses(t) {\n    const e = h.getDataClassAttributes(this._element);\n    return t = {\n      ...$_,\n      ...e,\n      ...t\n    }, D(ga, t, L_), t;\n  }\n  _activate(t, e, i, n, o) {\n    const a = (e && (e.nodeName === \"UL\" || e.nodeName === \"OL\") ? d.find(va, e) : d.children(e, ba))[0], l = i && a && a.hasAttribute(Le), p = () => this._transitionComplete(\n      t,\n      a,\n      i,\n      n,\n      o\n    );\n    a && l ? (h.removeClass(a, this._classes.show), h.addClass(a, this._classes.hide), this._queueCallback(p, t, !0)) : p();\n  }\n  _transitionComplete(t, e, i, n, o) {\n    if (e && n) {\n      e.removeAttribute(Le), n.removeAttribute(Hs);\n      const a = d.findOne(\n        D_,\n        e.parentNode\n      );\n      a && a.removeAttribute(Le), e.getAttribute(\"role\") === \"tab\" && e.setAttribute(\"aria-selected\", !1);\n    }\n    t.setAttribute(Le, \"\"), o.setAttribute(Hs, \"\"), t.getAttribute(\"role\") === \"tab\" && t.setAttribute(\"aria-selected\", !0), Je(t), t.classList.contains(this._classes.hide) && (h.removeClass(t, this._classes.hide), h.addClass(t, this._classes.show));\n    let r = t.parentNode;\n    if (r && r.nodeName === \"LI\" && (r = r.parentNode), r && r.hasAttribute(k_)) {\n      const a = t.closest(x_);\n      a && d.find(I_, a).forEach(\n        (l) => l.setAttribute(Le, \"\")\n      ), t.setAttribute(\"aria-expanded\", !0);\n    }\n    i && i();\n  }\n  // Static\n  static jQueryInterface(t) {\n    return this.each(function() {\n      const e = Vc.getOrCreateInstance(this);\n      if (typeof t == \"string\") {\n        if (typeof e[t] > \"u\")\n          throw new TypeError(`No method named \"${t}\"`);\n        e[t]();\n      }\n    });\n  }\n}\nconst Wn = \"toast\", N_ = \"te.toast\", ie = `.${N_}`, M_ = `mouseover${ie}`, R_ = `mouseout${ie}`, P_ = `focusin${ie}`, B_ = `focusout${ie}`, H_ = `hide${ie}`, V_ = `hidden${ie}`, W_ = `show${ie}`, F_ = `shown${ie}`, Ta = \"data-te-toast-hide\", Fn = \"data-te-toast-show\", ns = \"data-te-toast-showing\", Y_ = {\n  animation: \"boolean\",\n  autohide: \"boolean\",\n  delay: \"number\"\n}, Ea = {\n  animation: !0,\n  autohide: !0,\n  delay: 5e3\n}, j_ = {\n  fadeIn: \"animate-[fade-in_0.3s_both] p-[auto] motion-reduce:transition-none motion-reduce:animate-none\",\n  fadeOut: \"animate-[fade-out_0.3s_both] p-[auto] motion-reduce:transition-none motion-reduce:animate-none\"\n}, K_ = {\n  fadeIn: \"string\",\n  fadeOut: \"string\"\n};\nclass Ro extends gt {\n  constructor(t, e, i) {\n    super(t), this._config = this._getConfig(e), this._classes = this._getClasses(i), this._timeout = null, this._hasMouseInteraction = !1, this._hasKeyboardInteraction = !1, this._setListeners(), this._didInit = !1, this._init();\n  }\n  // Getters\n  static get DefaultType() {\n    return Y_;\n  }\n  static get Default() {\n    return Ea;\n  }\n  static get NAME() {\n    return Wn;\n  }\n  // Public\n  show() {\n    if (c.trigger(this._element, W_).defaultPrevented)\n      return;\n    this._clearTimeout(), this._config.animation && (h.removeClass(this._element, this._classes.fadeOut), h.addClass(this._element, this._classes.fadeIn));\n    const e = () => {\n      this._element.removeAttribute(ns), c.trigger(this._element, F_), this._maybeScheduleHide();\n    };\n    this._element.removeAttribute(Ta), Je(this._element), this._element.setAttribute(Fn, \"\"), this._element.setAttribute(ns, \"\"), this._queueCallback(e, this._element, this._config.animation);\n  }\n  hide() {\n    if (!this._element || this._element.dataset.teToastShow === void 0 || c.trigger(this._element, H_).defaultPrevented)\n      return;\n    const e = () => {\n      let i = 0;\n      this._config.animation && (i = 300, h.removeClass(this._element, this._classes.fadeIn), h.addClass(this._element, this._classes.fadeOut)), setTimeout(() => {\n        this._element.setAttribute(Ta, \"\"), this._element.removeAttribute(ns), this._element.removeAttribute(Fn), c.trigger(this._element, V_);\n      }, i);\n    };\n    this._element.setAttribute(ns, \"\"), this._queueCallback(e, this._element, this._config.animation);\n  }\n  dispose() {\n    this._clearTimeout(), this._element.dataset.teToastShow !== void 0 && this._element.removeAttribute(Fn), super.dispose();\n  }\n  // Private\n  _init() {\n    this._didInit || (cn(Ro), this._didInit = !0);\n  }\n  _getConfig(t) {\n    return t = {\n      ...Ea,\n      ...h.getDataAttributes(this._element),\n      ...typeof t == \"object\" && t ? t : {}\n    }, D(Wn, t, this.constructor.DefaultType), t;\n  }\n  _getClasses(t) {\n    const e = h.getDataClassAttributes(this._element);\n    return t = {\n      ...j_,\n      ...e,\n      ...t\n    }, D(Wn, t, K_), t;\n  }\n  _maybeScheduleHide() {\n    this._config.autohide && (this._hasMouseInteraction || this._hasKeyboardInteraction || (this._timeout = setTimeout(() => {\n      this.hide();\n    }, this._config.delay)));\n  }\n  _onInteraction(t, e) {\n    switch (t.type) {\n      case \"mouseover\":\n      case \"mouseout\":\n        this._hasMouseInteraction = e;\n        break;\n      case \"focusin\":\n      case \"focusout\":\n        this._hasKeyboardInteraction = e;\n        break;\n    }\n    if (e) {\n      this._clearTimeout();\n      return;\n    }\n    const i = t.relatedTarget;\n    this._element === i || this._element.contains(i) || this._maybeScheduleHide();\n  }\n  _setListeners() {\n    c.on(\n      this._element,\n      M_,\n      (t) => this._onInteraction(t, !0)\n    ), c.on(\n      this._element,\n      R_,\n      (t) => this._onInteraction(t, !1)\n    ), c.on(\n      this._element,\n      P_,\n      (t) => this._onInteraction(t, !0)\n    ), c.on(\n      this._element,\n      B_,\n      (t) => this._onInteraction(t, !1)\n    );\n  }\n  _clearTimeout() {\n    clearTimeout(this._timeout), this._timeout = null;\n  }\n  // Static\n  static jQueryInterface(t) {\n    return this.each(function() {\n      const e = Ro.getOrCreateInstance(this, t);\n      if (typeof t == \"string\") {\n        if (typeof e[t] > \"u\")\n          throw new TypeError(`No method named \"${t}\"`);\n        e[t](this);\n      }\n    });\n  }\n}\n(() => {\n  var s = { 454: (i, n, o) => {\n    o.d(n, { Z: () => l });\n    var r = o(645), a = o.n(r)()(function(p) {\n      return p[1];\n    });\n    a.push([i.id, \"INPUT:-webkit-autofill,SELECT:-webkit-autofill,TEXTAREA:-webkit-autofill{animation-name:onautofillstart}INPUT:not(:-webkit-autofill),SELECT:not(:-webkit-autofill),TEXTAREA:not(:-webkit-autofill){animation-name:onautofillcancel}@keyframes onautofillstart{}@keyframes onautofillcancel{}\", \"\"]);\n    const l = a;\n  }, 645: (i) => {\n    i.exports = function(n) {\n      var o = [];\n      return o.toString = function() {\n        return this.map(function(r) {\n          var a = n(r);\n          return r[2] ? \"@media \".concat(r[2], \" {\").concat(a, \"}\") : a;\n        }).join(\"\");\n      }, o.i = function(r, a, l) {\n        typeof r == \"string\" && (r = [[null, r, \"\"]]);\n        var p = {};\n        if (l)\n          for (var u = 0; u < this.length; u++) {\n            var _ = this[u][0];\n            _ != null && (p[_] = !0);\n          }\n        for (var f = 0; f < r.length; f++) {\n          var g = [].concat(r[f]);\n          l && p[g[0]] || (a && (g[2] ? g[2] = \"\".concat(a, \" and \").concat(g[2]) : g[2] = a), o.push(g));\n        }\n      }, o;\n    };\n  }, 810: () => {\n    (function() {\n      if (typeof window < \"u\")\n        try {\n          var i = new window.CustomEvent(\"test\", { cancelable: !0 });\n          if (i.preventDefault(), i.defaultPrevented !== !0)\n            throw new Error(\"Could not prevent default\");\n        } catch {\n          var n = function(r, a) {\n            var l, p;\n            return (a = a || {}).bubbles = !!a.bubbles, a.cancelable = !!a.cancelable, (l = document.createEvent(\"CustomEvent\")).initCustomEvent(r, a.bubbles, a.cancelable, a.detail), p = l.preventDefault, l.preventDefault = function() {\n              p.call(this);\n              try {\n                Object.defineProperty(this, \"defaultPrevented\", { get: function() {\n                  return !0;\n                } });\n              } catch {\n                this.defaultPrevented = !0;\n              }\n            }, l;\n          };\n          n.prototype = window.Event.prototype, window.CustomEvent = n;\n        }\n    })();\n  }, 379: (i, n, o) => {\n    var r, a = function() {\n      var E = {};\n      return function(T) {\n        if (E[T] === void 0) {\n          var A = document.querySelector(T);\n          if (window.HTMLIFrameElement && A instanceof window.HTMLIFrameElement)\n            try {\n              A = A.contentDocument.head;\n            } catch {\n              A = null;\n            }\n          E[T] = A;\n        }\n        return E[T];\n      };\n    }(), l = [];\n    function p(E) {\n      for (var T = -1, A = 0; A < l.length; A++)\n        if (l[A].identifier === E) {\n          T = A;\n          break;\n        }\n      return T;\n    }\n    function u(E, T) {\n      for (var A = {}, k = [], I = 0; I < E.length; I++) {\n        var O = E[I], x = T.base ? O[0] + T.base : O[0], L = A[x] || 0, S = \"\".concat(x, \" \").concat(L);\n        A[x] = L + 1;\n        var N = p(S), P = { css: O[1], media: O[2], sourceMap: O[3] };\n        N !== -1 ? (l[N].references++, l[N].updater(P)) : l.push({ identifier: S, updater: w(P, T), references: 1 }), k.push(S);\n      }\n      return k;\n    }\n    function _(E) {\n      var T = document.createElement(\"style\"), A = E.attributes || {};\n      if (A.nonce === void 0) {\n        var k = o.nc;\n        k && (A.nonce = k);\n      }\n      if (Object.keys(A).forEach(function(O) {\n        T.setAttribute(O, A[O]);\n      }), typeof E.insert == \"function\")\n        E.insert(T);\n      else {\n        var I = a(E.insert || \"head\");\n        if (!I)\n          throw new Error(\"Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.\");\n        I.appendChild(T);\n      }\n      return T;\n    }\n    var f, g = (f = [], function(E, T) {\n      return f[E] = T, f.filter(Boolean).join(`\n`);\n    });\n    function m(E, T, A, k) {\n      var I = A ? \"\" : k.media ? \"@media \".concat(k.media, \" {\").concat(k.css, \"}\") : k.css;\n      if (E.styleSheet)\n        E.styleSheet.cssText = g(T, I);\n      else {\n        var O = document.createTextNode(I), x = E.childNodes;\n        x[T] && E.removeChild(x[T]), x.length ? E.insertBefore(O, x[T]) : E.appendChild(O);\n      }\n    }\n    function b(E, T, A) {\n      var k = A.css, I = A.media, O = A.sourceMap;\n      if (I ? E.setAttribute(\"media\", I) : E.removeAttribute(\"media\"), O && typeof btoa < \"u\" && (k += `\n/*# sourceMappingURL=data:application/json;base64,`.concat(btoa(unescape(encodeURIComponent(JSON.stringify(O)))), \" */\")), E.styleSheet)\n        E.styleSheet.cssText = k;\n      else {\n        for (; E.firstChild; )\n          E.removeChild(E.firstChild);\n        E.appendChild(document.createTextNode(k));\n      }\n    }\n    var v = null, C = 0;\n    function w(E, T) {\n      var A, k, I;\n      if (T.singleton) {\n        var O = C++;\n        A = v || (v = _(T)), k = m.bind(null, A, O, !1), I = m.bind(null, A, O, !0);\n      } else\n        A = _(T), k = b.bind(null, A, T), I = function() {\n          (function(x) {\n            if (x.parentNode === null)\n              return !1;\n            x.parentNode.removeChild(x);\n          })(A);\n        };\n      return k(E), function(x) {\n        if (x) {\n          if (x.css === E.css && x.media === E.media && x.sourceMap === E.sourceMap)\n            return;\n          k(E = x);\n        } else\n          I();\n      };\n    }\n    i.exports = function(E, T) {\n      (T = T || {}).singleton || typeof T.singleton == \"boolean\" || (T.singleton = (r === void 0 && (r = !!(window && document && document.all && !window.atob)), r));\n      var A = u(E = E || [], T);\n      return function(k) {\n        if (k = k || [], Object.prototype.toString.call(k) === \"[object Array]\") {\n          for (var I = 0; I < A.length; I++) {\n            var O = p(A[I]);\n            l[O].references--;\n          }\n          for (var x = u(k, T), L = 0; L < A.length; L++) {\n            var S = p(A[L]);\n            l[S].references === 0 && (l[S].updater(), l.splice(S, 1));\n          }\n          A = x;\n        }\n      };\n    };\n  } }, t = {};\n  function e(i) {\n    var n = t[i];\n    if (n !== void 0)\n      return n.exports;\n    var o = t[i] = { id: i, exports: {} };\n    return s[i](o, o.exports, e), o.exports;\n  }\n  e.n = (i) => {\n    var n = i && i.__esModule ? () => i.default : () => i;\n    return e.d(n, { a: n }), n;\n  }, e.d = (i, n) => {\n    for (var o in n)\n      e.o(n, o) && !e.o(i, o) && Object.defineProperty(i, o, { enumerable: !0, get: n[o] });\n  }, e.o = (i, n) => Object.prototype.hasOwnProperty.call(i, n), (() => {\n    var i = e(379), n = e.n(i), o = e(454);\n    function r(l) {\n      if (!l.hasAttribute(\"autocompleted\")) {\n        l.setAttribute(\"autocompleted\", \"\");\n        var p = new window.CustomEvent(\"onautocomplete\", { bubbles: !0, cancelable: !0, detail: null });\n        l.dispatchEvent(p) || (l.value = \"\");\n      }\n    }\n    function a(l) {\n      l.hasAttribute(\"autocompleted\") && (l.removeAttribute(\"autocompleted\"), l.dispatchEvent(new window.CustomEvent(\"onautocomplete\", { bubbles: !0, cancelable: !1, detail: null })));\n    }\n    n()(o.Z, { insert: \"head\", singleton: !1 }), o.Z.locals, e(810), document.addEventListener(\"animationstart\", function(l) {\n      l.animationName === \"onautofillstart\" ? r(l.target) : a(l.target);\n    }, !0), document.addEventListener(\"input\", function(l) {\n      l.inputType !== \"insertReplacementText\" && \"data\" in l ? a(l.target) : r(l.target);\n    }, !0);\n  })();\n})();\nconst Yn = \"input\", os = \"te.input\", Wc = \"data-te-input-wrapper-init\", Fc = \"data-te-input-notch-ref\", Yc = \"data-te-input-notch-leading-ref\", jc = \"data-te-input-notch-middle-ref\", z_ = \"data-te-input-notch-trailing-ref\", U_ = \"data-te-input-helper-ref\", X_ = \"data-te-input-placeholder-active\", Ft = \"data-te-input-state-active\", Ca = \"data-te-input-focused\", Aa = \"data-te-input-form-counter\", de = `[${Wc}] input`, ue = `[${Wc}] textarea`, ke = `[${Fc}]`, ya = `[${Yc}]`, wa = `[${jc}]`, G_ = `[${U_}]`, q_ = {\n  inputFormWhite: !1\n}, Z_ = {\n  inputFormWhite: \"(boolean)\"\n}, Kc = {\n  notch: \"group flex absolute left-0 top-0 w-full max-w-full h-full text-left pointer-events-none\",\n  notchLeading: \"pointer-events-none border border-solid box-border bg-transparent transition-all duration-200 ease-linear motion-reduce:transition-none left-0 top-0 h-full w-2 border-r-0 rounded-l-[0.25rem] group-data-[te-input-focused]:border-r-0 group-data-[te-input-state-active]:border-r-0\",\n  notchLeadingNormal: \"border-neutral-300 dark:border-neutral-600 group-data-[te-input-focused]:shadow-[-1px_0_0_#3b71ca,_0_1px_0_0_#3b71ca,_0_-1px_0_0_#3b71ca] group-data-[te-input-focused]:border-primary\",\n  notchLeadingWhite: \"border-neutral-200 group-data-[te-input-focused]:shadow-[-1px_0_0_#ffffff,_0_1px_0_0_#ffffff,_0_-1px_0_0_#ffffff] group-data-[te-input-focused]:border-white\",\n  notchMiddle: \"pointer-events-none border border-solid box-border bg-transparent transition-all duration-200 ease-linear motion-reduce:transition-none grow-0 shrink-0 basis-auto w-auto max-w-[calc(100%-1rem)] h-full border-r-0 border-l-0 group-data-[te-input-focused]:border-x-0 group-data-[te-input-state-active]:border-x-0 group-data-[te-input-focused]:border-t group-data-[te-input-state-active]:border-t group-data-[te-input-focused]:border-solid group-data-[te-input-state-active]:border-solid group-data-[te-input-focused]:border-t-transparent group-data-[te-input-state-active]:border-t-transparent\",\n  notchMiddleNormal: \"border-neutral-300 dark:border-neutral-600 group-data-[te-input-focused]:shadow-[0_1px_0_0_#3b71ca] group-data-[te-input-focused]:border-primary\",\n  notchMiddleWhite: \"border-neutral-200 group-data-[te-input-focused]:shadow-[0_1px_0_0_#ffffff] group-data-[te-input-focused]:border-white\",\n  notchTrailing: \"pointer-events-none border border-solid box-border bg-transparent transition-all duration-200 ease-linear motion-reduce:transition-none grow h-full border-l-0 rounded-r-[0.25rem] group-data-[te-input-focused]:border-l-0 group-data-[te-input-state-active]:border-l-0\",\n  notchTrailingNormal: \"border-neutral-300 dark:border-neutral-600 group-data-[te-input-focused]:shadow-[1px_0_0_#3b71ca,_0_-1px_0_0_#3b71ca,_0_1px_0_0_#3b71ca] group-data-[te-input-focused]:border-primary\",\n  notchTrailingWhite: \"border-neutral-200 group-data-[te-input-focused]:shadow-[1px_0_0_#ffffff,_0_-1px_0_0_#ffffff,_0_1px_0_0_#ffffff] group-data-[te-input-focused]:border-white\",\n  counter: \"text-right leading-[1.6]\"\n}, Q_ = {\n  notch: \"string\",\n  notchLeading: \"string\",\n  notchLeadingNormal: \"string\",\n  notchLeadingWhite: \"string\",\n  notchMiddle: \"string\",\n  notchMiddleNormal: \"string\",\n  notchMiddleWhite: \"string\",\n  notchTrailing: \"string\",\n  notchTrailingNormal: \"string\",\n  notchTrailingWhite: \"string\",\n  counter: \"string\"\n};\nclass V {\n  constructor(t, e, i) {\n    this._config = this._getConfig(e, t), this._element = t, this._classes = this._getClasses(i), this._label = null, this._labelWidth = 0, this._labelMarginLeft = 0, this._notchLeading = null, this._notchMiddle = null, this._notchTrailing = null, this._initiated = !1, this._helper = null, this._counter = !1, this._counterElement = null, this._maxLength = 0, this._leadingIcon = null, this._element && (y.setData(t, os, this), this.init());\n  }\n  // Getters\n  static get NAME() {\n    return Yn;\n  }\n  get input() {\n    return d.findOne(\"input\", this._element) || d.findOne(\"textarea\", this._element);\n  }\n  // Public\n  init() {\n    this._initiated || (this._getLabelData(), this._applyDivs(), this._applyNotch(), this._activate(), this._getHelper(), this._getCounter(), this._getEvents(), this._initiated = !0);\n  }\n  update() {\n    this._getLabelData(), this._getNotchData(), this._applyNotch(), this._activate(), this._getHelper(), this._getCounter();\n  }\n  forceActive() {\n    this.input.setAttribute(Ft, \"\"), d.findOne(ke, this.input.parentNode).setAttribute(\n      Ft,\n      \"\"\n    );\n  }\n  forceInactive() {\n    this.input.removeAttribute(Ft), d.findOne(\n      ke,\n      this.input.parentNode\n    ).removeAttribute(Ft);\n  }\n  dispose() {\n    this._removeBorder(), y.removeData(this._element, os), this._element = null;\n  }\n  // Private\n  _getConfig(t, e) {\n    return t = {\n      ...q_,\n      ...h.getDataAttributes(e),\n      ...typeof t == \"object\" ? t : {}\n    }, D(Yn, t, Z_), t;\n  }\n  _getClasses(t) {\n    const e = h.getDataClassAttributes(this._element);\n    return t = {\n      ...Kc,\n      ...e,\n      ...t\n    }, D(Yn, t, Q_), t;\n  }\n  _getLabelData() {\n    this._label = d.findOne(\"label\", this._element), this._label === null ? this._showPlaceholder() : (this._getLabelWidth(), this._getLabelPositionInInputGroup(), this._toggleDefaultDatePlaceholder());\n  }\n  _getHelper() {\n    this._helper = d.findOne(G_, this._element);\n  }\n  _getCounter() {\n    this._counter = h.getDataAttribute(\n      this.input,\n      \"inputShowcounter\"\n    ), this._counter && (this._maxLength = this.input.maxLength, this._showCounter());\n  }\n  _getEvents() {\n    c.on(\n      document,\n      \"focus\",\n      de,\n      V.activate(new V())\n    ), c.on(\n      document,\n      \"input\",\n      de,\n      V.activate(new V())\n    ), c.on(\n      document,\n      \"blur\",\n      de,\n      V.deactivate(new V())\n    ), c.on(\n      document,\n      \"focus\",\n      ue,\n      V.activate(new V())\n    ), c.on(\n      document,\n      \"input\",\n      ue,\n      V.activate(new V())\n    ), c.on(\n      document,\n      \"blur\",\n      ue,\n      V.deactivate(new V())\n    ), c.on(window, \"shown.te.modal\", (t) => {\n      d.find(de, t.target).forEach(\n        (e) => {\n          const i = V.getInstance(e.parentNode);\n          i && i.update();\n        }\n      ), d.find(ue, t.target).forEach(\n        (e) => {\n          const i = V.getInstance(e.parentNode);\n          i && i.update();\n        }\n      );\n    }), c.on(window, \"shown.te.dropdown\", (t) => {\n      const e = t.target.parentNode.querySelector(\n        \"[data-te-dropdown-menu-ref]\"\n      );\n      e && (d.find(de, e).forEach(\n        (i) => {\n          const n = V.getInstance(i.parentNode);\n          n && n.update();\n        }\n      ), d.find(ue, e).forEach(\n        (i) => {\n          const n = V.getInstance(i.parentNode);\n          n && n.update();\n        }\n      ));\n    }), c.on(window, \"shown.te.tab\", (t) => {\n      let e;\n      t.target.href ? e = t.target.href.split(\"#\")[1] : e = h.getDataAttribute(t.target, \"target\").split(\n        \"#\"\n      )[1];\n      const i = d.findOne(`#${e}`);\n      d.find(de, i).forEach((n) => {\n        const o = V.getInstance(n.parentNode);\n        o && o.update();\n      }), d.find(ue, i).forEach(\n        (n) => {\n          const o = V.getInstance(n.parentNode);\n          o && o.update();\n        }\n      );\n    }), c.on(window, \"reset\", (t) => {\n      d.find(de, t.target).forEach(\n        (e) => {\n          const i = V.getInstance(e.parentNode);\n          i && i.forceInactive();\n        }\n      ), d.find(ue, t.target).forEach(\n        (e) => {\n          const i = V.getInstance(e.parentNode);\n          i && i.forceInactive();\n        }\n      );\n    }), c.on(window, \"onautocomplete\", (t) => {\n      const e = V.getInstance(t.target.parentNode);\n      !e || !t.cancelable || e.forceActive();\n    });\n  }\n  _showCounter() {\n    if (d.find(\n      `[${Aa}]`,\n      this._element\n    ).length > 0)\n      return;\n    this._counterElement = document.createElement(\"div\"), h.addClass(this._counterElement, this._classes.counter), this._counterElement.setAttribute(Aa, \"\");\n    const e = this.input.value.length;\n    this._counterElement.innerHTML = `${e} / ${this._maxLength}`, this._helper.appendChild(this._counterElement), this._bindCounter();\n  }\n  _bindCounter() {\n    c.on(this.input, \"input\", () => {\n      const t = this.input.value.length;\n      this._counterElement.innerHTML = `${t} / ${this._maxLength}`;\n    });\n  }\n  _toggleDefaultDatePlaceholder(t = this.input) {\n    if (!(t.getAttribute(\"type\") === \"date\"))\n      return;\n    !(document.activeElement === t) && !t.value ? t.style.opacity = 0 : t.style.opacity = 1;\n  }\n  _showPlaceholder() {\n    this.input.setAttribute(X_, \"\");\n  }\n  _getNotchData() {\n    this._notchMiddle = d.findOne(\n      wa,\n      this._element\n    ), this._notchLeading = d.findOne(\n      ya,\n      this._element\n    );\n  }\n  _getLabelWidth() {\n    this._labelWidth = this._label.clientWidth * 0.8 + 8;\n  }\n  _getLabelPositionInInputGroup() {\n    if (this._labelMarginLeft = 0, !this._element.hasAttribute(\"data-te-input-group-ref\"))\n      return;\n    const t = this.input, e = d.prev(\n      t,\n      \"[data-te-input-group-text-ref]\"\n    )[0];\n    e === void 0 ? this._labelMarginLeft = 0 : this._labelMarginLeft = e.offsetWidth - 1;\n  }\n  _applyDivs() {\n    const t = this._config.inputFormWhite ? this._classes.notchLeadingWhite : this._classes.notchLeadingNormal, e = this._config.inputFormWhite ? this._classes.notchMiddleWhite : this._classes.notchMiddleNormal, i = this._config.inputFormWhite ? this._classes.notchTrailingWhite : this._classes.notchTrailingNormal, n = d.find(ke, this._element), o = $(\"div\");\n    h.addClass(o, this._classes.notch), o.setAttribute(Fc, \"\"), this._notchLeading = $(\"div\"), h.addClass(\n      this._notchLeading,\n      `${this._classes.notchLeading} ${t}`\n    ), this._notchLeading.setAttribute(Yc, \"\"), this._notchMiddle = $(\"div\"), h.addClass(\n      this._notchMiddle,\n      `${this._classes.notchMiddle} ${e}`\n    ), this._notchMiddle.setAttribute(jc, \"\"), this._notchTrailing = $(\"div\"), h.addClass(\n      this._notchTrailing,\n      `${this._classes.notchTrailing} ${i}`\n    ), this._notchTrailing.setAttribute(z_, \"\"), !(n.length >= 1) && (o.append(this._notchLeading), o.append(this._notchMiddle), o.append(this._notchTrailing), this._element.append(o));\n  }\n  _applyNotch() {\n    this._notchMiddle.style.width = `${this._labelWidth}px`, this._notchLeading.style.width = `${this._labelMarginLeft + 9}px`, this._label !== null && (this._label.style.marginLeft = `${this._labelMarginLeft}px`);\n  }\n  _removeBorder() {\n    const t = d.findOne(ke, this._element);\n    t && t.remove();\n  }\n  _activate(t) {\n    Zl(() => {\n      this._getElements(t);\n      const e = t ? t.target : this.input, i = d.findOne(\n        ke,\n        this._element\n      );\n      t && t.type === \"focus\" && i && i.setAttribute(Ca, \"\"), e.value !== \"\" && (e.setAttribute(Ft, \"\"), i && i.setAttribute(Ft, \"\")), this._toggleDefaultDatePlaceholder(e);\n    });\n  }\n  _getElements(t) {\n    if (t && (this._element = t.target.parentNode, this._label = d.findOne(\"label\", this._element)), t && this._label) {\n      const e = this._labelWidth;\n      this._getLabelData(), e !== this._labelWidth && (this._notchMiddle = d.findOne(\n        wa,\n        t.target.parentNode\n      ), this._notchLeading = d.findOne(\n        ya,\n        t.target.parentNode\n      ), this._applyNotch());\n    }\n  }\n  _deactivate(t) {\n    const e = t ? t.target : this.input, i = d.findOne(\n      ke,\n      e.parentNode\n    );\n    i.removeAttribute(Ca), e.value === \"\" && (e.removeAttribute(Ft), i.removeAttribute(Ft)), this._toggleDefaultDatePlaceholder(e);\n  }\n  static activate(t) {\n    return function(e) {\n      t._activate(e);\n    };\n  }\n  static deactivate(t) {\n    return function(e) {\n      t._deactivate(e);\n    };\n  }\n  static jQueryInterface(t, e) {\n    return this.each(function() {\n      let i = y.getData(this, os);\n      const n = typeof t == \"object\" && t;\n      if (!(!i && /dispose/.test(t)) && (i || (i = new V(this, n)), typeof t == \"string\")) {\n        if (typeof i[t] > \"u\")\n          throw new TypeError(`No method named \"${t}\"`);\n        i[t](e);\n      }\n    });\n  }\n  static getInstance(t) {\n    return y.getData(t, os);\n  }\n  static getOrCreateInstance(t, e = {}) {\n    return this.getInstance(t) || new this(t, typeof e == \"object\" ? e : null);\n  }\n}\nconst ka = \"animation\", jn = \"te.animation\", J_ = {\n  animation: \"string\",\n  animationStart: \"string\",\n  animationShowOnLoad: \"boolean\",\n  onStart: \"(null|function)\",\n  onEnd: \"(null|function)\",\n  onHide: \"(null|function)\",\n  onShow: \"(null|function)\",\n  animationOnScroll: \"(string)\",\n  animationWindowHeight: \"number\",\n  animationOffset: \"(number|string)\",\n  animationDelay: \"(number|string)\",\n  animationReverse: \"boolean\",\n  animationInterval: \"(number|string)\",\n  animationRepeat: \"(number|boolean)\",\n  animationReset: \"boolean\"\n}, tf = {\n  animation: \"fade\",\n  animationStart: \"onClick\",\n  animationShowOnLoad: !0,\n  onStart: null,\n  onEnd: null,\n  onHide: null,\n  onShow: null,\n  animationOnScroll: \"once\",\n  animationWindowHeight: 0,\n  animationOffset: 0,\n  animationDelay: 0,\n  animationReverse: !1,\n  animationInterval: 0,\n  animationRepeat: !1,\n  animationReset: !1\n};\nclass pr {\n  constructor(t, e) {\n    this._element = t, this._animateElement = this._getAnimateElement(), this._isFirstScroll = !0, this._repeatAnimateOnScroll = !0, this._options = this._getConfig(e), this._element && (y.setData(t, jn, this), this._init());\n  }\n  // Getters\n  static get NAME() {\n    return ka;\n  }\n  // Public\n  init() {\n    this._init();\n  }\n  startAnimation() {\n    this._startAnimation();\n  }\n  stopAnimation() {\n    this._clearAnimationClass();\n  }\n  changeAnimationType(t) {\n    this._options.animation = t;\n  }\n  dispose() {\n    c.off(this._element, \"mousedown\"), c.off(this._animateElement, \"animationend\"), c.off(window, \"scroll\"), c.off(this._element, \"mouseover\"), y.removeData(this._element, jn), this._element = null, this._animateElement = null, this._isFirstScroll = null, this._repeatAnimateOnScroll = null, this._options = null;\n  }\n  // Private\n  _init() {\n    switch (this._options.animationStart) {\n      case \"onHover\":\n        this._bindHoverEvents();\n        break;\n      case \"onLoad\":\n        this._startAnimation();\n        break;\n      case \"onScroll\":\n        this._bindScrollEvents();\n        break;\n      case \"onClick\":\n        this._bindClickEvents();\n        break;\n    }\n    this._bindTriggerOnEndCallback(), this._options.animationReset && this._bindResetAnimationAfterFinish();\n  }\n  _getAnimateElement() {\n    const t = h.getDataAttribute(\n      this._element,\n      \"animation-target\"\n    );\n    return t ? d.find(t)[0] : this._element;\n  }\n  _getConfig(t) {\n    const e = h.getDataAttributes(this._animateElement);\n    return t = {\n      ...tf,\n      ...e,\n      ...t\n    }, D(ka, t, J_), t;\n  }\n  _animateOnScroll() {\n    const t = h.offset(this._animateElement).top, e = this._animateElement.offsetHeight, i = window.innerHeight, n = t + this._options.animationOffset <= i && t + this._options.animationOffset + e >= 0, o = this._animateElement.style.visibility === \"visible\";\n    switch (!0) {\n      case (n && this._isFirstScroll):\n        this._isFirstScroll = !1, this._startAnimation();\n        break;\n      case (!n && this._isFirstScroll):\n        this._isFirstScroll = !1, this._hideAnimateElement();\n        break;\n      case (n && !o && this._repeatAnimateOnScroll):\n        this._options.animationOnScroll !== \"repeat\" && (this._repeatAnimateOnScroll = !1), this._callback(this._options.onShow), this._showAnimateElement(), this._startAnimation();\n        break;\n      case (!n && o && this._repeatAnimateOnScroll):\n        this._hideAnimateElement(), this._clearAnimationClass(), this._callback(this._options.onHide);\n        break;\n    }\n  }\n  _addAnimatedClass() {\n    h.addClass(\n      this._animateElement,\n      `animate-${this._options.animation}`\n    );\n  }\n  _clearAnimationClass() {\n    this._animateElement.classList.remove(`animate-${this._options.animation}`);\n  }\n  _startAnimation() {\n    this._callback(this._options.onStart), this._addAnimatedClass(), this._options.animationRepeat && !this._options.animationInterval && this._setAnimationRepeat(), this._options.animationReverse && this._setAnimationReverse(), this._options.animationDelay && this._setAnimationDelay(), this._options.animationDuration && this._setAnimationDuration(), this._options.animationInterval && this._setAnimationInterval();\n  }\n  _setAnimationReverse() {\n    h.style(this._animateElement, {\n      animationIterationCount: this._options.animationRepeat === !0 ? \"infinite\" : \"2\",\n      animationDirection: \"alternate\"\n    });\n  }\n  _setAnimationDuration() {\n    h.style(this._animateElement, {\n      animationDuration: `${this._options.animationDuration}ms`\n    });\n  }\n  _setAnimationDelay() {\n    h.style(this._animateElement, {\n      animationDelay: `${this._options.animationDelay}ms`\n    });\n  }\n  _setAnimationRepeat() {\n    h.style(this._animateElement, {\n      animationIterationCount: this._options.animationRepeat === !0 ? \"infinite\" : this._options.animationRepeat\n    });\n  }\n  _setAnimationInterval() {\n    c.on(this._animateElement, \"click\", () => {\n      this._clearAnimationClass(), setTimeout(() => {\n        this._addAnimatedClass();\n      }, this._options.animationInterval);\n    });\n  }\n  _hideAnimateElement() {\n    h.style(this._animateElement, { visibility: \"hidden\" });\n  }\n  _showAnimateElement() {\n    h.style(this._animateElement, { visibility: \"visible\" });\n  }\n  _bindResetAnimationAfterFinish() {\n    c.on(this._animateElement, \"animationend\", () => {\n      this._clearAnimationClass();\n    });\n  }\n  _bindTriggerOnEndCallback() {\n    c.on(this._animateElement, \"animationend\", () => {\n      this._callback(this._options.onEnd);\n    });\n  }\n  _bindScrollEvents() {\n    this._options.animationShowOnLoad || this._animateOnScroll(), c.on(window, \"scroll\", () => {\n      this._animateOnScroll();\n    });\n  }\n  _bindClickEvents() {\n    c.on(this._element, \"mousedown\", () => {\n      this._startAnimation();\n    });\n  }\n  _bindHoverEvents() {\n    c.one(this._element, \"mouseover\", () => {\n      this._startAnimation();\n    }), c.one(this._animateElement, \"animationend\", () => {\n      setTimeout(() => {\n        this._bindHoverEvents();\n      }, 100);\n    });\n  }\n  _callback(t) {\n    t instanceof Function && t();\n  }\n  // Static\n  static autoInit(t) {\n    t._init();\n  }\n  static jQueryInterface(t) {\n    new pr(this[0], t).init();\n  }\n  static getInstance(t) {\n    return y.getData(t, jn);\n  }\n  static getOrCreateInstance(t, e = {}) {\n    return this.getInstance(t) || new this(t, typeof e == \"object\" ? e : null);\n  }\n}\nconst Kn = \"ripple\", rs = \"te.ripple\", ef = \"rgba({{color}}, 0.2) 0, rgba({{color}}, 0.3) 40%, rgba({{color}}, 0.4) 50%, rgba({{color}}, 0.5) 60%, rgba({{color}}, 0) 70%\", sf = [\"[data-te-ripple-init]\"], as = [0, 0, 0], nf = [\n  { name: \"primary\", gradientColor: \"#3B71CA\" },\n  { name: \"secondary\", gradientColor: \"#9FA6B2\" },\n  { name: \"success\", gradientColor: \"#14A44D\" },\n  { name: \"danger\", gradientColor: \"#DC4C64\" },\n  { name: \"warning\", gradientColor: \"#E4A11B\" },\n  { name: \"info\", gradientColor: \"#54B4D3\" },\n  { name: \"light\", gradientColor: \"#fbfbfb\" },\n  { name: \"dark\", gradientColor: \"#262626\" }\n], xa = 0.5, of = {\n  rippleCentered: !1,\n  rippleColor: \"\",\n  rippleColorDark: \"\",\n  rippleDuration: \"500ms\",\n  rippleRadius: 0,\n  rippleUnbound: !1\n}, rf = {\n  rippleCentered: \"boolean\",\n  rippleColor: \"string\",\n  rippleColorDark: \"string\",\n  rippleDuration: \"string\",\n  rippleRadius: \"number\",\n  rippleUnbound: \"boolean\"\n}, af = {\n  ripple: \"relative overflow-hidden inline-block align-bottom\",\n  rippleWave: \"rounded-[50%] opacity-50 pointer-events-none absolute touch-none scale-0 transition-[transform,_opacity] ease-[cubic-bezier(0,0,0.15,1),_cubic-bezier(0,0,0.15,1)] z-[999]\",\n  unbound: \"overflow-visible\"\n}, lf = {\n  ripple: \"string\",\n  rippleWave: \"string\",\n  unbound: \"string\"\n};\nclass Ze {\n  constructor(t, e, i) {\n    this._element = t, this._options = this._getConfig(e), this._classes = this._getClasses(i), this._element && (y.setData(t, rs, this), h.addClass(this._element, this._classes.ripple)), this._clickHandler = this._createRipple.bind(this), this._rippleTimer = null, this._isMinWidthSet = !1, this._initialClasses = null, this.init();\n  }\n  // Getters\n  static get NAME() {\n    return Kn;\n  }\n  // Public\n  init() {\n    this._addClickEvent(this._element);\n  }\n  dispose() {\n    y.removeData(this._element, rs), c.off(this._element, \"click\", this._clickHandler), this._element = null, this._options = null;\n  }\n  // Private\n  _autoInit(t) {\n    sf.forEach((e) => {\n      d.closest(t.target, e) && (this._element = d.closest(t.target, e));\n    }), this._element.style.minWidth || (h.style(this._element, {\n      \"min-width\": getComputedStyle(this._element).width\n    }), this._isMinWidthSet = !0), this._options = this._getConfig(), this._classes = this._getClasses(), this._initialClasses = [...this._element.classList], h.addClass(this._element, this._classes.ripple), this._createRipple(t);\n  }\n  _addClickEvent(t) {\n    c.on(t, \"mousedown\", this._clickHandler);\n  }\n  _createRipple(t) {\n    this._element.className.indexOf(this._classes.ripple) < 0 && h.addClass(this._element, this._classes.ripple);\n    const { layerX: e, layerY: i } = t, n = t.offsetX || e, o = t.offsetY || i, r = this._element.offsetHeight, a = this._element.offsetWidth, l = this._durationToMsNumber(this._options.rippleDuration), p = {\n      offsetX: this._options.rippleCentered ? r / 2 : n,\n      offsetY: this._options.rippleCentered ? a / 2 : o,\n      height: r,\n      width: a\n    }, u = this._getDiameter(p), _ = this._options.rippleRadius || u / 2, f = {\n      delay: l * xa,\n      duration: l - l * xa\n    }, g = {\n      left: this._options.rippleCentered ? `${a / 2 - _}px` : `${n - _}px`,\n      top: this._options.rippleCentered ? `${r / 2 - _}px` : `${o - _}px`,\n      height: `${this._options.rippleRadius * 2 || u}px`,\n      width: `${this._options.rippleRadius * 2 || u}px`,\n      transitionDelay: `0s, ${f.delay}ms`,\n      transitionDuration: `${l}ms, ${f.duration}ms`\n    }, m = $(\"div\");\n    this._createHTMLRipple({\n      wrapper: this._element,\n      ripple: m,\n      styles: g\n    }), this._removeHTMLRipple({ ripple: m, duration: l });\n  }\n  _createHTMLRipple({ wrapper: t, ripple: e, styles: i }) {\n    Object.keys(i).forEach(\n      (n) => e.style[n] = i[n]\n    ), h.addClass(e, this._classes.rippleWave), e.setAttribute(\"data-te-ripple-ref\", \"\"), this._addColor(e, t), this._toggleUnbound(t), this._appendRipple(e, t);\n  }\n  _removeHTMLRipple({ ripple: t, duration: e }) {\n    this._rippleTimer && (clearTimeout(this._rippleTimer), this._rippleTimer = null), t && setTimeout(() => {\n      t.classList.add(\"!opacity-0\");\n    }, 10), this._rippleTimer = setTimeout(() => {\n      if (t && (t.remove(), this._element)) {\n        d.find(\"[data-te-ripple-ref]\", this._element).forEach(\n          (n) => {\n            n.remove();\n          }\n        ), this._isMinWidthSet && (h.style(this._element, { \"min-width\": \"\" }), this._isMinWidthSet = !1);\n        const i = this._initialClasses ? this._addedNewRippleClasses(\n          this._classes.ripple,\n          this._initialClasses\n        ) : this._classes.ripple.split(\" \");\n        h.removeClass(this._element, i);\n      }\n    }, e);\n  }\n  _addedNewRippleClasses(t, e) {\n    return t.split(\" \").filter(\n      (i) => e.findIndex((n) => i === n) === -1\n    );\n  }\n  _durationToMsNumber(t) {\n    return Number(t.replace(\"ms\", \"\").replace(\"s\", \"000\"));\n  }\n  _getConfig(t = {}) {\n    const e = h.getDataAttributes(this._element);\n    return t = {\n      ...of,\n      ...e,\n      ...t\n    }, D(Kn, t, rf), t;\n  }\n  _getClasses(t = {}) {\n    const e = h.getDataClassAttributes(this._element);\n    return t = {\n      ...af,\n      ...e,\n      ...t\n    }, D(Kn, t, lf), t;\n  }\n  _getDiameter({ offsetX: t, offsetY: e, height: i, width: n }) {\n    const o = e <= i / 2, r = t <= n / 2, a = (f, g) => Math.sqrt(f ** 2 + g ** 2), l = e === i / 2 && t === n / 2, p = {\n      first: o === !0 && r === !1,\n      second: o === !0 && r === !0,\n      third: o === !1 && r === !0,\n      fourth: o === !1 && r === !1\n    }, u = {\n      topLeft: a(t, e),\n      topRight: a(n - t, e),\n      bottomLeft: a(t, i - e),\n      bottomRight: a(n - t, i - e)\n    };\n    let _ = 0;\n    return l || p.fourth ? _ = u.topLeft : p.third ? _ = u.topRight : p.second ? _ = u.bottomRight : p.first && (_ = u.bottomLeft), _ * 2;\n  }\n  _appendRipple(t, e) {\n    e.appendChild(t), setTimeout(() => {\n      h.addClass(t, \"opacity-0 scale-100\");\n    }, 50);\n  }\n  _toggleUnbound(t) {\n    this._options.rippleUnbound === !0 ? h.addClass(t, this._classes.unbound) : h.removeClass(t, this._classes.unbound);\n  }\n  _addColor(t) {\n    let e = this._options.rippleColor || \"rgb(0,0,0)\";\n    (localStorage.theme === \"dark\" || !(\"theme\" in localStorage) && window.matchMedia(\"(prefers-color-scheme: dark)\").matches) && (e = this._options.rippleColorDark || this._options.rippleColor);\n    const i = nf.find(\n      (r) => r.name === e.toLowerCase()\n    ), n = i ? this._colorToRGB(i.gradientColor).join(\",\") : this._colorToRGB(e).join(\",\"), o = ef.split(\"{{color}}\").join(`${n}`);\n    t.style.backgroundImage = `radial-gradient(circle, ${o})`;\n  }\n  _colorToRGB(t) {\n    function e(o) {\n      return o.length < 7 && (o = `#${o[1]}${o[1]}${o[2]}${o[2]}${o[3]}${o[3]}`), [\n        parseInt(o.substr(1, 2), 16),\n        parseInt(o.substr(3, 2), 16),\n        parseInt(o.substr(5, 2), 16)\n      ];\n    }\n    function i(o) {\n      const r = document.body.appendChild(\n        document.createElement(\"fictum\")\n      ), a = \"rgb(1, 2, 3)\";\n      return r.style.color = a, r.style.color !== a || (r.style.color = o, r.style.color === a || r.style.color === \"\") ? as : (o = getComputedStyle(r).color, document.body.removeChild(r), o);\n    }\n    function n(o) {\n      return o = o.match(/[.\\d]+/g).map((r) => +Number(r)), o.length = 3, o;\n    }\n    return t.toLowerCase() === \"transparent\" ? as : t[0] === \"#\" ? e(t) : (t.indexOf(\"rgb\") === -1 && (t = i(t)), t.indexOf(\"rgb\") === 0 ? n(t) : as);\n  }\n  // Static\n  static autoInitial(t) {\n    return function(e) {\n      t._autoInit(e);\n    };\n  }\n  static jQueryInterface(t) {\n    return this.each(function() {\n      return y.getData(this, rs) ? null : new Ze(this, t);\n    });\n  }\n  static getInstance(t) {\n    return y.getData(t, rs);\n  }\n  static getOrCreateInstance(t, e = {}) {\n    return this.getInstance(t) || new this(t, typeof e == \"object\" ? e : null);\n  }\n}\nfunction Z(s) {\n  return s.getDate();\n}\nfunction Vs(s) {\n  return s.getDay();\n}\nfunction Y(s) {\n  return s.getMonth();\n}\nfunction B(s) {\n  return s.getFullYear();\n}\nfunction cf(s, t, e) {\n  const i = e.startDay, n = i > 0 ? 7 - i : 0, r = new Date(s, t).getDay() + n;\n  return r >= 7 ? r - 7 : r;\n}\nfunction Po(s) {\n  return hf(s).getDate();\n}\nfunction hf(s) {\n  return Et(s.getFullYear(), s.getMonth() + 1, 0);\n}\nfunction Be() {\n  return /* @__PURE__ */ new Date();\n}\nfunction it(s, t) {\n  return nt(s, t * 12);\n}\nfunction nt(s, t) {\n  const e = Et(\n    s.getFullYear(),\n    s.getMonth() + t,\n    s.getDate()\n  ), i = Z(s), n = Z(e);\n  return i !== n && e.setDate(0), e;\n}\nfunction xe(s, t) {\n  return Et(s.getFullYear(), s.getMonth(), s.getDate() + t);\n}\nfunction Et(s, t, e) {\n  const i = new Date(s, t, e);\n  return s >= 0 && s < 100 && i.setFullYear(i.getFullYear() - 1900), i;\n}\nfunction Oa(s) {\n  const t = s.split(\"-\"), e = t[0], i = t[1], n = t[2];\n  return Et(e, i, n);\n}\nfunction df(s) {\n  return !Number.isNaN(s.getTime());\n}\nfunction Re(s, t) {\n  return B(s) - B(t) || Y(s) - Y(t) || Z(s) - Z(t);\n}\nfunction fe(s, t) {\n  return s.setHours(0, 0, 0, 0), t.setHours(0, 0, 0, 0), s.getTime() === t.getTime();\n}\nfunction Ws(s, t) {\n  const i = B(s) - pf();\n  return uf(i, t);\n}\nfunction uf(s, t) {\n  return (s % t + t) % t;\n}\nfunction pf(s, t, e) {\n  let i = 0;\n  return e ? i = B(e) - s + 1 : t && (i = B(t)), i;\n}\nfunction nn(s, t, e, i, n, o) {\n  const r = /* @__PURE__ */ new Date();\n  r.setHours(0, 0, 0, 0);\n  const a = t && Re(s, t) <= -1, l = e && Re(s, e) >= 1, p = n && Re(s, r) <= -1, u = o && Re(s, r) >= 1, _ = i && i(s) === !1;\n  return a || l || _ || p || u;\n}\nfunction zc(s, t, e, i, n, o) {\n  const r = /* @__PURE__ */ new Date(), a = i && B(i), l = i && Y(i), p = e && B(e), u = e && Y(e), _ = B(r), f = Y(r), g = l && a && (t > a || t === a && s > l), m = u && p && (t < p || t === p && s < u), b = n && (t < _ || t === _ && s < f), v = o && (t > _ || t === _ && s > f);\n  return g || m || b || v;\n}\nfunction Bo(s, t, e, i, n) {\n  const o = t && B(t), r = e && B(e), a = B(/* @__PURE__ */ new Date()), l = r && s > r, p = o && s < o, u = i && s < a, _ = n && s > a;\n  return l || p || u || _;\n}\nfunction _f(s, t, e, i, n, o, r, a) {\n  const l = /* @__PURE__ */ new Date();\n  return l.setHours(0, 0, 0, 0), (s && o && Re(o, l) < 0 || s) && (o = l), o && Di(\n    t,\n    o,\n    e,\n    i,\n    n,\n    o,\n    r,\n    a\n  );\n}\nfunction ff(s, t, e, i, n, o, r, a) {\n  const l = /* @__PURE__ */ new Date();\n  return l.setHours(0, 0, 0, 0), (s && n && Re(n, l) < 0 || s) && (n = l), n && Di(\n    t,\n    n,\n    e,\n    i,\n    n,\n    o,\n    r,\n    a\n  );\n}\nfunction Di(s, t, e, i, n, o, r, a) {\n  return e === \"days\" ? B(s) === B(t) && Y(s) === Y(t) : e === \"months\" ? B(s) === B(t) : e === \"years\" ? B(t) >= a && B(t) <= r : !1;\n}\nconst mf = \"data-te-datepicker-modal-container-ref\", gf = \"data-te-datepicker-dropdown-container-ref\", bf = \"data-te-dropdown-backdrop-ref\", vf = \"data-te-datepicker-date-text-ref\", Sa = \"data-te-datepicker-view-ref\", Tf = \"data-te-datepicker-previous-button-ref\", Ef = \"data-te-datepicker-next-button-ref\", Cf = \"data-te-datepicker-ok-button-ref\", Af = \"data-te-datepicker-cancel-button-ref\", yf = \"data-te-datepicker-clear-button-ref\", wf = \"data-te-datepicker-view-change-button-ref\";\nfunction kf(s, t, e, i, n, o, r, a, l, p) {\n  const u = Y(s), _ = B(s), f = Z(s), g = Vs(s), m = $(\"div\"), b = `\n        ${Ia(\n    s,\n    u,\n    _,\n    t,\n    e,\n    i,\n    n,\n    o,\n    r,\n    a,\n    p\n  )}\n    `, v = `\n      ${Of(f, g, u, n, p)}\n      ${Ia(\n    s,\n    u,\n    _,\n    t,\n    e,\n    i,\n    n,\n    o,\n    r,\n    a,\n    p\n  )}\n    `;\n  return n.inline ? (h.addClass(m, p.datepickerDropdownContainer), m.setAttribute(gf, l), m.innerHTML = b) : (h.addClass(m, p.modalContainer), m.setAttribute(mf, l), m.innerHTML = v), m;\n}\nfunction xf(s) {\n  const t = $(\"div\");\n  return h.addClass(t, s), t.setAttribute(bf, \"\"), t;\n}\nfunction Of(s, t, e, i, n) {\n  return `\n      <div class=\"${n.datepickerHeader}\" data-te-datepicker-header>\n        <div class=\"${n.datepickerTitle}\">\n          <span class=\"${n.datepickerTitleText}\">${i.title}</span>\n        </div>\n        <div class=\"${n.datepickerDate}\">\n          <span class=\"${n.datepickerDateText}\" ${vf} >${i.weekdaysShort[t]}, ${i.monthsShort[e]} ${s}</span>\n        </div>\n      </div>\n    `;\n}\nfunction Ia(s, t, e, i, n, o, r, a, l, p, u) {\n  let _;\n  return r.inline ? _ = `\n    <div class=\"${u.datepickerMain}\">\n      ${$a(t, e, r, u)}\n      <div class=\"${u.datepickerView}\" ${Sa} tabindex=\"0\">\n        ${Da(\n    s,\n    e,\n    i,\n    n,\n    o,\n    r,\n    a,\n    l,\n    p,\n    u\n  )}\n      </div>\n    </div>\n  ` : _ = `\n    <div class=\"${u.datepickerMain}\">\n      ${$a(t, e, r, u)}\n      <div class=\"${u.datepickerView}\" ${Sa} tabindex=\"0\">\n        ${Da(\n    s,\n    e,\n    i,\n    n,\n    o,\n    r,\n    a,\n    l,\n    p,\n    u\n  )}\n      </div>\n      ${Sf(r, u)}\n    </div>\n  `, _;\n}\nfunction Da(s, t, e, i, n, o, r, a, l, p) {\n  let u;\n  return o.view === \"days\" ? u = Fs(s, e, o, p) : o.view === \"months\" ? u = Ys(\n    t,\n    i,\n    n,\n    o,\n    r,\n    p\n  ) : u = js(\n    s,\n    i,\n    o,\n    a,\n    l,\n    p\n  ), u;\n}\nfunction $a(s, t, e, i) {\n  return `\n    <div class=\"${i.datepickerDateControls}\">\n      <button class=\"${i.datepickerViewChangeButton}\" aria-label=\"${e.switchToMultiYearViewLabel}\" ${wf}>\n        ${e.monthsFull[s]} ${t} ${$t(\n    e,\n    i\n  )}\n      </button>\n      <div class=\"${i.datepickerArrowControls}\">\n        <button class=\"${i.datepickerPreviousButton}\" aria-label=\"${e.prevMonthLabel}\" ${Tf}>${e.changeMonthIconTemplate}</button>\n        <button class=\"${i.datepickerNextButton}\" aria-label=\"${e.nextMonthLabel}\" ${Ef}>${e.changeMonthIconTemplate}</button>\n      </div>\n    </div>\n    `;\n}\nfunction $t(s, t) {\n  return `\n  <span class=\"${t.datepickerViewChangeIcon}\">\n  ${s.viewChangeIconTemplate}\n  </span>\n  `;\n}\nfunction Sf(s, t) {\n  const e = `<button class=\"${t.datepickerFooterBtn}\" aria-label=\"${s.okBtnLabel}\" ${Cf}>${s.okBtnText}</button>`, i = `<button class=\"${t.datepickerFooterBtn}\" aria-label=\"${s.cancelBtnLabel}\" ${Af}>${s.cancelBtnText}</button>`, n = `<button class=\"${t.datepickerFooterBtn} ${t.datepickerClearBtn}\" aria-label=\"${s.clearBtnLabel}\" ${yf}>${s.clearBtnText}</button>`;\n  return `\n        <div class=\"${t.datepickerFooter}\">\n          \n        ${s.removeClearBtn ? \"\" : n}\n        ${s.removeCancelBtn ? \"\" : i}\n        ${s.removeOkBtn ? \"\" : e}\n        </div>\n      `;\n}\nfunction Fs(s, t, e, i) {\n  const n = If(s, t, e), r = `\n      <tr>\n        ${e.weekdaysNarrow.map((l, p) => `<th class=\"${i.datepickerDayHeading}\" scope=\"col\" aria-label=\"${e.weekdaysFull[p]}\">${l}</th>`).join(\"\")}\n      </tr>\n    `, a = n.map((l) => `\n        <tr>\n          ${l.map((p) => `\n              <td\n              class=\"${i.datepickerCell} ${i.datepickerCellSmall}\"\n              data-te-date=\"${B(p.date)}-${Y(\n    p.date\n  )}-${Z(p.date)}\"\n              aria-label=\"${p.date}\"\n              aria-selected=\"${p.isSelected}\"\n              ${p.isSelected ? \"data-te-datepicker-cell-selected\" : \"\"}\n              ${!p.currentMonth || p.disabled ? \"data-te-datepicker-cell-disabled\" : \"\"}\n              ${p.isToday ? \"data-te-datepicker-cell-current\" : \"\"}\n              >\n                <div\n                  class=\"${i.datepickerCellContent} ${i.datepickerCellContentSmall}\"\n                  style=\"${p.currentMonth ? \"display: block\" : \"display: none\"}\"\n                  >\n                  ${p.dayNumber}\n                  </div>\n              </td>\n            `).join(\"\")}\n        </tr>\n      `).join(\"\");\n  return `\n      <table class=\"${i.datepickerTable}\">\n        <thead>\n          ${r}\n        </thead>\n        <tbody>\n         ${a}\n        </tbody>\n      </table>\n    `;\n}\nfunction If(s, t, e) {\n  const i = [], n = Y(s), o = Y(nt(s, -1)), r = Y(nt(s, 1)), a = B(s), l = cf(a, n, e), p = Po(s), u = Po(nt(s, -1)), _ = 7;\n  let f = 1, g = !1;\n  for (let m = 1; m < _; m++) {\n    const b = [];\n    if (m === 1) {\n      const v = u - l + 1;\n      for (let w = v; w <= u; w++) {\n        const E = Et(a, o, w);\n        b.push({\n          date: E,\n          currentMonth: g,\n          isSelected: t && fe(E, t),\n          isToday: fe(E, Be()),\n          dayNumber: Z(E)\n        });\n      }\n      g = !0;\n      const C = _ - b.length;\n      for (let w = 0; w < C; w++) {\n        const E = Et(a, n, f);\n        b.push({\n          date: E,\n          currentMonth: g,\n          isSelected: t && fe(E, t),\n          isToday: fe(E, Be()),\n          dayNumber: Z(E),\n          disabled: nn(\n            E,\n            e.min,\n            e.max,\n            e.filter,\n            e.disablePast,\n            e.disableFuture\n          )\n        }), f++;\n      }\n    } else\n      for (let v = 1; v < 8; v++) {\n        f > p && (f = 1, g = !1);\n        const C = Et(\n          a,\n          g ? n : r,\n          f\n        );\n        b.push({\n          date: C,\n          currentMonth: g,\n          isSelected: t && fe(C, t),\n          isToday: fe(C, Be()),\n          dayNumber: Z(C),\n          disabled: nn(\n            C,\n            e.min,\n            e.max,\n            e.filter,\n            e.disablePast,\n            e.disableFuture\n          )\n        }), f++;\n      }\n    i.push(b);\n  }\n  return i;\n}\nfunction Ys(s, t, e, i, n, o) {\n  const r = Df(i, n), a = Y(Be()), l = B(Be()), p = `\n      ${r.map((u) => `\n          <tr>\n            ${u.map((_) => {\n    const f = i.monthsShort.indexOf(_);\n    return `\n                <td class=\"${o.datepickerCell} ${o.datepickerCellLarge}\"\n                ${zc(\n      f,\n      s,\n      i.min,\n      i.max,\n      i.disablePast,\n      i.disableFuture\n    ) ? \"data-te-datepicker-cell-disabled\" : \"\"}\n                \n                data-te-month=\"${f}\" data-te-year=\"${s}\" aria-label=\"${_}, ${s}\"\n                ${f === e && s === t ? \"data-te-datepicker-cell-selected\" : \"\"}\n                ${f === a && s === l ? \"data-te-datepicker-cell-current\" : \"\"}\" data-te-month=\"${f}\" data-te-year=\"${s}\" aria-label=\"${_}, ${s}\">\n                  <div class=\"${o.datepickerCellContent} ${o.datepickerCellContentLarge}\">${_}</div>\n                </td>\n              `;\n  }).join(\"\")}\n          </tr>\n        `).join(\"\")}\n    `;\n  return `\n      <table class=\"${o.datepickerTable}\">\n        <tbody>\n         ${p}\n        </tbody>\n      </table>\n    `;\n}\nfunction Df(s, t) {\n  const e = [];\n  let i = [];\n  for (let n = 0; n < s.monthsShort.length; n++)\n    if (i.push(s.monthsShort[n]), i.length === t) {\n      const o = i;\n      e.push(o), i = [];\n    }\n  return e;\n}\nfunction js(s, t, e, i, n, o) {\n  const r = $f(s, i, n), a = B(Be()), l = `\n    ${r.map((p) => `\n        <tr>\n          ${p.map((u) => `\n              <td class=\"${o.datepickerCell} ${o.datepickerCellLarge}\"  aria-label=\"${u}\" data-te-year=\"${u}\"\n              ${Bo(\n    u,\n    e.min,\n    e.max,\n    e.disablePast,\n    e.disableFuture\n  ) ? \"data-te-datepicker-cell-disabled\" : \"\"}\n              ${u === t ? \"data-te-datepicker-cell-selected\" : \"\"}\n              ${u === a ? \"data-te-datepicker-cell-current\" : \"\"}\n              >\n                <div class=\"${o.datepickerCellContent} ${o.datepickerCellContentLarge}\">${u}</div>\n              </td>\n            `).join(\"\")}\n        </tr>\n      `).join(\"\")}\n  `;\n  return `\n      <table class=\"${o.datepickerTable}\">\n        <tbody>\n        ${l}\n        </tbody>\n      </table>\n    `;\n}\nfunction $f(s, t, e) {\n  const i = [], n = B(s), o = Ws(s, t), r = n - o;\n  let a = [];\n  for (let l = 0; l < t; l++)\n    if (a.push(r + l), a.length === e) {\n      const p = a;\n      i.push(p), a = [];\n    }\n  return i;\n}\nfunction Lf(s, t) {\n  return `\n    <button id=\"${s}\" type=\"button\" class=\"${t}\" data-te-datepicker-toggle-button-ref data-te-datepicker-toggle-ref>\n      <svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\" fill=\"currentColor\">\n      <path fill-rule=\"evenodd\" d=\"M6.75 2.25A.75.75 0 017.5 3v1.5h9V3A.75.75 0 0118 3v1.5h.75a3 3 0 013 3v11.25a3 3 0 01-3 3H5.25a3 3 0 01-3-3V7.5a3 3 0 013-3H6V3a.75.75 0 01.75-.75zm13.5 9a1.5 1.5 0 00-1.5-1.5H5.25a1.5 1.5 0 00-1.5 1.5v7.5a1.5 1.5 0 001.5 1.5h13.5a1.5 1.5 0 001.5-1.5v-7.5z\" clip-rule=\"evenodd\" />\n      </svg>  \n    </button>\n  `;\n}\nconst He = 37, at = 38, Ve = 39, z = 40, We = 36, Fe = 35, zn = 33, Un = 34, ct = 13, Ks = 32, Fi = 27, Pi = 9, Nf = 8, Mf = 46, vt = 24, ls = 4, cs = 4, Xn = \"datepicker\", zs = \"te.datepicker\", dn = `.${zs}`, Rf = \".data-api\", Pf = `close${dn}`, Bf = `open${dn}`, Hf = `dateChange${dn}`, hs = `click${dn}${Rf}`, Uc = \"data-te-datepicker-modal-container-ref\", Xc = \"data-te-datepicker-dropdown-container-ref\", ds = \"[data-te-datepicker-toggle-ref]\", Vf = `[${Uc}]`, Wf = `[${Xc}]`, Ff = \"[data-te-datepicker-view-change-button-ref]\", Yf = \"[data-te-datepicker-previous-button-ref]\", jf = \"[data-te-datepicker-next-button-ref]\", Kf = \"[data-te-datepicker-ok-button-ref]\", zf = \"[data-te-datepicker-cancel-button-ref]\", Uf = \"[data-te-datepicker-clear-button-ref]\", Xf = \"[data-te-datepicker-view-ref]\", Gf = \"[data-te-datepicker-toggle-button-ref]\", qf = \"[data-te-datepicker-date-text-ref]\", Zf = \"[data-te-dropdown-backdrop-ref]\", Qf = \"animate-[fade-in_0.3s_both] px-[auto] motion-reduce:transition-none motion-reduce:animate-none\", Jf = \"animate-[fade-out_0.3s_both] px-[auto] motion-reduce:transition-none motion-reduce:animate-none\", tm = \"animate-[fade-in_0.15s_both] px-[auto] motion-reduce:transition-none motion-reduce:animate-none\", em = \"animate-[fade-out_0.15s_both] px-[auto] motion-reduce:transition-none motion-reduce:animate-none\", im = \"flex flex-col fixed top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 w-[328px] h-[512px] bg-white rounded-[0.6rem] shadow-lg z-[1066] xs:max-md:landscape:w-[475px] xs:max-md:landscape:h-[360px] xs:max-md:landscape:flex-row dark:bg-zinc-700\", sm = \"w-full h-full fixed top-0 right-0 left-0 bottom-0 bg-black/40 z-[1065]\", nm = \"relative h-full\", om = \"xs:max-md:landscape:h-full h-[120px] px-6 bg-primary flex flex-col rounded-t-lg dark:bg-zinc-800\", rm = \"h-8 flex flex-col justify-end\", am = \"text-[10px] font-normal uppercase tracking-[1.7px] text-white\", lm = \"xs:max-md:landscape:mt-24 h-[72px] flex flex-col justify-end\", cm = \"text-[34px] font-normal text-white\", hm = \"outline-none px-3\", dm = \"px-3 pt-2.5 pb-0 flex justify-between text-black/[64]\", um = \"flex items-center outline-none p-2.5 text-neutral-500 font-medium text-[0.9rem] rounded-xl shadow-none bg-transparent m-0 border-none hover:bg-neutral-200 focus:bg-neutral-200  dark:text-white dark:hover:bg-white/10 dark:focus:bg-white/10\", pm = \"mt-2.5\", _m = \"p-0 w-10 h-10 leading-10 border-none outline-none m-0 text-gray-600 bg-transparent mr-6 hover:bg-neutral-200 hover:rounded-[50%] focus:bg-neutral-200 focus:rounded-[50%] dark:text-white dark:hover:bg-white/10 dark:focus:bg-white/10 [&>svg]:w-4 [&>svg]:h-4 [&>svg]:mx-auto\", fm = \"p-0 w-10 h-10 leading-10 border-none outline-none m-0 text-gray-600 bg-transparent hover:bg-neutral-200 hover:rounded-[50%] focus:bg-neutral-200 focus:rounded-[50%] dark:text-white dark:hover:bg-white/10 dark:focus:bg-white/10 [&>svg]:w-4 [&>svg]:h-4 [&>svg]:rotate-180 [&>svg]:mx-auto\", mm = \"h-14 flex absolute w-full bottom-0 justify-end items-center px-3\", gm = \"outline-none bg-white text-primary border-none cursor-pointer py-0 px-2.5 uppercase text-[0.8rem] leading-10 font-medium h-10 tracking-[.1rem] rounded-[10px] mb-2.5 hover:bg-neutral-200 focus:bg-neutral-200 dark:bg-transparent dark:text-white dark:hover:bg-white/10 dark:focus:bg-white/10\", bm = \"mr-auto\", vm = \"w-10 h-10 text-center text-[12px] font-normal dark:text-white\", Tm = \"text-center data-[te-datepicker-cell-disabled]:text-neutral-300 data-[te-datepicker-cell-disabled]:cursor-default data-[te-datepicker-cell-disabled]:pointer-events-none data-[te-datepicker-cell-disabled]:hover:cursor-default hover:cursor-pointer group\", Em = \"w-10 h-10 xs:max-md:landscape:w-8 xs:max-md:landscape:h-8\", Cm = \"w-[76px] h-[42px]\", Am = \"mx-auto group-[:not([data-te-datepicker-cell-disabled]):not([data-te-datepicker-cell-selected]):hover]:bg-neutral-300 group-[[data-te-datepicker-cell-selected]]:bg-primary group-[[data-te-datepicker-cell-selected]]:text-white group-[:not([data-te-datepicker-cell-selected])[data-te-datepicker-cell-focused]]:bg-neutral-100 group-[[data-te-datepicker-cell-focused]]:data-[te-datepicker-cell-selected]:bg-primary group-[[data-te-datepicker-cell-current]]:border-solid group-[[data-te-datepicker-cell-current]]:border-black group-[[data-te-datepicker-cell-current]]:border dark:group-[:not([data-te-datepicker-cell-disabled]):not([data-te-datepicker-cell-selected]):hover]:bg-white/10 dark:group-[[data-te-datepicker-cell-current]]:border-white dark:text-white dark:group-[:not([data-te-datepicker-cell-selected])[data-te-datepicker-cell-focused]]:bg-white/10 dark:group-[[data-te-datepicker-cell-disabled]]:text-neutral-500\", ym = \"w-9 h-9 leading-9 rounded-[50%] text-[13px]\", wm = \"w-[72px] h-10 leading-10 py-[1px] px-0.5 rounded-[999px]\", km = \"mx-auto w-[304px]\", xm = \"flex items-center justify-content-center [&>svg]:w-5 [&>svg]:h-5 absolute outline-none border-none bg-transparent right-0.5 top-1/2 -translate-x-1/2 -translate-y-1/2 hover:text-primary focus:text-primary dark:hover:text-primary-400 dark:focus:text-primary-400 dark:text-neutral-200\", Om = \"inline-block pointer-events-none ml-[3px] [&>svg]:w-4 [&>svg]:h-4 [&>svg]:fill-neutral-500 dark:[&>svg]:fill-white\", Sm = \"w-[328px] h-[380px] bg-white rounded-lg shadow-[0px_2px_15px_-3px_rgba(0,0,0,.07),_0px_10px_20px_-2px_rgba(0,0,0,.04)] z-[1066] dark:bg-zinc-700\", Im = {\n  title: \"Select date\",\n  container: \"body\",\n  disablePast: !1,\n  disableFuture: !1,\n  monthsFull: [\n    \"January\",\n    \"February\",\n    \"March\",\n    \"April\",\n    \"May\",\n    \"June\",\n    \"July\",\n    \"August\",\n    \"September\",\n    \"October\",\n    \"November\",\n    \"December\"\n  ],\n  monthsShort: [\n    \"Jan\",\n    \"Feb\",\n    \"Mar\",\n    \"Apr\",\n    \"May\",\n    \"Jun\",\n    \"Jul\",\n    \"Aug\",\n    \"Sep\",\n    \"Oct\",\n    \"Nov\",\n    \"Dec\"\n  ],\n  weekdaysFull: [\n    \"Sunday\",\n    \"Monday\",\n    \"Tuesday\",\n    \"Wednesday\",\n    \"Thursday\",\n    \"Friday\",\n    \"Saturday\"\n  ],\n  weekdaysShort: [\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"],\n  weekdaysNarrow: [\"S\", \"M\", \"T\", \"W\", \"T\", \"F\", \"S\"],\n  okBtnText: \"Ok\",\n  clearBtnText: \"Clear\",\n  cancelBtnText: \"Cancel\",\n  okBtnLabel: \"Confirm selection\",\n  clearBtnLabel: \"Clear selection\",\n  cancelBtnLabel: \"Cancel selection\",\n  nextMonthLabel: \"Next month\",\n  prevMonthLabel: \"Previous month\",\n  nextYearLabel: \"Next year\",\n  prevYearLabel: \"Previous year\",\n  changeMonthIconTemplate: `<svg xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" viewBox=\"0 0 24 24\" stroke-width=\"3\" stroke=\"currentColor\" class=\"w-6 h-6\">\n  <path stroke-linecap=\"round\" stroke-linejoin=\"round\" d=\"M15.75 19.5L8.25 12l7.5-7.5\" />\n  </svg>\n  `,\n  nextMultiYearLabel: \"Next 24 years\",\n  prevMultiYearLabel: \"Previous 24 years\",\n  switchToMultiYearViewLabel: \"Choose year and month\",\n  switchToMonthViewLabel: \"Choose date\",\n  switchToDayViewLabel: \"Choose date\",\n  startDate: null,\n  startDay: 0,\n  format: \"dd/mm/yyyy\",\n  view: \"days\",\n  viewChangeIconTemplate: `<svg xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" viewBox=\"0 0 24 24\" stroke-width=\"0\" stroke=\"currentColor\" class=\"w-6 h-6\">\n  <path stroke-linecap=\"round\" stroke-linejoin=\"round\" d=\"M19.5 8.25l-7.5 7.5-7.5-7.5\" />\n  </svg>\n  `,\n  min: null,\n  max: null,\n  filter: null,\n  inline: !1,\n  toggleButton: !0,\n  disableToggleButton: !1,\n  disableInput: !1,\n  animations: !0,\n  confirmDateOnSelect: !1,\n  removeOkBtn: !1,\n  removeCancelBtn: !1,\n  removeClearBtn: !1\n}, Dm = {\n  title: \"string\",\n  container: \"string\",\n  disablePast: \"boolean\",\n  disableFuture: \"boolean\",\n  monthsFull: \"array\",\n  monthsShort: \"array\",\n  weekdaysFull: \"array\",\n  weekdaysShort: \"array\",\n  weekdaysNarrow: \"array\",\n  okBtnText: \"string\",\n  clearBtnText: \"string\",\n  cancelBtnText: \"string\",\n  okBtnLabel: \"string\",\n  clearBtnLabel: \"string\",\n  cancelBtnLabel: \"string\",\n  nextMonthLabel: \"string\",\n  prevMonthLabel: \"string\",\n  nextYearLabel: \"string\",\n  prevYearLabel: \"string\",\n  nextMultiYearLabel: \"string\",\n  prevMultiYearLabel: \"string\",\n  changeMonthIconTemplate: \"string\",\n  switchToMultiYearViewLabel: \"string\",\n  switchToMonthViewLabel: \"string\",\n  switchToDayViewLabel: \"string\",\n  startDate: \"(null|string|date)\",\n  startDay: \"number\",\n  format: \"string\",\n  view: \"string\",\n  viewChangeIconTemplate: \"string\",\n  min: \"(null|string|date)\",\n  max: \"(null|string|date)\",\n  filter: \"(null|function)\",\n  inline: \"boolean\",\n  toggleButton: \"boolean\",\n  disableToggleButton: \"boolean\",\n  disableInput: \"boolean\",\n  animations: \"boolean\",\n  confirmDateOnSelect: \"boolean\",\n  removeOkBtn: \"boolean\",\n  removeCancelBtn: \"boolean\",\n  removeClearBtn: \"boolean\"\n}, $m = {\n  fadeIn: Qf,\n  fadeOut: Jf,\n  fadeInShort: tm,\n  fadeOutShort: em,\n  modalContainer: im,\n  datepickerBackdrop: sm,\n  datepickerMain: nm,\n  datepickerHeader: om,\n  datepickerTitle: rm,\n  datepickerTitleText: am,\n  datepickerDate: lm,\n  datepickerDateText: cm,\n  datepickerView: hm,\n  datepickerDateControls: dm,\n  datepickerViewChangeButton: um,\n  datepickerViewChangeIcon: Om,\n  datepickerArrowControls: pm,\n  datepickerPreviousButton: _m,\n  datepickerNextButton: fm,\n  datepickerFooter: mm,\n  datepickerFooterBtn: gm,\n  datepickerClearBtn: bm,\n  datepickerDayHeading: vm,\n  datepickerCell: Tm,\n  datepickerCellSmall: Em,\n  datepickerCellLarge: Cm,\n  datepickerCellContent: Am,\n  datepickerCellContentSmall: ym,\n  datepickerCellContentLarge: wm,\n  datepickerTable: km,\n  datepickerToggleButton: xm,\n  datepickerDropdownContainer: Sm\n}, Lm = {\n  fadeIn: \"string\",\n  fadeOut: \"string\",\n  fadeInShort: \"string\",\n  fadeOutShort: \"string\",\n  modalContainer: \"string\",\n  datepickerBackdrop: \"string\",\n  datepickerMain: \"string\",\n  datepickerHeader: \"string\",\n  datepickerTitle: \"string\",\n  datepickerTitleText: \"string\",\n  datepickerDate: \"string\",\n  datepickerDateText: \"string\",\n  datepickerView: \"string\",\n  datepickerDateControls: \"string\",\n  datepickerViewChangeButton: \"string\",\n  datepickerArrowControls: \"string\",\n  datepickerPreviousButton: \"string\",\n  datepickerNextButton: \"string\",\n  datepickerFooter: \"string\",\n  datepickerFooterBtn: \"string\",\n  datepickerClearBtn: \"string\",\n  datepickerDayHeading: \"string\",\n  datepickerCell: \"string\",\n  datepickerCellSmall: \"string\",\n  datepickerCellLarge: \"string\",\n  datepickerCellContent: \"string\",\n  datepickerCellContentSmall: \"string\",\n  datepickerCellContentLarge: \"string\",\n  datepickerTable: \"string\",\n  datepickerToggleButton: \"string\",\n  datepickerDropdownContainer: \"string\"\n};\nclass Nm {\n  constructor(t, e, i) {\n    this._element = t, this._input = d.findOne(\"input\", this._element), this._options = this._getConfig(e), this._classes = this._getClasses(i), this._activeDate = /* @__PURE__ */ new Date(), this._selectedDate = null, this._selectedYear = null, this._selectedMonth = null, this._headerDate = null, this._headerYear = null, this._headerMonth = null, this._view = this._options.view, this._popper = null, this._focusTrap = null, this._isOpen = !1, this._toggleButtonId = rt(\"datepicker-toggle-\"), this._animations = !window.matchMedia(\"(prefers-reduced-motion: reduce)\").matches && this._options.animations, this._scrollBar = new qe(), this._element && y.setData(t, zs, this), this._init(), this.toggleButton && this._options.disableToggle && (this.toggleButton.disabled = \"true\"), this._options.disableInput && (this._input.disabled = \"true\");\n  }\n  // Getters\n  static get NAME() {\n    return Xn;\n  }\n  get container() {\n    return d.findOne(\n      `[${Uc}='${this._toggleButtonId}']`\n    ) || d.findOne(\n      `[${Xc}='${this._toggleButtonId}']`\n    );\n  }\n  get options() {\n    return this._options;\n  }\n  get activeCell() {\n    let t;\n    return this._view === \"days\" && (t = this._getActiveDayCell()), this._view === \"months\" && (t = this._getActiveMonthCell()), this._view === \"years\" && (t = this._getActiveYearCell()), t;\n  }\n  get activeDay() {\n    return Z(this._activeDate);\n  }\n  get activeMonth() {\n    return Y(this._activeDate);\n  }\n  get activeYear() {\n    return B(this._activeDate);\n  }\n  get firstYearInView() {\n    return this.activeYear - Ws(this._activeDate, vt);\n  }\n  get lastYearInView() {\n    return this.firstYearInView + vt - 1;\n  }\n  get viewChangeButton() {\n    return d.findOne(Ff, this.container);\n  }\n  get previousButton() {\n    return d.findOne(Yf, this.container);\n  }\n  get nextButton() {\n    return d.findOne(jf, this.container);\n  }\n  get okButton() {\n    return d.findOne(Kf, this.container);\n  }\n  get cancelButton() {\n    return d.findOne(zf, this.container);\n  }\n  get clearButton() {\n    return d.findOne(Uf, this.container);\n  }\n  get datesContainer() {\n    return d.findOne(Xf, this.container);\n  }\n  get toggleButton() {\n    return d.findOne(Gf, this._element);\n  }\n  update(t = {}) {\n    this._options = this._getConfig({ ...this._options, ...t });\n  }\n  _getConfig(t) {\n    const e = h.getDataAttributes(this._element);\n    if (t = {\n      ...Im,\n      ...e,\n      ...t\n    }, D(Xn, t, Dm), t.max && typeof t.max == \"string\" && (t.max = new Date(t.max)), t.min && typeof t.min == \"string\" && (t.min = new Date(t.min)), t.startDay && t.startDay !== 0) {\n      const i = this._getNewDaysOrderArray(t);\n      t.weekdaysNarrow = i;\n    }\n    return t;\n  }\n  _getClasses(t) {\n    const e = h.getDataClassAttributes(this._element);\n    return t = {\n      ...$m,\n      ...e,\n      ...t\n    }, D(Xn, t, Lm), t;\n  }\n  _getContainer() {\n    return d.findOne(this._options.container);\n  }\n  _getNewDaysOrderArray(t) {\n    const e = t.startDay, i = t.weekdaysNarrow;\n    return i.slice(e).concat(i.slice(0, e));\n  }\n  _init() {\n    !this.toggleButton && this._options.toggleButton && (this._appendToggleButton(), (this._input.readOnly || this._input.disabled) && (this.toggleButton.style.pointerEvents = \"none\")), this._listenToUserInput(), this._listenToToggleClick(), this._listenToToggleKeydown();\n  }\n  _appendToggleButton() {\n    const t = Lf(\n      this._toggleButtonId,\n      this._classes.datepickerToggleButton\n    );\n    this._element.insertAdjacentHTML(\"beforeend\", t);\n  }\n  open() {\n    if (this._input.readOnly || this._input.disabled)\n      return;\n    const t = c.trigger(this._element, Bf);\n    if (this._isOpen || t.defaultPrevented)\n      return;\n    this._setInitialDate();\n    const e = xf(this._classes.datepickerBackdrop), i = kf(\n      this._activeDate,\n      this._selectedDate,\n      this._selectedYear,\n      this._selectedMonth,\n      this._options,\n      cs,\n      vt,\n      ls,\n      this._toggleButtonId,\n      this._classes\n    );\n    this._options.inline ? this._openDropdown(i) : (this._openModal(e, i), this._scrollBar.hide()), this._animations && (h.addClass(this.container, this._classes.fadeIn), h.addClass(e, this._classes.fadeInShort)), this._setFocusTrap(this.container), this._listenToDateSelection(), this._addControlsListeners(), this._updateControlsDisabledState(), this._listenToEscapeClick(), this._listenToKeyboardNavigation(), this._listenToDatesContainerFocus(), this._listenToDatesContainerBlur(), this._asyncFocusDatesContainer(), this._updateViewControlsAndAttributes(this._view), this._isOpen = !0, setTimeout(() => {\n      this._listenToOutsideClick();\n    }, 0);\n  }\n  _openDropdown(t) {\n    this._popper = Ce(this._input, t, {\n      placement: \"bottom-start\"\n    }), this._getContainer().appendChild(t);\n  }\n  _openModal(t, e) {\n    const i = this._getContainer();\n    i.appendChild(t), i.appendChild(e);\n  }\n  _setFocusTrap(t) {\n    this._focusTrap = new Wi(t, {\n      event: \"keydown\",\n      condition: (e) => e.key === \"Tab\"\n    }), this._focusTrap.trap();\n  }\n  _listenToUserInput() {\n    c.on(this._input, \"input\", (t) => {\n      this._handleUserInput(t.target.value);\n    });\n  }\n  _listenToToggleClick() {\n    c.on(\n      this._element,\n      hs,\n      ds,\n      (t) => {\n        t.preventDefault(), this.open();\n      }\n    );\n  }\n  _listenToToggleKeydown() {\n    c.on(\n      this._element,\n      \"keydown\",\n      ds,\n      (t) => {\n        t.keyCode === ct && !this._isOpen && this.open();\n      }\n    );\n  }\n  _listenToDateSelection() {\n    c.on(this.datesContainer, \"click\", (t) => {\n      this._handleDateSelection(t);\n    });\n  }\n  _handleDateSelection(t) {\n    const e = t.target.nodeName === \"DIV\" ? t.target.parentNode.dataset : t.target.dataset, i = t.target.nodeName === \"DIV\" ? t.target.parentNode : t.target;\n    if (e.teDate && this._pickDay(e.teDate, i), e.teMonth && e.teYear) {\n      const n = parseInt(e.teMonth, 10), o = parseInt(e.teYear, 10);\n      this._pickMonth(n, o);\n    }\n    if (e.teYear && !e.teMonth) {\n      const n = parseInt(e.teYear, 10);\n      this._pickYear(n);\n    }\n    this._options.inline || this._updateHeaderDate(\n      this._activeDate,\n      this._options.monthsShort,\n      this._options.weekdaysShort\n    );\n  }\n  _updateHeaderDate(t, e, i) {\n    const n = d.findOne(\n      qf,\n      this.container\n    ), o = Y(t), r = Z(t), a = Vs(t);\n    n.innerHTML = `${i[a]}, ${e[o]} ${r}`;\n  }\n  _addControlsListeners() {\n    c.on(this.nextButton, \"click\", () => {\n      this._view === \"days\" ? this.nextMonth() : this._view === \"years\" ? this.nextYears() : this.nextYear(), this._updateControlsDisabledState();\n    }), c.on(this.previousButton, \"click\", () => {\n      this._view === \"days\" ? this.previousMonth() : this._view === \"years\" ? this.previousYears() : this.previousYear(), this._updateControlsDisabledState();\n    }), c.on(this.viewChangeButton, \"click\", () => {\n      this._view === \"days\" ? this._changeView(\"years\") : (this._view === \"years\" || this._view === \"months\") && this._changeView(\"days\");\n    }), this._options.inline || this._listenToFooterButtonsClick();\n  }\n  _listenToFooterButtonsClick() {\n    c.on(this.okButton, \"click\", () => this.handleOk()), c.on(this.cancelButton, \"click\", () => this.handleCancel()), c.on(this.clearButton, \"click\", () => this.handleClear());\n  }\n  _listenToOutsideClick() {\n    c.on(document, hs, (t) => {\n      const e = t.target === this.container, i = this.container && this.container.contains(t.target);\n      !e && !i && this.close();\n    });\n  }\n  _listenToEscapeClick() {\n    c.on(document, \"keydown\", (t) => {\n      t.keyCode === Fi && this._isOpen && this.close();\n    });\n  }\n  _listenToKeyboardNavigation() {\n    c.on(this.datesContainer, \"keydown\", (t) => {\n      this._handleKeydown(t);\n    });\n  }\n  _listenToDatesContainerFocus() {\n    c.on(this.datesContainer, \"focus\", () => {\n      this._focusActiveCell(this.activeCell);\n    });\n  }\n  _listenToDatesContainerBlur() {\n    c.on(this.datesContainer, \"blur\", () => {\n      this._removeCurrentFocusStyles();\n    });\n  }\n  _handleKeydown(t) {\n    this._view === \"days\" && this._handleDaysViewKeydown(t), this._view === \"months\" && this._handleMonthsViewKeydown(t), this._view === \"years\" && this._handleYearsViewKeydown(t);\n  }\n  _handleDaysViewKeydown(t) {\n    const e = this._activeDate, i = this.activeCell;\n    switch (t.keyCode) {\n      case He:\n        this._activeDate = xe(this._activeDate, F() ? 1 : -1);\n        break;\n      case Ve:\n        this._activeDate = xe(this._activeDate, F() ? -1 : 1);\n        break;\n      case at:\n        this._activeDate = xe(this._activeDate, -7);\n        break;\n      case z:\n        this._activeDate = xe(this._activeDate, 7);\n        break;\n      case We:\n        this._activeDate = xe(\n          this._activeDate,\n          1 - Z(this._activeDate)\n        );\n        break;\n      case Fe:\n        this._activeDate = xe(\n          this._activeDate,\n          Po(this._activeDate) - Z(this._activeDate)\n        );\n        break;\n      case zn:\n        this._activeDate = nt(this._activeDate, -1);\n        break;\n      case Un:\n        this._activeDate = nt(this._activeDate, 1);\n        break;\n      case ct:\n      case Ks:\n        this._selectDate(this._activeDate), this._handleDateSelection(t), t.preventDefault();\n        return;\n      default:\n        return;\n    }\n    Di(\n      e,\n      this._activeDate,\n      this._view,\n      vt,\n      this._options.min,\n      this._options.max\n    ) || this._changeView(\"days\"), this._removeHighlightFromCell(i), this._focusActiveCell(this.activeCell), t.preventDefault();\n  }\n  _asyncFocusDatesContainer() {\n    setTimeout(() => {\n      this.datesContainer.focus();\n    }, 0);\n  }\n  _focusActiveCell(t) {\n    t && t.setAttribute(\"data-te-datepicker-cell-focused\", \"\");\n  }\n  _removeHighlightFromCell(t) {\n    t && t.removeAttribute(\"data-te-datepicker-cell-focused\");\n  }\n  _getActiveDayCell() {\n    const t = d.find(\"td\", this.datesContainer);\n    return Array.from(t).find((i) => {\n      const n = Oa(i.dataset.teDate);\n      return fe(n, this._activeDate);\n    });\n  }\n  _handleMonthsViewKeydown(t) {\n    const e = this._activeDate, i = this.activeCell;\n    switch (t.keyCode) {\n      case He:\n        this._activeDate = nt(this._activeDate, F() ? 1 : -1);\n        break;\n      case Ve:\n        this._activeDate = nt(this._activeDate, F() ? -1 : 1);\n        break;\n      case at:\n        this._activeDate = nt(this._activeDate, -4);\n        break;\n      case z:\n        this._activeDate = nt(this._activeDate, 4);\n        break;\n      case We:\n        this._activeDate = nt(this._activeDate, -this.activeMonth);\n        break;\n      case Fe:\n        this._activeDate = nt(this._activeDate, 11 - this.activeMonth);\n        break;\n      case zn:\n        this._activeDate = it(this._activeDate, -1);\n        break;\n      case Un:\n        this._activeDate = it(this._activeDate, 1);\n        break;\n      case ct:\n      case Ks:\n        this._selectMonth(this.activeMonth);\n        return;\n      default:\n        return;\n    }\n    Di(\n      e,\n      this._activeDate,\n      this._view,\n      vt,\n      this._options.min,\n      this._options.max\n    ) || this._changeView(\"months\"), this._removeHighlightFromCell(i), this._focusActiveCell(this.activeCell), t.preventDefault();\n  }\n  _getActiveMonthCell() {\n    const t = d.find(\"td\", this.datesContainer);\n    return Array.from(t).find((i) => {\n      const n = parseInt(i.dataset.teYear, 10), o = parseInt(i.dataset.teMonth, 10);\n      return n === this.activeYear && o === this.activeMonth;\n    });\n  }\n  _handleYearsViewKeydown(t) {\n    const e = this._activeDate, i = this.activeCell, n = 4, o = 24;\n    switch (t.keyCode) {\n      case He:\n        this._activeDate = it(this._activeDate, F() ? 1 : -1);\n        break;\n      case Ve:\n        this._activeDate = it(this._activeDate, F() ? -1 : 1);\n        break;\n      case at:\n        this._activeDate = it(this._activeDate, -n);\n        break;\n      case z:\n        this._activeDate = it(this._activeDate, n);\n        break;\n      case We:\n        this._activeDate = it(\n          this._activeDate,\n          -Ws(this._activeDate, o)\n        );\n        break;\n      case Fe:\n        this._activeDate = it(\n          this._activeDate,\n          o - Ws(this._activeDate, o) - 1\n        );\n        break;\n      case zn:\n        this._activeDate = it(this._activeDate, -o);\n        break;\n      case Un:\n        this._activeDate = it(this._activeDate, o);\n        break;\n      case ct:\n      case Ks:\n        this._selectYear(this.activeYear);\n        return;\n      default:\n        return;\n    }\n    Di(\n      e,\n      this._activeDate,\n      this._view,\n      vt,\n      this._options.min,\n      this._options.max\n    ) || this._changeView(\"years\"), this._removeHighlightFromCell(i), this._focusActiveCell(this.activeCell), t.preventDefault();\n  }\n  _getActiveYearCell() {\n    const t = d.find(\"td\", this.datesContainer);\n    return Array.from(t).find((i) => parseInt(i.dataset.teYear, 10) === this.activeYear);\n  }\n  _setInitialDate() {\n    this._input.value ? this._handleUserInput(this._input.value) : this._options.startDate ? this._activeDate = new Date(this._options.startDate) : this._activeDate = /* @__PURE__ */ new Date();\n  }\n  close() {\n    const t = c.trigger(this._element, Pf);\n    !this._isOpen || t.defaultPrevented || (this._removeDatepickerListeners(), this._animations && h.addClass(this.container, this._classes.fadeOut), this._options.inline ? this._closeDropdown() : this._closeModal(), this._isOpen = !1, this._view = this._options.view, this.toggleButton ? this.toggleButton.focus() : this._input.focus());\n  }\n  _closeDropdown() {\n    const t = d.findOne(Wf), e = this._getContainer();\n    window.matchMedia(\"(prefers-reduced-motion: reduce)\").matches && (t && e.removeChild(t), this._popper && this._popper.destroy()), t.addEventListener(\"animationend\", () => {\n      t && e.removeChild(t), this._popper && this._popper.destroy();\n    }), this._removeFocusTrap();\n  }\n  _closeModal() {\n    const t = d.findOne(Zf), e = d.findOne(Vf);\n    !e || !t || (this._animations ? (h.addClass(t, this._classes.fadeOutShort), t.addEventListener(\"animationend\", () => {\n      this._removePicker(t, e), this._scrollBar.reset();\n    })) : (this._removePicker(t, e), this._scrollBar.reset()));\n  }\n  _removePicker(t, e) {\n    const i = this._getContainer();\n    i.removeChild(t), i.removeChild(e);\n  }\n  _removeFocusTrap() {\n    this._focusTrap && (this._focusTrap.disable(), this._focusTrap = null);\n  }\n  _removeDatepickerListeners() {\n    c.off(this.nextButton, \"click\"), c.off(this.previousButton, \"click\"), c.off(this.viewChangeButton, \"click\"), c.off(this.okButton, \"click\"), c.off(this.cancelButton, \"click\"), c.off(this.clearButton, \"click\"), c.off(this.datesContainer, \"click\"), c.off(this.datesContainer, \"keydown\"), c.off(this.datesContainer, \"focus\"), c.off(this.datesContainer, \"blur\"), c.off(document, hs);\n  }\n  dispose() {\n    this._isOpen && this.close(), this._removeInputAndToggleListeners();\n    const t = d.findOne(\n      `#${this._toggleButtonId}`\n    );\n    t && this._element.removeChild(t), y.removeData(this._element, zs), this._element = null, this._input = null, this._options = null, this._activeDate = null, this._selectedDate = null, this._selectedYear = null, this._selectedMonth = null, this._headerDate = null, this._headerYear = null, this._headerMonth = null, this._view = null, this._popper = null, this._focusTrap = null;\n  }\n  _removeInputAndToggleListeners() {\n    c.off(this._input, \"input\"), c.off(\n      this._element,\n      hs,\n      ds\n    ), c.off(this._element, \"keydown\", ds);\n  }\n  handleOk() {\n    this._confirmSelection(this._headerDate), this.close();\n  }\n  _selectDate(t, e = this.activeCell) {\n    const { min: i, max: n, filter: o, disablePast: r, disableFuture: a } = this._options;\n    nn(t, i, n, o, r, a) || (this._removeCurrentSelectionStyles(), this._removeCurrentFocusStyles(), this._addSelectedStyles(e), this._selectedDate = t, this._selectedYear = B(t), this._selectedMonth = Y(t), this._headerDate = t, (this._options.inline || this.options.confirmDateOnSelect) && (this._confirmSelection(t), this.close()));\n  }\n  _selectYear(t, e = this.activeCell) {\n    this._removeCurrentSelectionStyles(), this._removeCurrentFocusStyles(), this._addSelectedStyles(e), this._headerYear = t, this._asyncChangeView(\"months\");\n  }\n  _selectMonth(t, e = this.activeCell) {\n    this._removeCurrentSelectionStyles(), this._removeCurrentFocusStyles(), this._addSelectedStyles(e), this._headerMonth = t, this._asyncChangeView(\"days\");\n  }\n  _removeSelectedStyles(t) {\n    t && t.removeAttribute(\"data-te-datepicker-cell-selected\");\n  }\n  _addSelectedStyles(t) {\n    t && t.setAttribute(\"data-te-datepicker-cell-selected\", \"\");\n  }\n  _confirmSelection(t) {\n    if (t) {\n      const e = this.formatDate(t);\n      this._input.value = e, c.trigger(this._element, Hf, { date: t }), c.trigger(this._input, \"input\");\n    }\n  }\n  handleCancel() {\n    this._selectedDate = null, this._selectedYear = null, this._selectedMonth = null, this.close();\n  }\n  handleClear() {\n    this._selectedDate = null, this._selectedMonth = null, this._selectedYear = null, this._headerDate = null, this._headerMonth = null, this._headerYear = null, this._removeCurrentSelectionStyles(), this._input.value = \"\", this._setInitialDate(), this._changeView(\"days\"), this._updateHeaderDate(\n      this._activeDate,\n      this._options.monthsShort,\n      this._options.weekdaysShort\n    );\n  }\n  _removeCurrentSelectionStyles() {\n    const t = d.findOne(\n      \"[data-te-datepicker-cell-selected]\",\n      this.container\n    );\n    t && t.removeAttribute(\"data-te-datepicker-cell-selected\");\n  }\n  _removeCurrentFocusStyles() {\n    const t = d.findOne(\n      \"[data-te-datepicker-cell-focused]\",\n      this.container\n    );\n    t && t.removeAttribute(\"data-te-datepicker-cell-focused\");\n  }\n  formatDate(t) {\n    const e = Z(t), i = this._addLeadingZero(Z(t)), n = this._options.weekdaysShort[Vs(t)], o = this._options.weekdaysFull[Vs(t)], r = Y(t) + 1, a = this._addLeadingZero(Y(t) + 1), l = this._options.monthsShort[Y(t)], p = this._options.monthsFull[Y(t)], u = B(t).toString().length === 2 ? B(t) : B(t).toString().slice(2, 4), _ = B(t), f = this._options.format.split(\n      /(d{1,4}|m{1,4}|y{4}|yy|!.)/g\n    );\n    let g = \"\";\n    return f.forEach((m) => {\n      switch (m) {\n        case \"dddd\":\n          m = m.replace(m, o);\n          break;\n        case \"ddd\":\n          m = m.replace(m, n);\n          break;\n        case \"dd\":\n          m = m.replace(m, i);\n          break;\n        case \"d\":\n          m = m.replace(m, e);\n          break;\n        case \"mmmm\":\n          m = m.replace(m, p);\n          break;\n        case \"mmm\":\n          m = m.replace(m, l);\n          break;\n        case \"mm\":\n          m = m.replace(m, a);\n          break;\n        case \"m\":\n          m = m.replace(m, r);\n          break;\n        case \"yyyy\":\n          m = m.replace(m, _);\n          break;\n        case \"yy\":\n          m = m.replace(m, u);\n          break;\n      }\n      g += m;\n    }), g;\n  }\n  _addLeadingZero(t) {\n    return parseInt(t, 10) < 10 ? `0${t}` : t;\n  }\n  _pickDay(t, e) {\n    const i = Oa(t), { min: n, max: o, filter: r, disablePast: a, disableFuture: l } = this._options;\n    nn(i, n, o, r, a, l) || (this._activeDate = i, this._selectDate(i, e));\n  }\n  _pickYear(t) {\n    const { min: e, max: i, disablePast: n, disableFuture: o } = this._options;\n    if (Bo(t, e, i, n, o))\n      return;\n    const r = Et(t, this.activeMonth, this.activeDay);\n    this._activeDate = r, this._selectedDate = r, this._selectYear(t);\n  }\n  _pickMonth(t, e) {\n    const { min: i, max: n, disablePast: o, disableFuture: r } = this._options;\n    if (zc(t, e, i, n, o, r) || Bo(e, i, n, o, r))\n      return;\n    const a = Et(e, t, this.activeDay);\n    this._activeDate = a, this._selectMonth(t);\n  }\n  nextMonth() {\n    const t = nt(this._activeDate, 1), e = Fs(\n      t,\n      this._headerDate,\n      this._options,\n      this._classes\n    );\n    this._activeDate = t, this.viewChangeButton.textContent = `${this._options.monthsFull[this.activeMonth]} ${this.activeYear}`, this.viewChangeButton.innerHTML += $t(\n      this._options,\n      this._classes\n    ), this.datesContainer.innerHTML = e;\n  }\n  previousMonth() {\n    const t = nt(this._activeDate, -1);\n    this._activeDate = t;\n    const e = Fs(\n      t,\n      this._headerDate,\n      this._options,\n      this._classes\n    );\n    this.viewChangeButton.textContent = `${this._options.monthsFull[this.activeMonth]} ${this.activeYear}`, this.viewChangeButton.innerHTML += $t(\n      this._options,\n      this._classes\n    ), this.datesContainer.innerHTML = e;\n  }\n  nextYear() {\n    const t = it(this._activeDate, 1);\n    this._activeDate = t, this.viewChangeButton.textContent = `${this.activeYear}`, this.viewChangeButton.innerHTML += $t(\n      this._options,\n      this._classes\n    );\n    const e = Ys(\n      this.activeYear,\n      this._selectedYear,\n      this._selectedMonth,\n      this._options,\n      cs,\n      this._classes\n    );\n    this.datesContainer.innerHTML = e;\n  }\n  previousYear() {\n    const t = it(this._activeDate, -1);\n    this._activeDate = t, this.viewChangeButton.textContent = `${this.activeYear}`, this.viewChangeButton.innerHTML += $t(\n      this._options,\n      this._classes\n    );\n    const e = Ys(\n      this.activeYear,\n      this._selectedYear,\n      this._selectedMonth,\n      this._options,\n      cs,\n      this._classes\n    );\n    this.datesContainer.innerHTML = e;\n  }\n  nextYears() {\n    const t = it(this._activeDate, 24);\n    this._activeDate = t;\n    const e = js(\n      t,\n      this._selectedYear,\n      this._options,\n      vt,\n      ls,\n      this._classes\n    );\n    this.viewChangeButton.textContent = `${this.firstYearInView} - ${this.lastYearInView}`, this.viewChangeButton.innerHTML += $t(\n      this._options,\n      this._classes\n    ), this.datesContainer.innerHTML = e;\n  }\n  previousYears() {\n    const t = it(this._activeDate, -24);\n    this._activeDate = t;\n    const e = js(\n      t,\n      this._selectedYear,\n      this._options,\n      vt,\n      ls,\n      this._classes\n    );\n    this.viewChangeButton.textContent = `${this.firstYearInView} - ${this.lastYearInView}`, this.viewChangeButton.innerHTML += $t(\n      this._options,\n      this._classes\n    ), this.datesContainer.innerHTML = e;\n  }\n  _asyncChangeView(t) {\n    setTimeout(() => {\n      this._changeView(t);\n    }, 0);\n  }\n  _changeView(t) {\n    this._view = t, this.datesContainer.blur(), t === \"days\" && (this.datesContainer.innerHTML = Fs(\n      this._activeDate,\n      this._headerDate,\n      this._options,\n      this._classes\n    )), t === \"months\" && (this.datesContainer.innerHTML = Ys(\n      this.activeYear,\n      this._selectedYear,\n      this._selectedMonth,\n      this._options,\n      cs,\n      this._classes\n    )), t === \"years\" && (this.datesContainer.innerHTML = js(\n      this._activeDate,\n      this._selectedYear,\n      this._options,\n      vt,\n      ls,\n      this._classes\n    )), this.datesContainer.focus(), this._updateViewControlsAndAttributes(t), this._updateControlsDisabledState();\n  }\n  _updateViewControlsAndAttributes(t) {\n    t === \"days\" && (this.viewChangeButton.textContent = `${this._options.monthsFull[this.activeMonth]} ${this.activeYear}`, this.viewChangeButton.innerHTML += $t(\n      this._options,\n      this._classes\n    ), this.viewChangeButton.setAttribute(\n      \"aria-label\",\n      this._options.switchToMultiYearViewLabel\n    ), this.previousButton.setAttribute(\n      \"aria-label\",\n      this._options.prevMonthLabel\n    ), this.nextButton.setAttribute(\"aria-label\", this._options.nextMonthLabel)), t === \"months\" && (this.viewChangeButton.textContent = `${this.activeYear}`, this.viewChangeButton.innerHTML += $t(\n      this._options,\n      this._classes\n    ), this.viewChangeButton.setAttribute(\n      \"aria-label\",\n      this._options.switchToDayViewLabel\n    ), this.previousButton.setAttribute(\n      \"aria-label\",\n      this._options.prevYearLabel\n    ), this.nextButton.setAttribute(\"aria-label\", this._options.nextYearLabel)), t === \"years\" && (this.viewChangeButton.textContent = `${this.firstYearInView} - ${this.lastYearInView}`, this.viewChangeButton.innerHTML += $t(\n      this._options,\n      this._classes\n    ), this.viewChangeButton.setAttribute(\n      \"aria-label\",\n      this._options.switchToMonthViewLabel\n    ), this.previousButton.setAttribute(\n      \"aria-label\",\n      this._options.prevMultiYearLabel\n    ), this.nextButton.setAttribute(\n      \"aria-label\",\n      this._options.nextMultiYearLabel\n    ));\n  }\n  _updateControlsDisabledState() {\n    _f(\n      this._options.disableFuture,\n      this._activeDate,\n      this._view,\n      vt,\n      this._options.min,\n      this._options.max,\n      this.lastYearInView,\n      this.firstYearInView\n    ) ? this.nextButton.disabled = !0 : this.nextButton.disabled = !1, ff(\n      this._options.disablePast,\n      this._activeDate,\n      this._view,\n      vt,\n      this._options.min,\n      this._options.max,\n      this.lastYearInView,\n      this.firstYearInView\n    ) ? this.previousButton.disabled = !0 : this.previousButton.disabled = !1;\n  }\n  _handleUserInput(t) {\n    const e = this._getDelimeters(this._options.format), i = this._parseDate(t, this._options.format, e);\n    df(i) ? (this._activeDate = i, this._selectedDate = i, this._selectedYear = B(i), this._selectedMonth = Y(i), this._headerDate = i) : (this._activeDate = /* @__PURE__ */ new Date(), this._selectedDate = null, this._selectedMonth = null, this._selectedYear = null, this._headerDate = null, this._headerMonth = null, this._headerYear = null);\n  }\n  _getDelimeters(t) {\n    return t.match(/[^(dmy)]{1,}/g);\n  }\n  _parseDate(t, e, i) {\n    let n;\n    i[0] !== i[1] ? n = i[0] + i[1] : n = i[0];\n    const o = new RegExp(`[${n}]`), r = t.split(o), a = e.split(o), l = e.indexOf(\"mmm\") !== -1, p = [];\n    for (let b = 0; b < a.length; b++)\n      a[b].indexOf(\"yy\") !== -1 && (p[0] = { value: r[b], format: a[b] }), a[b].indexOf(\"m\") !== -1 && (p[1] = { value: r[b], format: a[b] }), a[b].indexOf(\"d\") !== -1 && a[b].length <= 2 && (p[2] = { value: r[b], format: a[b] });\n    let u;\n    e.indexOf(\"mmmm\") !== -1 ? u = this._options.monthsFull : u = this._options.monthsShort;\n    const _ = Number(p[0].value), f = l ? this.getMonthNumberByMonthName(p[1].value, u) : Number(p[1].value) - 1, g = Number(p[2].value);\n    return Et(_, f, g);\n  }\n  getMonthNumberByMonthName(t, e) {\n    return e.findIndex((i) => i === t);\n  }\n  static getInstance(t) {\n    return y.getData(t, zs);\n  }\n  static getOrCreateInstance(t, e = {}) {\n    return this.getInstance(t) || new this(t, typeof e == \"object\" ? e : null);\n  }\n}\nconst Mm = ({\n  format24: s,\n  okLabel: t,\n  cancelLabel: e,\n  headID: i,\n  footerID: n,\n  bodyID: o,\n  pickerID: r,\n  clearLabel: a,\n  inline: l,\n  showClearBtn: p,\n  amLabel: u,\n  pmLabel: _\n}, f) => {\n  const g = `<div id='${r}' class='${f.timepickerWrapper}' data-te-timepicker-wrapper>\n      <div class=\"${f.timepickerContainer}\">\n        <div class=\"${f.timepickerElements}\" data-te-timepicker-elements-wrapper>\n        <div id='${i}' class='${f.timepickerHead}' style='padding-right:${s ? 50 : 10}px'>\n        <div class='${f.timepickerHeadContent}'>\n            <div class=\"${f.timepickerCurrentWrapper}\">\n              <span class=\"${f.timepickerCurrentButtonWrapper}\">\n                <button type='button' class='${f.timepickerCurrentButton}' tabindex=\"0\" data-te-timepicker-active data-te-timepicker-current data-te-timepicker-hour data-te-ripple-init>21</button>\n              </span>\n              <button type='button' class='${f.timepickerDot}' disabled>:</button>\n            <span class=\"${f.timepickerCurrentButtonWrapper}\">\n              <button type='button' class='${f.timepickerCurrentButton}' tabindex=\"0\" data-te-timepicker-current data-te-timepicker-minute data-te-ripple-init>21</button>\n            </span>\n            </div>\n            ${s ? \"\" : `<div class=\"${f.timepickerModeWrapper}\">\n                  <button type='button' class=\"${f.timepickerModeAm}\" tabindex=\"0\" data-te-timepicker-am data-te-timepicker-hour-mode data-te-ripple-init>${u}</button>\n                  <button class=\"${f.timepickerModePm}\" tabindex=\"0\" data-te-timepicker-pm data-te-timepicker-hour-mode data-te-ripple-init>${_}</button>\n                </div>`}\n        </div>\n      </div>\n      ${l ? \"\" : `<div id='${o}' class='${f.timepickerClockWrapper}' data-te-timepicker-clock-wrapper>\n            <div class='${f.timepickerClock}' data-te-timepicker-clock>\n              <span class='${f.timepickerMiddleDot}' data-te-timepicker-middle-dot></span>\n              <div class='${f.timepickerHandPointer}' data-te-timepicker-hand-pointer>\n                <div class='${f.timepickerPointerCircle}' data-te-timepicker-circle></div>\n              </div>\n              ${s ? '<div class=\"' + f.timepickerClockInner + '\" data-te-timepicker-clock-inner></div>' : \"\"}\n            </div>\n          </div>`}\n    </div>\n    <div id='${n}' class='${f.timepickerFooterWrapper}'>\n      <div class=\"${f.timepickerFooter}\">\n        ${p ? `<button type='button' class='${f.timepickerFooterButton}' data-te-timepicker-clear tabindex=\"0\" data-te-ripple-init>${a}</button>` : \"\"}\n        <button type='button' class='${f.timepickerFooterButton}' data-te-timepicker-cancel tabindex=\"0\" data-te-ripple-init>${e}</button>\n        <button type='button' class='${f.timepickerFooterButton}' data-te-timepicker-submit tabindex=\"0\" data-te-ripple-init>${t}</button>\n      </div>\n    </div>\n  </div>\n</div>`, m = `<div id='${r}' class='${f.timepickerInlineWrapper}' data-te-timepicker-wrapper>\n        <div class=\"${f.timepickerInlineContainer}\">\n          <div class=\"${f.timepickerInlineElements}\" data-te-timepicker-elements-wrapper>\n          <div id='${i}' class='${f.timepickerInlineHead}'\n          style='padding-right:10px'>\n          <div class='${f.timepickerInlineHeadContent}'>\n              <div class=\"${f.timepickerCurrentWrapper}\">\n                <span class=\"${f.timepickerInlineHourWrapper}\" data-te-timepicker-inline-hour-icons>\n                  <span class=\"${f.timepickerInlineIconUp}\" data-te-timepicker-icon-up data-te-timepicker-icon-inline-hour>\n                    <span class=\"${f.timepickerInlineIconSvg}\">\n                      <svg xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" viewBox=\"0 0 24 24\" stroke-width=\"1.5\" stroke=\"currentColor\" class=\"w-5 h-5\">\n                      <path stroke-linecap=\"round\" stroke-linejoin=\"round\" d=\"M4.5 15.75l7.5-7.5 7.5 7.5\" />\n                      </svg>   \n                    </span>\n                  </span>\n                  <button type='button' class='${f.timepickerInlineCurrentButton}' data-te-timepicker-hour data-te-timepicker-current data-te-timepicker-current-inline tabindex=\"0\" data-te-ripple-init>21</button>\n                  <span class=\"${f.timepickerInlineIconDown}\" data-te-timepicker-icon-inline-hour data-te-timepicker-icon-down>\n                    <span class=\"${f.timepickerInlineIconSvg}\">\n                      <svg xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" viewBox=\"0 0 24 24\" stroke-width=\"1.5\" stroke=\"currentColor\" class=\"w-5 h-5\">\n                      <path stroke-linecap=\"round\" stroke-linejoin=\"round\" d=\"M19.5 8.25l-7.5 7.5-7.5-7.5\" />\n                      </svg>  \n                    </span>\n                  </span>\n                </span>\n                <button type='button' class='${f.timepickerInlineDot}' data-te-timepicker-current-inline disabled>:</button>\n              <span class=\"${f.timepickerCurrentMinuteWrapper}\">\n                <span class=\"${f.timepickerInlineIconUp}\" data-te-timepicker-icon-up data-te-timepicker-icon-inline-minute>\n                  <span class=\"${f.timepickerInlineIconSvg}\">\n                    <svg xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" viewBox=\"0 0 24 24\" stroke-width=\"1.5\" stroke=\"currentColor\" class=\"w-5 h-5\">\n                    <path stroke-linecap=\"round\" stroke-linejoin=\"round\" d=\"M4.5 15.75l7.5-7.5 7.5 7.5\" />\n                    </svg>\n                  </span>\n                </span>\n                <button type='button' class='${f.timepickerInlineCurrentButton}' data-te-timepicker-minute data-te-timepicker-current data-te-timepicker-current-inline tabindex=\"0\" data-te-ripple-init>21</button>\n                <span class=\"${f.timepickerInlineIconDown}\" data-te-timepicker-icon-inline-minute data-te-timepicker-icon-down>\n                  <span class=\"${f.timepickerInlineIconSvg}\">\n                    <svg xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" viewBox=\"0 0 24 24\" stroke-width=\"1.5\" stroke=\"currentColor\" class=\"w-5 h-5\">\n                    <path stroke-linecap=\"round\" stroke-linejoin=\"round\" d=\"M19.5 8.25l-7.5 7.5-7.5-7.5\" />\n                    </svg> \n                  </span>\n                </span>\n              </span>\n              </div>\n              ${s ? \"\" : `<div class=\"${f.timepickerInlineModeWrapper}\">\n                      <button type='button' class=\"${f.timepickerInlineModeAm}\" data-te-timepicker-am data-te-timepicker-hour-mode tabindex=\"0\" data-te-ripple-init>${u}</button>\n                      <button class=\"${f.timepickerInlineModePm}\" data-te-timepicker-hour-mode data-te-timepicker-pm tabindex=\"0\" data-te-ripple-init>${_}</button>\n                      <button type='button' class='${f.timepickerInlineSubmitButton}' data-te-timepicker-submit tabindex=\"0\" data-te-ripple-init>${t}</button>\n                    </div>`}\n              ${s ? `<button class='${f.timepickerInlineSubmitButton}' data-te-timepicker-submit tabindex=\"0\" data-te-ripple-init>${t}</button>` : \"\"}\n          </div>\n        </div>\n      </div>\n    </div>\n</div>`;\n  return l ? m : g;\n}, Rm = (s, t, e) => {\n  const { iconSVG: i } = s;\n  return `\n  <button id=\"${t}\" tabindex=\"0\" type=\"button\" class=\"${e.timepickerToggleButton}\" data-te-toggle=\"timepicker\" data-te-timepicker-toggle-button data-te-timepicker-icon>\n    ${i}\n  </button>\n`;\n}, un = \"data-te-timepicker-disabled\", us = \"data-te-timepicker-active\", ve = (s) => {\n  if (s === \"\")\n    return;\n  let t, e, i, n;\n  return Gc(s) ? (t = s.getHours(), n = t, e = s.getMinutes(), t %= 12, n === 0 && t === 0 && (i = \"AM\"), t = t || 12, i === void 0 && (i = Number(n) >= 12 ? \"PM\" : \"AM\"), e = e < 10 ? `0${e}` : e) : ([t, e, i] = R(s, !1), n = t, t %= 12, n === 0 && t === 0 && (i = \"AM\"), t = t || 12, i === void 0 && (i = Number(n) >= 12 ? \"PM\" : \"AM\")), {\n    hours: t,\n    minutes: e,\n    amOrPm: i\n  };\n}, Gc = (s) => s && Object.prototype.toString.call(s) === \"[object Date]\" && !Number.isNaN(s), La = (s) => {\n  if (s === \"\")\n    return;\n  let t, e;\n  return Gc(s) ? (t = s.getHours(), e = s.getMinutes()) : [t, e] = R(s, !1), e = Number(e) < 10 ? `0${Number(e)}` : e, {\n    hours: t,\n    minutes: e\n  };\n}, Pm = (s, t, e) => c.on(document, s, t, ({ target: i }) => {\n  if (i.hasAttribute(us))\n    return;\n  document.querySelectorAll(t).forEach((o) => {\n    o.hasAttribute(us) && (h.removeClass(o, e.opacity), o.removeAttribute(us));\n  }), h.addClass(i, e.opacity), i.setAttribute(us, \"\");\n}), Na = ({ clientX: s, clientY: t, touches: e }, i, n = !1) => {\n  const { left: o, top: r } = i.getBoundingClientRect();\n  let a = {};\n  return !n || !e ? a = {\n    x: s - o,\n    y: t - r\n  } : n && Object.keys(e).length > 0 && (a = {\n    x: e[0].clientX - o,\n    y: e[0].clientY - r\n  }), a;\n}, ps = () => navigator.maxTouchPoints && navigator.maxTouchPoints > 2 && /MacIntel/.test(navigator.platform) || /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(\n  navigator.userAgent\n), R = (s, t = !0) => t ? s.value.replace(/:/gi, \" \").split(\" \") : s.replace(/:/gi, \" \").split(\" \"), qc = (s, t) => {\n  const [e, i, n] = R(s, !1), [o, r, a] = R(t, !1);\n  return n === \"PM\" && a === \"AM\" || n === a && e > o || i > r;\n}, Zc = () => {\n  const s = /* @__PURE__ */ new Date(), t = s.getHours(), e = s.getMinutes();\n  return `${t}:${e < 10 ? `0${e}` : e}`;\n}, Xt = (s, t, e) => {\n  if (!t)\n    return s;\n  let i = Zc();\n  return e && (i = `${ve(i).hours}:${ve(i).minutes} ${ve(i).amOrPm}`), (s !== \"\" && qc(i, s) || s === \"\") && (s = i), s;\n}, Gt = (s, t, e) => {\n  if (!t)\n    return s;\n  let i = Zc();\n  return e && (i = `${ve(i).hours}:${ve(i).minutes} ${ve(i).amOrPm}`), (s !== \"\" && !qc(i, s) || s === \"\") && (s = i), s;\n}, Bm = ({ format12: s, maxTime: t, minTime: e, disablePast: i, disableFuture: n }, o, r) => {\n  const a = R(o)[1];\n  e = Xt(e, i, s), t = Gt(t, n, s);\n  const [l, p, u] = R(t, !1), [_, f, g] = R(e, !1);\n  if (u !== void 0 || g !== void 0)\n    return [r, a];\n  if (!(l !== \"\" && _ === \"\" && Number(r) > Number(l)) && !(l === \"\" && _ !== \"\" && p === void 0 && f !== \"\" && Number(r) < Number(_)))\n    return [r, a];\n}, Ma = (s, t, e, i) => {\n  s.forEach((n) => {\n    t = t === \"12\" && i ? \"0\" : t, (n.textContent === \"00\" || Number(n.textContent === \"12\" && i ? \"0\" : n.textContent) > t) && (h.addClass(n, e.tipsDisabled), n.setAttribute(un, \"\"));\n  });\n}, Ra = (s, t, e, i) => {\n  s.forEach((n) => {\n    t = t === \"12\" && i ? \"0\" : t, n.textContent !== \"00\" && Number(n.textContent === \"12\" && i ? \"0\" : n.textContent) < Number(t) && (h.addClass(n, e.tipsDisabled), n.setAttribute(un, \"\"));\n  });\n}, Qc = (s, t, e, i) => {\n  if (t === \"12\" || t === \"24\")\n    return;\n  const n = e ? 12 : 24;\n  return i === \"max\" ? (Number(s) === n ? 0 : Number(s)) > Number(t) : (Number(s) === n ? 0 : Number(s)) < Number(t);\n}, Hm = (s, t, e, i, n, o) => {\n  s.forEach((r) => {\n    (Qc(i, e, o, \"max\") || Number(r.textContent) > t && Number(i) === Number(e)) && (h.addClass(r, n.tipsDisabled), r.setAttribute(un, \"\"));\n  });\n}, Vm = (s, t, e, i, n, o) => {\n  s.forEach((r) => {\n    (Qc(i, e, o, \"min\") || Number(r.textContent) < t && Number(i) === Number(e)) && (h.addClass(r, n.tipsDisabled), r.setAttribute(un, \"\"));\n  });\n}, Wm = (s) => s.startsWith(\"0\") ? Number(s.slice(1)) : Number(s), $i = \"timepicker\", M = `data-te-${$i}`, Pa = \"[data-te-toggle]\", Us = `te.${$i}`, Rt = `.${Us}`, Pt = \".data-api\", Ba = `click${Rt}${Pt}`, _s = `keydown${Rt}${Pt}`, Ha = `mousedown${Rt}${Pt}`, Va = `mouseup${Rt}${Pt}`, Wa = `mousemove${Rt}${Pt}`, Fa = `mouseleave${Rt}${Pt}`, Ya = `mouseover${Rt}${Pt}`, ja = `touchmove${Rt}${Pt}`, Ka = `touchend${Rt}${Pt}`, za = `touchstart${Rt}${Pt}`, Fm = `[${M}-am]`, Ym = `[${M}-pm]`, jm = `[${M}-format24]`, fs = `[${M}-current]`, ms = `[${M}-hour-mode]`, Km = `[${M}-toggle-button]`, Gn = `${M}-cancel`, Ua = `${M}-clear`, qn = `${M}-submit`, zm = `${M}-icon`, Zn = `${M}-icon-up`, Qn = `${M}-icon-down`, Um = `${M}-icon-inline-hour`, Xm = `${M}-icon-inline-minute`, Xa = `${M}-inline-hour-icons`, Gm = `${M}-current-inline`, qm = \"readonly\", Zm = `${M}-invalid-feedback`, Jn = `${M}-is-invalid`, Yt = `${M}-disabled`, H = `${M}-active`, Qm = `${M}-input`, pe = `${M}-clock`, di = `${M}-clock-inner`, to = `${M}-wrapper`, Ga = `${M}-clock-wrapper`, gs = `${M}-hour`, eo = `${M}-minute`, bs = `${M}-tips-element`, K = `${M}-tips-hours`, X = `${M}-tips-minutes`, lt = `${M}-tips-inner`, vs = `${M}-tips-inner-element`, qa = `${M}-middle-dot`, io = `${M}-hand-pointer`, so = `${M}-circle`, Za = `${M}-modal`, Jm = `<svg xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" viewBox=\"0 0 24 24\" stroke-width=\"1.5\" stroke=\"currentColor\">\n  <path stroke-linecap=\"round\" stroke-linejoin=\"round\" d=\"M12 6v6h4.5m4.5 0a9 9 0 11-18 0 9 9 0 0118 0z\" />\n</svg>`, tg = {\n  appendValidationInfo: !0,\n  bodyID: \"\",\n  cancelLabel: \"Cancel\",\n  clearLabel: \"Clear\",\n  closeModalOnBackdropClick: !0,\n  closeModalOnMinutesClick: !1,\n  container: \"body\",\n  defaultTime: \"\",\n  disabled: !1,\n  disablePast: !1,\n  disableFuture: !1,\n  enableValidation: !0,\n  focusInputAfterApprove: !1,\n  footerID: \"\",\n  format12: !0,\n  format24: !1,\n  headID: \"\",\n  increment: !1,\n  inline: !1,\n  invalidLabel: \"Invalid Time Format\",\n  maxTime: \"\",\n  minTime: \"\",\n  modalID: \"\",\n  okLabel: \"Ok\",\n  overflowHidden: !0,\n  pickerID: \"\",\n  readOnly: !1,\n  showClearBtn: !0,\n  switchHoursToMinutesOnClick: !0,\n  iconSVG: Jm,\n  withIcon: !0,\n  pmLabel: \"PM\",\n  amLabel: \"AM\",\n  animations: !0\n}, eg = {\n  appendValidationInfo: \"boolean\",\n  bodyID: \"string\",\n  cancelLabel: \"string\",\n  clearLabel: \"string\",\n  closeModalOnBackdropClick: \"boolean\",\n  closeModalOnMinutesClick: \"boolean\",\n  container: \"string\",\n  disabled: \"boolean\",\n  disablePast: \"boolean\",\n  disableFuture: \"boolean\",\n  enableValidation: \"boolean\",\n  footerID: \"string\",\n  format12: \"boolean\",\n  format24: \"boolean\",\n  headID: \"string\",\n  increment: \"boolean\",\n  inline: \"boolean\",\n  invalidLabel: \"string\",\n  modalID: \"string\",\n  okLabel: \"string\",\n  overflowHidden: \"boolean\",\n  pickerID: \"string\",\n  readOnly: \"boolean\",\n  showClearBtn: \"boolean\",\n  switchHoursToMinutesOnClick: \"boolean\",\n  defaultTime: \"(string|date|number)\",\n  iconSVG: \"string\",\n  withIcon: \"boolean\",\n  pmLabel: \"string\",\n  amLabel: \"string\",\n  animations: \"boolean\"\n}, ig = {\n  tips: \"absolute rounded-[100%] w-[32px] h-[32px] text-center cursor-pointer text-[1.1rem] rounded-[100%] bg-transparent flex justify-center items-center font-light focus:outline-none selection:bg-transparent\",\n  tipsActive: \"text-white bg-[#3b71ca] font-normal\",\n  tipsDisabled: \"text-[#b3afaf] pointer-events-none bg-transparent\",\n  transform: \"transition-[transform,height] ease-in-out duration-[400ms]\",\n  modal: \"z-[1065]\",\n  clockAnimation: \"animate-[show-up-clock_350ms_linear]\",\n  opacity: \"!opacity-100\",\n  timepickerWrapper: \"touch-none opacity-100 z-[1065] inset-0 bg-[#00000066] h-full flex items-center justify-center flex-col fixed\",\n  timepickerContainer: \"flex items-center justify-center flex-col max-h-[calc(100%-64px)] overflow-y-auto shadow-[0_10px_15px_-3px_rgba(0,0,0,0.07),0_4px_6px_-2px_rgba(0,0,0,0.05)] min-[320px]:max-[825px]:landscape:rounded-lg\",\n  timepickerElements: \"flex flex-col min-w-[310px] min-h-[325px] bg-white rounded-t-[0.6rem] min-[320px]:max-[825px]:landscape:!flex-row min-[320px]:max-[825px]:landscape:min-w-[auto] min-[320px]:max-[825px]:landscape:min-h-[auto] min-[320px]:max-[825px]:landscape:overflow-y-auto justify-around\",\n  timepickerHead: \"bg-[#3b71ca] dark:bg-zinc-700 h-[100px] rounded-t-lg pr-[24px] pl-[50px] py-[10px] min-[320px]:max-[825px]:landscape:rounded-tr-none min-[320px]:max-[825px]:landscape:rounded-bl-none min-[320px]:max-[825px]:landscape:p-[10px] min-[320px]:max-[825px]:landscape:pr-[10px] min-[320px]:max-[825px]:landscape:h-auto min-[320px]:max-[825px]:landscape:min-h-[305px] flex flex-row items-center justify-center\",\n  timepickerHeadContent: \"min-[320px]:max-[825px]:landscape:flex-col flex w-full justify-evenly\",\n  timepickerCurrentWrapper: \"[direction:ltr] rtl:[direction:rtl]\",\n  timepickerCurrentButtonWrapper: \"relative h-full\",\n  timepickerCurrentButton: \"text-[3.75rem] font-light leading-[1.2] tracking-[-0.00833em] text-white opacity-[.54] border-none bg-transparent p-0 min-[320px]:max-[825px]:landscape:text-5xl min-[320px]:max-[825px]:landscape:font-normal cursor-pointer hover:bg-[#00000026] hover:outline-none focus:bg-[#00000026] focus:outline-none \",\n  timepickerDot: \"font-light leading-[1.2] tracking-[-0.00833em] text-[3.75rem] opacity-[.54] border-none bg-transparent p-0 text-white min-[320px]:max-[825px]:landscape:text-[3rem] min-[320px]:max-[825px]:landscape:font-normal\",\n  timepickerModeWrapper: \"flex flex-col justify-center text-[18px] text-[#ffffff8a] min-[320px]:max-[825px]:landscape:!justify-around min-[320px]:max-[825px]:landscape:!flex-row\",\n  timepickerModeAm: \"p-0 bg-transparent border-none text-white opacity-[.54] cursor-pointer hover:bg-[#00000026] hover:outline-none focus:bg-[#00000026] focus:outline-none\",\n  timepickerModePm: \"p-0 bg-transparent border-none text-white opacity-[.54] cursor-pointer hover:bg-[#00000026] hover:outline-none focus:bg-[#00000026] focus:outline-none\",\n  timepickerClockWrapper: \"min-w-[310px] max-w-[325px] min-h-[305px] overflow-x-hidden h-full flex justify-center flex-col items-center dark:bg-zinc-500\",\n  timepickerClock: \"relative rounded-[100%] w-[260px] h-[260px] cursor-default my-0 mx-auto bg-[#00000012] dark:bg-zinc-600/50\",\n  timepickerMiddleDot: \"top-1/2 left-1/2 w-[6px] h-[6px] -translate-y-1/2 -translate-x-1/2 rounded-[50%] bg-[#3b71ca] absolute\",\n  timepickerHandPointer: \"bg-[#3b71ca] bottom-1/2 h-2/5 left-[calc(50%-1px)] rtl:!left-auto origin-[center_bottom_0] rtl:!origin-[50%_50%_0] w-[2px] absolute\",\n  timepickerPointerCircle: \"-top-[21px] -left-[15px] w-[4px] border-[14px] border-solid border-[#3b71ca] h-[4px] box-content rounded-[100%] absolute\",\n  timepickerClockInner: \"absolute top-1/2 left-1/2 -translate-y-1/2 -translate-x-1/2 w-[160px] h-[160px] rounded-[100%]\",\n  timepickerFooterWrapper: \"rounded-b-lg flex justify-between items-center w-full h-[56px] px-[12px] bg-white dark:bg-zinc-500\",\n  timepickerFooter: \"w-full flex justify-between\",\n  timepickerFooterButton: \"text-[0.8rem] min-w-[64px] box-border font-medium leading-[40px] rounded-[10px] tracking-[0.1rem] uppercase text-[#3b71ca] dark:text-white border-none bg-transparent transition-[background-color,box-shadow,border] duration-[250ms] ease-[cubic-bezier(0.4,0,0.2,1)] delay-[0ms] outline-none py-0 px-[10px] h-[40px] mb-[10px] hover:bg-[#00000014] focus:bg-[#00000014] focus:outline-none\",\n  timepickerInlineWrapper: \"touch-none opacity-100 z-[1065] inset-0 bg-[#00000066] h-full flex items-center justify-center flex-col rounded-lg\",\n  timepickerInlineContainer: \"flex items-center justify-center flex-col max-h-[calc(100%-64px)] overflow-y-auto shadow-[0_10px_15px_-3px_rgba(0,0,0,0.07),0_4px_6px_-2px_rgba(0,0,0,0.05)]\",\n  timepickerInlineElements: \"flex flex-col min-h-[auto] min-w-[310px] bg-white rounded-[0.6rem] min-[320px]:max-[825px]:landscape:!flex-row min-[320px]:max-[825px]:landscape:rounded-bl-lg min-[320px]:max-[825px]:landscape:min-w-[auto] min-[320px]:max-[825px]:landscape::min-h-[auto] min-[320px]:max-[825px]:landscape:overflow-y-auto justify-around\",\n  timepickerInlineHead: \"bg-[#3b71ca] dark:bg-zinc-700 h-[100px] rounded-t-lg min-[320px]:max-[825px]:landscape:rounded-tr-none min-[320px]:max-[825px]:landscape:rounded-bl-none min-[320px]:max-[825px]:landscape:p-[10px] min-[320px]:max-[825px]:landscape:pr-[10px] min-[320px]:max-[825px]:landscape:h-auto min-[320px]:max-[825px]:landscape:min-h-[305px] flex flex-row items-center justify-center p-0 rounded-b-lg\",\n  timepickerInlineHeadContent: \"min-[320px]:max-[825px]:landscape:flex-col flex w-full justify-evenly items-center\",\n  timepickerInlineHourWrapper: \"relative h-full !opacity-100\",\n  timepickerCurrentMinuteWrapper: \"relative h-full\",\n  timepickerInlineIconUp: \"absolute text-white -top-[35px] opacity-0 hover:opacity-100 transition-all duration-200 ease-[ease] cursor-pointer -translate-x-1/2 -translate-y-1/2 left-1/2 w-[30px] h-[30px] flex justify-center items-center\",\n  timepickerInlineIconSvg: \"h-4 w-4\",\n  timepickerInlineCurrentButton: \"font-light leading-[1.2] tracking-[-0.00833em] text-white border-none bg-transparent p-0 min-[320px]:max-[825px]:landscape:text-5xl min-[320px]:max-[825px]:landscape:font-normal !opacity-100 cursor-pointer focus:bg-[#00000026] hover:outline-none focus:outline-none text-[2.5rem] hover:bg-[unset]\",\n  timepickerInlineIconDown: \"absolute text-white -bottom-[47px] opacity-0 hover:opacity-100 transition-all duration-200 ease-[ease] cursor-pointer -translate-x-1/2 -translate-y-1/2 left-1/2 w-[30px] h-[30px] flex justify-center items-center\",\n  timepickerInlineDot: \"font-light leading-[1.2] tracking-[-0.00833em] opacity-[.54] border-none bg-transparent p-0 text-white min-[320px]:max-[825px]:landscape:text-[3rem] min-[320px]:max-[825px]:landscape:font-normal text-[2.5rem]\",\n  timepickerInlineModeWrapper: \"flex justify-center text-[18px] text-[#ffffff8a] min-[320px]:max-[825px]:landscape:!justify-around min-[320px]:max-[825px]:landscape:!flex-row\",\n  timepickerInlineModeAm: \"hover:bg-[#00000026] hover:outline-none focus:bg-[#00000026] focus:outline-none p-0 bg-transparent border-none text-white opacity-[.54] cursor-pointer mr-2 ml-6\",\n  timepickerInlineModePm: \"hover:bg-[#00000026] hover:outline-none focus:bg-[#00000026] focus:outline-none p-0 bg-transparent border-none text-white opacity-[.54] cursor-pointer\",\n  timepickerInlineSubmitButton: \"hover:bg-[#00000014] focus:bg-[#00000014] focus:outline-none text-[0.8rem] box-border font-medium leading-[40px] tracking-[.1rem] uppercase border-none bg-transparent [transition:background-color_250ms_cubic-bezier(0.4,0,0.2,1)_0ms,box-shadow_250ms_cubic-bezier(0.4,0,0.2,1)_0ms,border_250ms_cubic-bezier(0.4,0,0.2,1)_0ms] outline-none rounded-[100%] h-[48px] min-w-[48px] inline-block ml-[30px] text-white py-1 px-2 mb-0\",\n  timepickerToggleButton: \"h-4 w-4 ml-auto absolute outline-none border-none bg-transparent right-1.5 top-1/2 -translate-x-1/2 -translate-y-1/2 transition-all duration-300 ease-[cubic-bezier(0.25,0.1,0.25,1)] cursor-pointer hover:text-[#3b71ca] focus:text-[#3b71ca] dark:hover:text-[#3b71ca] dark:focus:text-[#3b71ca] dark:text-white\"\n}, sg = {\n  tips: \"string\",\n  tipsActive: \"string\",\n  tipsDisabled: \"string\",\n  transform: \"string\",\n  modal: \"string\",\n  clockAnimation: \"string\",\n  opacity: \"string\",\n  timepickerWrapper: \"string\",\n  timepickerContainer: \"string\",\n  timepickerElements: \"string\",\n  timepickerHead: \"string\",\n  timepickerHeadContent: \"string\",\n  timepickerCurrentWrapper: \"string\",\n  timepickerCurrentButtonWrapper: \"string\",\n  timepickerCurrentButton: \"string\",\n  timepickerDot: \"string\",\n  timepickerModeWrapper: \"string\",\n  timepickerModeAm: \"string\",\n  timepickerModePm: \"string\",\n  timepickerClockWrapper: \"string\",\n  timepickerClock: \"string\",\n  timepickerMiddleDot: \"string\",\n  timepickerHandPointer: \"string\",\n  timepickerPointerCircle: \"string\",\n  timepickerClockInner: \"string\",\n  timepickerFooterWrapper: \"string\",\n  timepickerFooterButton: \"string\",\n  timepickerInlineWrapper: \"string\",\n  timepickerInlineContainer: \"string\",\n  timepickerInlineElements: \"string\",\n  timepickerInlineHead: \"string\",\n  timepickerInlineHeadContent: \"string\",\n  timepickerInlineHourWrapper: \"string\",\n  timepickerCurrentMinuteWrapper: \"string\",\n  timepickerInlineIconUp: \"string\",\n  timepickerInlineIconSvg: \"string\",\n  timepickerInlineCurrentButton: \"string\",\n  timepickerInlineIconDown: \"string\",\n  timepickerInlineDot: \"string\",\n  timepickerInlineModeWrapper: \"string\",\n  timepickerInlineModeAm: \"string\",\n  timepickerInlineModePm: \"string\",\n  timepickerInlineSubmitButton: \"string\",\n  timepickerToggleButton: \"string\"\n};\nclass ng {\n  constructor(t, e = {}, i) {\n    yt(this, \"_toggleAmPm\", (t) => {\n      t === \"PM\" ? (this._isPmEnabled = !0, this._isAmEnabled = !1) : t === \"AM\" && (this._isPmEnabled = !1, this._isAmEnabled = !0);\n    });\n    yt(this, \"_toggleBackgroundColorCircle\", (t) => {\n      if (this._modal.querySelector(`${t}[${H}]`) !== null) {\n        h.addStyle(this._circle, {\n          backgroundColor: \"#1976d2\"\n        });\n        return;\n      }\n      h.addStyle(this._circle, {\n        backgroundColor: \"transparent\"\n      });\n    });\n    yt(this, \"_toggleClassActive\", (t, { textContent: e }, i) => {\n      const n = [...t].find(\n        (o) => Number(o) === Number(e)\n      );\n      return i.forEach((o) => {\n        if (!o.hasAttribute(Yt)) {\n          if (o.textContent === n) {\n            h.addClass(o, this._classes.tipsActive), o.setAttribute(H, \"\");\n            return;\n          }\n          h.removeClass(o, this._classes.tipsActive), o.removeAttribute(H);\n        }\n      });\n    });\n    yt(this, \"_makeMinutesDegrees\", (t, e) => {\n      const { increment: i } = this._options;\n      return t < 0 ? (e = Math.round(360 + t / 6) % 60, t = 360 + Math.round(t / 6) * 6) : (e = Math.round(t / 6) % 60, t = Math.round(t / 6) * 6), i && (t = Math.round(t / 30) * 30, e = Math.round(t / 6) * 6 / 6, e === 60 && (e = \"00\")), t >= 360 && (t = 0), {\n        degrees: t,\n        minute: e,\n        addDegrees: i ? 30 : 6\n      };\n    });\n    yt(this, \"_makeHourDegrees\", (t, e, i) => {\n      if (t)\n        return this._hasTargetInnerClass(t) ? e < 0 ? (i = Math.round(360 + e / 30) % 24, e = 360 + e) : (i = Math.round(e / 30) + 12, i === 12 && (i = \"00\")) : e < 0 ? (i = Math.round(360 + e / 30) % 12, e = 360 + e) : (i = Math.round(e / 30) % 12, (i === 0 || i > 12) && (i = 12)), e >= 360 && (e = 0), {\n          degrees: e,\n          hour: i,\n          addDegrees: 30\n        };\n    });\n    yt(this, \"_makeInnerHoursDegrees\", (t, e) => (t < 0 ? (e = Math.round(360 + t / 30) % 24, t = 360 + t) : (e = Math.round(t / 30) + 12, e === 12 && (e = \"00\")), {\n      degrees: t,\n      hour: e,\n      addDegrees: 30\n    }));\n    yt(this, \"_getAppendClock\", (t = [], e = `[${pe}]`, i) => {\n      let { minTime: n, maxTime: o } = this._options;\n      const { inline: r, format12: a, disablePast: l, disableFuture: p } = this._options;\n      n = Xt(n, l, a), o = Gt(o, p, a);\n      const [u, _, f] = R(\n        o,\n        !1\n      ), [g, m, b] = R(\n        n,\n        !1\n      );\n      !r && a && this._isInvalidTimeFormat && !this._AM.hasAttribute(H) && (h.addClass(this._PM, this._classes.opacity), this._PM.setAttribute(H, \"\"));\n      const v = d.findOne(e), C = 360 / t.length;\n      function w(k) {\n        return k * (Math.PI / 180);\n      }\n      if (v === null)\n        return;\n      const E = (v.offsetWidth - 32) / 2, T = (v.offsetHeight - 32) / 2, A = E - 4;\n      setTimeout(() => {\n        let k;\n        a && (k = d.findOne(\n          `${ms}[${H}]`\n        ).textContent), this._handleDisablingTipsMinTime(\n          k,\n          b,\n          m,\n          g\n        ), this._handleDisablingTipsMaxTime(\n          k,\n          f,\n          _,\n          u\n        );\n      }, 0), [...t].forEach((k, I) => {\n        const O = w(I * C), x = $(\"span\"), L = $(\"span\");\n        L.innerHTML = k, h.addClass(x, this._classes.tips), x.setAttribute(i, \"\");\n        const S = x.offsetWidth, N = x.offsetHeight;\n        return h.addStyle(x, {\n          left: `${E + Math.sin(O) * A - S}px`,\n          bottom: `${T + Math.cos(O) * A - N}px`\n        }), t.includes(\"05\") && x.setAttribute(X, \"\"), t.includes(\"13\") ? L.setAttribute(vs, \"\") : L.setAttribute(bs, \"\"), x.appendChild(L), v.appendChild(x);\n      });\n    });\n    this._element = t, this._element && y.setData(t, Us, this), this._document = document, this._options = this._getConfig(e), this._classes = this._getClasses(i), this._currentTime = null, this._toggleButtonId = rt(\"timepicker-toggle-\"), this.hoursArray = [\n      \"12\",\n      \"1\",\n      \"2\",\n      \"3\",\n      \"4\",\n      \"5\",\n      \"6\",\n      \"7\",\n      \"8\",\n      \"9\",\n      \"10\",\n      \"11\"\n    ], this.innerHours = [\n      \"00\",\n      \"13\",\n      \"14\",\n      \"15\",\n      \"16\",\n      \"17\",\n      \"18\",\n      \"19\",\n      \"20\",\n      \"21\",\n      \"22\",\n      \"23\"\n    ], this.minutesArray = [\n      \"00\",\n      \"05\",\n      \"10\",\n      \"15\",\n      \"20\",\n      \"25\",\n      \"30\",\n      \"35\",\n      \"40\",\n      \"45\",\n      \"50\",\n      \"55\"\n    ], this.input = d.findOne(\"input\", this._element), this.dataWithIcon = t.dataset.withIcon, this.dataToggle = t.dataset.toggle, this.customIcon = d.findOne(\n      Km,\n      this._element\n    ), this._checkToggleButton(), this.inputFormatShow = d.findOne(\n      jm,\n      this._element\n    ), this.inputFormat = this.inputFormatShow === null ? \"\" : Object.values(this.inputFormatShow.dataset)[0], this.elementToggle = d.findOne(\n      Pa,\n      this._element\n    ), this.toggleElement = Object.values(\n      t.querySelector(Pa).dataset\n    )[0], this._hour = null, this._minutes = null, this._AM = null, this._PM = null, this._wrapper = null, this._modal = null, this._hand = null, this._circle = null, this._focusTrap = null, this._popper = null, this._interval = null, this._timeoutInterval = null, this._inputValue = this._options.defaultTime !== \"\" ? this._options.defaultTime : this.input.value, this._options.format24 && (this._options.format12 = !1, this._currentTime = La(this._inputValue)), this._options.format12 && (this._options.format24 = !1, this._currentTime = ve(this._inputValue)), this._options.readOnly && this.input.setAttribute(qm, !0), this.inputFormat === \"true\" && this.inputFormat !== \"\" && (this._options.format12 = !1, this._options.format24 = !0, this._currentTime = La(this._inputValue)), this._animations = !window.matchMedia(\"(prefers-reduced-motion: reduce)\").matches && this._options.animations, this.init(), this._isHours = !0, this._isMinutes = !1, this._isInvalidTimeFormat = !1, this._isMouseMove = !1, this._isInner = !1, this._isAmEnabled = !1, this._isPmEnabled = !1, this._options.format12 && !this._options.defaultTime && (this._isPmEnabled = !0), this._objWithDataOnChange = { degrees: null }, this._scrollBar = new qe();\n  }\n  // Getters\n  static get NAME() {\n    return $i;\n  }\n  // Public\n  init() {\n    const { format12: t, format24: e, enableValidation: i } = this._options;\n    let n, o, r;\n    if (this.input.setAttribute(Qm, \"\"), this._currentTime !== void 0) {\n      const { hours: a, minutes: l, amOrPm: p } = this._currentTime;\n      n = Number(a) < 10 ? 0 : \"\", o = `${n}${Number(a)}:${l}`, r = p, t ? this.input.value = `${o} ${r}` : e && (this.input.value = `${o}`);\n    } else\n      n = \"\", o = \"\", r = \"\", this.input.value = \"\";\n    this.input.value.length > 0 && this.input.value !== \"\" && (this.input.setAttribute(H, \"\"), c.trigger(this.input, \"input\")), !(this._options === null && this._element === null) && (i && this._getValidate(\"keydown change blur focus\"), this._handleOpen(), this._listenToToggleKeydown());\n  }\n  dispose() {\n    this._removeModal(), this._element !== null && y.removeData(this._element, Us), setTimeout(() => {\n      this._element = null, this._options = null, this.input = null, this._focusTrap = null;\n    }, 350), c.off(\n      this._document,\n      \"click\",\n      `[data-te-toggle='${this.toggleElement}']`\n    ), c.off(\n      this._element,\n      \"keydown\",\n      `[data-te-toggle='${this.toggleElement}']`\n    );\n  }\n  update(t = {}) {\n    this._options = this._getConfig({ ...this._options, ...t });\n  }\n  // private\n  _checkToggleButton() {\n    this.customIcon === null && (this.dataWithIcon !== void 0 && (this._options.withIcon = null, this.dataWithIcon === \"true\" && this._appendToggleButton(this._options)), this._options.withIcon && this._appendToggleButton(this._options));\n  }\n  _appendToggleButton() {\n    const t = Rm(\n      this._options,\n      this._toggleButtonId,\n      this._classes\n    );\n    this.input.insertAdjacentHTML(\"afterend\", t);\n  }\n  _getDomElements() {\n    this._hour = d.findOne(`[${gs}]`), this._minutes = d.findOne(`[${eo}]`), this._AM = d.findOne(Fm), this._PM = d.findOne(Ym), this._wrapper = d.findOne(`[${to}]`), this._modal = d.findOne(`[${Za}]`), this._hand = d.findOne(`[${io}]`), this._circle = d.findOne(`[${so}]`), this._clock = d.findOne(`[${pe}]`), this._clockInner = d.findOne(\n      `[${di}]`\n    );\n  }\n  _handlerMaxMinHoursOptions(t, e, i, n, o, r) {\n    if (!e && !i)\n      return !0;\n    const { format24: a, format12: l, disablePast: p, disableFuture: u } = this._options, { _isAmEnabled: _, _isPmEnabled: f } = this, g = r.keyCode, m = r.target.hasAttribute(di) || r.target.hasAttribute(lt) || r.target.hasAttribute(vs);\n    i = Xt(i, p, l), e = Gt(e, u, l), typeof e != \"number\" && (e = R(e, !1)[0]);\n    const b = e !== \"\" ? e * 30 : \"\", v = i !== \"\" ? i * 30 : \"\";\n    t < 0 && (t = 360 + t), t = t === 360 ? 0 : t;\n    const C = () => {\n      const I = document.querySelectorAll(\n        `[${bs}]`\n      ), O = document.querySelectorAll(\n        `[${vs}]`\n      ), x = Wm(this._hour.innerText);\n      let L, S, N;\n      return g === at ? S = 1 : g === z && (S = -1), x === 12 && g === at ? N = 1 : x === 0 && g === at ? N = 13 : x === 0 && g === z ? N = 23 : x === 13 && g === z ? N = 0 : x === 1 && g === z ? N = 12 : N = x + S, I.forEach((P) => {\n        Number(P.textContent) === N && (L = P);\n      }), O.forEach((P) => {\n        Number(P.textContent) === N && (L = P);\n      }), !L.parentElement.hasAttribute(Yt);\n    }, w = () => {\n      const I = i !== \"\" && i > 12 ? (i - 12) * 30 : \"\", O = e !== \"\" && e > 12 ? (e - 12) * 30 : \"\";\n      if (!(I && t < I || O && t > O || e && e < 12))\n        return !0;\n    };\n    if (a && r.type !== \"keydown\" && m)\n      return w();\n    if (r.type === \"keydown\")\n      return C();\n    const E = !o || o === \"PM\" && f || i !== \"\" && o === \"AM\" && _, T = !n || n === \"PM\" && f || e !== \"\" && n === \"AM\" && _, A = () => {\n      const I = v === 360 && l ? 0 : v;\n      if (i) {\n        if (o === \"PM\" && _ || E && t < I)\n          return;\n      } else\n        return !0;\n      return !0;\n    }, k = () => {\n      const I = b === 360 && l ? 0 : b;\n      if (e) {\n        if (n === \"AM\" && f || T && t > I)\n          return;\n      } else\n        return !0;\n      return !0;\n    };\n    return A() && k();\n  }\n  _handleKeyboard() {\n    c.on(this._document, _s, \"\", (t) => {\n      let e, i, n;\n      const {\n        increment: o,\n        maxTime: r,\n        minTime: a,\n        format12: l,\n        disablePast: p,\n        disableFuture: u\n      } = this._options;\n      let _ = R(a, !1)[0], f = R(r, !1)[0];\n      const g = R(a, !1)[2], m = R(r, !1)[2];\n      _ = Xt(_, p, l), f = Gt(f, u, l), typeof f != \"number\" && (f = R(f, !1)[0]);\n      const b = d.findOne(`[${X}]`) === null, v = d.findOne(`[${lt}]`) !== null, C = Number(this._hand.style.transform.replace(/[^\\d-]/g, \"\")), w = d.find(\n        `[${X}]`,\n        this._modal\n      ), E = d.find(\n        `[${K}]`,\n        this._modal\n      ), T = d.find(\n        `[${lt}]`,\n        this._modal\n      );\n      let A = this._makeHourDegrees(t.target, C, e).hour;\n      const { degrees: k, addDegrees: I } = this._makeHourDegrees(\n        t.target,\n        C,\n        e\n      );\n      let { minute: O, degrees: x } = this._makeMinutesDegrees(C, i);\n      const L = this._makeMinutesDegrees(\n        C,\n        i\n      ).addDegrees;\n      let { hour: S } = this._makeInnerHoursDegrees(\n        C,\n        n\n      );\n      if (t.keyCode === Fi) {\n        const N = d.findOne(\n          `[${Gn}]`,\n          this._modal\n        );\n        c.trigger(N, \"click\");\n      } else if (b) {\n        if (v && (t.keyCode === Ve && (this._isInner = !1, h.addStyle(this._hand, {\n          height: \"calc(40% + 1px)\"\n        }), this._hour.textContent = this._setHourOrMinute(\n          A > 12 ? 1 : A\n        ), this._toggleClassActive(this.hoursArray, this._hour, E), this._toggleClassActive(this.innerHours, this._hour, T)), t.keyCode === He && (this._isInner = !0, h.addStyle(this._hand, {\n          height: \"21.5%\"\n        }), this._hour.textContent = this._setHourOrMinute(\n          S >= 24 || S === \"00\" ? 0 : S\n        ), this._toggleClassActive(this.innerHours, this._hour, T), this._toggleClassActive(\n          this.hoursArray,\n          this._hour - 1,\n          E\n        ))), t.keyCode === at) {\n          if (!this._handlerMaxMinHoursOptions(\n            k + 30,\n            f,\n            _,\n            m,\n            g,\n            t\n          ))\n            return;\n          h.addStyle(this._hand, {\n            transform: `rotateZ(${k + I}deg)`\n          }), this._isInner ? (S += 1, S === 24 ? S = 0 : (S === 25 || S === \"001\") && (S = 13), this._hour.textContent = this._setHourOrMinute(S), this._toggleClassActive(this.innerHours, this._hour, T)) : (A += 1, this._hour.textContent = this._setHourOrMinute(\n            A > 12 ? 1 : A\n          ), this._toggleClassActive(this.hoursArray, this._hour, E));\n        }\n        if (t.keyCode === z) {\n          if (!this._handlerMaxMinHoursOptions(\n            k - 30,\n            f,\n            _,\n            m,\n            g,\n            t\n          ))\n            return;\n          h.addStyle(this._hand, {\n            transform: `rotateZ(${k - I}deg)`\n          }), this._isInner ? (S -= 1, S === 12 ? S = 0 : S === -1 && (S = 23), this._hour.textContent = this._setHourOrMinute(S), this._toggleClassActive(this.innerHours, this._hour, T)) : (A -= 1, this._hour.textContent = this._setHourOrMinute(\n            A === 0 ? 12 : A\n          ), this._toggleClassActive(this.hoursArray, this._hour, E));\n        }\n      } else\n        t.keyCode === at && (x += L, h.addStyle(this._hand, {\n          transform: `rotateZ(${x}deg)`\n        }), O += 1, o && (O += 4, O === \"0014\" && (O = 5)), this._minutes.textContent = this._setHourOrMinute(\n          O > 59 ? 0 : O\n        ), this._toggleClassActive(\n          this.minutesArray,\n          this._minutes,\n          w\n        ), this._toggleBackgroundColorCircle(\n          `[${X}]`\n        )), t.keyCode === z && (x -= L, h.addStyle(this._hand, {\n          transform: `rotateZ(${x}deg)`\n        }), o ? O -= 5 : O -= 1, O === -1 ? O = 59 : O === -5 && (O = 55), this._minutes.textContent = this._setHourOrMinute(O), this._toggleClassActive(\n          this.minutesArray,\n          this._minutes,\n          w\n        ), this._toggleBackgroundColorCircle(\n          `[${X}]`\n        ));\n    });\n  }\n  _setActiveClassToTipsOnOpen(t, ...e) {\n    if (!this._isInvalidTimeFormat)\n      if (this._options.format24) {\n        const i = d.find(\n          `[${K}]`,\n          this._modal\n        ), n = d.find(\n          `[${lt}]`,\n          this._modal\n        );\n        this._addActiveClassToTip(i, t), this._addActiveClassToTip(n, t);\n      } else {\n        [...e].filter((n) => (n === \"PM\" ? (h.addClass(this._PM, this._classes.opacity), this._PM.setAttribute(H, \"\")) : n === \"AM\" ? (h.addClass(this._AM, this._classes.opacity), this._AM.setAttribute(H, \"\")) : (h.removeClass(this._AM, this._classes.opacity), h.removeClass(this._PM, this._classes.opacity), this._AM.removeAttribute(H), this._PM.removeAttribute(H)), n));\n        const i = d.find(\n          `[${K}]`,\n          this._modal\n        );\n        this._addActiveClassToTip(i, t);\n      }\n  }\n  _setTipsAndTimesDependOnInputValue(t, e) {\n    const { inline: i, format12: n } = this._options;\n    if (this._isInvalidTimeFormat)\n      this._hour.textContent = \"12\", this._minutes.textContent = \"00\", i || h.addStyle(this._hand, {\n        transform: \"rotateZ(0deg)\"\n      }), n && (h.addClass(this._PM, this._classes.opacity), this._PM.setAttribute(H, \"\"));\n    else {\n      const o = t > 12 ? t * 30 - 360 : t * 30;\n      this._hour.textContent = t, this._minutes.textContent = e, i || (h.addStyle(this._hand, {\n        transform: `rotateZ(${o}deg)`\n      }), h.addStyle(this._circle, {\n        backgroundColor: \"#1976d2\"\n      }), (Number(t) > 12 || t === \"00\") && h.addStyle(this._hand, {\n        height: \"21.5%\"\n      }));\n    }\n  }\n  _listenToToggleKeydown() {\n    c.on(\n      this._element,\n      \"keydown\",\n      `[data-te-toggle='${this.toggleElement}']`,\n      (t) => {\n        t.keyCode === ct && (t.preventDefault(), c.trigger(this.elementToggle, \"click\"));\n      }\n    );\n  }\n  _handleOpen() {\n    const t = this._getContainer();\n    re.on(\n      this._element,\n      \"click\",\n      `[data-te-toggle='${this.toggleElement}']`,\n      (e) => {\n        if (this._options === null)\n          return;\n        const i = h.getDataAttribute(this.input, \"toggle\") !== null ? 200 : 0;\n        setTimeout(() => {\n          h.addStyle(this.elementToggle, {\n            pointerEvents: \"none\"\n          }), this.elementToggle.blur();\n          let n;\n          R(this.input)[0] === \"\" ? n = [\"12\", \"00\", \"PM\"] : n = R(this.input);\n          const { modalID: o, inline: r, format12: a } = this._options, [l, p, u] = n, _ = $(\"div\");\n          if ((Number(l) > 12 || l === \"00\") && (this._isInner = !0), this.input.blur(), e.target.blur(), _.innerHTML = Mm(this._options, this._classes), h.addClass(_, this._classes.modal), _.setAttribute(Za, \"\"), _.setAttribute(\"role\", \"dialog\"), _.setAttribute(\"tabIndex\", \"-1\"), _.setAttribute(\"id\", o), r ? (this._popper = Ce(this.input, _, {\n            placement: \"bottom-start\"\n          }), t.appendChild(_)) : (t.appendChild(_), this._scrollBar.hide()), this._getDomElements(), this._animations ? this._toggleBackdropAnimation() : h.addClass(this._wrapper, this._classes.opacity), this._setActiveClassToTipsOnOpen(l, p, u), this._appendTimes(), this._setActiveClassToTipsOnOpen(l, p, u), this._setTipsAndTimesDependOnInputValue(l, p), this.input.value === \"\") {\n            const f = d.find(\n              `[${K}]`,\n              this._modal\n            );\n            a && (h.addClass(this._PM, this._classes.opacity), this._PM.setAttribute(H, \"\")), this._hour.textContent = \"12\", this._minutes.textContent = \"00\", this._addActiveClassToTip(\n              f,\n              Number(this._hour.textContent)\n            );\n          }\n          if (this._handleSwitchTimeMode(), this._handleOkButton(), this._handleClose(), r)\n            this._handleHoverInlineBtn(), this._handleDocumentClickInline(), this._handleInlineClicks();\n          else {\n            this._handleSwitchHourMinute(), this._handleClockClick(), this._handleKeyboard();\n            const f = document.querySelector(\n              `${fs}[${H}]`\n            );\n            h.addClass(f, this._classes.opacity), h.addStyle(this._hour, {\n              pointerEvents: \"none\"\n            }), h.addStyle(this._minutes, {\n              pointerEvents: \"\"\n            });\n          }\n          this._focusTrap = new Wi(this._wrapper, {\n            event: \"keydown\",\n            condition: ({ key: f }) => f === \"Tab\"\n          }), this._focusTrap.trap();\n        }, i);\n      }\n    );\n  }\n  _handleInlineClicks() {\n    let t, e;\n    const i = (g) => {\n      let m = g;\n      return m > 59 ? m = 0 : m < 0 && (m = 59), m;\n    }, n = (g) => {\n      let m = g;\n      return this._options.format24 ? (m > 24 ? m = 1 : m < 0 && (m = 23), m > 23 && (m = 0)) : (m > 12 ? m = 1 : m < 1 && (m = 12), m > 12 && (m = 1)), m;\n    }, o = (g) => {\n      const m = n(g);\n      this._hour.textContent = this._setHourOrMinute(m);\n    }, r = (g) => {\n      const m = i(g);\n      this._minutes.textContent = this._setHourOrMinute(m);\n    }, a = () => {\n      t = n(t) + 1, o(t);\n    }, l = () => {\n      e = i(e) + 1, r(e);\n    }, p = () => {\n      t = n(t) - 1, o(t);\n    }, u = () => {\n      e = i(e) - 1, r(e);\n    }, _ = () => {\n      clearInterval(this._interval), clearTimeout(this._timeoutInterval);\n    }, f = (g) => {\n      _(), this._timeoutInterval = setTimeout(() => {\n        this._interval = setInterval(g, 100);\n      }, 500);\n    };\n    re.on(\n      this._modal,\n      \"click mousedown mouseup touchstart touchend contextmenu\",\n      `[${Zn}], [${Qn}]`,\n      (g) => {\n        t = Number(this._hour.textContent), e = Number(this._minutes.textContent);\n        const { target: m, type: b } = g, v = b === \"mousedown\" || b === \"touchstart\";\n        m.closest(`[${Zn}]`) ? m.closest(`[${Zn}]`).parentNode.hasAttribute(Xa) ? v ? f(a) : b === \"mouseup\" || b === \"touchend\" || b === \"contextmenu\" ? _() : a() : v ? f(l) : b === \"mouseup\" || b === \"touchend\" || b === \"contextmenu\" ? _() : l() : m.closest(`[${Qn}]`) && (m.closest(`[${Qn}]`).parentNode.hasAttribute(Xa) ? v ? f(p) : b === \"mouseup\" || b === \"touchend\" ? _() : p() : v ? f(u) : b === \"mouseup\" || b === \"touchend\" ? _() : u());\n      }\n    ), c.on(window, _s, (g) => {\n      const m = g.code, b = document.activeElement.hasAttribute(gs), v = document.activeElement.hasAttribute(\n        eo\n      ), C = document.activeElement === document.body;\n      switch (t = Number(this._hour.textContent), e = Number(this._minutes.textContent), m) {\n        case \"ArrowUp\":\n          g.preventDefault(), C || b ? (this._hour.focus(), a()) : v && l();\n          break;\n        case \"ArrowDown\":\n          g.preventDefault(), C || b ? (this._hour.focus(), p()) : v && u();\n          break;\n      }\n    });\n  }\n  _handleClose() {\n    c.on(\n      this._modal,\n      \"click\",\n      `[${to}], [${Gn}], [${Ua}]`,\n      ({ target: t }) => {\n        const { closeModalOnBackdropClick: e } = this._options, i = () => {\n          var n;\n          h.addStyle(this.elementToggle, {\n            pointerEvents: \"auto\"\n          }), this._animations && this._toggleBackdropAnimation(!0), this._removeModal(), (n = this._focusTrap) == null || n.disable(), this._focusTrap = null, this.elementToggle ? this.elementToggle.focus() : this.input && this.input.focus();\n        };\n        if (t.hasAttribute(Ua)) {\n          this._toggleAmPm(\"PM\"), this.input.value = \"\", this.input.removeAttribute(H);\n          let n;\n          R(this.input)[0] === \"\" ? n = [\"12\", \"00\", \"PM\"] : n = R(this.input);\n          const [o, r, a] = n;\n          this._setTipsAndTimesDependOnInputValue(\"12\", \"00\"), this._setActiveClassToTipsOnOpen(o, r, a), this._hour.click();\n        } else\n          (t.hasAttribute(Gn) || t.hasAttribute(qn) || t.hasAttribute(to) && e) && i();\n      }\n    );\n  }\n  showValueInput() {\n    return this.input.value;\n  }\n  _handleOkButton() {\n    re.on(\n      this._modal,\n      \"click\",\n      `[${qn}]`,\n      () => {\n        let { maxTime: t, minTime: e } = this._options;\n        const {\n          format12: i,\n          format24: n,\n          readOnly: o,\n          focusInputAfterApprove: r,\n          disablePast: a,\n          disableFuture: l\n        } = this._options, p = this._document.querySelector(\n          `${ms}[${H}]`\n        ), u = `${this._hour.textContent}:${this._minutes.textContent}`, _ = Number(this._hour.textContent), f = _ === 12 && i ? 0 : _, g = Number(this._minutes.textContent);\n        e = Xt(e, a, i), t = Gt(t, l, i);\n        let [m, b, v] = R(\n          t,\n          !1\n        ), [C, w, E] = R(\n          e,\n          !1\n        );\n        C = C === \"12\" && i ? \"00\" : C, m = m === \"12\" && i ? \"00\" : m;\n        const T = f < Number(C), A = f > Number(m);\n        let k = !0;\n        p && (k = v === p.textContent);\n        let I = !0;\n        p && (I = E === p.textContent);\n        const O = g > b && f === Number(m), x = g < w && f === Number(C);\n        if (this.input.setAttribute(H, \"\"), h.addStyle(this.elementToggle, {\n          pointerEvents: \"auto\"\n        }), t !== \"\") {\n          if (k && (A || O))\n            return;\n          if (v === \"AM\" && p.textContent === \"PM\")\n            return;\n        }\n        e !== \"\" && (I && (T || x) || E === \"PM\" && p.textContent === \"AM\") || Bm(\n          this._options,\n          this.input,\n          this._hour.textContent\n        ) !== void 0 && (this._isInvalidTimeFormat && this.input.removeAttribute(Jn), !o && r && this.input.focus(), h.addStyle(this.elementToggle, {\n          pointerEvents: \"auto\"\n        }), n ? this.input.value = u : p === null ? this.input.value = `${u} PM` : this.input.value = `${u} ${p.textContent}`, this._animations && this._toggleBackdropAnimation(!0), this._removeModal(), c.trigger(this.input, \"input.te.timepicker\"), c.trigger(this.input, \"input\"));\n      }\n    );\n  }\n  _handleHoverInlineBtn() {\n    re.on(\n      this._modal,\n      \"mouseover mouseleave\",\n      `[${Gm}]`,\n      ({ type: t, target: e }) => {\n        const i = d.find(\n          `[${Um}]`,\n          this._modal\n        ), n = d.find(\n          `[${Xm}]`,\n          this._modal\n        ), o = (l, p) => l.forEach((u) => {\n          if (p) {\n            h.addClass(u, this._classes.opacity), u.setAttribute(H, \"\");\n            return;\n          }\n          h.removeClass(u, this._classes.opacity), u.removeAttribute(H);\n        }), a = e.hasAttribute(gs) ? i : n;\n        o(a, t === \"mouseover\");\n      }\n    );\n  }\n  _handleDocumentClickInline() {\n    c.on(document, Ba, ({ target: t }) => {\n      if (this._modal && !this._modal.contains(t) && !t.hasAttribute(zm)) {\n        if (clearInterval(this._interval), h.addStyle(this.elementToggle, {\n          pointerEvents: \"auto\"\n        }), this._removeModal(), !this._animations)\n          return;\n        this._toggleBackdropAnimation(!0);\n      }\n    });\n  }\n  _handleSwitchHourMinute() {\n    Pm(\n      \"click\",\n      fs,\n      this._classes\n    ), c.on(\n      this._modal,\n      \"click\",\n      fs,\n      () => {\n        const { format24: t } = this._options, e = d.find(\n          fs,\n          this._modal\n        ), i = d.find(\n          `[${X}]`,\n          this._modal\n        ), n = d.find(\n          `[${K}]`,\n          this._modal\n        ), o = d.find(\n          `[${lt}]`,\n          this._modal\n        ), r = Number(this._hour.textContent), a = Number(this._minutes.textContent), l = (p, u) => {\n          n.forEach((f) => f.remove()), i.forEach((f) => f.remove()), h.addClass(this._hand, this._classes.transform), setTimeout(() => {\n            h.removeClass(this._hand, this._classes.transform);\n          }, 401), this._getAppendClock(p, `[${pe}]`, u);\n          const _ = () => {\n            const f = d.find(\n              `[${K}]`,\n              this._modal\n            ), g = d.find(\n              `[${X}]`,\n              this._modal\n            );\n            this._addActiveClassToTip(f, r), this._addActiveClassToTip(g, a);\n          };\n          if (!t)\n            setTimeout(() => {\n              _();\n            }, 401);\n          else {\n            const f = d.find(\n              `[${lt}]`,\n              this._modal\n            );\n            setTimeout(() => {\n              this._addActiveClassToTip(f, r), _();\n            }, 401);\n          }\n        };\n        e.forEach((p) => {\n          p.hasAttribute(H) && (p.hasAttribute(eo) ? (h.addClass(this._hand, this._classes.transform), h.addStyle(this._hand, {\n            transform: `rotateZ(${this._minutes.textContent * 6}deg)`,\n            height: \"calc(40% + 1px)\"\n          }), t && o.length > 0 && o.forEach((u) => u.remove()), l(\n            this.minutesArray,\n            X\n          ), this._hour.style.pointerEvents = \"\", this._minutes.style.pointerEvents = \"none\") : p.hasAttribute(gs) && (h.addStyle(this._hand, {\n            transform: `rotateZ(${this._hour.textContent * 30}deg)`\n          }), Number(this._hour.textContent) > 12 ? (h.addStyle(this._hand, {\n            transform: `rotateZ(${this._hour.textContent * 30 - 360}deg)`,\n            height: \"21.5%\"\n          }), Number(this._hour.textContent) > 12 && h.addStyle(this._hand, {\n            height: \"21.5%\"\n          })) : h.addStyle(this._hand, {\n            height: \"calc(40% + 1px)\"\n          }), t && this._getAppendClock(\n            this.innerHours,\n            `[${di}]`,\n            lt\n          ), o.length > 0 && o.forEach((u) => u.remove()), l(\n            this.hoursArray,\n            K\n          ), h.addStyle(this._hour, {\n            pointerEvents: \"none\"\n          }), h.addStyle(this._minutes, {\n            pointerEvents: \"\"\n          })));\n        });\n      }\n    );\n  }\n  _handleDisablingTipsMaxTime(t, e, i, n) {\n    if (!this._options.maxTime && !this._options.disableFuture)\n      return;\n    const o = d.find(\n      `[${K}]`\n    ), r = d.find(\n      `[${lt}]`\n    ), a = d.find(\n      `[${X}]`\n    );\n    if (!e || e === t) {\n      Ma(\n        r,\n        n,\n        this._classes,\n        this._options.format12\n      ), Ma(\n        o,\n        n,\n        this._classes,\n        this._options.format12\n      ), Hm(\n        a,\n        i,\n        n,\n        this._hour.textContent,\n        this._classes,\n        this._options.format12\n      );\n      return;\n    }\n    e === \"AM\" && t === \"PM\" && (o.forEach((l) => {\n      h.addClass(l, this._classes.tipsDisabled), l.setAttribute(Yt, \"\");\n    }), a.forEach((l) => {\n      h.addClass(l, this._classes.tipsDisabled), l.setAttribute(Yt, \"\");\n    }));\n  }\n  _handleDisablingTipsMinTime(t, e, i, n) {\n    if (!this._options.minTime && !this._options.disablePast)\n      return;\n    const o = d.find(\n      `[${K}]`\n    ), r = d.find(\n      `[${lt}]`\n    ), a = d.find(\n      `[${X}]`\n    );\n    !e || e === t ? (Ra(\n      o,\n      n,\n      this._classes,\n      this._options.format12\n    ), Ra(\n      r,\n      n,\n      this._classes,\n      this._options.format12\n    ), Vm(\n      a,\n      i,\n      n,\n      this._hour.textContent,\n      this._classes,\n      this._options.format12\n    )) : e === \"PM\" && t === \"AM\" && (o.forEach((l) => {\n      h.addClass(l, this._classes.tipsDisabled), l.setAttribute(Yt, \"\");\n    }), a.forEach((l) => {\n      h.addClass(l, this._classes.tipsDisabled), l.setAttribute(Yt, \"\");\n    }));\n  }\n  _handleSwitchTimeMode() {\n    c.on(\n      document,\n      \"click\",\n      ms,\n      ({ target: t }) => {\n        let { maxTime: e, minTime: i } = this._options;\n        const { disablePast: n, disableFuture: o, format12: r } = this._options;\n        i = Xt(i, n, r), e = Gt(e, o, r);\n        const [a, l, p] = R(\n          e,\n          !1\n        ), [u, _, f] = R(\n          i,\n          !1\n        ), g = d.find(\n          `[${K}]`\n        ), m = d.find(\n          `[${X}]`\n        );\n        (() => {\n          g.forEach((v) => {\n            h.removeClass(v, this._classes.tipsDisabled), v.removeAttribute(Yt);\n          }), m.forEach((v) => {\n            h.removeClass(v, this._classes.tipsDisabled), v.removeAttribute(Yt);\n          });\n        })(), this._handleDisablingTipsMinTime(\n          t.textContent,\n          f,\n          _,\n          u\n        ), this._handleDisablingTipsMaxTime(\n          t.textContent,\n          p,\n          l,\n          a\n        ), this._toggleAmPm(t.textContent), t.hasAttribute(H) || (d.find(\n          ms\n        ).forEach((C) => {\n          C.hasAttribute(H) && (h.removeClass(C, this._classes.opacity), C.removeAttribute(H));\n        }), h.addClass(t, this._classes.opacity), t.setAttribute(H, \"\"));\n      }\n    );\n  }\n  _handleClockClick() {\n    let { maxTime: t, minTime: e } = this._options;\n    const { disablePast: i, disableFuture: n, format12: o } = this._options;\n    e = Xt(e, i, o), t = Gt(t, n, o);\n    const r = R(t, !1)[2], a = R(e, !1)[2], l = R(t, !1)[0], p = R(e, !1)[0], u = d.findOne(\n      `[${Ga}]`\n    );\n    re.on(\n      document,\n      `${Ha} ${Va} ${Wa} ${Fa} ${Ya} ${za} ${ja} ${Ka}`,\n      \"\",\n      (_) => {\n        ps() || _.preventDefault();\n        const { type: f, target: g } = _, { closeModalOnMinutesClick: m, switchHoursToMinutesOnClick: b } = this._options, v = d.findOne(\n          `[${X}]`,\n          this._modal\n        ) !== null, C = d.findOne(\n          `[${K}]`,\n          this._modal\n        ) !== null, w = d.findOne(\n          `[${lt}]`,\n          this._modal\n        ) !== null, E = d.find(\n          `[${X}]`,\n          this._modal\n        ), T = Na(_, u), A = u.offsetWidth / 2;\n        let k = Math.atan2(T.y - A, T.x - A);\n        if (ps()) {\n          const L = Na(_, u, !0);\n          k = Math.atan2(L.y - A, L.x - A);\n        }\n        let I = null, O = null, x = null;\n        if (f === \"mousedown\" || f === \"mousemove\" || f === \"touchmove\" || f === \"touchstart\")\n          (f === \"mousedown\" || f === \"touchstart\" || f === \"touchmove\") && (this._hasTargetInnerClass(g) || g.hasAttribute(Ga) || g.hasAttribute(pe) || g.hasAttribute(X) || g.hasAttribute(K) || g.hasAttribute(so) || g.hasAttribute(io) || g.hasAttribute(qa) || g.hasAttribute(bs)) && (this._isMouseMove = !0, ps() && _.touches && (I = _.touches[0].clientX, O = _.touches[0].clientY, x = document.elementFromPoint(I, O)));\n        else if (f === \"mouseup\" || f === \"touchend\") {\n          if (this._isMouseMove = !1, this._hasTargetInnerClass(g) || g.hasAttribute(pe) || g.hasAttribute(K) || g.hasAttribute(so) || g.hasAttribute(io) || g.hasAttribute(qa) || g.hasAttribute(bs)) {\n            if ((C || w) && b) {\n              const L = Number(this._hour.textContent) > l || Number(this._hour.textContent) < p;\n              if (this._options.format24 && l !== \"\" && p !== \"\" && L)\n                return;\n              if (this._options.format24 && p !== \"\" && Number(this._hour.textContent) < p)\n                return;\n            }\n            c.trigger(this._minutes, \"click\");\n          }\n          if (v && m) {\n            const L = d.findOne(\n              `[${qn}]`,\n              this._modal\n            );\n            c.trigger(L, \"click\");\n          }\n        }\n        if (v) {\n          let L;\n          const S = Math.trunc(k * 180 / Math.PI) + 90, { degrees: N, minute: P } = this._makeMinutesDegrees(S, L);\n          if (this._handlerMaxMinMinutesOptions(N, P) === void 0)\n            return;\n          const { degrees: tt, minute: et } = this._handlerMaxMinMinutesOptions(N, P);\n          if (this._isMouseMove) {\n            if (h.addStyle(this._hand, {\n              transform: `rotateZ(${tt}deg)`\n            }), et === void 0)\n              return;\n            const U = () => et >= 10 || et === \"00\" ? et : `0${et}`;\n            this._minutes.textContent = U(), this._toggleClassActive(\n              this.minutesArray,\n              this._minutes,\n              E\n            ), this._toggleBackgroundColorCircle(\n              `[${X}]`\n            ), this._objWithDataOnChange.degreesMinutes = tt, this._objWithDataOnChange.minutes = et;\n          }\n        }\n        if (C || w) {\n          let L, S = Math.trunc(k * 180 / Math.PI) + 90;\n          if (S = Math.round(S / 30) * 30, h.addStyle(this._circle, {\n            backgroundColor: \"#1976d2\"\n          }), this._makeHourDegrees(g, S, L) === void 0)\n            return;\n          const N = () => {\n            if (ps() && S && x) {\n              const { degrees: P, hour: tt } = this._makeHourDegrees(x, S, L);\n              return this._handleMoveHand(\n                x,\n                tt,\n                P\n              );\n            } else {\n              const { degrees: P, hour: tt } = this._makeHourDegrees(g, S, L);\n              return this._handleMoveHand(g, tt, P);\n            }\n          };\n          this._objWithDataOnChange.degreesHours = S, this._handlerMaxMinHoursOptions(\n            S,\n            l,\n            p,\n            r,\n            a,\n            _\n          ) && N();\n        }\n        _.stopPropagation();\n      }\n    );\n  }\n  _hasTargetInnerClass(t) {\n    return t.hasAttribute(di) || t.hasAttribute(lt) || t.hasAttribute(vs);\n  }\n  _handleMoveHand(t, e, i) {\n    const n = d.find(\n      `[${K}]`,\n      this._modal\n    ), o = d.find(\n      `[${lt}]`,\n      this._modal\n    );\n    this._isMouseMove && (this._hasTargetInnerClass(t) ? h.addStyle(this._hand, {\n      height: \"21.5%\"\n    }) : h.addStyle(this._hand, {\n      height: \"calc(40% + 1px)\"\n    }), h.addStyle(this._hand, {\n      transform: `rotateZ(${i}deg)`\n    }), this._hour.textContent = e >= 10 || e === \"00\" ? e : `0${e}`, this._toggleClassActive(this.hoursArray, this._hour, n), this._toggleClassActive(this.innerHours, this._hour, o), this._objWithDataOnChange.hour = e >= 10 || e === \"00\" ? e : `0${e}`);\n  }\n  _handlerMaxMinMinutesOptions(t, e) {\n    let { maxTime: i, minTime: n } = this._options;\n    const { format12: o, increment: r, disablePast: a, disableFuture: l } = this._options;\n    n = Xt(n, a, o), i = Gt(i, l, o);\n    const p = R(i, !1)[1], u = R(n, !1)[1], _ = R(i, !1)[0], f = R(n, !1)[0], g = f === \"12\" && o ? \"0\" : f, m = _ === \"12\" && o ? \"0\" : _, b = R(i, !1)[2], v = R(n, !1)[2], C = p !== \"\" ? p * 6 : \"\", w = u !== \"\" ? u * 6 : \"\", E = Number(this._hour.textContent), T = E === 12 && o ? 0 : E;\n    if (!b && !v) {\n      if (i !== \"\" && n !== \"\") {\n        if (Number(m) === T && t > C || Number(g) === T && t < w)\n          return t;\n      } else if (n !== \"\" && T <= Number(g)) {\n        if (t <= w - 6)\n          return t;\n      } else if (i !== \"\" && T >= Number(m) && t >= C + 6)\n        return t;\n    } else {\n      if (n !== \"\") {\n        if (v === \"PM\" && this._isAmEnabled)\n          return;\n        if (v === \"PM\" && this._isPmEnabled) {\n          if (T < Number(g))\n            return;\n          if (T <= Number(g) && t <= w - 6)\n            return t;\n        } else if (v === \"AM\" && this._isAmEnabled) {\n          if (T < Number(g))\n            return;\n          if (T <= Number(g) && t <= w - 6)\n            return t;\n        }\n      }\n      if (i !== \"\") {\n        if (b === \"AM\" && this._isPmEnabled)\n          return;\n        if (b === \"PM\" && this._isPmEnabled) {\n          if (T >= Number(m) && t >= C + 6)\n            return t;\n        } else if (b === \"AM\" && this._isAmEnabled && T >= Number(m) && t >= C + 6)\n          return t;\n      }\n    }\n    return r && (t = Math.round(t / 30) * 30), t < 0 ? t = 360 + t : t >= 360 && (t = 0), {\n      degrees: t,\n      minute: e\n    };\n  }\n  _removeModal() {\n    this._animations ? setTimeout(() => {\n      this._removeModalElements(), this._scrollBar.reset();\n    }, 300) : (this._removeModalElements(), this._scrollBar.reset()), re.off(\n      this._document,\n      `${Ba} ${_s} ${Ha} ${Va} ${Wa} ${Fa} ${Ya} ${za} ${ja} ${Ka}`\n    ), c.off(window, _s);\n  }\n  _removeModalElements() {\n    this._modal && this._modal.remove();\n  }\n  _toggleBackdropAnimation(t = !1) {\n    t ? this._wrapper.classList.add(\"animate-[fade-out_350ms_ease-in-out]\") : (this._wrapper.classList.add(\"animate-[fade-in_350ms_ease-in-out]\"), this._options.inline || h.addClass(this._clock, this._classes.clockAnimation)), setTimeout(() => {\n      this._wrapper.classList.remove(\n        \"animate-[fade-out_350ms_ease-in-out]\",\n        \"animate-[fade-in_350ms_ease-in-out]\"\n      );\n    }, 351);\n  }\n  _addActiveClassToTip(t, e) {\n    t.forEach((i) => {\n      Number(i.textContent) === Number(e) && (h.addClass(i, this._classes.tipsActive), i.setAttribute(H, \"\"));\n    });\n  }\n  _setHourOrMinute(t) {\n    return t < 10 ? `0${t}` : t;\n  }\n  _appendTimes() {\n    const { format24: t } = this._options;\n    if (t) {\n      this._getAppendClock(\n        this.hoursArray,\n        `[${pe}]`,\n        K\n      ), this._getAppendClock(\n        this.innerHours,\n        `[${di}]`,\n        lt\n      );\n      return;\n    }\n    this._getAppendClock(\n      this.hoursArray,\n      `[${pe}]`,\n      K\n    );\n  }\n  _getConfig(t) {\n    const e = h.getDataAttributes(this._element);\n    return t = {\n      ...tg,\n      ...e,\n      ...t\n    }, D($i, t, eg), t;\n  }\n  _getClasses(t) {\n    const e = h.getDataClassAttributes(this._element);\n    return t = {\n      ...ig,\n      ...e,\n      ...t\n    }, D($i, t, sg), t;\n  }\n  _getContainer() {\n    return d.findOne(this._options.container);\n  }\n  _getValidate(t) {\n    const { format24: e, format12: i, appendValidationInfo: n } = this._options;\n    re.on(this.input, t, ({ target: o }) => {\n      if (this._options === null || this.input.value === \"\")\n        return;\n      const r = /^(0?[1-9]|1[012])(:[0-5]\\d) [APap][mM]$/, a = /^([01]\\d|2[0-3])(:[0-5]\\d)$/, l = r.test(o.value);\n      if (a.test(o.value) !== !0 && e || l !== !0 && i) {\n        n && this.input.setAttribute(Jn, \"\"), h.addStyle(o, { marginBottom: 0 }), this._isInvalidTimeFormat = !0;\n        return;\n      }\n      this.input.removeAttribute(Jn), this._isInvalidTimeFormat = !1;\n      const u = d.findOne(\n        `[${Zm}]`\n      );\n      u !== null && u.remove();\n    });\n  }\n  // Static\n  static getInstance(t) {\n    return y.getData(t, Us);\n  }\n  static getOrCreateInstance(t, e = {}) {\n    return this.getInstance(t) || new this(t, typeof e == \"object\" ? e : null);\n  }\n}\nconst og = {\n  threshold: 10,\n  direction: \"all\"\n};\nlet rg = class {\n  constructor(t, e) {\n    this._element = t, this._startPosition = null, this._options = {\n      ...og,\n      ...e\n    };\n  }\n  handleTouchStart(t) {\n    this._startPosition = this._getCoordinates(t);\n  }\n  handleTouchMove(t) {\n    if (!this._startPosition)\n      return;\n    const e = this._getCoordinates(t), i = {\n      x: e.x - this._startPosition.x,\n      y: e.y - this._startPosition.y\n    }, n = this._getDirection(i);\n    if (this._options.direction === \"all\") {\n      if (n.y.value < this._options.threshold && n.x.value < this._options.threshold)\n        return;\n      const r = n.y.value > n.x.value ? n.y.direction : n.x.direction;\n      c.trigger(this._element, `swipe${r}`), c.trigger(this._element, \"swipe\", { direction: r }), this._startPosition = null;\n      return;\n    }\n    const o = this._options.direction === \"left\" || this._options === \"right\" ? \"x\" : \"y\";\n    n[o].direction === this._options.direction && n[o].value > this._options.threshold && (c.trigger(this._element, `swipe${n[o].direction}`), this._startPosition = null);\n  }\n  handleTouchEnd() {\n    this._startPosition = null;\n  }\n  _getCoordinates(t) {\n    const [e] = t.touches;\n    return {\n      x: e.clientX,\n      y: e.clientY\n    };\n  }\n  _getDirection(t) {\n    return {\n      x: {\n        direction: t.x < 0 ? \"left\" : \"right\",\n        value: Math.abs(t.x)\n      },\n      y: {\n        direction: t.y < 0 ? \"up\" : \"down\",\n        value: Math.abs(t.y)\n      }\n    };\n  }\n}, ag = class {\n  constructor(t, e = \"swipe\", i = {}) {\n    this._element = t, this._event = e, this.swipe = new rg(t, i), this._touchStartHandler = this._handleTouchStart.bind(this), this._touchMoveHandler = this._handleTouchMove.bind(this), this._touchEndHandler = this._handleTouchEnd.bind(this);\n  }\n  dispose() {\n    this._element.removeEventListener(\"touchstart\", this._touchStartHandler), this._element.removeEventListener(\"touchmove\", this._touchMoveHandler), window.removeEventListener(\"touchend\", this._touchEndHandler);\n  }\n  init() {\n    this._element.addEventListener(\n      \"touchstart\",\n      (t) => this._handleTouchStart(t)\n    ), this._element.addEventListener(\n      \"touchmove\",\n      (t) => this._handleTouchMove(t)\n    ), window.addEventListener(\"touchend\", (t) => this._handleTouchEnd(t));\n  }\n  _handleTouchStart(t) {\n    this[this._event].handleTouchStart(t);\n  }\n  _handleTouchMove(t) {\n    this[this._event].handleTouchMove(t);\n  }\n  _handleTouchEnd(t) {\n    this[this._event].handleTouchEnd(t);\n  }\n};\nconst Qa = \"sidenav\", Ts = \"te.sidenav\", lg = \"data-te-sidenav-rotate-icon-ref\", no = \"[data-te-sidenav-toggle-ref]\", cg = \"[data-te-collapse-init]\", hg = '[data-te-sidenav-slim=\"true\"]', dg = '[data-te-sidenav-slim=\"false\"]', ug = \"[data-te-sidenav-menu-ref]\", Oe = \"[data-te-sidenav-collapse-ref]\", ui = \"[data-te-sidenav-link-ref]\", pg = F() ? 100 : -100, _g = F() ? -100 : 100, fg = {\n  sidenavAccordion: \"(boolean)\",\n  sidenavBackdrop: \"(boolean)\",\n  sidenavBackdropClass: \"(null|string)\",\n  sidenavCloseOnEsc: \"(boolean)\",\n  sidenavColor: \"(string)\",\n  sidenavContent: \"(null|string)\",\n  sidenavExpandable: \"(boolean)\",\n  sidenavExpandOnHover: \"(boolean)\",\n  sidenavFocusTrap: \"(boolean)\",\n  sidenavHidden: \"(boolean)\",\n  sidenavMode: \"(string)\",\n  sidenavModeBreakpointOver: \"(null|string|number)\",\n  sidenavModeBreakpointSide: \"(null|string|number)\",\n  sidenavModeBreakpointPush: \"(null|string|number)\",\n  sidenavBreakpointSm: \"(number)\",\n  sidenavBreakpointMd: \"(number)\",\n  sidenavBreakpointLg: \"(number)\",\n  sidenavBreakpointXl: \"(number)\",\n  sidenavBreakpoint2xl: \"(number)\",\n  sidenavScrollContainer: \"(null|string)\",\n  sidenavSlim: \"(boolean)\",\n  sidenavSlimCollapsed: \"(boolean)\",\n  sidenavSlimWidth: \"(number)\",\n  sidenavPosition: \"(string)\",\n  sidenavRight: \"(boolean)\",\n  sidenavTransitionDuration: \"(number)\",\n  sidenavWidth: \"(number)\"\n}, mg = {\n  sidenavAccordion: !1,\n  sidenavBackdrop: !0,\n  sidenavBackdropClass: null,\n  sidenavCloseOnEsc: !0,\n  sidenavColor: \"primary\",\n  sidenavContent: null,\n  sidenavExpandable: !0,\n  sidenavExpandOnHover: !1,\n  sidenavFocusTrap: !0,\n  sidenavHidden: !0,\n  sidenavMode: \"over\",\n  sidenavModeBreakpointOver: null,\n  sidenavModeBreakpointSide: null,\n  sidenavModeBreakpointPush: null,\n  sidenavBreakpointSm: 640,\n  sidenavBreakpointMd: 768,\n  sidenavBreakpointLg: 1024,\n  sidenavBreakpointXl: 1280,\n  sidenavBreakpoint2xl: 1536,\n  sidenavScrollContainer: null,\n  sidenavSlim: !1,\n  sidenavSlimCollapsed: !1,\n  sidenavSlimWidth: 77,\n  sidenavPosition: \"fixed\",\n  sidenavRight: !1,\n  sidenavTransitionDuration: 300,\n  sidenavWidth: 240\n};\nclass gi {\n  constructor(t, e = {}) {\n    yt(this, \"_addBackdropOnInit\", () => {\n      this._options.sidenavHidden || (this._backdrop.show(), c.off(this._element, \"transitionend\", this._addBackdropOnInit));\n    });\n    this._element = t, this._options = e, this._ID = rt(\"\"), this._content = null, this._initialContentStyle = null, this._slimCollapsed = !1, this._activeNode = null, this._tempSlim = !1, this._backdrop = this._initializeBackDrop(), this._focusTrap = null, this._perfectScrollbar = null, this._touch = null, this._setModeFromBreakpoints(), this.escHandler = (i) => {\n      i.keyCode === Fi && this.toggler && Nt(this.toggler) && (this._update(!1), c.off(window, \"keydown\", this.escHandler));\n    }, this.hashHandler = () => {\n      this._setActiveElements();\n    }, t && (y.setData(t, Ts, this), this._setup()), this.options.sidenavBackdrop && !this.options.sidenavHidden && this.options.sidenavMode === \"over\" && c.on(this._element, \"transitionend\", this._addBackdropOnInit), this._didInit = !1, this._init();\n  }\n  // Getters\n  static get NAME() {\n    return Qa;\n  }\n  get container() {\n    if (this.options.sidenavPosition === \"fixed\")\n      return d.findOne(\"body\");\n    const t = (e) => !e.parentNode || e.parentNode === document ? e : e.parentNode.style.position === \"relative\" || e.parentNode.classList.contains(\"relative\") ? e.parentNode : t(e.parentNode);\n    return t(this._element);\n  }\n  get isVisible() {\n    let t = 0, e = window.innerWidth;\n    if (this.options.sidenavPosition !== \"fixed\") {\n      const n = this.container.getBoundingClientRect();\n      t = n.x, e = n.x + n.width;\n    }\n    const { x: i } = this._element.getBoundingClientRect();\n    return this.options.sidenavRight ? Math.abs(i - e) > 10 : Math.abs(i - t) < 10;\n  }\n  get links() {\n    return d.find(ui, this._element);\n  }\n  get navigation() {\n    return d.find(ug, this._element);\n  }\n  get options() {\n    const t = {\n      ...mg,\n      ...h.getDataAttributes(this._element),\n      ...this._options\n    };\n    return D(Qa, t, fg), t;\n  }\n  get sidenavStyle() {\n    return {\n      width: `${this.width}px`,\n      height: this.options.sidenavPosition === \"fixed\" ? \"100vh\" : \"100%\",\n      position: this.options.sidenavPosition,\n      transition: `all ${this.transitionDuration} linear`\n    };\n  }\n  get toggler() {\n    return d.find(no).find(\n      (e) => {\n        const i = h.getDataAttribute(e, \"target\");\n        return d.findOne(i) === this._element;\n      }\n    );\n  }\n  get transitionDuration() {\n    return `${this.options.sidenavTransitionDuration / 1e3}s`;\n  }\n  get translation() {\n    return this.options.sidenavRight ? _g : pg;\n  }\n  get width() {\n    return this._slimCollapsed ? this.options.sidenavSlimWidth : this.options.sidenavWidth;\n  }\n  get isBackdropVisible() {\n    return !!this._backdrop._element;\n  }\n  // Public\n  changeMode(t) {\n    this._setMode(t);\n  }\n  dispose() {\n    c.off(window, \"keydown\", this.escHandler), this.options.sidenavBackdrop && this._backdrop.dispose(), c.off(window, \"hashchange\", this.hashHandler), this._touch.dispose(), y.removeData(this._element, Ts), this._element = null;\n  }\n  hide() {\n    this._emitEvents(!1), this._update(!1), this._options.sidenavBackdrop && this.isBackdropVisible && this._backdrop.hide();\n  }\n  show() {\n    this._emitEvents(!0), this._update(!0), this._options.sidenavBackdrop && this._options.sidenavMode === \"over\" && this._backdrop.show();\n  }\n  toggle() {\n    this._emitEvents(!this.isVisible), this._update(!this.isVisible);\n  }\n  toggleSlim() {\n    this._setSlim(!this._slimCollapsed);\n  }\n  update(t) {\n    this._options = t, this._setup();\n  }\n  getBreakpoint(t) {\n    return this._transformBreakpointValuesToObject()[t];\n  }\n  // Private\n  _init() {\n    this._didInit || (c.on(\n      document,\n      \"click\",\n      no,\n      gi.toggleSidenav()\n    ), this._didInit = !0);\n  }\n  _transformBreakpointValuesToObject() {\n    return {\n      sm: this.options.sidenavBreakpointSm,\n      md: this.options.sidenavBreakpointMd,\n      lg: this.options.sidenavBreakpointLg,\n      xl: this.options.sidenavBreakpointXl,\n      \"2xl\": this.options.sidenavBreakpoint2xl\n    };\n  }\n  _setModeFromBreakpoints() {\n    const t = window.innerWidth, e = this._transformBreakpointValuesToObject();\n    if (t === void 0 || !e)\n      return;\n    const i = typeof this.options.sidenavModeBreakpointOver == \"number\" ? t - this.options.sidenavModeBreakpointOver : t - e[this.options.sidenavModeBreakpointOver], n = typeof this.options.sidenavModeBreakpointSide == \"number\" ? t - this.options.sidenavModeBreakpointSide : t - e[this.options.sidenavModeBreakpointSide], o = typeof this.options.sidenavModeBreakpointPush == \"number\" ? t - this.options.sidenavModeBreakpointPush : t - e[this.options.sidenavModeBreakpointPush], r = (l, p) => l - p < 0 ? -1 : p - l < 0 ? 1 : 0, a = [i, n, o].filter((l) => l != null && l >= 0).sort(r)[0];\n    i > 0 && i === a ? (this._options.sidenavMode = \"over\", this._options.sidenavHidden = !0) : n > 0 && n === a ? this._options.sidenavMode = \"side\" : o > 0 && o === a && (this._options.sidenavMode = \"push\");\n  }\n  _collapseItems() {\n    this.navigation.forEach((t) => {\n      d.find(Oe, t).forEach((i) => {\n        Zt.getInstance(i).hide();\n      });\n    });\n  }\n  _getOffsetValue(t, { index: e, property: i, offsets: n }) {\n    const o = this._getPxValue(\n      this._initialContentStyle[e][n[i].property]\n    ), r = t ? n[i].value : 0;\n    return o + r;\n  }\n  _getProperty(...t) {\n    return t.map((e, i) => i === 0 ? e : e[0].toUpperCase().concat(e.slice(1))).join(\"\");\n  }\n  _getPxValue(t) {\n    return t ? parseFloat(t) : 0;\n  }\n  _handleSwipe(t, e) {\n    e && this._slimCollapsed && this.options.sidenavSlim && this.options.sidenavExpandable ? this.toggleSlim() : e || (this._slimCollapsed || !this.options.sidenavSlim || !this.options.sidenavExpandable ? this.toggler && Nt(this.toggler) && this.toggle() : this.toggleSlim());\n  }\n  _isActive(t, e) {\n    return e ? e === t : t.attributes.href ? new URL(t, window.location.href).href === window.location.href : !1;\n  }\n  _isAllToBeCollapsed() {\n    return d.find(\n      cg,\n      this._element\n    ).filter(\n      (i) => i.getAttribute(\"aria-expanded\") === \"true\"\n    ).length === 0;\n  }\n  _isAllCollapsed() {\n    return d.find(Oe, this._element).filter(\n      (t) => Nt(t)\n    ).length === 0;\n  }\n  _initializeBackDrop() {\n    if (!this.options.sidenavBackdrop)\n      return;\n    const t = this.options.sidenavBackdropClass ? this.options.sidenavBackdropClass.split(\" \") : this.options.sidenavPosition ? [\n      \"opacity-50\",\n      \"transition-all\",\n      \"duration-300\",\n      \"ease-in-out\",\n      this.options.sidenavPosition,\n      \"top-0\",\n      \"left-0\",\n      \"z-50\",\n      \"bg-black/10\",\n      \"dark:bg-black-60\",\n      \"w-full\",\n      \"h-full\",\n      this._element.id\n    ] : null;\n    return new hr({\n      isVisible: this.options.sidenavBackdrop,\n      isAnimated: !0,\n      rootElement: this._element.parentNode,\n      backdropClasses: t,\n      clickCallback: () => this.hide()\n    });\n  }\n  _updateBackdrop(t) {\n    if (this.options.sidenavMode === \"over\") {\n      t ? this._backdrop.show() : this.isBackdropVisible && this._backdrop.hide();\n      return;\n    }\n    this.isBackdropVisible && this._backdrop.hide();\n  }\n  _setup() {\n    this._setupTouch(), this.options.sidenavFocusTrap && this._setupFocusTrap(), this._setupCollapse(), this.options.sidenavSlim && this._setupSlim(), this._setupInitialStyling(), this._setupScrolling(), this.options.sidenavContent && this._setupContent(), this._setupActiveState(), this._setupRippleEffect(), this.options.sidenavHidden || this._updateOffsets(!0, !0), this.options.sidenavMode === \"over\" && this._setTabindex(!0);\n  }\n  _setupActiveState() {\n    this._setActiveElements(), this.links.forEach((t) => {\n      c.on(t, \"click\", () => this._setActiveElements(t)), c.on(t, \"keydown\", (e) => {\n        e.keyCode === ct && this._setActiveElements(t);\n      });\n    }), c.on(window, \"hashchange\", this.hashHandler);\n  }\n  _setupCollapse() {\n    this.navigation.forEach((t, e) => {\n      d.find(Oe, t).forEach(\n        (n, o) => this._setupCollapseList({ list: n, index: o, menu: t, menuIndex: e })\n      );\n    });\n  }\n  _generateCollpaseID(t, e) {\n    return `sidenav-collapse-${this._ID}-${e}-${t}`;\n  }\n  _setupCollapseList({ list: t, index: e, menu: i, menuIndex: n }) {\n    const o = this._generateCollpaseID(e, n);\n    t.setAttribute(\"id\", o), t.setAttribute(\"data-te-collapse-item\", \"\");\n    const [r] = d.prev(t, ui);\n    h.setDataAttribute(r, \"collapse-init\", \"\"), r.setAttribute(\"href\", `#${o}`), r.setAttribute(\"role\", \"button\");\n    const a = Zt.getInstance(t) || new Zt(t, {\n      toggle: !1,\n      parent: this.options.sidenavAccordion ? i : t\n    });\n    (t.dataset.teSidenavStateShow === \"\" || t.dataset.teCollapseShow === \"\") && this._rotateArrow(r, !1), c.on(r, \"click\", (l) => {\n      this._toggleCategory(l, a, t), this._tempSlim && this._isAllToBeCollapsed() && (this._setSlim(!0), this._tempSlim = !1), this.options.sidenavMode === \"over\" && this._focusTrap && this._focusTrap.update();\n    }), c.on(\n      t,\n      \"show.te.collapse\",\n      () => this._rotateArrow(r, !1)\n    ), c.on(\n      t,\n      \"hide.te.collapse\",\n      () => this._rotateArrow(r, !0)\n    ), c.on(t, \"shown.te.collapse\", () => {\n      this.options.sidenavMode === \"over\" && this._focusTrap && this._focusTrap.update();\n    }), c.on(t, \"hidden.te.collapse\", () => {\n      this._tempSlim && this._isAllCollapsed() && (this._setSlim(!0), this._tempSlim = !1), this.options.sidenavMode === \"over\" && this._focusTrap && this._focusTrap.update();\n    });\n  }\n  _setupContent() {\n    this._content = d.find(this.options.sidenavContent), this._content.forEach((t) => {\n      const e = [\n        \"!p\",\n        \"!m\",\n        \"!px\",\n        \"!pl\",\n        \"!pr\",\n        \"!mx\",\n        \"!ml\",\n        \"!mr\",\n        \"!-p\",\n        \"!-m\",\n        \"!-px\",\n        \"!-pl\",\n        \"!-pr\",\n        \"!-mx\",\n        \"!-ml\",\n        \"!-mr\"\n      ];\n      [...t.classList].filter(\n        (n) => e.findIndex((o) => n.includes(o)) >= 0\n      ).forEach((n) => t.classList.remove(n));\n    }), this._initialContentStyle = this._content.map((t) => {\n      const { paddingLeft: e, paddingRight: i, marginLeft: n, marginRight: o, transition: r } = window.getComputedStyle(t);\n      return { paddingLeft: e, paddingRight: i, marginLeft: n, marginRight: o, transition: r };\n    });\n  }\n  _setupFocusTrap() {\n    this._focusTrap = new Wi(\n      this._element,\n      {\n        event: \"keydown\",\n        condition: (t) => t.keyCode === Pi,\n        onlyVisible: !0\n      },\n      this.toggler\n    );\n  }\n  _setupInitialStyling() {\n    this._setColor(), h.style(this._element, this.sidenavStyle);\n  }\n  _setupScrolling() {\n    let t = this._element;\n    if (this.options.sidenavScrollContainer) {\n      t = d.findOne(\n        this.options.sidenavScrollContainer,\n        this._element\n      );\n      const i = Kh(t.parentNode.children).filter(\n        (n) => n !== t\n      ).reduce((n, o) => n + o.clientHeight, 0);\n      h.style(t, {\n        maxHeight: `calc(100% - ${i}px)`,\n        position: \"relative\"\n      });\n    }\n    this._perfectScrollbar = new mh(t, {\n      suppressScrollX: !0,\n      handlers: [\"click-rail\", \"drag-thumb\", \"wheel\", \"touch\"]\n    });\n  }\n  _setupSlim() {\n    this._slimCollapsed = this.options.sidenavSlimCollapsed, this._toggleSlimDisplay(this._slimCollapsed), this.options.sidenavExpandOnHover && (this._element.addEventListener(\"mouseenter\", () => {\n      this._slimCollapsed && this._setSlim(!1);\n    }), this._element.addEventListener(\"mouseleave\", () => {\n      this._slimCollapsed || this._setSlim(!0);\n    }));\n  }\n  _setupRippleEffect() {\n    this.links.forEach((t) => {\n      let e = Ze.getInstance(t), i = this.options.sidenavColor;\n      if (e && e._options.sidenavColor !== this.options.sidenavColor)\n        e.dispose();\n      else if (e)\n        return;\n      (localStorage.theme === \"dark\" || !(\"theme\" in localStorage) && window.matchMedia(\"(prefers-color-scheme: dark)\").matches) && (i = \"white\"), e = new Ze(t, { rippleColor: i });\n    });\n  }\n  _setupTouch() {\n    this._touch = new ag(this._element, \"swipe\", { threshold: 20 }), this._touch.init(), c.on(\n      this._element,\n      \"swipeleft\",\n      (t) => this._handleSwipe(t, this.options.sidenavRight)\n    ), c.on(\n      this._element,\n      \"swiperight\",\n      (t) => this._handleSwipe(t, !this.options.sidenavRight)\n    );\n  }\n  _setActive(t, e) {\n    t.setAttribute(\"data-te-sidebar-state-active\", \"\"), this._activeNode && t.removeAttribute(\"data-te-sidebar-state-active\"), this._activeNode = t;\n    const [i] = d.parents(\n      this._activeNode,\n      Oe\n    );\n    if (!i) {\n      this._setActiveCategory();\n      return;\n    }\n    const [n] = d.prev(i, ui);\n    this._setActiveCategory(n), !e && !this._slimCollapsed && Zt.getInstance(i).show();\n  }\n  _setActiveCategory(t) {\n    this.navigation.forEach((e) => {\n      d.find(Oe, e).forEach((n) => {\n        const [o] = d.prev(n, ui);\n        o !== t ? o.removeAttribute(\"data-te-sidenav-state-active\") : o.setAttribute(\"data-te-sidenav-state-active\", \"\");\n      });\n    });\n  }\n  _setActiveElements(t) {\n    this.navigation.forEach((e) => {\n      d.find(ui, e).filter((n) => d.next(n, Oe).length === 0).forEach((n) => {\n        this._isActive(n, t) && n !== this._activeNode && this._setActive(n, t);\n      });\n    }), t && this._updateFocus(this.isVisible);\n  }\n  _setColor() {\n    const t = [\n      \"primary\",\n      \"secondary\",\n      \"success\",\n      \"info\",\n      \"warning\",\n      \"danger\",\n      \"light\",\n      \"dark\"\n    ], { sidenavColor: e } = this.options, i = t.includes(e) ? e : \"primary\";\n    t.forEach((n) => {\n      this._element.classList.remove(`sidenav-${n}`);\n    }), h.addClass(this._element, `sidenav-${i}`);\n  }\n  _setContentOffsets(t, e, i) {\n    this._content.forEach((n, o) => {\n      const r = this._getOffsetValue(t, {\n        index: o,\n        property: \"padding\",\n        offsets: e\n      }), a = this._getOffsetValue(t, {\n        index: o,\n        property: \"margin\",\n        offsets: e\n      }), l = {};\n      if (i || (l.transition = `all ${this.transitionDuration} linear`), l[e.padding.property] = `${r}px`, l[e.margin.property] = `${a}px`, h.style(n, l), !!t) {\n        if (i) {\n          h.style(n, {\n            transition: this._initialContentStyle[o].transition\n          });\n          return;\n        }\n        c.on(n, \"transitionend\", () => {\n          h.style(n, {\n            transition: this._initialContentStyle[o].transition\n          });\n        });\n      }\n    });\n  }\n  _setMode(t) {\n    this.options.sidenavMode !== t && (this._options.sidenavMode = t, this._update(this.isVisible));\n  }\n  _setSlim(t) {\n    const e = t ? [\"collapse\", \"collapsed\"] : [\"expand\", \"expanded\"];\n    this._triggerEvents(...e), t && this._collapseItems(), this._slimCollapsed = t, this._toggleSlimDisplay(t), h.style(this._element, { width: `${this.width}px` }), this._updateOffsets(this.isVisible);\n  }\n  _setTabindex(t) {\n    this.links.forEach((e) => {\n      e.tabIndex = t ? 0 : -1;\n    });\n  }\n  _emitEvents(t) {\n    const e = t ? [\"show\", \"shown\"] : [\"hide\", \"hidden\"];\n    this._triggerEvents(...e);\n  }\n  _rotateArrow(t, e) {\n    const [i] = d.children(t, `[${lg}]`);\n    i && (e ? h.removeClass(i, \"rotate-180\") : h.addClass(i, \"rotate-180\"));\n  }\n  _toggleCategory(t, e) {\n    t.preventDefault(), e.toggle(), this._slimCollapsed && this.options.sidenavExpandable && (this._tempSlim = !0, this._setSlim(!1));\n  }\n  _toggleSlimDisplay(t) {\n    const e = d.find(\n      hg,\n      this._element\n    ), i = d.find(\n      dg,\n      this._element\n    ), n = () => {\n      e.forEach((o) => {\n        h.style(o, {\n          display: this._slimCollapsed ? \"unset\" : \"none\"\n        });\n      }), i.forEach((o) => {\n        h.style(o, {\n          display: this._slimCollapsed ? \"none\" : \"unset\"\n        });\n      });\n    };\n    t ? setTimeout(\n      () => n(),\n      this.options.sidenavTransitionDuration\n    ) : n();\n  }\n  async _triggerEvents(t, e) {\n    c.trigger(this._element, `${t}.te.sidenav`), e && await setTimeout(() => {\n      c.trigger(this._element, `${e}.te.sidenav`);\n    }, this.options.sidenavTransitionDuration + 5);\n  }\n  _isiPhone() {\n    return /iPhone|iPod/i.test(navigator.userAgent);\n  }\n  _update(t) {\n    t && this._isiPhone() && h.addClass(this._element, \"ps--scrolling-y\"), this.toggler && this._updateTogglerAria(t), this._updateDisplay(t), this.options.sidenavBackdrop && this._updateBackdrop(t), this._updateOffsets(t), t && this.options.sidenavCloseOnEsc && this.options.sidenavMode !== \"side\" && c.on(window, \"keydown\", this.escHandler), this.options.sidenavFocusTrap && this._updateFocus(t);\n  }\n  _updateDisplay(t) {\n    const e = t ? 0 : this.translation;\n    h.style(this._element, {\n      transform: `translateX(${e}%)`\n    });\n  }\n  _updateFocus(t) {\n    if (this._setTabindex(t), this.options.sidenavMode === \"over\" && this.options.sidenavFocusTrap) {\n      if (t) {\n        this._focusTrap.trap();\n        return;\n      }\n      this._focusTrap.disable();\n    }\n    this._focusTrap.disable();\n  }\n  _updateOffsets(t, e = !1) {\n    const [i, n] = this.options.sidenavRight ? [\"right\", \"left\"] : [\"left\", \"right\"], o = {\n      property: this._getProperty(\"padding\", i),\n      value: this.options.sidenavMode === \"over\" ? 0 : this.width\n    }, r = {\n      property: this._getProperty(\"margin\", n),\n      value: this.options.sidenavMode === \"push\" ? -1 * this.width : 0\n    };\n    c.trigger(this._element, \"update.te.sidenav\", {\n      margin: r,\n      padding: o\n    }), this._content && (this._content.className = \"\", this._setContentOffsets(t, { padding: o, margin: r }, e));\n  }\n  _updateTogglerAria(t) {\n    this.toggler.setAttribute(\"aria-expanded\", t);\n  }\n  // Static\n  static toggleSidenav() {\n    return function(t) {\n      const e = d.closest(t.target, no), i = h.getDataAttributes(e).target;\n      d.find(i).forEach((n) => {\n        (gi.getInstance(n) || new gi(n)).toggle();\n      });\n    };\n  }\n  static jQueryInterface(t, e) {\n    return this.each(function() {\n      let i = y.getData(this, Ts);\n      const n = typeof t == \"object\" && t;\n      if (!(!i && /dispose/.test(t)) && (i || (i = new gi(this, n)), typeof t == \"string\")) {\n        if (typeof i[t] > \"u\")\n          throw new TypeError(`No method named \"${t}\"`);\n        i[t](e);\n      }\n    });\n  }\n  static getInstance(t) {\n    return y.getData(t, Ts);\n  }\n  static getOrCreateInstance(t, e = {}) {\n    return this.getInstance(t) || new this(t, typeof e == \"object\" ? e : null);\n  }\n}\nconst Ho = \"stepper\", Xs = \"te.stepper\", pn = `.${Xs}`, Yi = `data-te-${Ho}`, bi = \"horizontal\", xt = \"vertical\", gg = {\n  stepperType: \"string\",\n  stepperLinear: \"boolean\",\n  stepperNoEditable: \"boolean\",\n  stepperActive: \"string\",\n  stepperCompleted: \"string\",\n  stepperInvalid: \"string\",\n  stepperDisabled: \"string\",\n  stepperVerticalBreakpoint: \"number\",\n  stepperMobileBreakpoint: \"number\",\n  stepperMobileBarBreakpoint: \"number\"\n}, bg = {\n  stepperType: bi,\n  stepperLinear: !1,\n  stepperNoEditable: !1,\n  stepperActive: \"\",\n  stepperCompleted: \"\",\n  stepperInvalid: \"\",\n  stepperDisabled: \"\",\n  stepperVerticalBreakpoint: 0,\n  stepperMobileBreakpoint: 0,\n  stepperMobileBarBreakpoint: 4\n}, Ja = `mousedown${pn}`, tl = `keydown${pn}`, vg = `keyup${pn}`, el = `resize${pn}`, jt = `[${Yi}-step-ref]`, G = `[${Yi}-head-ref]`, il = `[${Yi}-head-text-ref]`, Es = `[${Yi}-head-icon-ref]`, st = `[${Yi}-content-ref]`;\nclass XC {\n  constructor(t, e) {\n    this._element = t, this._options = this._getConfig(e), this._elementHeight = 0, this._steps = d.find(`${jt}`, this._element), this._currentView = \"\", this._activeStepIndex = 0, this._verticalStepperStyles = [], this._element && (y.setData(t, Xs, this), this._init());\n  }\n  // Getters\n  static get NAME() {\n    return Ho;\n  }\n  get activeStep() {\n    return this._steps[this._activeStepIndex];\n  }\n  get activeStepIndex() {\n    return this._activeStepIndex;\n  }\n  // Public\n  dispose() {\n    this._steps.forEach((t) => {\n      c.off(t, Ja), c.off(t, tl);\n    }), c.off(window, el), y.removeData(this._element, Xs), this._element = null;\n  }\n  changeStep(t) {\n    this._toggleStep(t);\n  }\n  nextStep() {\n    this._toggleStep(this._activeStepIndex + 1);\n  }\n  previousStep() {\n    this._toggleStep(this._activeStepIndex - 1);\n  }\n  // Private\n  _init() {\n    const t = d.find(`${jt}`, this._element)[this._activeStepIndex].setAttribute(\"data-te\", \"active-step\"), e = d.find(\n      `${il}`,\n      this._element\n    ), i = d.find(\n      `${Es}`,\n      this._element\n    );\n    switch (t ? (this._activeStepIndex = this._steps.indexOf(t), this._toggleStepClass(\n      this._activeStepIndex,\n      \"add\",\n      this._options.stepperActive\n    ), e[this._activeStepIndex].classList.add(\"font-medium\"), i[this._activeStepIndex].classList.add(\"!bg-primary-100\"), i[this._activeStepIndex].classList.add(\"!text-primary-700\")) : (e[this._activeStepIndex].classList.add(\"font-medium\"), i[this._activeStepIndex].classList.add(\"!bg-primary-100\"), i[this._activeStepIndex].classList.add(\"!text-primary-700\"), this._toggleStepClass(\n      this._activeStepIndex,\n      \"add\",\n      this._options.stepperActive\n    )), this._bindMouseDown(), this._bindKeysNavigation(), this._options.stepperType) {\n      case xt:\n        this._toggleVertical();\n        break;\n      default:\n        this._toggleHorizontal();\n        break;\n    }\n    (this._options.stepperVerticalBreakpoint || this._options.stepperMobileBreakpoint) && this._toggleStepperView(), this._bindResize();\n  }\n  _getConfig(t) {\n    const e = h.getDataAttributes(this._element);\n    return t = {\n      ...bg,\n      ...e,\n      ...t\n    }, D(Ho, t, gg), t;\n  }\n  _bindMouseDown() {\n    this._steps.forEach((t) => {\n      const e = d.findOne(`${G}`, t);\n      c.on(e, Ja, (i) => {\n        const n = d.parents(i.target, `${jt}`)[0], o = this._steps.indexOf(n);\n        i.preventDefault(), this._toggleStep(o);\n      });\n    });\n  }\n  _bindResize() {\n    c.on(window, el, () => {\n      this._currentView === xt && this._setSingleStepHeight(this.activeStep), this._currentView === bi && this._setHeight(this.activeStep), (this._options.stepperVerticalBreakpoint || this._options.stepperMobileBreakpoint) && this._toggleStepperView();\n    });\n  }\n  _toggleStepperView() {\n    const t = this._options.stepperVerticalBreakpoint < window.innerWidth, e = this._options.stepperVerticalBreakpoint > window.innerWidth, i = this._options.stepperMobileBreakpoint > window.innerWidth;\n    t && this._currentView !== bi && this._toggleHorizontal(), e && !i && this._currentView !== xt && (this._steps.forEach((n) => {\n      const o = d.findOne(`${st}`, n);\n      this._resetStepperHeight(), this._showElement(o);\n    }), this._toggleVertical());\n  }\n  _toggleStep(t) {\n    this._activeStepIndex !== t && (this._options.stepperNoEditable && this._toggleDisabled(), this._showElement(\n      d.findOne(`${st}`, this._steps[t])\n    ), this._toggleActive(t), t > this._activeStepIndex && this._toggleCompleted(this._activeStepIndex), this._currentView === bi ? this._animateHorizontalStep(t) : (this._animateVerticalStep(t), this._setSingleStepHeight(this._steps[t])), this._toggleStepTabIndex(\n      d.findOne(`${G}`, this.activeStep),\n      d.findOne(`${G}`, this._steps[t])\n    ), this._activeStepIndex = t, this._steps[this._activeStepIndex].setAttribute(\"data-te\", \"active-step\"), this._steps.forEach((e, i) => {\n      e[this._activeStepIndex] !== i && e.removeAttribute(\"data-te\");\n    }));\n  }\n  _resetStepperHeight() {\n    this._element.style.height = \"\";\n  }\n  _setStepsHeight() {\n    this._steps.forEach((t) => {\n      const e = d.findOne(`${st}`, t), i = window.getComputedStyle(e);\n      this._verticalStepperStyles.push({\n        paddingTop: parseFloat(i.paddingTop),\n        paddingBottom: parseFloat(i.paddingBottom)\n      });\n      const n = e.scrollHeight;\n      e.style.height = `${n}px`;\n    });\n  }\n  _setSingleStepHeight(t) {\n    const e = d.findOne(`${st}`, t), i = this.activeStep === t, n = this._steps.indexOf(t);\n    let o;\n    i ? (e.style.height = \"\", o = e.scrollHeight) : o = e.scrollHeight + this._verticalStepperStyles[n].paddingTop + this._verticalStepperStyles[n].paddingBottom, e.style.height = `${o}px`;\n  }\n  _toggleVertical() {\n    this._currentView = xt, this._setStepsHeight(), this._hideInactiveSteps();\n  }\n  _toggleHorizontal() {\n    this._currentView = bi, this._setHeight(this.activeStep), this._hideInactiveSteps();\n  }\n  _toggleStepperClass() {\n    d.findOne(\n      \"[data-te-stepper-type]\",\n      this._element\n    ) !== null && this._steps.forEach((e) => {\n      d.findOne(`${st}`, e).classList.remove(\"!my-0\"), d.findOne(`${st}`, e).classList.remove(\"!py-0\"), d.findOne(`${st}`, e).classList.remove(\"!h-0\");\n    });\n  }\n  _toggleStepClass(t, e, i) {\n    i && this._steps[t].classList[e](i);\n  }\n  _bindKeysNavigation() {\n    this._toggleStepTabIndex(\n      !1,\n      d.findOne(`${G}`, this.activeStep)\n    ), this._steps.forEach((t) => {\n      const e = d.findOne(`${G}`, t);\n      c.on(e, tl, (i) => {\n        const n = d.parents(\n          i.currentTarget,\n          `${jt}`\n        )[0], o = d.next(n, `${jt}`)[0], r = d.prev(n, `${jt}`)[0], a = d.findOne(\n          `${G}`,\n          n\n        ), l = d.findOne(\n          `${G}`,\n          this.activeStep\n        );\n        let p = null, u = null;\n        if (o && (p = d.findOne(`${G}`, o)), r && (u = d.findOne(`${G}`, r)), i.keyCode === He && this._currentView !== xt && (u ? (this._toggleStepTabIndex(a, u), this._toggleOutlineStyles(a, u), u.focus()) : p && (this._toggleStepTabIndex(a, p), this._toggleOutlineStyles(a, p), p.focus())), i.keyCode === Ve && this._currentView !== xt && (p ? (this._toggleStepTabIndex(a, p), this._toggleOutlineStyles(a, p), p.focus()) : u && (this._toggleStepTabIndex(a, u), this._toggleOutlineStyles(a, u), u.focus())), i.keyCode === z && this._currentView === xt && (i.preventDefault(), p && (this._toggleStepTabIndex(a, p), this._toggleOutlineStyles(a, p), p.focus())), i.keyCode === at && this._currentView === xt && (i.preventDefault(), u && (this._toggleStepTabIndex(a, u), this._toggleOutlineStyles(a, u), u.focus())), i.keyCode === We) {\n          const _ = d.findOne(\n            `${G}`,\n            this._steps[0]\n          );\n          this._toggleStepTabIndex(a, _), this._toggleOutlineStyles(a, _), _.focus();\n        }\n        if (i.keyCode === Fe) {\n          const _ = this._steps[this._steps.length - 1], f = d.findOne(`${G}`, _);\n          this._toggleStepTabIndex(a, f), this._toggleOutlineStyles(a, f), f.focus();\n        }\n        (i.keyCode === ct || i.keyCode === Ks) && (i.preventDefault(), this.changeStep(this._steps.indexOf(n))), i.keyCode === Pi && (this._toggleStepTabIndex(a, l), this._toggleOutlineStyles(a, !1), l.focus());\n      }), c.on(e, vg, (i) => {\n        const n = d.parents(\n          i.currentTarget,\n          `${jt}`\n        )[0], o = d.findOne(\n          `${G}`,\n          n\n        ), r = d.findOne(\n          `${G}`,\n          this.activeStep\n        );\n        i.keyCode === Pi && (this._toggleStepTabIndex(o, r), this._toggleOutlineStyles(!1, r), r.focus());\n      });\n    });\n  }\n  _toggleStepTabIndex(t, e) {\n    t && t.setAttribute(\"tabIndex\", -1), e && e.setAttribute(\"tabIndex\", 0);\n  }\n  _toggleOutlineStyles(t, e) {\n    t && (t.style.outline = \"\"), e && (e.style.outline = \"revert\");\n  }\n  _toggleDisabled() {\n    const t = d.find(`${G}`, this._element), e = d.find(\n      `${Es}`,\n      this._element\n    );\n    t[this._activeStepIndex].classList.add(\"color-[#858585]\"), t[this._activeStepIndex].classList.add(\"cursor-default\"), e[this._activeStepIndex].classList.add(\"!bg-[#858585]\"), this._toggleStepClass(\n      this._activeStepIndex,\n      \"add\",\n      this._options.stepperDisabled\n    );\n  }\n  _toggleActive(t) {\n    const e = d.find(\n      `${il}`,\n      this._element\n    ), i = d.find(\n      `${Es}`,\n      this._element\n    );\n    e[t].classList.add(\"font-medium\"), i[t].classList.add(\"!bg-primary-100\"), i[t].classList.add(\"!text-primary-700\"), i[t].classList.remove(\"!bg-success-100\"), i[t].classList.remove(\"!text-success-700\"), e[this._activeStepIndex].classList.remove(\"font-medium\"), i[this._activeStepIndex].classList.remove(\"!bg-primary-100\"), i[this._activeStepIndex].classList.remove(\n      \"!text-primary-700\"\n    ), this._toggleStepClass(t, \"add\", this._options.stepperActive), this._toggleStepClass(\n      this._activeStepIndex,\n      \"remove\",\n      this._options.stepperActive\n    );\n  }\n  _toggleCompleted(t) {\n    const e = d.find(\n      `${Es}`,\n      this._element\n    );\n    e[t].classList.add(\"!bg-success-100\"), e[t].classList.add(\"!text-success-700\"), e[t].classList.remove(\"!bg-danger-100\"), e[t].classList.remove(\"!text-danger-700\"), this._toggleStepClass(t, \"add\", this._options.stepperCompleted), this._toggleStepClass(t, \"remove\", this._options.stepperInvalid);\n  }\n  _hideInactiveSteps() {\n    this._steps.forEach((t) => {\n      t.getAttribute(\"data-te\") || this._hideElement(d.findOne(`${st}`, t));\n    });\n  }\n  _setHeight(t) {\n    const e = d.findOne(`${st}`, t), i = getComputedStyle(e), n = d.findOne(`${G}`, t), o = getComputedStyle(n), r = e.offsetHeight + parseFloat(i.marginTop) + parseFloat(i.marginBottom), a = n.offsetHeight + parseFloat(o.marginTop) + parseFloat(o.marginBottom);\n    this._element.style.height = `${a + r}px`;\n  }\n  _hideElement(t) {\n    !d.parents(\n      t,\n      `${jt}`\n    )[0].getAttribute(\"data-te\") && this._currentView !== xt || (t.classList.add(\"!my-0\"), t.classList.add(\"!py-0\"), t.classList.add(\"!h-0\"));\n  }\n  _showElement(t) {\n    this._currentView === xt ? (t.classList.remove(\"!my-0\"), t.classList.remove(\"!py-0\"), t.classList.remove(\"!h-0\")) : t.style.display = \"block\";\n  }\n  _animateHorizontalStep(t) {\n    const e = t > this._activeStepIndex, i = d.findOne(\n      `${st}`,\n      this._steps[t]\n    ), n = d.findOne(\n      `${st}`,\n      this.activeStep\n    );\n    let o, r;\n    this._steps.forEach((u, _) => {\n      const f = d.findOne(`${st}`, u);\n      _ !== t && _ !== this._activeStepIndex && this._hideElement(f);\n    });\n    const a = \"translate-x-[150%]\", l = \"-translate-x-[150%]\", p = \"translate-0\";\n    e ? (r = l, o = p, i.classList.remove(\"translate-x-[150%]\"), i.classList.remove(\"-translate-x-[150%]\")) : (r = a, o = p, i.classList.remove(\"-translate-x-[150%]\"), i.classList.remove(\"translate-x-[150%]\")), n.classList.add(r), i.classList.add(o), this._setHeight(this._steps[t]);\n  }\n  _animateVerticalStep(t) {\n    const e = d.findOne(\n      `${st}`,\n      this._steps[t]\n    ), i = d.findOne(\n      `${st}`,\n      this.activeStep\n    );\n    this._hideElement(i), this._showElement(e);\n  }\n  static getInstance(t) {\n    return y.getData(t, Xs);\n  }\n  static getOrCreateInstance(t, e = {}) {\n    return this.getInstance(t) || new this(t, typeof e == \"object\" ? e : null);\n  }\n}\nconst sl = \"data-te-input-state-active\", Cs = \"data-te-input-selected\", nl = \"data-te-input-multiple-active\", ol = \"[data-te-form-check-input]\";\nclass rl {\n  constructor(t, e, i, n, o, r, a, l, p, u, _) {\n    this.id = t, this.nativeOption = e, this.multiple = i, this.value = n, this.label = o, this.selected = r, this.disabled = a, this.hidden = l, this.secondaryText = p, this.groupId = u, this.icon = _, this.node = null, this.active = !1;\n  }\n  select() {\n    this.multiple ? this._selectMultiple() : this._selectSingle();\n  }\n  _selectSingle() {\n    this.selected || (this.node.setAttribute(Cs, \"\"), this.node.setAttribute(\"aria-selected\", !0), this.selected = !0, this.nativeOption && (this.nativeOption.selected = !0));\n  }\n  _selectMultiple() {\n    if (!this.selected) {\n      const t = d.findOne(\n        ol,\n        this.node\n      );\n      t.checked = !0, this.node.setAttribute(Cs, \"\"), this.node.setAttribute(\"aria-selected\", !0), this.selected = !0, this.nativeOption && (this.nativeOption.selected = !0);\n    }\n  }\n  deselect() {\n    this.multiple ? this._deselectMultiple() : this._deselectSingle();\n  }\n  _deselectSingle() {\n    this.selected && (this.node.removeAttribute(Cs), this.node.setAttribute(\"aria-selected\", !1), this.selected = !1, this.nativeOption && (this.nativeOption.selected = !1));\n  }\n  _deselectMultiple() {\n    if (this.selected) {\n      const t = d.findOne(\n        ol,\n        this.node\n      );\n      t.checked = !1, this.node.removeAttribute(Cs), this.node.setAttribute(\"aria-selected\", !1), this.selected = !1, this.nativeOption && (this.nativeOption.selected = !1);\n    }\n  }\n  setNode(t) {\n    this.node = t;\n  }\n  setActiveStyles() {\n    if (!this.active) {\n      if (this.multiple) {\n        this.node.setAttribute(nl, \"\");\n        return;\n      }\n      this.active = !0, this.node.setAttribute(sl, \"\");\n    }\n  }\n  removeActiveStyles() {\n    this.active && (this.active = !1, this.node.removeAttribute(sl)), this.multiple && this.node.removeAttribute(nl);\n  }\n}\nclass Tg {\n  constructor(t = !1) {\n    this._multiple = t, this._selections = [];\n  }\n  select(t) {\n    this._multiple ? this._selections.push(t) : this._selections = [t];\n  }\n  deselect(t) {\n    if (this._multiple) {\n      const e = this._selections.findIndex(\n        (i) => t === i\n      );\n      this._selections.splice(e, 1);\n    } else\n      this._selections = [];\n  }\n  clear() {\n    this._selections = [];\n  }\n  get selection() {\n    return this._selections[0];\n  }\n  get selections() {\n    return this._selections;\n  }\n  get label() {\n    return this._selections[0] && this.selection.label;\n  }\n  get labels() {\n    return this._selections.map((t) => t.label).join(\", \");\n  }\n  get value() {\n    return this.selections[0] && this.selection.value;\n  }\n  get values() {\n    return this._selections.map((t) => t.value);\n  }\n}\nfunction Vo(s) {\n  return s.filter((t) => !t.disabled).every((t) => t.selected);\n}\nconst Eg = \"data-te-select-form-outline-ref\", Cg = \"data-te-select-wrapper-ref\", Ag = \"data-te-select-input-ref\", yg = \"data-te-select-clear-btn-ref\", wg = \"data-te-select-dropdown-container-ref\", kg = \"data-te-select-dropdown-ref\", xg = \"data-te-select-options-wrapper-ref\", Og = \"data-te-select-options-list-ref\", Sg = \"data-te-select-input-filter-ref\", Jc = \"data-te-select-option-ref\", Ig = \"data-te-select-option-all-ref\", Dg = \"data-te-select-option-text-ref\", $g = \"data-te-form-check-input\", Lg = \"data-te-select-option-group-ref\", Ng = \"data-te-select-option-group-label-ref\", th = \"data-te-select-selected\", Mg = `\n<svg xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" viewBox=\"0 0 24 24\" stroke-width=\"1.5\" stroke=\"currentColor\">\n  <path stroke-linecap=\"round\" stroke-linejoin=\"round\" d=\"M19.5 8.25l-7.5 7.5-7.5-7.5\" />\n</svg>\n`, Rg = (s) => {\n  s.code === \"Tab\" || s.code === \"Esc\" || s.preventDefault();\n};\nfunction As(s, t, e, i, n) {\n  t.selectSize === \"default\" && h.addClass(s, e), t.selectSize === \"sm\" && h.addClass(s, i), t.selectSize === \"lg\" && h.addClass(s, n);\n}\nfunction Pg(s, t, e, i, n) {\n  const o = document.createElement(\"div\");\n  o.setAttribute(\"id\", s), o.setAttribute(Cg, \"\");\n  const r = $(\"div\");\n  r.setAttribute(Eg, \"\"), h.addClass(r, i.formOutline);\n  const a = $(\"input\"), l = t.selectFilter ? \"combobox\" : \"listbox\", p = t.multiple ? \"true\" : \"false\", u = t.disabled ? \"true\" : \"false\";\n  a.setAttribute(Ag, \"\"), h.addClass(a, i.selectInput), As(\n    a,\n    t,\n    i.selectInputSizeDefault,\n    i.selectInputSizeSm,\n    i.selectInputSizeLg\n  ), t.selectFormWhite && h.addClass(a, i.selectInputWhite), a.setAttribute(\"type\", \"text\"), a.setAttribute(\"role\", l), a.setAttribute(\"aria-multiselectable\", p), a.setAttribute(\"aria-disabled\", u), a.setAttribute(\"aria-haspopup\", \"true\"), a.setAttribute(\"aria-expanded\", !1), a.name = n, t.tabIndex && a.setAttribute(\"tabIndex\", t.tabIndex), t.disabled && a.setAttribute(\"disabled\", \"\"), t.selectPlaceholder !== \"\" && a.setAttribute(\"placeholder\", t.selectPlaceholder), t.selectValidation ? (h.addStyle(a, {\n    \"pointer-events\": \"none\",\n    \"caret-color\": \"transparent\"\n  }), h.addStyle(r, { cursor: \"pointer\" })) : a.setAttribute(\"readonly\", \"true\"), t.selectValidation && (a.setAttribute(\"required\", \"true\"), a.setAttribute(\"aria-required\", \"true\"), a.addEventListener(\"keydown\", Rg));\n  const _ = $(\"div\");\n  h.addClass(_, i.selectValidationValid);\n  const f = document.createTextNode(\n    `${t.selectValidFeedback}`\n  );\n  _.appendChild(f);\n  const g = $(\"div\");\n  h.addClass(g, i.selectValidationInvalid);\n  const m = document.createTextNode(\n    `${t.selectInvalidFeedback}`\n  );\n  g.appendChild(m);\n  const b = $(\"span\");\n  b.setAttribute(yg, \"\"), h.addClass(b, i.selectClearBtn), As(\n    b,\n    t,\n    i.selectClearBtnDefault,\n    i.selectClearBtnSm,\n    i.selectClearBtnLg\n  ), t.selectFormWhite && h.addClass(b, i.selectClearBtnWhite);\n  const v = document.createTextNode(\"✕\");\n  b.appendChild(v), b.setAttribute(\"tabindex\", \"0\");\n  const C = $(\"span\");\n  return h.addClass(C, i.selectArrow), As(\n    C,\n    t,\n    i.selectArrowDefault,\n    i.selectArrowSm,\n    i.selectArrowLg\n  ), t.selectFormWhite && h.addClass(C, i.selectArrowWhite), C.innerHTML = Mg, r.appendChild(a), e && (h.addClass(e, i.selectLabel), As(\n    e,\n    t,\n    i.selectLabelSizeDefault,\n    i.selectLabelSizeSm,\n    i.selectLabelSizeLg\n  ), t.selectFormWhite && h.addClass(e, i.selectLabelWhite), r.appendChild(e)), t.selectValidation && (r.appendChild(_), r.appendChild(g)), t.selectClearButton && r.appendChild(b), r.appendChild(C), o.appendChild(r), o;\n}\nfunction al(s, t, e, i, n, o, r, a) {\n  const l = document.createElement(\"div\");\n  l.setAttribute(wg, \"\"), h.addClass(l, a.selectDropdownContainer), l.setAttribute(\"id\", `${s}`), l.style.width = `${e}px`;\n  const p = document.createElement(\"div\");\n  p.setAttribute(\"tabindex\", 0), p.setAttribute(kg, \"\"), h.addClass(p, a.dropdown);\n  const u = $(\"div\");\n  u.setAttribute(xg, \"\"), h.addClass(u, a.optionsWrapper), h.addClass(u, a.optionsWrapperScrollbar), u.style.maxHeight = `${i}px`;\n  const _ = eh(\n    o,\n    n,\n    t,\n    a\n  );\n  return u.appendChild(_), t.selectFilter && p.appendChild(\n    Bg(t.selectSearchPlaceholder, a)\n  ), p.appendChild(u), r && p.appendChild(r), l.appendChild(p), l;\n}\nfunction eh(s, t, e, i) {\n  const n = $(\"div\");\n  n.setAttribute(Og, \"\"), h.addClass(n, i.optionsList);\n  let o;\n  return e.multiple ? o = Vg(\n    s,\n    t,\n    e,\n    i\n  ) : o = Hg(s, e, i), o.forEach((r) => {\n    n.appendChild(r);\n  }), n;\n}\nfunction Bg(s, t) {\n  const e = $(\"div\");\n  h.addClass(e, t.inputGroup);\n  const i = $(\"input\");\n  return i.setAttribute(Sg, \"\"), h.addClass(i, t.selectFilterInput), i.placeholder = s, i.setAttribute(\"role\", \"searchbox\"), i.setAttribute(\"type\", \"text\"), e.appendChild(i), e;\n}\nfunction Hg(s, t, e) {\n  return ih(s, t, e);\n}\nfunction Vg(s, t, e, i) {\n  let n = null;\n  e.selectAll && (n = Wg(\n    t,\n    s,\n    e,\n    i\n  ));\n  const o = ih(s, e, i);\n  return n ? [n, ...o] : o;\n}\nfunction ih(s, t, e) {\n  const i = [];\n  return s.forEach((n) => {\n    if (Object.prototype.hasOwnProperty.call(\n      n,\n      \"options\"\n    )) {\n      const r = Kg(n, t, e);\n      i.push(r);\n    } else\n      i.push(sh(n, t, e));\n  }), i;\n}\nfunction Wg(s, t, e, i) {\n  const n = Vo(t), o = $(\"div\");\n  return o.setAttribute(Jc, \"\"), h.addClass(o, i.selectOption), o.setAttribute(Ig, \"\"), h.addStyle(o, {\n    height: `${e.selectOptionHeight}px`\n  }), o.setAttribute(\"role\", \"option\"), o.setAttribute(\"aria-selected\", n), n && o.setAttribute(th, \"\"), o.appendChild(nh(s, e, i)), s.setNode(o), o;\n}\nfunction sh(s, t, e) {\n  if (s.node)\n    return s.node;\n  const i = $(\"div\");\n  return i.setAttribute(Jc, \"\"), h.addClass(i, e.selectOption), h.addStyle(i, {\n    height: `${t.selectOptionHeight}px`\n  }), h.setDataAttribute(i, \"id\", s.id), i.setAttribute(\"role\", \"option\"), i.setAttribute(\"aria-selected\", s.selected), i.setAttribute(\"aria-disabled\", s.disabled), s.selected && i.setAttribute(th, \"\"), s.disabled && i.setAttribute(\"data-te-select-option-disabled\", !0), s.hidden && h.addClass(i, \"hidden\"), i.appendChild(nh(s, t, e)), s.icon && i.appendChild(jg(s, e)), s.setNode(i), i;\n}\nfunction nh(s, t, e) {\n  const i = $(\"span\");\n  i.setAttribute(Dg, \"\"), h.addClass(i, e.selectOptionText);\n  const n = document.createTextNode(s.label);\n  return t.multiple && i.appendChild(Yg(s, e)), i.appendChild(n), (s.secondaryText || typeof s.secondaryText == \"number\") && i.appendChild(\n    Fg(s.secondaryText, e)\n  ), i;\n}\nfunction Fg(s, t) {\n  const e = $(\"span\");\n  h.addClass(e, t.selectOptionSecondaryText);\n  const i = document.createTextNode(s);\n  return e.appendChild(i), e;\n}\nfunction Yg(s, t) {\n  const e = $(\"input\");\n  e.setAttribute(\"type\", \"checkbox\"), h.addClass(e, t.formCheckInput), e.setAttribute($g, \"\");\n  const i = $(\"label\");\n  return s.selected && e.setAttribute(\"checked\", !0), s.disabled && e.setAttribute(\"disabled\", !0), e.appendChild(i), e;\n}\nfunction jg(s, t) {\n  const e = $(\"span\"), i = $(\"img\");\n  return h.addClass(i, t.selectOptionIcon), i.src = s.icon, e.appendChild(i), e;\n}\nfunction Kg(s, t, e) {\n  const i = $(\"div\");\n  i.setAttribute(Lg, \"\"), h.addClass(i, e.selectOptionGroup), i.setAttribute(\"role\", \"group\"), i.setAttribute(\"id\", s.id), s.hidden && h.addClass(i, \"hidden\");\n  const n = $(\"label\");\n  return n.setAttribute(Ng, \"\"), h.addClass(n, e.selectOptionGroupLabel), h.addStyle(n, { height: `${t.selectOptionHeight}px` }), n.setAttribute(\"for\", s.id), n.textContent = s.label, i.appendChild(n), s.options.forEach((o) => {\n    i.appendChild(sh(o, t, e));\n  }), i;\n}\nfunction zg(s, t) {\n  const e = $(\"div\");\n  return e.innerHTML = s, h.addClass(e, t.selectLabel), h.addClass(e, t.selectFakeValue), e;\n}\nconst oo = \"select\", vi = \"te.select\", ji = `.${vi}`, Ug = `close${ji}`, Xg = `open${ji}`, ll = `optionSelect${ji}`, cl = `optionDeselect${ji}`, Gg = `valueChange${ji}`, qg = \"change\", hl = \"data-te-select-init\", oh = \"data-te-select-no-results-ref\", dl = \"data-te-select-open\", q = \"data-te-input-state-active\", Kt = \"data-te-input-focused\", ro = \"data-te-input-disabled\", Zg = \"data-te-select-option-group-label-ref\", Qg = \"data-te-select-option-all-ref\", pi = \"data-te-select-selected\", Jg = \"[data-te-select-label-ref]\", ul = \"[data-te-select-input-ref]\", tb = \"[data-te-select-input-filter-ref]\", eb = \"[data-te-select-dropdown-ref]\", ib = \"[data-te-select-options-wrapper-ref]\", pl = \"[data-te-select-options-list-ref]\", sb = \"[data-te-select-option-ref]\", nb = \"[data-te-select-clear-btn-ref]\", ob = \"[data-te-select-custom-content-ref]\", rb = `[${oh}]`, _l = \"[data-te-select-form-outline-ref]\", ab = \"[data-te-select-toggle]\", ao = \"[data-te-input-notch-ref]\", lb = 200, cb = {\n  selectAutoSelect: !1,\n  selectContainer: \"body\",\n  selectClearButton: !1,\n  disabled: !1,\n  selectDisplayedLabels: 5,\n  selectFormWhite: !1,\n  multiple: !1,\n  selectOptionsSelectedLabel: \"options selected\",\n  selectOptionHeight: 38,\n  selectAll: !0,\n  selectAllLabel: \"Select all\",\n  selectSearchPlaceholder: \"Search...\",\n  selectSize: \"default\",\n  selectVisibleOptions: 5,\n  selectFilter: !1,\n  selectFilterDebounce: 300,\n  selectNoResultText: \"No results\",\n  selectValidation: !1,\n  selectValidFeedback: \"Valid\",\n  selectInvalidFeedback: \"Invalid\",\n  selectPlaceholder: \"\"\n}, hb = {\n  selectAutoSelect: \"boolean\",\n  selectContainer: \"string\",\n  selectClearButton: \"boolean\",\n  disabled: \"boolean\",\n  selectDisplayedLabels: \"number\",\n  selectFormWhite: \"boolean\",\n  multiple: \"boolean\",\n  selectOptionsSelectedLabel: \"string\",\n  selectOptionHeight: \"number\",\n  selectAll: \"boolean\",\n  selectAllLabel: \"string\",\n  selectSearchPlaceholder: \"string\",\n  selectSize: \"string\",\n  selectVisibleOptions: \"number\",\n  selectFilter: \"boolean\",\n  selectFilterDebounce: \"number\",\n  selectNoResultText: \"string\",\n  selectValidation: \"boolean\",\n  selectValidFeedback: \"string\",\n  selectInvalidFeedback: \"string\",\n  selectPlaceholder: \"string\"\n}, db = {\n  dropdown: \"relative outline-none min-w-[100px] m-0 scale-[0.8] opacity-0 bg-white shadow-[0_2px_5px_0_rgba(0,0,0,0.16),_0_2px_10px_0_rgba(0,0,0,0.12)] transition duration-200 motion-reduce:transition-none data-[te-select-open]:scale-100 data-[te-select-open]:opacity-100 dark:bg-zinc-700\",\n  formCheckInput: \"relative float-left mt-[0.15rem] mr-[8px] h-[1.125rem] w-[1.125rem] appearance-none rounded-[0.25rem] border-[0.125rem] border-solid border-neutral-300 dark:border-neutral-600 outline-none before:pointer-events-none before:absolute before:h-[0.875rem] before:w-[0.875rem] before:scale-0 before:rounded-full before:bg-transparent before:opacity-0 before:shadow-[0px_0px_0px_13px_transparent] before:content-[''] checked:border-primary dark:checked:border-primary checked:bg-primary dark:checked:bg-primary checked:before:opacity-[0.16] checked:after:absolute checked:after:ml-[0.25rem] checked:after:-mt-px checked:after:block checked:after:h-[0.8125rem] checked:after:w-[0.375rem] checked:after:rotate-45 checked:after:border-[0.125rem] checked:after:border-t-0 checked:after:border-l-0 checked:after:border-solid checked:after:border-white checked:after:bg-transparent checked:after:content-[''] hover:cursor-pointer hover:before:opacity-[0.04] hover:before:shadow-[0px_0px_0px_13px_rgba(0,0,0,0.6)] focus:shadow-none focus:transition-[border-color_0.2s] focus:before:scale-100 focus:before:opacity-[0.12] focus:before:shadow-[0px_0px_0px_13px_rgba(0,0,0,0.6)] dark:focus:before:shadow-[0px_0px_0px_13px_rgba(255,255,255,0.4)] focus:before:transition-[box-shadow_0.2s,transform_0.2s] focus:after:absolute focus:after:z-[1] focus:after:block focus:after:h-[0.875rem] focus:after:w-[0.875rem] focus:after:rounded-[0.125rem] focus:after:content-[''] checked:focus:before:scale-100 checked:focus:before:shadow-[0px_0px_0px_13px_#3b71ca] dark:checked:focus:before:shadow-[0px_0px_0px_13px_#3b71ca] checked:focus:before:transition-[box-shadow_0.2s,transform_0.2s] checked:focus:after:ml-[0.25rem] checked:focus:after:-mt-px checked:focus:after:h-[0.8125rem] checked:focus:after:w-[0.375rem] checked:focus:after:rotate-45 checked:focus:after:rounded-none checked:focus:after:border-[0.125rem] checked:focus:after:border-t-0 checked:focus:after:border-l-0 checked:focus:after:border-solid checked:focus:after:border-white checked:focus:after:bg-transparent\",\n  formOutline: \"relative\",\n  initialized: \"hidden\",\n  inputGroup: \"flex items-center whitespace-nowrap p-2.5 text-center text-base font-normal leading-[1.6] text-gray-700 dark:bg-zinc-800 dark:text-gray-200 dark:placeholder:text-gray-200\",\n  noResult: \"flex items-center px-4\",\n  optionsList: \"list-none m-0 p-0\",\n  optionsWrapper: \"overflow-y-auto\",\n  optionsWrapperScrollbar: \"[&::-webkit-scrollbar]:w-1 [&::-webkit-scrollbar]:h-1 [&::-webkit-scrollbar-button]:block [&::-webkit-scrollbar-button]:h-0 [&::-webkit-scrollbar-button]:bg-transparent [&::-webkit-scrollbar-track-piece]:bg-transparent [&::-webkit-scrollbar-track-piece]:rounded-none [&::-webkit-scrollbar-track-piece]: [&::-webkit-scrollbar-track-piece]:rounded-l [&::-webkit-scrollbar-thumb]:h-[50px] [&::-webkit-scrollbar-thumb]:bg-[#999] [&::-webkit-scrollbar-thumb]:rounded\",\n  selectArrow: \"absolute right-3 text-[0.8rem] cursor-pointer peer-focus:text-primary peer-data-[te-input-focused]:text-primary group-data-[te-was-validated]/validation:peer-valid:text-green-600 group-data-[te-was-validated]/validation:peer-invalid:text-[rgb(220,76,100)] w-5 h-5\",\n  selectArrowWhite: \"text-gray-50 peer-focus:!text-white peer-data-[te-input-focused]:!text-white\",\n  selectArrowDefault: \"top-2\",\n  selectArrowLg: \"top-[13px]\",\n  selectArrowSm: \"top-1\",\n  selectClearBtn: \"absolute top-2 right-9 text-black cursor-pointer focus:text-primary outline-none dark:text-gray-200\",\n  selectClearBtnWhite: \"!text-gray-50\",\n  selectClearBtnDefault: \"top-2 text-base\",\n  selectClearBtnLg: \"top-[11px] text-base\",\n  selectClearBtnSm: \"top-1 text-[0.8rem]\",\n  selectDropdownContainer: \"z-[1070]\",\n  selectFakeValue: \"transform-none hidden data-[te-input-state-active]:block\",\n  selectFilterInput: \"relative m-0 block w-full min-w-0 flex-auto rounded border border-solid border-gray-300 bg-transparent bg-clip-padding px-3 py-1.5 text-base font-normal text-gray-700 transition duration-300 ease-in-out motion-reduce:transition-none focus:border-primary focus:text-gray-700 focus:shadow-te-primary focus:outline-none dark:text-gray-200 dark:placeholder:text-gray-200\",\n  selectInput: \"peer block min-h-[auto] w-full rounded border-0 bg-transparent outline-none transition-all duration-200 ease-linear focus:placeholder:opacity-100 data-[te-input-state-active]:placeholder:opacity-100 motion-reduce:transition-none dark:text-gray-200 dark:placeholder:text-gray-200 [&:not([data-te-input-placeholder-active])]:placeholder:opacity-0 cursor-pointer data-[te-input-disabled]:bg-[#e9ecef] data-[te-input-disabled]:cursor-default group-data-[te-was-validated]/validation:mb-4 dark:data-[te-input-disabled]:bg-zinc-600\",\n  selectInputWhite: \"!text-gray-50\",\n  selectInputSizeDefault: \"py-[0.32rem] px-3 leading-[1.6]\",\n  selectInputSizeLg: \"py-[0.32rem] px-3 leading-[2.15]\",\n  selectInputSizeSm: \"py-[0.33rem] px-3 text-xs leading-[1.5]\",\n  selectLabel: \"pointer-events-none absolute top-0 left-3 mb-0 max-w-[90%] origin-[0_0] truncate text-gray-500 transition-all duration-200 ease-out peer-focus:scale-[0.8] peer-focus:text-primary peer-data-[te-input-state-active]:scale-[0.8] motion-reduce:transition-none dark:text-gray-200 dark:peer-focus:text-gray-200 data-[te-input-state-active]:scale-[0.8] dark:peer-focus:text-primary\",\n  selectLabelWhite: \"!text-gray-50\",\n  selectLabelSizeDefault: \"pt-[0.37rem] leading-[1.6] peer-focus:-translate-y-[0.9rem] peer-data-[te-input-state-active]:-translate-y-[0.9rem] data-[te-input-state-active]:-translate-y-[0.9rem]\",\n  selectLabelSizeLg: \"pt-[0.37rem] leading-[2.15] peer-focus:-translate-y-[1.15rem] peer-data-[te-input-state-active]:-translate-y-[1.15rem] data-[te-input-state-active]:-translate-y-[1.15rem]\",\n  selectLabelSizeSm: \"pt-[0.37rem] text-xs leading-[1.5] peer-focus:-translate-y-[0.75rem] peer-data-[te-input-state-active]:-translate-y-[0.75rem] data-[te-input-state-active]:-translate-y-[0.75rem]\",\n  selectOption: \"flex flex-row items-center justify-between w-full px-4 truncate text-gray-700 bg-transparent select-none cursor-pointer data-[te-input-multiple-active]:bg-black/5 hover:[&:not([data-te-select-option-disabled])]:bg-black/5 data-[te-input-state-active]:bg-black/5 data-[te-select-option-selected]:data-[te-input-state-active]:bg-black/5 data-[te-select-selected]:data-[te-select-option-disabled]:cursor-default data-[te-select-selected]:data-[te-select-option-disabled]:text-gray-400 data-[te-select-selected]:data-[te-select-option-disabled]:bg-transparent data-[te-select-option-selected]:bg-black/[0.02] data-[te-select-option-disabled]:text-gray-400 data-[te-select-option-disabled]:cursor-default group-data-[te-select-option-group-ref]/opt:pl-7 dark:text-gray-200 dark:hover:[&:not([data-te-select-option-disabled])]:bg-white/30 dark:data-[te-input-state-active]:bg-white/30 dark:data-[te-select-option-selected]:data-[te-input-state-active]:bg-white/30 dark:data-[te-select-option-disabled]:text-gray-400 dark:data-[te-input-multiple-active]:bg-white/30\",\n  selectOptionGroup: \"group/opt\",\n  selectOptionGroupLabel: \"flex flex-row items-center w-full px-4 truncate bg-transparent text-black/50 select-none dark:text-gray-300\",\n  selectOptionIcon: \"w-7 h-7 rounded-full\",\n  selectOptionSecondaryText: \"block text-[0.8rem] text-gray-500 dark:text-gray-300\",\n  selectOptionText: \"group\",\n  selectValidationValid: \"hidden absolute -mt-3 w-auto text-sm text-green-600 cursor-pointer group-data-[te-was-validated]/validation:peer-valid:block\",\n  selectValidationInvalid: \"hidden absolute -mt-3 w-auto text-sm text-[rgb(220,76,100)] cursor-pointer group-data-[te-was-validated]/validation:peer-invalid:block\"\n}, ub = {\n  dropdown: \"string\",\n  formCheckInput: \"string\",\n  formOutline: \"string\",\n  initialized: \"string\",\n  inputGroup: \"string\",\n  noResult: \"string\",\n  optionsList: \"string\",\n  optionsWrapper: \"string\",\n  optionsWrapperScrollbar: \"string\",\n  selectArrow: \"string\",\n  selectArrowDefault: \"string\",\n  selectArrowLg: \"string\",\n  selectArrowSm: \"string\",\n  selectClearBtn: \"string\",\n  selectClearBtnDefault: \"string\",\n  selectClearBtnLg: \"string\",\n  selectClearBtnSm: \"string\",\n  selectDropdownContainer: \"string\",\n  selectFakeValue: \"string\",\n  selectFilterInput: \"string\",\n  selectInput: \"string\",\n  selectInputSizeDefault: \"string\",\n  selectInputSizeLg: \"string\",\n  selectInputSizeSm: \"string\",\n  selectLabel: \"string\",\n  selectLabelSizeDefault: \"string\",\n  selectLabelSizeLg: \"string\",\n  selectLabelSizeSm: \"string\",\n  selectOption: \"string\",\n  selectOptionGroup: \"string\",\n  selectOptionGroupLabel: \"string\",\n  selectOptionIcon: \"string\",\n  selectOptionSecondaryText: \"string\",\n  selectOptionText: \"string\"\n};\nclass _r {\n  constructor(t, e, i) {\n    this._element = t, this._config = this._getConfig(e), this._classes = this._getClasses(i), this._config.selectPlaceholder && !this._config.multiple && this._addPlaceholderOption(), this._optionsToRender = this._getOptionsToRender(t), this._plainOptions = this._getPlainOptions(this._optionsToRender), this._filteredOptionsList = null, this._selectionModel = new Tg(this.multiple), this._activeOptionIndex = -1, this._activeOption = null, this._wrapperId = rt(\"select-wrapper-\"), this._dropdownContainerId = rt(\"select-dropdown-container-\"), this._selectAllId = rt(\"select-all-\"), this._debounceTimeoutId = null, this._dropdownHeight = this._config.selectOptionHeight * this._config.selectVisibleOptions, this._popper = null, this._input = null, this._label = d.next(this._element, Jg)[0], this._notch = null, this._fakeValue = null, this._isFakeValueActive = !1, this._customContent = d.next(\n      t,\n      ob\n    )[0], this._toggleButton = null, this._elementToggle = null, this._wrapper = null, this._inputEl = null, this._dropdownContainer = null, this._container = null, this._selectAllOption = null, this._init(), this._mutationObserver = null, this._isOpen = !1, this._addMutationObserver(), this._element && y.setData(t, vi, this);\n  }\n  static get NAME() {\n    return oo;\n  }\n  get filterInput() {\n    return d.findOne(\n      tb,\n      this._dropdownContainer\n    );\n  }\n  get dropdown() {\n    return d.findOne(eb, this._dropdownContainer);\n  }\n  get optionsList() {\n    return d.findOne(\n      pl,\n      this._dropdownContainer\n    );\n  }\n  get optionsWrapper() {\n    return d.findOne(\n      ib,\n      this._dropdownContainer\n    );\n  }\n  get clearButton() {\n    return d.findOne(nb, this._wrapper);\n  }\n  get options() {\n    return this._filteredOptionsList ? this._filteredOptionsList : this._plainOptions;\n  }\n  get value() {\n    return this.multiple ? this._selectionModel.values : this._selectionModel.value;\n  }\n  get multiple() {\n    return this._config.multiple;\n  }\n  get hasSelectAll() {\n    return this.multiple && this._config.selectAll;\n  }\n  get hasSelection() {\n    return this._selectionModel.selection || this._selectionModel.selections.length > 0;\n  }\n  _getConfig(t) {\n    const e = h.getDataAttributes(this._element);\n    return t = {\n      ...cb,\n      ...e,\n      ...t\n    }, this._element.hasAttribute(\"multiple\") && (t.multiple = !0), this._element.hasAttribute(\"disabled\") && (t.disabled = !0), this._element.tabIndex && (t.tabIndex = this._element.getAttribute(\"tabIndex\")), D(oo, t, hb), t;\n  }\n  _getClasses(t) {\n    const e = h.getDataClassAttributes(this._element);\n    return t = {\n      ...db,\n      ...e,\n      ...t\n    }, D(oo, t, ub), t;\n  }\n  _addPlaceholderOption() {\n    const t = new Option(\"\", \"\", !0, !0);\n    t.hidden = !0, t.selected = !0, this._element.prepend(t);\n  }\n  _getOptionsToRender(t) {\n    const e = [];\n    return t.childNodes.forEach((n) => {\n      if (n.nodeName === \"OPTGROUP\") {\n        const o = {\n          id: rt(\"group-\"),\n          label: n.label,\n          disabled: n.hasAttribute(\"disabled\"),\n          hidden: n.hasAttribute(\"hidden\"),\n          options: []\n        };\n        n.childNodes.forEach((a) => {\n          a.nodeName === \"OPTION\" && o.options.push(\n            this._createOptionObject(a, o)\n          );\n        }), e.push(o);\n      } else\n        n.nodeName === \"OPTION\" && e.push(this._createOptionObject(n));\n    }), e;\n  }\n  _getPlainOptions(t) {\n    if (!d.findOne(\"optgroup\", this._element))\n      return t;\n    const i = [];\n    return t.forEach((n) => {\n      Object.prototype.hasOwnProperty.call(\n        n,\n        \"options\"\n      ) ? n.options.forEach((r) => {\n        i.push(r);\n      }) : i.push(n);\n    }), i;\n  }\n  _createOptionObject(t, e = {}) {\n    const i = rt(\"option-\"), n = e.id ? e.id : null, o = e.disabled ? e.disabled : !1, r = t.selected || t.hasAttribute(pi), a = t.hasAttribute(\"disabled\") || o, l = t.hasAttribute(\"hidden\") || e && e.hidden, p = this.multiple, u = t.value, _ = t.label, f = h.getDataAttribute(\n      t,\n      \"selectSecondaryText\"\n    ), g = h.getDataAttribute(t, \"select-icon\");\n    return new rl(\n      i,\n      t,\n      p,\n      u,\n      _,\n      r,\n      a,\n      l,\n      f,\n      n,\n      g\n    );\n  }\n  _getNavigationOptions() {\n    const t = this.options.filter((e) => !e.hidden);\n    return this.hasSelectAll ? [this._selectAllOption, ...t] : t;\n  }\n  _init() {\n    this._renderMaterialWrapper(), this._wrapper = d.findOne(`#${this._wrapperId}`), this._input = d.findOne(ul, this._wrapper), this._config.disabled && this._input.setAttribute(ro, \"\");\n    const t = this._config.selectContainer;\n    t === \"body\" ? this._container = document.body : this._container = d.findOne(t), this._initOutlineInput(), this._setDefaultSelections(), this._updateInputValue(), this._appendFakeValue(), this._updateFakeLabelPosition(), this._updateLabelPosition(), this._updateClearButtonVisibility(), this._bindComponentEvents(), this.hasSelectAll && (this._selectAllOption = this._createSelectAllOption()), this._dropdownContainer = al(\n      this._dropdownContainerId,\n      this._config,\n      this._input.offsetWidth,\n      this._dropdownHeight,\n      this._selectAllOption,\n      this._optionsToRender,\n      this._customContent,\n      this._classes\n    ), this._setFirstActiveOption(), this._listenToFocusChange();\n  }\n  _renderMaterialWrapper() {\n    const t = Pg(\n      this._wrapperId,\n      this._config,\n      this._label,\n      this._classes,\n      this._element.name\n    );\n    this._element.parentNode.insertBefore(t, this._element), h.addClass(this._element, this._classes.initialized), t.appendChild(this._element);\n  }\n  _initOutlineInput() {\n    const t = d.findOne(\n      _l,\n      this._wrapper\n    );\n    new V(\n      t,\n      {\n        inputFormWhite: this._config.selectFormWhite\n      },\n      this._classes\n    ).init(), this._notch = d.findOne(ao, this._wrapper);\n  }\n  _bindComponentEvents() {\n    this._listenToComponentKeydown(), this._listenToWrapperClick(), this._listenToClearBtnClick(), this._listenToClearBtnKeydown();\n  }\n  _setDefaultSelections() {\n    this.options.forEach((t) => {\n      t.selected && this._selectionModel.select(t);\n    });\n  }\n  _listenToComponentKeydown() {\n    c.on(this._wrapper, \"keydown\", this._handleKeydown.bind(this));\n  }\n  _handleKeydown(t) {\n    this._isOpen && !this._config.selectFilter ? this._handleOpenKeydown(t) : this._handleClosedKeydown(t);\n  }\n  _handleOpenKeydown(t) {\n    const e = t.keyCode, i = e === Fi || e === at && t.altKey || e === Pi;\n    if (e === Pi && this._config.selectAutoSelect && !this.multiple && this._handleAutoSelection(this._activeOption), i) {\n      this.close(), this._input.focus();\n      return;\n    }\n    switch (e) {\n      case z:\n        this._setNextOptionActive(), this._scrollToOption(this._activeOption);\n        break;\n      case at:\n        this._setPreviousOptionActive(), this._scrollToOption(this._activeOption);\n        break;\n      case We:\n        this._setFirstOptionActive(), this._scrollToOption(this._activeOption);\n        break;\n      case Fe:\n        this._setLastOptionActive(), this._scrollToOption(this._activeOption);\n        break;\n      case ct:\n        t.preventDefault(), this._activeOption && (this.hasSelectAll && this._activeOptionIndex === 0 ? this._handleSelectAll() : this._handleSelection(this._activeOption));\n        return;\n      default:\n        return;\n    }\n    t.preventDefault();\n  }\n  _handleClosedKeydown(t) {\n    const e = t.keyCode;\n    if (e === ct && t.preventDefault(), (e === ct || e === z && t.altKey || e === z && this.multiple) && this.open(), this.multiple)\n      switch (e) {\n        case z:\n          this.open();\n          break;\n        case at:\n          this.open();\n          break;\n        default:\n          return;\n      }\n    else\n      switch (e) {\n        case z:\n          this._setNextOptionActive(), this._handleSelection(this._activeOption);\n          break;\n        case at:\n          this._setPreviousOptionActive(), this._handleSelection(this._activeOption);\n          break;\n        case We:\n          this._setFirstOptionActive(), this._handleSelection(this._activeOption);\n          break;\n        case Fe:\n          this._setLastOptionActive(), this._handleSelection(this._activeOption);\n          break;\n        default:\n          return;\n      }\n    t.preventDefault();\n  }\n  _scrollToOption(t) {\n    if (!t)\n      return;\n    let e;\n    const i = this.options.filter((u) => !u.hidden);\n    this.hasSelectAll ? e = i.indexOf(t) + 1 : e = i.indexOf(t);\n    const n = this._getNumberOfGroupsBeforeOption(e), o = e + n, r = this.optionsWrapper, a = r.offsetHeight, l = this._config.selectOptionHeight, p = r.scrollTop;\n    if (e > -1) {\n      const u = o * l, _ = u + l > p + a;\n      u < p ? r.scrollTop = u : _ ? r.scrollTop = u - a + l : r.scrollTop = p;\n    }\n  }\n  _getNumberOfGroupsBeforeOption(t) {\n    const e = this.options.filter((r) => !r.hidden), i = this._optionsToRender.filter((r) => !r.hidden), n = this.hasSelectAll ? t - 1 : t;\n    let o = 0;\n    for (let r = 0; r <= n; r++)\n      e[r].groupId && i[o] && i[o].id && e[r].groupId === i[o].id && o++;\n    return o;\n  }\n  _setNextOptionActive() {\n    let t = this._activeOptionIndex + 1;\n    const e = this._getNavigationOptions();\n    if (e[t]) {\n      for (; e[t].disabled; )\n        if (t += 1, !e[t])\n          return;\n      this._updateActiveOption(e[t], t);\n    }\n  }\n  _setPreviousOptionActive() {\n    let t = this._activeOptionIndex - 1;\n    const e = this._getNavigationOptions();\n    if (e[t]) {\n      for (; e[t].disabled; )\n        if (t -= 1, !e[t])\n          return;\n      this._updateActiveOption(e[t], t);\n    }\n  }\n  _setFirstOptionActive() {\n    const e = this._getNavigationOptions();\n    this._updateActiveOption(e[0], 0);\n  }\n  _setLastOptionActive() {\n    const t = this._getNavigationOptions(), e = t.length - 1;\n    this._updateActiveOption(t[e], e);\n  }\n  _updateActiveOption(t, e) {\n    const i = this._activeOption;\n    i && i.removeActiveStyles(), t.setActiveStyles(), this._activeOptionIndex = e, this._activeOption = t;\n  }\n  _listenToWrapperClick() {\n    c.on(this._wrapper, \"click\", () => {\n      this.toggle();\n    });\n  }\n  _listenToClearBtnClick() {\n    c.on(this.clearButton, \"click\", (t) => {\n      t.preventDefault(), t.stopPropagation(), this._handleClear();\n    });\n  }\n  _listenToClearBtnKeydown() {\n    c.on(this.clearButton, \"keydown\", (t) => {\n      t.keyCode === ct && (this._handleClear(), t.preventDefault(), t.stopPropagation());\n    });\n  }\n  _handleClear() {\n    if (this.multiple)\n      this._selectionModel.clear(), this._deselectAllOptions(this.options), this.hasSelectAll && this._updateSelectAllState();\n    else {\n      const t = this._selectionModel.selection;\n      this._selectionModel.clear(), t.deselect();\n    }\n    this._fakeValue.innerHTML = \"\", this._updateInputValue(), this._updateFakeLabelPosition(), this._updateLabelPosition(), this._updateClearButtonVisibility(), this._emitValueChangeEvent(null), this._emitNativeChangeEvent();\n  }\n  _listenToOptionsClick() {\n    c.on(this.optionsWrapper, \"click\", (t) => {\n      if (t.target.hasAttribute(\n        Zg\n      ))\n        return;\n      const i = t.target.nodeName === \"DIV\" ? t.target : d.closest(t.target, sb);\n      if (i.hasAttribute(Qg)) {\n        this._handleSelectAll();\n        return;\n      }\n      const o = i.dataset.teId, r = this.options.find((a) => a.id === o);\n      r && !r.disabled && this._handleSelection(r);\n    });\n  }\n  _handleSelectAll() {\n    this._selectAllOption.selected ? (this._deselectAllOptions(this.options), this._selectAllOption.deselect()) : (this._selectAllOptions(this.options), this._selectAllOption.select()), this._updateInputValue(), this._updateFakeLabelPosition(), this._updateLabelPosition(), this._updateClearButtonVisibility(), this._emitValueChangeEvent(this.value), this._emitNativeChangeEvent();\n  }\n  _selectAllOptions(t) {\n    t.forEach((e) => {\n      !e.selected && !e.disabled && (this._selectionModel.select(e), e.select());\n    });\n  }\n  _deselectAllOptions(t) {\n    t.forEach((e) => {\n      e.selected && !e.disabled && (this._selectionModel.deselect(e), e.deselect());\n    });\n  }\n  _handleSelection(t) {\n    this.multiple ? (this._handleMultiSelection(t), this.hasSelectAll && this._updateSelectAllState()) : this._handleSingleSelection(t), this._updateInputValue(), this._updateFakeLabelPosition(), this._updateLabelPosition(), this._updateClearButtonVisibility();\n  }\n  _handleAutoSelection(t) {\n    this._singleOptionSelect(t), this._updateInputValue(), this._updateFakeLabelPosition(), this._updateLabelPosition(), this._updateClearButtonVisibility();\n  }\n  _handleSingleSelection(t) {\n    this._singleOptionSelect(t), this.close(), this._input.focus();\n  }\n  _singleOptionSelect(t) {\n    const e = this._selectionModel.selections[0];\n    e && e !== t && (this._selectionModel.deselect(e), e.deselect(), e.node.setAttribute(pi, !1), c.trigger(this._element, cl, {\n      value: e.value\n    })), (!e || e && t !== e) && (this._selectionModel.select(t), t.select(), t.node.setAttribute(pi, !0), c.trigger(this._element, ll, {\n      value: t.value\n    }), this._emitValueChangeEvent(this.value), this._emitNativeChangeEvent());\n  }\n  _handleMultiSelection(t) {\n    t.selected ? (this._selectionModel.deselect(t), t.deselect(), t.node.setAttribute(pi, !1), c.trigger(this._element, cl, {\n      value: t.value\n    })) : (this._selectionModel.select(t), t.select(), t.node.setAttribute(pi, !0), c.trigger(this._element, ll, {\n      value: t.value\n    })), this._emitValueChangeEvent(this.value), this._emitNativeChangeEvent();\n  }\n  _emitValueChangeEvent(t) {\n    c.trigger(this._element, Gg, { value: t });\n  }\n  _emitNativeChangeEvent() {\n    c.trigger(this._element, qg);\n  }\n  _updateInputValue() {\n    const t = this.multiple ? this._selectionModel.labels : this._selectionModel.label;\n    let e;\n    this.multiple && this._config.selectDisplayedLabels !== -1 && this._selectionModel.selections.length > this._config.selectDisplayedLabels ? e = `${this._selectionModel.selections.length} ${this._config.selectOptionsSelectedLabel}` : e = t, !this.multiple && !this._isSelectionValid(this._selectionModel.selection) ? this._input.value = \"\" : this._isLabelEmpty(this._selectionModel.selection) ? this._input.value = \" \" : e ? this._input.value = e : this.multiple || !this._optionsToRender[0] ? this._input.value = \"\" : this._input.value = this._optionsToRender[0].label;\n  }\n  _isSelectionValid(t) {\n    return !(t && (t.disabled || t.value === \"\"));\n  }\n  _isLabelEmpty(t) {\n    return !!(t && t.label === \"\");\n  }\n  _appendFakeValue() {\n    if (!this._selectionModel.selection || this._selectionModel._multiple)\n      return;\n    const t = this._selectionModel.selection.label;\n    this._fakeValue = zg(t, this._classes), d.findOne(\n      _l,\n      this._wrapper\n    ).appendChild(this._fakeValue);\n  }\n  _updateLabelPosition() {\n    const t = this._element.hasAttribute(hl), e = this._input.value !== \"\";\n    this._label && (t && (e || this._isOpen || this._isFakeValueActive) ? (this._label.setAttribute(q, \"\"), this._notch.setAttribute(q, \"\")) : (this._label.removeAttribute(q), this._notch.removeAttribute(q, \"\")));\n  }\n  _updateLabelPositionWhileClosing() {\n    this._label && (this._input.value !== \"\" || this._isFakeValueActive ? (this._label.setAttribute(q, \"\"), this._notch.setAttribute(q, \"\")) : (this._label.removeAttribute(q), this._notch.removeAttribute(q)));\n  }\n  _updateFakeLabelPosition() {\n    this._fakeValue && (this._input.value === \"\" && this._fakeValue.innerHTML !== \"\" && !this._config.selectPlaceholder ? (this._isFakeValueActive = !0, this._fakeValue.setAttribute(q, \"\")) : (this._isFakeValueActive = !1, this._fakeValue.removeAttribute(q)));\n  }\n  _updateClearButtonVisibility() {\n    if (!this.clearButton)\n      return;\n    this._selectionModel.selection || this._selectionModel.selections.length > 0 ? h.addStyle(this.clearButton, { display: \"block\" }) : h.addStyle(this.clearButton, { display: \"none\" });\n  }\n  _updateSelectAllState() {\n    const t = this._selectAllOption.selected, e = Vo(this.options);\n    !e && t ? this._selectAllOption.deselect() : e && !t && this._selectAllOption.select();\n  }\n  toggle() {\n    this._isOpen ? this.close() : this.open();\n  }\n  open() {\n    const t = this._config.disabled, e = c.trigger(this._element, Xg);\n    this._isOpen || t || e.defaultPrevented || (this._openDropdown(), this._updateDropdownWidth(), this._setFirstActiveOption(), this._scrollToOption(this._activeOption), this._config.selectFilter && (setTimeout(() => {\n      this.filterInput.focus();\n    }, 0), this._listenToSelectSearch(), this._listenToDropdownKeydown()), this._listenToOptionsClick(), this._listenToOutsideClick(), this._listenToWindowResize(), this._isOpen = !0, this._updateLabelPosition(), this._setInputActiveStyles());\n  }\n  _openDropdown() {\n    this._popper = Ce(this._input, this._dropdownContainer, {\n      placement: \"bottom-start\",\n      modifiers: [\n        {\n          name: \"offset\",\n          options: {\n            offset: [0, 1]\n          }\n        }\n      ]\n    }), this._container.appendChild(this._dropdownContainer), setTimeout(() => {\n      this.dropdown.setAttribute(dl, \"\");\n    }, 0);\n  }\n  _updateDropdownWidth() {\n    const t = this._input.offsetWidth;\n    h.addStyle(this._dropdownContainer, { width: `${t}px` });\n  }\n  _setFirstActiveOption() {\n    const t = this._getNavigationOptions(), e = this._activeOption;\n    e && e.removeActiveStyles();\n    const i = this.multiple ? this._selectionModel.selections[0] : this._selectionModel.selection;\n    i ? (this._activeOption = i, i.setActiveStyles(), this._activeOptionIndex = t.findIndex(\n      (n) => n === i\n    )) : (this._activeOption = null, this._activeOptionIndex = -1);\n  }\n  _setInputActiveStyles() {\n    this._input.setAttribute(Kt, \"\"), d.findOne(ao, this._wrapper).setAttribute(\n      Kt,\n      \"\"\n    );\n  }\n  _listenToWindowResize() {\n    c.on(window, \"resize\", this._handleWindowResize.bind(this));\n  }\n  _handleWindowResize() {\n    this._dropdownContainer && this._updateDropdownWidth();\n  }\n  _listenToSelectSearch() {\n    this.filterInput.addEventListener(\"input\", (t) => {\n      const e = t.target.value, i = this._config.selectFilterDebounce;\n      this._debounceFilter(e, i);\n    });\n  }\n  _debounceFilter(t, e) {\n    this._debounceTimeoutId && clearTimeout(this._debounceTimeoutId), this._debounceTimeoutId = setTimeout(() => {\n      this._filterOptions(t);\n    }, e);\n  }\n  _filterOptions(t) {\n    const e = [];\n    this._optionsToRender.forEach((o) => {\n      const r = Object.prototype.hasOwnProperty.call(\n        o,\n        \"options\"\n      ), a = !r && o.label.toLowerCase().includes(t.toLowerCase()), l = {};\n      r && (l.label = o.label, l.options = this._filter(t, o.options), l.options.length > 0 && e.push(l)), a && e.push(o);\n    });\n    const i = this._config.selectNoResultText !== \"\", n = e.length !== 0;\n    if (n)\n      this._updateOptionsListTemplate(e), this._popper.forceUpdate(), this._filteredOptionsList = this._getPlainOptions(e), this.hasSelectAll && this._updateSelectAllState(), this._setFirstActiveOption();\n    else if (!n && i) {\n      const o = this._getNoResultTemplate();\n      this.optionsWrapper.innerHTML = o;\n    }\n  }\n  _updateOptionsListTemplate(t) {\n    const e = d.findOne(pl, this._dropdownContainer) || d.findOne(rb, this._dropdownContainer), i = eh(\n      t,\n      this._selectAllOption,\n      this._config,\n      this._classes\n    );\n    this.optionsWrapper.removeChild(e), this.optionsWrapper.appendChild(i);\n  }\n  _getNoResultTemplate() {\n    return `<div class=\"${this._classes.noResult}\" ${oh} style=\"height: ${this._config.selectOptionHeight}px\">${this._config.selectNoResultText}</div>`;\n  }\n  _filter(t, e) {\n    const i = t.toLowerCase();\n    return e.filter(\n      (n) => n.label.toLowerCase().includes(i)\n    );\n  }\n  _listenToDropdownKeydown() {\n    c.on(\n      this.dropdown,\n      \"keydown\",\n      this._handleOpenKeydown.bind(this)\n    );\n  }\n  _listenToOutsideClick() {\n    this._outsideClick = this._handleOutSideClick.bind(this), c.on(document, \"click\", this._outsideClick);\n  }\n  _listenToFocusChange(t = !0) {\n    if (t === !1) {\n      c.off(\n        this._input,\n        \"focus\",\n        () => this._notch.setAttribute(Kt, \"\")\n      ), c.off(\n        this._input,\n        \"blur\",\n        () => this._notch.removeAttribute(Kt)\n      );\n      return;\n    }\n    c.on(\n      this._input,\n      \"focus\",\n      () => this._notch.setAttribute(Kt, \"\")\n    ), c.on(\n      this._input,\n      \"blur\",\n      () => this._notch.removeAttribute(Kt)\n    );\n  }\n  _handleOutSideClick(t) {\n    const e = this._wrapper && this._wrapper.contains(t.target), i = t.target === this._dropdownContainer, n = this._dropdownContainer && this._dropdownContainer.contains(t.target);\n    let o;\n    this._toggleButton || (this._elementToggle = d.find(ab)), this._elementToggle && this._elementToggle.forEach((r) => {\n      const a = h.getDataAttribute(\n        r,\n        \"select-toggle\"\n      );\n      (a === this._element.id || this._element.classList.contains(a)) && (this._toggleButton = r, o = this._toggleButton.contains(t.target));\n    }), !e && !i && !n && !o && this.close();\n  }\n  close() {\n    const t = c.trigger(this._element, Ug);\n    !this._isOpen || t.defaultPrevented || (this._config.selectFilter && this.hasSelectAll && (this._resetFilterState(), this._updateOptionsListTemplate(this._optionsToRender), this._config.multiple && this._updateSelectAllState()), this._removeDropdownEvents(), this.dropdown.removeAttribute(dl), setTimeout(() => {\n      this._input.removeAttribute(Kt), this._input.blur(), d.findOne(ao, this._wrapper).removeAttribute(\n        Kt\n      ), this._label && !this.hasSelection && (this._label.removeAttribute(q), this._notch.setAttribute(q, \"\"), this._input.removeAttribute(q), this._notch.removeAttribute(q)), this._updateLabelPositionWhileClosing();\n    }, 0), setTimeout(() => {\n      this._container && this._dropdownContainer.parentNode === this._container && this._container.removeChild(this._dropdownContainer), this._popper.destroy(), this._isOpen = !1, c.off(this.dropdown, \"transitionend\");\n    }, lb));\n  }\n  _resetFilterState() {\n    this.filterInput.value = \"\", this._filteredOptionsList = null;\n  }\n  _removeDropdownEvents() {\n    c.off(document, \"click\", this._outsideClick), this._config.selectFilter && c.off(this.dropdown, \"keydown\"), c.off(this.optionsWrapper, \"click\");\n  }\n  _addMutationObserver() {\n    this._mutationObserver = new MutationObserver(() => {\n      this._wrapper && (this._updateSelections(), this._updateDisabledState());\n    }), this._observeMutationObserver();\n  }\n  _updateSelections() {\n    this._optionsToRender = this._getOptionsToRender(this._element), this._plainOptions = this._getPlainOptions(this._optionsToRender), this._selectionModel.clear(), this._setDefaultSelections(), this._updateInputValue(), this._updateFakeLabelPosition(), this._updateLabelPosition(), this._updateClearButtonVisibility(), this.hasSelectAll && this._updateSelectAllState();\n    const t = this._config.filter && this.filterInput && this.filterInput.value;\n    this._isOpen && !t ? (this._updateOptionsListTemplate(this._optionsToRender), this._setFirstActiveOption()) : this._isOpen && t ? (this._filterOptions(this.filterInput.value), this._setFirstActiveOption()) : this._dropdownContainer = al(\n      this._dropdownContainerId,\n      this._config,\n      this._input.offsetWidth,\n      this._dropdownHeight,\n      this._selectAllOption,\n      this._optionsToRender,\n      this._customContent,\n      this._classes\n    );\n  }\n  _updateDisabledState() {\n    const t = d.findOne(ul, this._wrapper);\n    this._element.hasAttribute(\"disabled\") ? (this._config.disabled = !0, t.setAttribute(\"disabled\", \"\"), t.setAttribute(ro, \"\")) : (this._config.disabled = !1, t.removeAttribute(\"disabled\"), t.removeAttribute(ro));\n  }\n  _observeMutationObserver() {\n    this._mutationObserver && this._mutationObserver.observe(this._element, {\n      attributes: !0,\n      childList: !0,\n      characterData: !0,\n      subtree: !0\n    });\n  }\n  _disconnectMutationObserver() {\n    this.mutationObserver && (this._mutationObserver.disconnect(), this._mutationObserver = null);\n  }\n  _createSelectAllOption() {\n    const t = this._selectAllId, e = null, i = !0, n = \"select-all\", o = this._config.selectAllLabel, r = Vo(this.options), a = !1, l = !1, p = null, u = null, _ = null;\n    return new rl(\n      t,\n      e,\n      i,\n      n,\n      o,\n      r,\n      a,\n      l,\n      p,\n      u,\n      _\n    );\n  }\n  dispose() {\n    this._removeComponentEvents(), this._destroyMaterialSelect(), this._listenToFocusChange(!1), y.removeData(this._element, vi);\n  }\n  _removeComponentEvents() {\n    c.off(this.input, \"click\"), c.off(this.wrapper, this._handleKeydown.bind(this)), c.off(this.clearButton, \"click\"), c.off(this.clearButton, \"keydown\"), c.off(window, \"resize\", this._handleWindowResize.bind(this));\n  }\n  _destroyMaterialSelect() {\n    this._isOpen && this.close(), this._destroyMaterialTemplate();\n  }\n  _destroyMaterialTemplate() {\n    const t = this._wrapper.parentNode, e = d.find(\"label\", this._wrapper);\n    t.appendChild(this._element), e.forEach((i) => {\n      t.appendChild(i);\n    }), e.forEach((i) => {\n      i.removeAttribute(q);\n    }), h.removeClass(this._element, this._classes.initialized), this._element.removeAttribute(hl), t.removeChild(this._wrapper);\n  }\n  setValue(t) {\n    this.options.filter((i) => i.selected).forEach((i) => i.nativeOption.selected = !1), Array.isArray(t) ? t.forEach((i) => {\n      this._selectByValue(i);\n    }) : this._selectByValue(t), this._updateSelections();\n  }\n  _selectByValue(t) {\n    const e = this.options.find(\n      (i) => i.value === t\n    );\n    return e ? (e.nativeOption.selected = !0, !0) : !1;\n  }\n  static jQueryInterface(t, e) {\n    return this.each(function() {\n      let i = y.getData(this, vi);\n      const n = typeof t == \"object\" && t;\n      if (!(!i && /dispose/.test(t)) && (i || (i = new _r(this, n)), typeof t == \"string\")) {\n        if (typeof i[t] > \"u\")\n          throw new TypeError(`No method named \"${t}\"`);\n        i[t](e);\n      }\n    });\n  }\n  static getInstance(t) {\n    return y.getData(t, vi);\n  }\n  static getOrCreateInstance(t, e = {}) {\n    return this.getInstance(t) || new this(t, typeof e == \"object\" ? e : null);\n  }\n}\nconst pb = ({ inputID: s, labelText: t }, e) => `<div data-te-chips-input-wrapper data-te-input-wrapper-init class=\"${e.chipsInputWrapper}\">\n      <input\n          type=\"text\"\n          class=\"${e.chipsInput}\"\n          id=\"${s}\"\n          placeholder=\"Example label\" />\n        <label\n          for=\"${s}\"\n          class=\"${e.chipsLabel}\"\n          >${t}\n        </label>\n      </div>\n    </div>`, _b = ({ text: s, iconSVG: t }, e) => `<div data-te-chip-init data-te-ripple-init class=\"${e.chipElement}\">\n    <span data-te-chip-text>${s}</span> \n      <span data-te-chip-close class=\"${e.chipCloseIcon}\">\n        ${t}\n      </span>\n  </div>`, Gs = \"chip\", fb = `te.${Gs}`, rh = \"data-te-chip-close\", lo = `[${rh}]`, mb = \"delete.te.chips\", gb = \"select.te.chip\", bb = '<svg xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" viewBox=\"0 0 24 24\" stroke-width=\"1.5\" stroke=\"currentColor\" class=\"w-3 h-3\"> <path stroke-linecap=\"round\" stroke-linejoin=\"round\" d=\"M6 18L18 6M6 6l12 12\" /></svg>', vb = {\n  text: \"string\",\n  closeIcon: \"boolean\",\n  img: \"object\",\n  iconSVG: \"string\"\n}, Tb = {\n  text: \"\",\n  closeIcon: !1,\n  img: { path: \"\", alt: \"\" },\n  iconSVG: bb\n}, Eb = {\n  icon: \"float-right pl-[8px] text-[16px] opacity-[.53] cursor-pointer fill-[#afafaf] hover:text-[#8b8b8b] transition-all duration-200 ease-in-out\",\n  chipElement: \"flex justify-between items-center h-[32px] leading-loose py-[5px] px-[12px] mr-4 my-[5px] text-[13px] font-normal text-[#4f4f4f] cursor-pointer bg-[#eceff1] dark:text-white dark:bg-neutral-600 rounded-[16px] transition-[opacity] duration-300 ease-linear [word-wrap: break-word] shadow-none normal-case hover:!shadow-none active:bg-[#cacfd1] inline-block font-medium leading-normal text-[#4f4f4f] text-center no-underline align-middle cursor-pointer select-none border-[.125rem] border-solid border-transparent py-1.5 px-3 text-xs rounded\",\n  chipCloseIcon: \"w-4 float-right pl-[8px] text-[16px] opacity-[.53] cursor-pointer fill-[#afafaf] hover:fill-[#8b8b8b] dark:fill-gray-400 dark:hover:fill-gray-100 transition-all duration-200 ease-in-out\"\n}, Cb = {\n  icon: \"string\",\n  chipElement: \"string\",\n  chipCloseIcon: \"string\"\n};\nclass _i {\n  constructor(t, e = {}, i) {\n    this._element = t, this._options = this._getConfig(e), this._classes = this._getClasses(i);\n  }\n  // Getters\n  static get NAME() {\n    return Gs;\n  }\n  // Public\n  init() {\n    this._appendCloseIcon(), this._handleDelete(), this._handleTextChip(), this._handleClickOnChip();\n  }\n  dispose() {\n    this._element = null, this._options = null, c.off(this._element, \"click\");\n  }\n  appendChip() {\n    const { text: t, closeIcon: e, iconSVG: i } = this._options;\n    return _b({ text: t, closeIcon: e, iconSVG: i }, this._classes);\n  }\n  // Private\n  _appendCloseIcon(t = this._element) {\n    if (!(d.find(lo, this._element).length > 0) && this._options.closeIcon) {\n      const e = $(\"span\");\n      e.classList = this._classes.icon, e.setAttribute(rh), e.innerHTML = this._options.iconSVG, t.insertAdjacentElement(\"beforeend\", e);\n    }\n  }\n  _handleClickOnChip() {\n    c.on(this._element, \"click\", (t) => {\n      const { textContent: e } = t.target, i = {};\n      i.tag = e.trim(), c.trigger(gb, { event: t, obj: i });\n    });\n  }\n  _handleDelete() {\n    d.find(\n      lo,\n      this._element\n    ).length !== 0 && c.on(this._element, \"click\", lo, () => {\n      c.trigger(this._element, mb), this._element.remove();\n    });\n  }\n  _handleTextChip() {\n    this._element.innerText === \"\" && (this._element.innerText = this._options.text);\n  }\n  _getConfig(t) {\n    const e = {\n      ...Tb,\n      ...h.getDataAttributes(this._element),\n      ...t\n    };\n    return D(Gs, e, vb), e;\n  }\n  _getClasses(t) {\n    const e = h.getDataClassAttributes(this._element);\n    return t = {\n      ...Eb,\n      ...e,\n      ...t\n    }, D(Gs, t, Cb), t;\n  }\n  static getInstance(t) {\n    return y.getData(t, fb);\n  }\n  static getOrCreateInstance(t, e = {}) {\n    return this.getInstance(t) || new this(t, typeof e == \"object\" ? e : null);\n  }\n}\nconst Li = \"chips\", Ki = `data-te-${Li}`, fl = `te.${Li}`, Ab = `${Ki}-input-init`, mt = `${Ki}-active`, ml = `${Ki}-initial`, ah = `${Ki}-placeholder`, yb = `${Ki}-input-wrapper`, Wo = \"data-te-chip-init\", lh = \"data-te-chip-close\", ch = \"data-te-chip-text\", wb = `[${mt}]`, Fo = `[${Wo}]`, kb = `${Fo}${wb}`, co = `[${lh}]`, xb = `[${yb}]`, Ob = `[${ch}]`, Sb = `[${ah}]`, Ib = \"data-te-input-notch-leading-ref\", Db = \"data-te-input-notch-middle-ref\", $b = `[${Ib}]`, Lb = `[${Db}]`, Se = \"data-te-input-state-active\", ho = \"[data-te-input-notch-ref]\", Nb = \"add.te.chips\", Mb = \"arrowDown.te.chips\", Rb = \"arrowLeft.te.chips\", Pb = \"arrowRight.te.chips\", Bb = \"arrowUp.te.chips\", gl = \"delete.te.chips\", bl = \"select.te.chips\", Hb = {\n  inputID: \"string\",\n  parentSelector: \"string\",\n  initialValues: \"array\",\n  editable: \"boolean\",\n  labelText: \"string\",\n  inputClasses: \"object\",\n  inputOptions: \"object\"\n}, Vb = {\n  inputID: rt(\"chips-input-\"),\n  parentSelector: \"\",\n  initialValues: [{ tag: \"init1\" }, { tag: \"init2\" }],\n  editable: !1,\n  labelText: \"Example label\",\n  inputClasses: {},\n  inputOptions: {}\n}, Wb = {\n  opacity: \"opacity-0\",\n  inputWrapperPadding: \"p-[5px]\",\n  transition: \"transition-all duration-300 ease-[cubic-bezier(0.25,0.1,0.25,1)]\",\n  contentEditable: \"outline-none !border-[3px] !border-solid !border-[#b2b3b4]\",\n  chipsInputWrapper: \"relative flex items-center flex-wrap transition-all duration-300 ease-[cubic-bezier(0.25,0.1,0.25,1)]\",\n  chipsInput: \"peer block min-h-[auto] w-[150px] rounded border-0 bg-transparent py-[0.32rem] px-3 leading-[1.6] outline-none transition-all duration-200 ease-linear focus:placeholder:opacity-100 data-[te-input-state-active]:placeholder:opacity-100 motion-reduce:transition-none dark:text-gray-200 dark:placeholder:text-gray-200 [&:not([data-te-input-placeholder-active])]:placeholder:opacity-0\",\n  chipsLabel: \"pointer-events-none absolute top-0 left-3 mb-0 max-w-[90%] origin-[0_0] truncate pt-[0.37rem] leading-[1.6] text-gray-500 transition-all duration-200 ease-out peer-focus:-translate-y-[0.9rem] peer-focus:scale-[0.8] peer-focus:text-primary peer-data-[te-input-state-active]:-translate-y-[0.9rem] peer-data-[te-input-state-active]:scale-[0.8] motion-reduce:transition-none dark:text-gray-200 dark:peer-focus:text-gray-200\"\n}, Fb = {\n  opacity: \"string\",\n  inputWrapperPadding: \"string\",\n  transition: \"string\",\n  contentEditable: \"string\",\n  chipsInputWrapper: \"string\",\n  chipsInput: \"string\",\n  chipsLabel: \"string\"\n};\nclass GC extends _i {\n  constructor(e, i = {}, n) {\n    super(e, i);\n    yt(this, \"_handleBlurInput\", ({ target: e }) => {\n      e.value.length > 0 && this._handleCreateChip(e, e.value), this.allChips.length > 0 ? (e.setAttribute(mt, \"\"), this.input.setAttribute(Se, \"\"), d.findOne(\n        ho,\n        this.input.parentNode\n      ).setAttribute(Se, \"\"), this.chipsInputWrapper.classList.add(\n        ...this._classes.inputWrapperPadding.split(\" \")\n      )) : (e.removeAttribute(mt), this.input.removeAttribute(Se), d.findOne(\n        ho,\n        this.input.parentNode\n      ).removeAttribute(Se), this.chipsInputWrapper.classList.remove(\n        ...this._classes.inputWrapperPadding.split(\" \")\n      )), this.allChips.forEach((i) => i.removeAttribute(mt));\n    });\n    this._element = e, this._inputInstance = null, this._element && y.setData(e, fl, this), this._options = this._getConfig(i), this._classes = this._getClasses(n), this.numberClicks = 0, this.init();\n  }\n  // Getters\n  static get NAME() {\n    return Li;\n  }\n  get activeChip() {\n    return d.findOne(kb, this._element);\n  }\n  get input() {\n    return d.findOne(\"input\", this._element);\n  }\n  get allChips() {\n    return d.find(Fo, this._element);\n  }\n  get chipsInputWrapper() {\n    return d.findOne(xb, this._element);\n  }\n  // Public\n  init() {\n    this._setChipsClass(), this._appendInputToElement(ah), this._handleInitialValue(), this._handleInputText(), this._handleKeyboard(), this._handleChipsOnSelect(), this._handleEditable(), this._handleChipsFocus(), this._handleClicksOnChips(), this._inputInstance._getLabelWidth(), this._inputInstance._applyNotch();\n  }\n  dispose() {\n    this._element = null, this._options = null;\n  }\n  // Private\n  _getNotchData() {\n    this._notchMiddle = d.findOne(\n      Lb,\n      this._element\n    ), this._notchLeading = d.findOne(\n      $b,\n      this._element\n    );\n  }\n  _setChipsClass() {\n    this._element.setAttribute(Ab, \"\");\n  }\n  _handleDeleteEvents(e) {\n    const [i] = this.allChips.slice(-1);\n    if (this.activeChip === null)\n      i.remove(), this._handleEvents(e, gl);\n    else {\n      const n = this.allChips.findIndex((a) => a === this.activeChip), o = this._handleActiveChipAfterRemove(n), r = [];\n      if (this.activeChip === null)\n        return;\n      this.activeChip.remove(), this._handleEvents(e, gl), this.numberClicks = n, o.setAttribute(mt, \"\"), this.allChips.forEach((a) => {\n        a.hasAttribute(mt) && (r.push(a), r.length > 1 && this.allChips.forEach((l) => l.remove()));\n      });\n    }\n  }\n  _handleUpEvents(e) {\n    this.numberClicks += 1, this.numberClicks === this.allChips.length + 1 && (this.numberClicks = 0), this._handleRightKeyboardArrow(this.numberClicks), this._handleEvents(e, Pb), this._handleEvents(e, Bb);\n  }\n  _handleDownEvents(e) {\n    this.numberClicks -= 1, this.numberClicks <= 0 && (this.numberClicks = this.allChips.length), this._handleLeftKeyboardArrow(this.numberClicks), this._handleEvents(e, Rb), this._handleEvents(e, Mb);\n  }\n  _keyboardEvents(e) {\n    const { target: i, keyCode: n, ctrlKey: o } = e;\n    i.value.length > 0 || this.allChips.length === 0 || (n === Nf || n === Mf ? this._handleDeleteEvents(e) : n === Ve || n === at ? this._handleUpEvents(e) : n === He || n === z ? this._handleDownEvents(e) : n === 65 && o && this._handleAddActiveClass());\n  }\n  _handleKeyboard() {\n    c.on(\n      this.input,\n      \"keydown\",\n      (e) => this._keyboardEvents(e)\n    );\n  }\n  _handleEditable() {\n    const { editable: e } = this._options;\n    e && this.allChips.forEach((i) => {\n      c.on(i, \"dblclick\", (n) => {\n        const o = d.findOne(co, i);\n        i.classList.add(...this._classes.contentEditable.split(\" \")), i.contentEditable = !0, i.focus(), setTimeout(() => {\n          h.addStyle(o, { display: \"none\" });\n        }, 200), o.classList.add(...this._classes.opacity.split(\" \")), n.target.textContent, c.trigger(i, bl, {\n          event: n,\n          allChips: this.allChips\n        });\n      }), c.on(document, \"click\", ({ target: n }) => {\n        const o = d.findOne(co, i), r = d.findOne(Ob, i), a = n === i, l = i && i.contains(n);\n        !a && !l && (i.contentEditable = !1, i.classList.remove(...this._classes.contentEditable.split(\" \")), r.textContent !== \"\" && setTimeout(() => {\n          h.addStyle(o, { display: \"block\" }), o.classList.remove(...this._classes.opacity.split(\" \"));\n        }, 160)), r.textContent === \"\" && (setTimeout(() => {\n          i.classList.add(...this._classes.opacity.split(\" \"));\n        }, 200), setTimeout(() => {\n          i.remove();\n        }, 300));\n      });\n    });\n  }\n  _handleRemoveActiveClass() {\n    this.allChips.forEach((e) => e.removeAttribute(mt));\n  }\n  _handleAddActiveClass() {\n    this.allChips.forEach((e) => e.setAttribute(mt, \"\"));\n  }\n  _handleRightKeyboardArrow(e) {\n    this._handleRemoveActiveClass(), e === 0 && (e = 1), this._handleAddActiveClassWithKebyboard(e);\n  }\n  _handleLeftKeyboardArrow(e) {\n    this._handleRemoveActiveClass(), this._handleAddActiveClassWithKebyboard(e);\n  }\n  _handleActiveChipAfterRemove(e) {\n    const i = e === 0 ? 1 : e - 1;\n    return this.allChips[i];\n  }\n  _handleClicksOnChips() {\n    c.on(this._element, \"click\", () => {\n      this.allChips.length === 0 && (this.chipsInputWrapper.classList.remove(\n        ...this._classes.inputWrapperPadding.split(\" \")\n      ), this.input.removeAttribute(mt));\n    });\n  }\n  _handleTextContent() {\n    const e = [];\n    return this.allChips.forEach((i) => e.push({ tag: i.textContent.trim() })), e;\n  }\n  _handleEvents(e, i) {\n    const n = this._handleTextContent(), o = this.allChips.filter(\n      (r) => r.hasAttribute(mt) && r\n    );\n    c.trigger(this._element, i, {\n      event: e,\n      allChips: this.allChips,\n      arrOfObjects: n,\n      active: o,\n      activeObj: {\n        tag: o.length <= 0 ? \"\" : o[0].textContent.trim()\n      }\n    });\n  }\n  _handleChipsFocus() {\n    c.on(this._element, \"click\", ({ target: { attributes: e } }) => {\n      const i = [...e];\n      i.includes(Wo) || i.includes(lh) || i.includes(ch) || this.input.focus();\n    });\n  }\n  _handleInitialValue() {\n    if (this._appendInputToElement(ml), this._element.hasAttribute(ml)) {\n      const { initialValues: e } = this._options;\n      e.forEach(\n        ({ tag: i }) => this._handleCreateChip(this.input, i)\n      ), d.findOne(\n        ho,\n        this.input.parentNode\n      ).setAttribute(Se, \"\"), this.input.setAttribute(mt, \"\"), this.input.setAttribute(Se, \"\");\n    }\n    this.allChips.length > 0 && (this.chipsInputWrapper.classList.add(\n      ...this._classes.inputWrapperPadding.split(\" \")\n    ), this.chipsInputWrapper.classList.add(\n      ...this._classes.transition.split(\" \")\n    ));\n  }\n  _handleKeysInputToElement(e) {\n    const { keyCode: i, target: n } = e;\n    if (n.hasAttribute(Wo)) {\n      const o = d.findOne(co, n);\n      i === ct && (n.contentEditable = !1, n.classList.remove(...this._classes.contentEditable.split(\" \")), n.textContent !== \"\" ? setTimeout(() => {\n        h.addStyle(o, { display: \"block\" }), o.classList.remove(...this._classes.opacity.split(\" \"));\n      }, 160) : n.textContent === \"\" && (setTimeout(() => {\n        n.classList.add(...this._classes.opacity.split(\" \"));\n      }, 200), setTimeout(() => {\n        n.remove();\n      }, 300)));\n      return;\n    }\n    if (i === ct) {\n      if (n.value === \"\")\n        return;\n      this._handleCreateChip(n, n.value), this._handleRemoveActiveClass(), this.numberClicks = this.allChips.length + 1, this._handleEvents(e, Nb);\n    }\n    this.allChips.length > 0 ? (this.chipsInputWrapper.classList.add(\n      ...this._classes.inputWrapperPadding.split(\" \")\n    ), this.chipsInputWrapper.classList.add(\n      ...this._classes.transition.split(\" \")\n    )) : this.chipsInputWrapper.classList.remove(\n      ...this._classes.inputWrapperPadding.split(\" \")\n    );\n  }\n  _handleInputText() {\n    const e = d.findOne(\n      Sb,\n      this._element\n    );\n    c.on(\n      this._element,\n      \"keyup\",\n      e,\n      (i) => this._handleKeysInputToElement(i)\n    ), c.on(this.input, \"blur\", (i) => this._handleBlurInput(i));\n  }\n  _appendInputToElement(e) {\n    if (!this._element.hasAttribute(e))\n      return;\n    const i = pb(this._options, this._classes);\n    this._element.insertAdjacentHTML(\"beforeend\", i);\n    const n = d.findOne(\n      \"[data-te-chips-input-wrapper]\",\n      this._element\n    );\n    this._inputInstance = new V(\n      n,\n      this._options.inputOptions,\n      this._options.inputClasses\n    );\n  }\n  _handleCreateChip(e, i) {\n    const n = $(\"div\"), o = _i.getInstance(n), r = new _i(o, { text: i }, this._classes);\n    this._options.parentSelector !== \"\" ? document.querySelector(this._options.parentSelector).insertAdjacentHTML(\"beforeend\", r.appendChip()) : e.insertAdjacentHTML(\"beforebegin\", r.appendChip()), e.value = \"\", d.find(Fo).forEach((a) => {\n      let l = _i.getInstance(a);\n      return l || (l = new _i(a, {}, this._classes)), l.init();\n    }), this._handleEditable();\n  }\n  _handleChipsOnSelect() {\n    this.allChips.forEach((e) => {\n      c.on(this._element, \"click\", (i) => {\n        c.trigger(e, bl, {\n          event: i,\n          allChips: this.allChips\n        });\n      });\n    });\n  }\n  _handleAddActiveClassWithKebyboard(e) {\n    let i;\n    this.allChips[e - 1] === void 0 ? i = this.allChips[e - 2] : i = this.allChips[e - 1], i.setAttribute(mt);\n  }\n  _getConfig(e) {\n    const i = {\n      ...Vb,\n      ...h.getDataAttributes(this._element),\n      ...e\n    };\n    return D(Li, i, Hb), i;\n  }\n  _getClasses(e) {\n    const i = h.getDataClassAttributes(this._element);\n    return e = {\n      ...Wb,\n      ...i,\n      ...e\n    }, D(Li, e, Fb), e;\n  }\n  static getInstance(e) {\n    return y.getData(e, fl);\n  }\n  static getOrCreateInstance(e, i = {}) {\n    return this.getInstance(e) || new this(e, typeof i == \"object\" ? i : null);\n  }\n}\nconst zt = {\n  plugins: {\n    legend: {\n      labels: {\n        color: \"rgb(102,102,102)\"\n      }\n    }\n  }\n}, Ti = {\n  line: {\n    options: {\n      ...zt,\n      elements: {\n        line: {\n          backgroundColor: \"rgba(59, 112, 202, 0.0)\",\n          borderColor: \"rgb(59, 112, 202)\",\n          borderWidth: 2,\n          tension: 0\n        },\n        point: {\n          borderColor: \"rgb(59, 112, 202)\",\n          backgroundColor: \"rgb(59, 112, 202)\"\n        }\n      },\n      responsive: !0,\n      legend: {\n        display: !0\n      },\n      tooltips: {\n        intersect: !1,\n        mode: \"index\"\n      },\n      datasets: {\n        borderColor: \"red\"\n      },\n      scales: {\n        x: {\n          stacked: !0,\n          grid: {\n            display: !1\n          },\n          ticks: {\n            fontColor: \"rgba(0,0,0, 0.5)\"\n          }\n        },\n        y: {\n          stacked: !1,\n          grid: {\n            borderDash: [2],\n            drawBorder: !1,\n            zeroLineColor: \"rgba(0,0,0,0)\",\n            zeroLineBorderDash: [2],\n            zeroLineBorderDashOffset: [2]\n          },\n          ticks: {\n            fontColor: \"rgba(0,0,0, 0.5)\"\n          }\n        }\n      }\n    }\n  },\n  bar: {\n    options: {\n      ...zt,\n      backgroundColor: \"rgb(59, 112, 202)\",\n      borderWidth: 0,\n      responsive: !0,\n      legend: {\n        display: !0\n      },\n      tooltips: {\n        intersect: !1,\n        mode: \"index\"\n      },\n      scales: {\n        x: {\n          stacked: !0,\n          grid: {\n            display: !1\n          },\n          ticks: {\n            fontColor: \"rgba(0,0,0, 0.5)\"\n          }\n        },\n        y: {\n          stacked: !0,\n          grid: {\n            borderDash: [2],\n            drawBorder: !1,\n            zeroLineColor: \"rgba(0,0,0,0)\",\n            zeroLineBorderDash: [2],\n            zeroLineBorderDashOffset: [2]\n          },\n          ticks: {\n            fontColor: \"rgba(0,0,0, 0.5)\"\n          }\n        }\n      }\n    }\n  },\n  pie: {\n    options: {\n      ...zt,\n      elements: {\n        arc: { backgroundColor: \"rgb(59, 112, 202)\" }\n      },\n      responsive: !0,\n      legend: {\n        display: !0\n      }\n    }\n  },\n  doughnut: {\n    options: {\n      ...zt,\n      elements: {\n        arc: { backgroundColor: \"rgb(59, 112, 202)\" }\n      },\n      responsive: !0,\n      legend: {\n        display: !0\n      }\n    }\n  },\n  polarArea: {\n    options: {\n      ...zt,\n      elements: {\n        arc: { backgroundColor: \"rgba(59, 112, 202, 0.5)\" }\n      },\n      responsive: !0,\n      legend: {\n        display: !0\n      }\n    }\n  },\n  radar: {\n    options: {\n      ...zt,\n      elements: {\n        line: {\n          backgroundColor: \"rgba(59, 112, 202, 0.5)\",\n          borderColor: \"rgb(59, 112, 202)\",\n          borderWidth: 2\n        },\n        point: {\n          borderColor: \"rgb(59, 112, 202)\",\n          backgroundColor: \"rgb(59, 112, 202)\"\n        }\n      },\n      responsive: !0,\n      legend: {\n        display: !0\n      }\n    }\n  },\n  scatter: {\n    options: {\n      ...zt,\n      elements: {\n        line: {\n          backgroundColor: \"rgba(59, 112, 202, 0.5)\",\n          borderColor: \"rgb(59, 112, 202)\",\n          borderWidth: 2,\n          tension: 0\n        },\n        point: {\n          borderColor: \"rgb(59, 112, 202)\",\n          backgroundColor: \"rgba(59, 112, 202, 0.5)\"\n        }\n      },\n      responsive: !0,\n      legend: {\n        display: !0\n      },\n      tooltips: {\n        intersect: !1,\n        mode: \"index\"\n      },\n      datasets: {\n        borderColor: \"red\"\n      },\n      scales: {\n        x: {\n          stacked: !0,\n          grid: {\n            display: !1\n          },\n          ticks: {\n            fontColor: \"rgba(0,0,0, 0.5)\"\n          }\n        },\n        y: {\n          stacked: !1,\n          grid: {\n            borderDash: [2],\n            drawBorder: !1,\n            zeroLineColor: \"rgba(0,0,0,0)\",\n            zeroLineBorderDash: [2],\n            zeroLineBorderDashOffset: [2]\n          },\n          ticks: {\n            fontColor: \"rgba(0,0,0, 0.5)\"\n          }\n        }\n      }\n    }\n  },\n  bubble: {\n    options: {\n      ...zt,\n      elements: {\n        point: {\n          borderColor: \"rgb(59, 112, 202)\",\n          backgroundColor: \"rgba(59, 112, 202, 0.5)\"\n        }\n      },\n      responsive: !0,\n      legend: {\n        display: !0\n      },\n      scales: {\n        x: {\n          grid: {\n            display: !1\n          },\n          ticks: {\n            fontColor: \"rgba(0,0,0, 0.5)\"\n          }\n        },\n        y: {\n          grid: {\n            borderDash: [2],\n            drawBorder: !1,\n            zeroLineColor: \"rgba(0,0,0,0)\",\n            zeroLineBorderDash: [2],\n            zeroLineBorderDashOffset: [2]\n          },\n          ticks: {\n            fontColor: \"rgba(0,0,0, 0.5)\"\n          }\n        }\n      }\n    }\n  }\n};\nvar Yb = function(t) {\n  return jb(t) && !Kb(t);\n};\nfunction jb(s) {\n  return !!s && typeof s == \"object\";\n}\nfunction Kb(s) {\n  var t = Object.prototype.toString.call(s);\n  return t === \"[object RegExp]\" || t === \"[object Date]\" || Xb(s);\n}\nvar zb = typeof Symbol == \"function\" && Symbol.for, Ub = zb ? Symbol.for(\"react.element\") : 60103;\nfunction Xb(s) {\n  return s.$$typeof === Ub;\n}\nfunction Gb(s) {\n  return Array.isArray(s) ? [] : {};\n}\nfunction Bi(s, t) {\n  return t.clone !== !1 && t.isMergeableObject(s) ? Qe(Gb(s), s, t) : s;\n}\nfunction qb(s, t, e) {\n  return s.concat(t).map(function(i) {\n    return Bi(i, e);\n  });\n}\nfunction Zb(s, t) {\n  if (!t.customMerge)\n    return Qe;\n  var e = t.customMerge(s);\n  return typeof e == \"function\" ? e : Qe;\n}\nfunction Qb(s) {\n  return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(s).filter(function(t) {\n    return Object.propertyIsEnumerable.call(s, t);\n  }) : [];\n}\nfunction vl(s) {\n  return Object.keys(s).concat(Qb(s));\n}\nfunction hh(s, t) {\n  try {\n    return t in s;\n  } catch {\n    return !1;\n  }\n}\nfunction Jb(s, t) {\n  return hh(s, t) && !(Object.hasOwnProperty.call(s, t) && Object.propertyIsEnumerable.call(s, t));\n}\nfunction tv(s, t, e) {\n  var i = {};\n  return e.isMergeableObject(s) && vl(s).forEach(function(n) {\n    i[n] = Bi(s[n], e);\n  }), vl(t).forEach(function(n) {\n    Jb(s, n) || (hh(s, n) && e.isMergeableObject(t[n]) ? i[n] = Zb(n, e)(s[n], t[n], e) : i[n] = Bi(t[n], e));\n  }), i;\n}\nfunction Qe(s, t, e) {\n  e = e || {}, e.arrayMerge = e.arrayMerge || qb, e.isMergeableObject = e.isMergeableObject || Yb, e.cloneUnlessOtherwiseSpecified = Bi;\n  var i = Array.isArray(t), n = Array.isArray(s), o = i === n;\n  return o ? i ? e.arrayMerge(s, t, e) : tv(s, t, e) : Bi(t, e);\n}\nQe.all = function(t, e) {\n  if (!Array.isArray(t))\n    throw new Error(\"first argument should be an array\");\n  return t.reduce(function(i, n) {\n    return Qe(i, n, e);\n  }, {});\n};\nvar ev = Qe, Yo = ev;\nconst Tl = \"chart\", ys = \"te.chart\", iv = \"chart\", uo = (s, t, e) => {\n  const i = (n, o, r) => {\n    const a = n.slice();\n    return o.forEach((l, p) => {\n      typeof a[p] > \"u\" ? a[p] = r.cloneUnlessOtherwiseSpecified(\n        l,\n        r\n      ) : r.isMergeableObject(l) ? a[p] = Yo(n[p], l, r) : n.indexOf(l) === -1 && a.push(l);\n    }), a;\n  };\n  return Yo(e[t], s, {\n    arrayMerge: i\n  });\n}, sv = {\n  darkTicksColor: \"#fff\",\n  darkLabelColor: \"#fff\",\n  darkGridLinesColor: \"#555\",\n  darkmodeOff: \"undefined\",\n  darkMode: null,\n  darkBgColor: \"#262626\",\n  darkBgColorLight: \"#fff\",\n  options: null\n}, nv = {\n  darkTicksColor: \"string\",\n  darkLabelColor: \"string\",\n  darkGridLinesColor: \"string\",\n  darkmodeOff: \"(string|null)\",\n  darkMode: \"(string|null)\",\n  darkBgColor: \"string\",\n  darkBgColorLight: \"string\",\n  options: \"(object|null)\"\n};\nclass dh {\n  constructor(t, e, i = {}, n = {}) {\n    this._waitForCharts(t, e, i, n);\n  }\n  async _getChartjs() {\n    const {\n      Chart: t,\n      ArcElement: e,\n      LineElement: i,\n      BarElement: n,\n      PointElement: o,\n      BarController: r,\n      BubbleController: a,\n      DoughnutController: l,\n      LineController: p,\n      PieController: u,\n      PolarAreaController: _,\n      RadarController: f,\n      ScatterController: g,\n      CategoryScale: m,\n      LinearScale: b,\n      LogarithmicScale: v,\n      RadialLinearScale: C,\n      TimeScale: w,\n      TimeSeriesScale: E,\n      Decimation: T,\n      Filler: A,\n      Legend: k,\n      Title: I,\n      Tooltip: O,\n      SubTitle: x\n    } = await __webpack_require__.e(/*! import() */ \"node_modules_tw-elements_dist_js_chart_es_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./chart.es.js */ \"./node_modules/tw-elements/dist/js/chart.es.js\")).then((L) => L.f);\n    return t.register(\n      e,\n      i,\n      n,\n      o,\n      r,\n      a,\n      l,\n      p,\n      u,\n      _,\n      f,\n      g,\n      m,\n      b,\n      v,\n      C,\n      w,\n      E,\n      T,\n      A,\n      k,\n      I,\n      O,\n      x\n    ), t;\n  }\n  async _getChartDataLabels() {\n    return await __webpack_require__.e(/*! import() */ \"node_modules_tw-elements_dist_js_chartjs-plugin-datalabels_es_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./chartjs-plugin-datalabels.es.js */ \"./node_modules/tw-elements/dist/js/chartjs-plugin-datalabels.es.js\"));\n  }\n  async _waitForCharts(t, e, i = {}, n = {}) {\n    if (this._Chartjs = await this._getChartjs(), this._ChartDataLabels = await this._getChartDataLabels(), this._element = t, this._data = e, this._options = i, this._type = e.type, this._canvas = null, this._chart = null, this._darkOptions = this._getDarkConfig(n), this._darkModeClassContainer = document.querySelector(\"html\"), this._prevConfig = null, this._observer = null, this._element && (y.setData(t, ys, this), h.addClass(this._element, iv), this._chartConstructor()), this._darkOptions.darkmodeOff !== null) {\n      const o = this._darkOptions.darkMode === \"dark\" ? \"dark\" : this._darkOptions.darkMode === \"light\" ? \"light\" : this.systemColorMode;\n      this._handleMode(o), this._observer = new MutationObserver(this._observerCallback.bind(this)), this._observer.observe(this._darkModeClassContainer, {\n        attributes: !0\n      });\n    }\n  }\n  // Getters\n  static get NAME() {\n    return Tl;\n  }\n  get systemColorMode() {\n    return localStorage.theme || (this._darkModeClassContainer.classList.contains(\"dark\") ? \"dark\" : \"light\");\n  }\n  // Public\n  dispose() {\n    this._observer.disconnect(), y.removeData(this._element, ys), this._element = null;\n  }\n  update(t, e) {\n    t && (this._data = { ...this._data, ...t }, this._chart.data = this._data);\n    const i = Object.prototype.hasOwnProperty.call(\n      e,\n      \"options\"\n    ) ? e : { options: { ...e } };\n    this._options = Yo(this._options, i), this._chart.options = uo(\n      this._options,\n      this._type,\n      Ti\n    ).options, this._chart.update();\n  }\n  setTheme(t) {\n    t !== \"dark\" && t !== \"light\" || !this._data || this._handleMode(t);\n  }\n  // Private\n  _getDarkConfig(t) {\n    let e = {};\n    const i = h.getDataAttributes(this._element);\n    Object.keys(i).forEach(\n      (p) => p.startsWith(\"dark\") && (e[p] = i[p])\n    ), e = {\n      ...sv,\n      ...e\n    };\n    const n = {\n      y: {\n        ticks: {\n          color: e.darkTicksColor\n        },\n        grid: {\n          color: e.darkGridLinesColor\n        }\n      },\n      x: {\n        ticks: {\n          color: e.darkTicksColor\n        },\n        grid: {\n          color: e.darkGridLinesColor\n        }\n      }\n    }, o = {\n      r: {\n        ticks: {\n          color: e.darkTicksColor,\n          backdropColor: e.darkBgColor\n        },\n        grid: {\n          color: e.darkGridLinesColor\n        },\n        pointLabels: {\n          color: e.darkTicksColor\n        }\n      }\n    }, l = {\n      scales: [\"pie\", \"doughnut\", \"polarArea\", \"radar\"].includes(this._type) ? [\"polarArea\", \"radar\"].includes(this._type) ? o : {} : n,\n      plugins: {\n        legend: {\n          labels: {\n            color: e.darkLabelColor\n          }\n        }\n      }\n    };\n    return t = {\n      ...e,\n      options: {\n        ...l\n      },\n      ...t\n    }, D(Tl, t, nv), t;\n  }\n  _chartConstructor() {\n    if (this._data) {\n      this._createCanvas();\n      const t = uo(this._options, this._type, Ti), e = [];\n      t.dataLabelsPlugin && e.push(this._ChartDataLabels.default), this._prevConfig = t, this._chart = new this._Chartjs(this._canvas, {\n        ...this._data,\n        ...t,\n        plugins: e\n      });\n    }\n  }\n  _createCanvas() {\n    this._canvas || (this._element.nodeName === \"CANVAS\" ? this._canvas = this._element : (this._canvas = $(\"canvas\"), this._element.appendChild(this._canvas)));\n  }\n  _handleMode(t) {\n    t === \"dark\" ? (this._changeDatasetBorderColor(), this.update(null, this._darkOptions.options)) : (this._changeDatasetBorderColor(!1), this._prevConfig && this.update(null, this._prevConfig));\n  }\n  _observerCallback(t) {\n    for (const e of t)\n      e.type === \"attributes\" && this._handleMode(this.systemColorMode);\n  }\n  _changeDatasetBorderColor(t = !0) {\n    [...this._data.data.datasets].forEach(\n      (e) => [\"pie\", \"doughnut\", \"polarArea\"].includes(this._type) && (e.borderColor = t ? this._darkOptions.darkBgColor : this._darkOptions.darkBgColorLight)\n    );\n  }\n  static jQueryInterface(t, e, i) {\n    return this.each(function() {\n      let n = y.getData(this, ys);\n      if (!(!n && /dispose/.test(t))) {\n        if (!n) {\n          const o = e ? uo(e, i, Ti) : Ti[i];\n          n = new dh(this, {\n            ...t,\n            ...o\n          });\n        }\n        if (typeof t == \"string\") {\n          if (typeof n[t] > \"u\")\n            throw new TypeError(`No method named \"${t}\"`);\n          n[t](e, i);\n        }\n      }\n    });\n  }\n  static getInstance(t) {\n    return y.getData(t, ys);\n  }\n  static getOrCreateInstance(t, e = {}) {\n    return this.getInstance(t) || new this(t, typeof e == \"object\" ? e : null);\n  }\n}\n/*!\n * perfect-scrollbar v1.5.3\n * Copyright 2021 Hyunje Jun, MDBootstrap and Contributors\n * Licensed under MIT\n */\nfunction Lt(s) {\n  return getComputedStyle(s);\n}\nfunction ot(s, t) {\n  for (var e in t) {\n    var i = t[e];\n    typeof i == \"number\" && (i = i + \"px\"), s.style[e] = i;\n  }\n  return s;\n}\nfunction ws(s) {\n  var t = document.createElement(\"div\");\n  return t.className = s, t;\n}\nvar El = typeof Element < \"u\" && (Element.prototype.matches || Element.prototype.webkitMatchesSelector || Element.prototype.mozMatchesSelector || Element.prototype.msMatchesSelector);\nfunction Qt(s, t) {\n  if (!El)\n    throw new Error(\"No element matching method supported\");\n  return El.call(s, t);\n}\nfunction Pe(s) {\n  s.remove ? s.remove() : s.parentNode && s.parentNode.removeChild(s);\n}\nfunction Cl(s, t) {\n  return Array.prototype.filter.call(\n    s.children,\n    function(e) {\n      return Qt(e, t);\n    }\n  );\n}\nvar j = {\n  main: \"ps\",\n  rtl: \"ps__rtl\",\n  element: {\n    thumb: function(s) {\n      return \"ps__thumb-\" + s;\n    },\n    rail: function(s) {\n      return \"ps__rail-\" + s;\n    },\n    consuming: \"ps__child--consume\"\n  },\n  state: {\n    focus: \"ps--focus\",\n    clicking: \"ps--clicking\",\n    active: function(s) {\n      return \"ps--active-\" + s;\n    },\n    scrolling: function(s) {\n      return \"ps--scrolling-\" + s;\n    }\n  }\n}, uh = { x: null, y: null };\nfunction ph(s, t) {\n  var e = s.element.classList, i = j.state.scrolling(t);\n  e.contains(i) ? clearTimeout(uh[t]) : e.add(i);\n}\nfunction _h(s, t) {\n  uh[t] = setTimeout(\n    function() {\n      return s.isAlive && s.element.classList.remove(j.state.scrolling(t));\n    },\n    s.settings.scrollingThreshold\n  );\n}\nfunction ov(s, t) {\n  ph(s, t), _h(s, t);\n}\nvar zi = function(t) {\n  this.element = t, this.handlers = {};\n}, fh = { isEmpty: { configurable: !0 } };\nzi.prototype.bind = function(t, e) {\n  typeof this.handlers[t] > \"u\" && (this.handlers[t] = []), this.handlers[t].push(e), this.element.addEventListener(t, e, !1);\n};\nzi.prototype.unbind = function(t, e) {\n  var i = this;\n  this.handlers[t] = this.handlers[t].filter(function(n) {\n    return e && n !== e ? !0 : (i.element.removeEventListener(t, n, !1), !1);\n  });\n};\nzi.prototype.unbindAll = function() {\n  for (var t in this.handlers)\n    this.unbind(t);\n};\nfh.isEmpty.get = function() {\n  var s = this;\n  return Object.keys(this.handlers).every(\n    function(t) {\n      return s.handlers[t].length === 0;\n    }\n  );\n};\nObject.defineProperties(zi.prototype, fh);\nvar si = function() {\n  this.eventElements = [];\n};\nsi.prototype.eventElement = function(t) {\n  var e = this.eventElements.filter(function(i) {\n    return i.element === t;\n  })[0];\n  return e || (e = new zi(t), this.eventElements.push(e)), e;\n};\nsi.prototype.bind = function(t, e, i) {\n  this.eventElement(t).bind(e, i);\n};\nsi.prototype.unbind = function(t, e, i) {\n  var n = this.eventElement(t);\n  n.unbind(e, i), n.isEmpty && this.eventElements.splice(this.eventElements.indexOf(n), 1);\n};\nsi.prototype.unbindAll = function() {\n  this.eventElements.forEach(function(t) {\n    return t.unbindAll();\n  }), this.eventElements = [];\n};\nsi.prototype.once = function(t, e, i) {\n  var n = this.eventElement(t), o = function(r) {\n    n.unbind(e, o), i(r);\n  };\n  n.bind(e, o);\n};\nfunction ks(s) {\n  if (typeof window.CustomEvent == \"function\")\n    return new CustomEvent(s);\n  var t = document.createEvent(\"CustomEvent\");\n  return t.initCustomEvent(s, !1, !1, void 0), t;\n}\nfunction on(s, t, e, i, n) {\n  i === void 0 && (i = !0), n === void 0 && (n = !1);\n  var o;\n  if (t === \"top\")\n    o = [\n      \"contentHeight\",\n      \"containerHeight\",\n      \"scrollTop\",\n      \"y\",\n      \"up\",\n      \"down\"\n    ];\n  else if (t === \"left\")\n    o = [\n      \"contentWidth\",\n      \"containerWidth\",\n      \"scrollLeft\",\n      \"x\",\n      \"left\",\n      \"right\"\n    ];\n  else\n    throw new Error(\"A proper axis should be provided\");\n  rv(s, e, o, i, n);\n}\nfunction rv(s, t, e, i, n) {\n  var o = e[0], r = e[1], a = e[2], l = e[3], p = e[4], u = e[5];\n  i === void 0 && (i = !0), n === void 0 && (n = !1);\n  var _ = s.element;\n  s.reach[l] = null, _[a] < 1 && (s.reach[l] = \"start\"), _[a] > s[o] - s[r] - 1 && (s.reach[l] = \"end\"), t && (_.dispatchEvent(ks(\"ps-scroll-\" + l)), t < 0 ? _.dispatchEvent(ks(\"ps-scroll-\" + p)) : t > 0 && _.dispatchEvent(ks(\"ps-scroll-\" + u)), i && ov(s, l)), s.reach[l] && (t || n) && _.dispatchEvent(ks(\"ps-\" + l + \"-reach-\" + s.reach[l]));\n}\nfunction W(s) {\n  return parseInt(s, 10) || 0;\n}\nfunction av(s) {\n  return Qt(s, \"input,[contenteditable]\") || Qt(s, \"select,[contenteditable]\") || Qt(s, \"textarea,[contenteditable]\") || Qt(s, \"button,[contenteditable]\");\n}\nfunction lv(s) {\n  var t = Lt(s);\n  return W(t.width) + W(t.paddingLeft) + W(t.paddingRight) + W(t.borderLeftWidth) + W(t.borderRightWidth);\n}\nvar Ne = {\n  isWebKit: typeof document < \"u\" && \"WebkitAppearance\" in document.documentElement.style,\n  supportsTouch: typeof window < \"u\" && (\"ontouchstart\" in window || \"maxTouchPoints\" in window.navigator && window.navigator.maxTouchPoints > 0 || window.DocumentTouch && document instanceof window.DocumentTouch),\n  supportsIePointer: typeof navigator < \"u\" && navigator.msMaxTouchPoints,\n  isChrome: typeof navigator < \"u\" && /Chrome/i.test(navigator && navigator.userAgent)\n};\nfunction Bt(s) {\n  var t = s.element, e = Math.floor(t.scrollTop), i = t.getBoundingClientRect();\n  s.containerWidth = Math.round(i.width), s.containerHeight = Math.round(i.height), s.contentWidth = t.scrollWidth, s.contentHeight = t.scrollHeight, t.contains(s.scrollbarXRail) || (Cl(t, j.element.rail(\"x\")).forEach(\n    function(n) {\n      return Pe(n);\n    }\n  ), t.appendChild(s.scrollbarXRail)), t.contains(s.scrollbarYRail) || (Cl(t, j.element.rail(\"y\")).forEach(\n    function(n) {\n      return Pe(n);\n    }\n  ), t.appendChild(s.scrollbarYRail)), !s.settings.suppressScrollX && s.containerWidth + s.settings.scrollXMarginOffset < s.contentWidth ? (s.scrollbarXActive = !0, s.railXWidth = s.containerWidth - s.railXMarginWidth, s.railXRatio = s.containerWidth / s.railXWidth, s.scrollbarXWidth = Al(\n    s,\n    W(s.railXWidth * s.containerWidth / s.contentWidth)\n  ), s.scrollbarXLeft = W(\n    (s.negativeScrollAdjustment + t.scrollLeft) * (s.railXWidth - s.scrollbarXWidth) / (s.contentWidth - s.containerWidth)\n  )) : s.scrollbarXActive = !1, !s.settings.suppressScrollY && s.containerHeight + s.settings.scrollYMarginOffset < s.contentHeight ? (s.scrollbarYActive = !0, s.railYHeight = s.containerHeight - s.railYMarginHeight, s.railYRatio = s.containerHeight / s.railYHeight, s.scrollbarYHeight = Al(\n    s,\n    W(s.railYHeight * s.containerHeight / s.contentHeight)\n  ), s.scrollbarYTop = W(\n    e * (s.railYHeight - s.scrollbarYHeight) / (s.contentHeight - s.containerHeight)\n  )) : s.scrollbarYActive = !1, s.scrollbarXLeft >= s.railXWidth - s.scrollbarXWidth && (s.scrollbarXLeft = s.railXWidth - s.scrollbarXWidth), s.scrollbarYTop >= s.railYHeight - s.scrollbarYHeight && (s.scrollbarYTop = s.railYHeight - s.scrollbarYHeight), cv(t, s), s.scrollbarXActive ? t.classList.add(j.state.active(\"x\")) : (t.classList.remove(j.state.active(\"x\")), s.scrollbarXWidth = 0, s.scrollbarXLeft = 0, t.scrollLeft = s.isRtl === !0 ? s.contentWidth : 0), s.scrollbarYActive ? t.classList.add(j.state.active(\"y\")) : (t.classList.remove(j.state.active(\"y\")), s.scrollbarYHeight = 0, s.scrollbarYTop = 0, t.scrollTop = 0);\n}\nfunction Al(s, t) {\n  return s.settings.minScrollbarLength && (t = Math.max(t, s.settings.minScrollbarLength)), s.settings.maxScrollbarLength && (t = Math.min(t, s.settings.maxScrollbarLength)), t;\n}\nfunction cv(s, t) {\n  var e = { width: t.railXWidth }, i = Math.floor(s.scrollTop);\n  t.isRtl ? e.left = t.negativeScrollAdjustment + s.scrollLeft + t.containerWidth - t.contentWidth : e.left = s.scrollLeft, t.isScrollbarXUsingBottom ? e.bottom = t.scrollbarXBottom - i : e.top = t.scrollbarXTop + i, ot(t.scrollbarXRail, e);\n  var n = { top: i, height: t.railYHeight };\n  t.isScrollbarYUsingRight ? t.isRtl ? n.right = t.contentWidth - (t.negativeScrollAdjustment + s.scrollLeft) - t.scrollbarYRight - t.scrollbarYOuterWidth - 9 : n.right = t.scrollbarYRight - s.scrollLeft : t.isRtl ? n.left = t.negativeScrollAdjustment + s.scrollLeft + t.containerWidth * 2 - t.contentWidth - t.scrollbarYLeft - t.scrollbarYOuterWidth : n.left = t.scrollbarYLeft + s.scrollLeft, ot(t.scrollbarYRail, n), ot(t.scrollbarX, {\n    left: t.scrollbarXLeft,\n    width: t.scrollbarXWidth - t.railBorderXWidth\n  }), ot(t.scrollbarY, {\n    top: t.scrollbarYTop,\n    height: t.scrollbarYHeight - t.railBorderYWidth\n  });\n}\nfunction hv(s) {\n  s.element, s.event.bind(s.scrollbarY, \"mousedown\", function(t) {\n    return t.stopPropagation();\n  }), s.event.bind(s.scrollbarYRail, \"mousedown\", function(t) {\n    var e = t.pageY - window.pageYOffset - s.scrollbarYRail.getBoundingClientRect().top, i = e > s.scrollbarYTop ? 1 : -1;\n    s.element.scrollTop += i * s.containerHeight, Bt(s), t.stopPropagation();\n  }), s.event.bind(s.scrollbarX, \"mousedown\", function(t) {\n    return t.stopPropagation();\n  }), s.event.bind(s.scrollbarXRail, \"mousedown\", function(t) {\n    var e = t.pageX - window.pageXOffset - s.scrollbarXRail.getBoundingClientRect().left, i = e > s.scrollbarXLeft ? 1 : -1;\n    s.element.scrollLeft += i * s.containerWidth, Bt(s), t.stopPropagation();\n  });\n}\nfunction dv(s) {\n  yl(s, [\n    \"containerWidth\",\n    \"contentWidth\",\n    \"pageX\",\n    \"railXWidth\",\n    \"scrollbarX\",\n    \"scrollbarXWidth\",\n    \"scrollLeft\",\n    \"x\",\n    \"scrollbarXRail\"\n  ]), yl(s, [\n    \"containerHeight\",\n    \"contentHeight\",\n    \"pageY\",\n    \"railYHeight\",\n    \"scrollbarY\",\n    \"scrollbarYHeight\",\n    \"scrollTop\",\n    \"y\",\n    \"scrollbarYRail\"\n  ]);\n}\nfunction yl(s, t) {\n  var e = t[0], i = t[1], n = t[2], o = t[3], r = t[4], a = t[5], l = t[6], p = t[7], u = t[8], _ = s.element, f = null, g = null, m = null;\n  function b(w) {\n    w.touches && w.touches[0] && (w[n] = w.touches[0].pageY), _[l] = f + m * (w[n] - g), ph(s, p), Bt(s), w.stopPropagation(), w.type.startsWith(\"touch\") && w.changedTouches.length > 1 && w.preventDefault();\n  }\n  function v() {\n    _h(s, p), s[u].classList.remove(j.state.clicking), s.event.unbind(s.ownerDocument, \"mousemove\", b);\n  }\n  function C(w, E) {\n    f = _[l], E && w.touches && (w[n] = w.touches[0].pageY), g = w[n], m = (s[i] - s[e]) / (s[o] - s[a]), E ? s.event.bind(s.ownerDocument, \"touchmove\", b) : (s.event.bind(s.ownerDocument, \"mousemove\", b), s.event.once(s.ownerDocument, \"mouseup\", v), w.preventDefault()), s[u].classList.add(j.state.clicking), w.stopPropagation();\n  }\n  s.event.bind(s[r], \"mousedown\", function(w) {\n    C(w);\n  }), s.event.bind(s[r], \"touchstart\", function(w) {\n    C(w, !0);\n  });\n}\nfunction uv(s) {\n  var t = s.element, e = function() {\n    return Qt(t, \":hover\");\n  }, i = function() {\n    return Qt(s.scrollbarX, \":focus\") || Qt(s.scrollbarY, \":focus\");\n  };\n  function n(o, r) {\n    var a = Math.floor(t.scrollTop);\n    if (o === 0) {\n      if (!s.scrollbarYActive)\n        return !1;\n      if (a === 0 && r > 0 || a >= s.contentHeight - s.containerHeight && r < 0)\n        return !s.settings.wheelPropagation;\n    }\n    var l = t.scrollLeft;\n    if (r === 0) {\n      if (!s.scrollbarXActive)\n        return !1;\n      if (l === 0 && o < 0 || l >= s.contentWidth - s.containerWidth && o > 0)\n        return !s.settings.wheelPropagation;\n    }\n    return !0;\n  }\n  s.event.bind(s.ownerDocument, \"keydown\", function(o) {\n    if (!(o.isDefaultPrevented && o.isDefaultPrevented() || o.defaultPrevented) && !(!e() && !i())) {\n      var r = document.activeElement ? document.activeElement : s.ownerDocument.activeElement;\n      if (r) {\n        if (r.tagName === \"IFRAME\")\n          r = r.contentDocument.activeElement;\n        else\n          for (; r.shadowRoot; )\n            r = r.shadowRoot.activeElement;\n        if (av(r))\n          return;\n      }\n      var a = 0, l = 0;\n      switch (o.which) {\n        case 37:\n          o.metaKey ? a = -s.contentWidth : o.altKey ? a = -s.containerWidth : a = -30;\n          break;\n        case 38:\n          o.metaKey ? l = s.contentHeight : o.altKey ? l = s.containerHeight : l = 30;\n          break;\n        case 39:\n          o.metaKey ? a = s.contentWidth : o.altKey ? a = s.containerWidth : a = 30;\n          break;\n        case 40:\n          o.metaKey ? l = -s.contentHeight : o.altKey ? l = -s.containerHeight : l = -30;\n          break;\n        case 32:\n          o.shiftKey ? l = s.containerHeight : l = -s.containerHeight;\n          break;\n        case 33:\n          l = s.containerHeight;\n          break;\n        case 34:\n          l = -s.containerHeight;\n          break;\n        case 36:\n          l = s.contentHeight;\n          break;\n        case 35:\n          l = -s.contentHeight;\n          break;\n        default:\n          return;\n      }\n      s.settings.suppressScrollX && a !== 0 || s.settings.suppressScrollY && l !== 0 || (t.scrollTop -= l, t.scrollLeft += a, Bt(s), n(a, l) && o.preventDefault());\n    }\n  });\n}\nfunction pv(s) {\n  var t = s.element;\n  function e(r, a) {\n    var l = Math.floor(t.scrollTop), p = t.scrollTop === 0, u = l + t.offsetHeight === t.scrollHeight, _ = t.scrollLeft === 0, f = t.scrollLeft + t.offsetWidth === t.scrollWidth, g;\n    return Math.abs(a) > Math.abs(r) ? g = p || u : g = _ || f, g ? !s.settings.wheelPropagation : !0;\n  }\n  function i(r) {\n    var a = r.deltaX, l = -1 * r.deltaY;\n    return (typeof a > \"u\" || typeof l > \"u\") && (a = -1 * r.wheelDeltaX / 6, l = r.wheelDeltaY / 6), r.deltaMode && r.deltaMode === 1 && (a *= 10, l *= 10), a !== a && l !== l && (a = 0, l = r.wheelDelta), r.shiftKey ? [-l, -a] : [a, l];\n  }\n  function n(r, a, l) {\n    if (!Ne.isWebKit && t.querySelector(\"select:focus\"))\n      return !0;\n    if (!t.contains(r))\n      return !1;\n    for (var p = r; p && p !== t; ) {\n      if (p.classList.contains(j.element.consuming))\n        return !0;\n      var u = Lt(p);\n      if (l && u.overflowY.match(/(scroll|auto)/)) {\n        var _ = p.scrollHeight - p.clientHeight;\n        if (_ > 0 && (p.scrollTop > 0 && l < 0 || p.scrollTop < _ && l > 0))\n          return !0;\n      }\n      if (a && u.overflowX.match(/(scroll|auto)/)) {\n        var f = p.scrollWidth - p.clientWidth;\n        if (f > 0 && (p.scrollLeft > 0 && a < 0 || p.scrollLeft < f && a > 0))\n          return !0;\n      }\n      p = p.parentNode;\n    }\n    return !1;\n  }\n  function o(r) {\n    var a = i(r), l = a[0], p = a[1];\n    if (!n(r.target, l, p)) {\n      var u = !1;\n      s.settings.useBothWheelAxes ? s.scrollbarYActive && !s.scrollbarXActive ? (p ? t.scrollTop -= p * s.settings.wheelSpeed : t.scrollTop += l * s.settings.wheelSpeed, u = !0) : s.scrollbarXActive && !s.scrollbarYActive && (l ? t.scrollLeft += l * s.settings.wheelSpeed : t.scrollLeft -= p * s.settings.wheelSpeed, u = !0) : (t.scrollTop -= p * s.settings.wheelSpeed, t.scrollLeft += l * s.settings.wheelSpeed), Bt(s), u = u || e(l, p), u && !r.ctrlKey && (r.stopPropagation(), r.preventDefault());\n    }\n  }\n  typeof window.onwheel < \"u\" ? s.event.bind(t, \"wheel\", o) : typeof window.onmousewheel < \"u\" && s.event.bind(t, \"mousewheel\", o);\n}\nfunction _v(s) {\n  if (!Ne.supportsTouch && !Ne.supportsIePointer)\n    return;\n  var t = s.element;\n  function e(m, b) {\n    var v = Math.floor(t.scrollTop), C = t.scrollLeft, w = Math.abs(m), E = Math.abs(b);\n    if (E > w) {\n      if (b < 0 && v === s.contentHeight - s.containerHeight || b > 0 && v === 0)\n        return window.scrollY === 0 && b > 0 && Ne.isChrome;\n    } else if (w > E && (m < 0 && C === s.contentWidth - s.containerWidth || m > 0 && C === 0))\n      return !0;\n    return !0;\n  }\n  function i(m, b) {\n    t.scrollTop -= b, t.scrollLeft -= m, Bt(s);\n  }\n  var n = {}, o = 0, r = {}, a = null;\n  function l(m) {\n    return m.targetTouches ? m.targetTouches[0] : m;\n  }\n  function p(m) {\n    return m.pointerType && m.pointerType === \"pen\" && m.buttons === 0 ? !1 : !!(m.targetTouches && m.targetTouches.length === 1 || m.pointerType && m.pointerType !== \"mouse\" && m.pointerType !== m.MSPOINTER_TYPE_MOUSE);\n  }\n  function u(m) {\n    if (p(m)) {\n      var b = l(m);\n      n.pageX = b.pageX, n.pageY = b.pageY, o = (/* @__PURE__ */ new Date()).getTime(), a !== null && clearInterval(a);\n    }\n  }\n  function _(m, b, v) {\n    if (!t.contains(m))\n      return !1;\n    for (var C = m; C && C !== t; ) {\n      if (C.classList.contains(j.element.consuming))\n        return !0;\n      var w = Lt(C);\n      if (v && w.overflowY.match(/(scroll|auto)/)) {\n        var E = C.scrollHeight - C.clientHeight;\n        if (E > 0 && (C.scrollTop > 0 && v < 0 || C.scrollTop < E && v > 0))\n          return !0;\n      }\n      if (b && w.overflowX.match(/(scroll|auto)/)) {\n        var T = C.scrollWidth - C.clientWidth;\n        if (T > 0 && (C.scrollLeft > 0 && b < 0 || C.scrollLeft < T && b > 0))\n          return !0;\n      }\n      C = C.parentNode;\n    }\n    return !1;\n  }\n  function f(m) {\n    if (p(m)) {\n      var b = l(m), v = { pageX: b.pageX, pageY: b.pageY }, C = v.pageX - n.pageX, w = v.pageY - n.pageY;\n      if (_(m.target, C, w))\n        return;\n      i(C, w), n = v;\n      var E = (/* @__PURE__ */ new Date()).getTime(), T = E - o;\n      T > 0 && (r.x = C / T, r.y = w / T, o = E), e(C, w) && m.preventDefault();\n    }\n  }\n  function g() {\n    s.settings.swipeEasing && (clearInterval(a), a = setInterval(function() {\n      if (s.isInitialized) {\n        clearInterval(a);\n        return;\n      }\n      if (!r.x && !r.y) {\n        clearInterval(a);\n        return;\n      }\n      if (Math.abs(r.x) < 0.01 && Math.abs(r.y) < 0.01) {\n        clearInterval(a);\n        return;\n      }\n      if (!s.element) {\n        clearInterval(a);\n        return;\n      }\n      i(r.x * 30, r.y * 30), r.x *= 0.8, r.y *= 0.8;\n    }, 10));\n  }\n  Ne.supportsTouch ? (s.event.bind(t, \"touchstart\", u), s.event.bind(t, \"touchmove\", f), s.event.bind(t, \"touchend\", g)) : Ne.supportsIePointer && (window.PointerEvent ? (s.event.bind(t, \"pointerdown\", u), s.event.bind(t, \"pointermove\", f), s.event.bind(t, \"pointerup\", g)) : window.MSPointerEvent && (s.event.bind(t, \"MSPointerDown\", u), s.event.bind(t, \"MSPointerMove\", f), s.event.bind(t, \"MSPointerUp\", g)));\n}\nvar fv = function() {\n  return {\n    handlers: [\"click-rail\", \"drag-thumb\", \"keyboard\", \"wheel\", \"touch\"],\n    maxScrollbarLength: null,\n    minScrollbarLength: null,\n    scrollingThreshold: 1e3,\n    scrollXMarginOffset: 0,\n    scrollYMarginOffset: 0,\n    suppressScrollX: !1,\n    suppressScrollY: !1,\n    swipeEasing: !0,\n    useBothWheelAxes: !1,\n    wheelPropagation: !0,\n    wheelSpeed: 1\n  };\n}, mv = {\n  \"click-rail\": hv,\n  \"drag-thumb\": dv,\n  keyboard: uv,\n  wheel: pv,\n  touch: _v\n}, Ui = function(t, e) {\n  var i = this;\n  if (e === void 0 && (e = {}), typeof t == \"string\" && (t = document.querySelector(t)), !t || !t.nodeName)\n    throw new Error(\"no element is specified to initialize PerfectScrollbar\");\n  this.element = t, t.classList.add(j.main), this.settings = fv();\n  for (var n in e)\n    this.settings[n] = e[n];\n  this.containerWidth = null, this.containerHeight = null, this.contentWidth = null, this.contentHeight = null;\n  var o = function() {\n    return t.classList.add(j.state.focus);\n  }, r = function() {\n    return t.classList.remove(j.state.focus);\n  };\n  this.isRtl = Lt(t).direction === \"rtl\", this.isRtl === !0 && t.classList.add(j.rtl), this.isNegativeScroll = function() {\n    var p = t.scrollLeft, u = null;\n    return t.scrollLeft = -1, u = t.scrollLeft < 0, t.scrollLeft = p, u;\n  }(), this.negativeScrollAdjustment = this.isNegativeScroll ? t.scrollWidth - t.clientWidth : 0, this.event = new si(), this.ownerDocument = t.ownerDocument || document, this.scrollbarXRail = ws(j.element.rail(\"x\")), t.appendChild(this.scrollbarXRail), this.scrollbarX = ws(j.element.thumb(\"x\")), this.scrollbarXRail.appendChild(this.scrollbarX), this.scrollbarX.setAttribute(\"tabindex\", 0), this.event.bind(this.scrollbarX, \"focus\", o), this.event.bind(this.scrollbarX, \"blur\", r), this.scrollbarXActive = null, this.scrollbarXWidth = null, this.scrollbarXLeft = null;\n  var a = Lt(this.scrollbarXRail);\n  this.scrollbarXBottom = parseInt(a.bottom, 10), isNaN(this.scrollbarXBottom) ? (this.isScrollbarXUsingBottom = !1, this.scrollbarXTop = W(a.top)) : this.isScrollbarXUsingBottom = !0, this.railBorderXWidth = W(a.borderLeftWidth) + W(a.borderRightWidth), ot(this.scrollbarXRail, { display: \"block\" }), this.railXMarginWidth = W(a.marginLeft) + W(a.marginRight), ot(this.scrollbarXRail, { display: \"\" }), this.railXWidth = null, this.railXRatio = null, this.scrollbarYRail = ws(j.element.rail(\"y\")), t.appendChild(this.scrollbarYRail), this.scrollbarY = ws(j.element.thumb(\"y\")), this.scrollbarYRail.appendChild(this.scrollbarY), this.scrollbarY.setAttribute(\"tabindex\", 0), this.event.bind(this.scrollbarY, \"focus\", o), this.event.bind(this.scrollbarY, \"blur\", r), this.scrollbarYActive = null, this.scrollbarYHeight = null, this.scrollbarYTop = null;\n  var l = Lt(this.scrollbarYRail);\n  this.scrollbarYRight = parseInt(l.right, 10), isNaN(this.scrollbarYRight) ? (this.isScrollbarYUsingRight = !1, this.scrollbarYLeft = W(l.left)) : this.isScrollbarYUsingRight = !0, this.scrollbarYOuterWidth = this.isRtl ? lv(this.scrollbarY) : null, this.railBorderYWidth = W(l.borderTopWidth) + W(l.borderBottomWidth), ot(this.scrollbarYRail, { display: \"block\" }), this.railYMarginHeight = W(l.marginTop) + W(l.marginBottom), ot(this.scrollbarYRail, { display: \"\" }), this.railYHeight = null, this.railYRatio = null, this.reach = {\n    x: t.scrollLeft <= 0 ? \"start\" : t.scrollLeft >= this.contentWidth - this.containerWidth ? \"end\" : null,\n    y: t.scrollTop <= 0 ? \"start\" : t.scrollTop >= this.contentHeight - this.containerHeight ? \"end\" : null\n  }, this.isAlive = !0, this.settings.handlers.forEach(function(p) {\n    return mv[p](i);\n  }), this.lastScrollTop = Math.floor(t.scrollTop), this.lastScrollLeft = t.scrollLeft, this.event.bind(this.element, \"scroll\", function(p) {\n    return i.onScroll(p);\n  }), Bt(this);\n};\nUi.prototype.update = function() {\n  this.isAlive && (this.negativeScrollAdjustment = this.isNegativeScroll ? this.element.scrollWidth - this.element.clientWidth : 0, ot(this.scrollbarXRail, { display: \"block\" }), ot(this.scrollbarYRail, { display: \"block\" }), this.railXMarginWidth = W(Lt(this.scrollbarXRail).marginLeft) + W(Lt(this.scrollbarXRail).marginRight), this.railYMarginHeight = W(Lt(this.scrollbarYRail).marginTop) + W(Lt(this.scrollbarYRail).marginBottom), ot(this.scrollbarXRail, { display: \"none\" }), ot(this.scrollbarYRail, { display: \"none\" }), Bt(this), on(this, \"top\", 0, !1, !0), on(this, \"left\", 0, !1, !0), ot(this.scrollbarXRail, { display: \"\" }), ot(this.scrollbarYRail, { display: \"\" }));\n};\nUi.prototype.onScroll = function(t) {\n  this.isAlive && (Bt(this), on(this, \"top\", this.element.scrollTop - this.lastScrollTop), on(\n    this,\n    \"left\",\n    this.element.scrollLeft - this.lastScrollLeft\n  ), this.lastScrollTop = Math.floor(this.element.scrollTop), this.lastScrollLeft = this.element.scrollLeft);\n};\nUi.prototype.destroy = function() {\n  this.isAlive && (this.event.unbindAll(), Pe(this.scrollbarX), Pe(this.scrollbarY), Pe(this.scrollbarXRail), Pe(this.scrollbarYRail), this.removePsClasses(), this.element = null, this.scrollbarX = null, this.scrollbarY = null, this.scrollbarXRail = null, this.scrollbarYRail = null, this.isAlive = !1);\n};\nUi.prototype.removePsClasses = function() {\n  this.element.className = this.element.className.split(\" \").filter(function(t) {\n    return !t.match(/^ps([-_].+|)$/);\n  }).join(\" \");\n};\nconst po = \"perfectScrollbar\", gv = \"perfect-scrollbar\", xs = \"te.perfectScrollbar\", Ot = \"te\", St = \"ps\", _o = [\n  { te: `scrollX.${Ot}.${St}`, ps: \"ps-scroll-x\" },\n  { te: `scrollY.${Ot}.${St}`, ps: \"ps-scroll-y\" },\n  { te: `scrollUp.${Ot}.${St}`, ps: \"ps-scroll-up\" },\n  { te: `scrollDown.${Ot}.${St}`, ps: \"ps-scroll-down\" },\n  { te: `scrollLeft.${Ot}.${St}`, ps: \"ps-scroll-left\" },\n  { te: `scrollRight.${Ot}.${St}`, ps: \"ps-scroll-right\" },\n  { te: `scrollXEnd.${Ot}.${St}`, ps: \"ps-x-reach-end\" },\n  { te: `scrollYEnd.${Ot}.${St}`, ps: \"ps-y-reach-end\" },\n  { te: `scrollXStart.${Ot}.${St}`, ps: \"ps-x-reach-start\" },\n  { te: `scrollYStart.${Ot}.${St}`, ps: \"ps-y-reach-start\" }\n], bv = {\n  handlers: [\"click-rail\", \"drag-thumb\", \"keyboard\", \"wheel\", \"touch\"],\n  wheelSpeed: 1,\n  wheelPropagation: !0,\n  swipeEasing: !0,\n  minScrollbarLength: null,\n  maxScrollbarLength: null,\n  scrollingThreshold: 1e3,\n  useBothWheelAxes: !1,\n  suppressScrollX: !1,\n  suppressScrollY: !1,\n  scrollXMarginOffset: 0,\n  scrollYMarginOffset: 0,\n  positionRight: !0\n}, vv = {\n  handlers: \"(string|array)\",\n  wheelSpeed: \"number\",\n  wheelPropagation: \"boolean\",\n  swipeEasing: \"boolean\",\n  minScrollbarLength: \"(number|null)\",\n  maxScrollbarLength: \"(number|null)\",\n  scrollingThreshold: \"number\",\n  useBothWheelAxes: \"boolean\",\n  suppressScrollX: \"boolean\",\n  suppressScrollY: \"boolean\",\n  scrollXMarginOffset: \"number\",\n  scrollYMarginOffset: \"number\",\n  positionRight: \"boolean\"\n}, Tv = {\n  ps: \"group/ps overflow-hidden [overflow-anchor:none] touch-none\",\n  railX: \"group/x absolute bottom-0 h-[0.9375rem] hidden opacity-0 transition-[background-color,_opacity] duration-200 ease-linear motion-reduce:transition-none z-[1035] group-[&.ps--active-x]/ps:block group-hover/ps:opacity-60 group-focus/ps:opacity-60 group-[&.ps--scrolling-x]/ps:opacity-60 hover:!opacity-90 focus:!opacity-90 [&.ps--clicking]:!opacity-90 outline-none\",\n  railXColors: \"group-[&.ps--active-x]/ps:bg-transparent hover:!bg-[#eee] focus:!bg-[#eee] [&.ps--clicking]:!bg-[#eee] dark:hover:!bg-[#555] dark:focus:!bg-[#555] dark:[&.ps--clicking]:!bg-[#555]\",\n  railXThumb: \"absolute bottom-0.5 rounded-md h-1.5 group-focus/ps:opacity-100 group-active/ps:opacity-100 [transition:background-color_.2s_linear,_height_.2s_ease-in-out] group-hover/x:h-[11px] group-focus/x:h-[0.6875rem] group-[&.ps--clicking]/x:bg-[#999] group-[&.ps--clicking]/x:h-[11px] outline-none\",\n  railXThumbColors: \"bg-[#aaa] group-hover/x:bg-[#999] group-focus/x:bg-[#999]\",\n  railY: \"group/y absolute right-0 w-[0.9375rem] hidden opacity-0 transition-[background-color,_opacity] duration-200 ease-linear motion-reduce:transition-none z-[1035] group-[&.ps--active-y]/ps:block group-hover/ps:opacity-60 group-focus/ps:opacity-60 group-[&.ps--scrolling-y]/ps:opacity-60 hover:!opacity-90 focus:!opacity-90 [&.ps--clicking]:!opacity-90 outline-none\",\n  railYColors: \"group-[&.ps--active-y]/ps:bg-transparent hover:!bg-[#eee] focus:!bg-[#eee] [&.ps--clicking]:!bg-[#eee] dark:hover:!bg-[#555] dark:focus:!bg-[#555] dark:[&.ps--clicking]:!bg-[#555]\",\n  railYThumb: \"absolute right-0.5 rounded-md w-1.5 group-focus/ps:opacity-100 group-active/ps:opacity-100 [transition:background-color_.2s_linear,_width_.2s_ease-in-out,_opacity] group-hover/y:w-[11px] group-focus/y:w-[0.6875rem] group-[&.ps--clicking]/y:w-[11px] outline-none\",\n  railYThumbColors: \"bg-[#aaa] group-hover/y:bg-[#999] group-focus/y:bg-[#999] group-[&.ps--clicking]/y:bg-[#999]\"\n}, Ev = {\n  ps: \"string\",\n  railX: \"string\",\n  railXColors: \"string\",\n  railXThumb: \"string\",\n  railXThumbColors: \"string\",\n  railY: \"string\",\n  railYColors: \"string\",\n  railYThumb: \"string\",\n  railYThumbColors: \"string\"\n};\nclass fr {\n  constructor(t, e = {}, i = {}) {\n    this._element = t, this._options = this._getConfig(e), this._classes = this._getClasses(i), this.perfectScrollbar = null, this._observer = null, this._psClasses = [\n      {\n        ps: \"ps__rail-x\",\n        te: this._classes.railX,\n        teColor: this._classes.railXColors\n      },\n      {\n        ps: \"ps__rail-y\",\n        te: this._classes.railY,\n        teColor: this._classes.railYColors\n      },\n      {\n        ps: \"ps__thumb-x\",\n        te: this._classes.railXThumb,\n        teColor: this._classes.railXThumbColors\n      },\n      {\n        ps: \"ps__thumb-y\",\n        te: this._classes.railYThumb,\n        teColor: this._classes.railYThumbColors\n      }\n    ], this._element && (y.setData(t, xs, this), h.addClass(this._element, gv)), this.init();\n  }\n  // Getters\n  static get NAME() {\n    return po;\n  }\n  get railX() {\n    return d.findOne(\".ps__rail-x\", this._element);\n  }\n  get railY() {\n    return d.findOne(\".ps__rail-y\", this._element);\n  }\n  _getConfig(t) {\n    const e = h.getDataAttributes(this._element);\n    return e.handlers !== void 0 && (e.handlers = e.handlers.split(\" \")), t = {\n      ...bv,\n      ...e,\n      ...t\n    }, D(po, t, vv), t;\n  }\n  _getClasses(t) {\n    const e = h.getDataClassAttributes(this._element);\n    return t = {\n      ...Tv,\n      ...e,\n      ...t\n    }, D(po, t, Ev), t;\n  }\n  // Public\n  dispose() {\n    this._options.positionRight && this._observer.disconnect(), y.removeData(this._element, xs), this._element = null, this._dataAttrOptions = null, this._options = null, this.perfectScrollbar.destroy(), this.removeEvent(_o), this.perfectScrollbar = null;\n  }\n  init() {\n    if (this.perfectScrollbar = new Ui(this._element, this._options), this._addPerfectScrollbarStyles(), this._updateScrollPosition(), this.perfectScrollbar.update(), this._initEvents(_o), this._options.positionRight) {\n      this._observer = new ResizeObserver(() => {\n        setTimeout(() => {\n          this._updateScrollPosition();\n        }, 100);\n      });\n      const t = {\n        attributes: !0,\n        attributeFilter: [\"class\", \"className\"]\n      };\n      this._observer.observe(this._element, t);\n    }\n  }\n  _updateScrollPosition() {\n    const t = getComputedStyle(this._element).getPropertyValue(\"height\"), e = getComputedStyle(this._element).getPropertyValue(\"width\");\n    this.railX && (this.railX.style.transform = `translateY(calc(-100% + ${this._canTransform(t) ? t : \"0px\"}))`), this.railY && (this.railY.style.transform = `translateX(calc(-100% + ${this._canTransform(e) ? e : \"0px\"}))`);\n  }\n  _canTransform(t) {\n    return t && t.includes(\"px\");\n  }\n  update() {\n    return this.perfectScrollbar.update();\n  }\n  _initEvents(t = []) {\n    t.forEach(\n      ({ ps: e, te: i }) => c.on(\n        this._element,\n        e,\n        (n) => c.trigger(this._element, i, { e: n })\n      )\n    );\n  }\n  _addPerfectScrollbarStyles() {\n    this._psClasses.forEach((t) => {\n      const e = d.findOne(`.${t.ps}`, this._element);\n      h.addClass(e, t.te), h.addClass(e, t.teColor);\n    }), h.addClass(this._element, this._classes.ps), h.removeClass(this._element, \"ps\");\n  }\n  removeEvent(t) {\n    let e = [];\n    typeof t == \"string\" && (e = _o.filter(({ te: i }) => i === t)), e.forEach(({ ps: i, te: n }) => {\n      c.off(this._element, i), c.off(this._element, n);\n    });\n  }\n  // Static\n  static jQueryInterface(t) {\n    return this.each(function() {\n      let e = y.getData(this, xs);\n      const i = typeof t == \"object\" && t;\n      if (!(!e && /dispose|hide/.test(t)) && (e || (e = new fr(this, i)), typeof t == \"string\")) {\n        if (typeof e[t] > \"u\")\n          throw new TypeError(`No method named \"${t}\"`);\n        e[t]();\n      }\n    });\n  }\n  static getInstance(t) {\n    return y.getData(t, xs);\n  }\n  static getOrCreateInstance(t, e = {}) {\n    return this.getInstance(t) || new this(t, typeof e == \"object\" ? e : null);\n  }\n}\nconst mh = fr, Cv = \"data-te-datatable-select-ref\", Av = \"data-te-datatable-pagination-nav-ref\", yv = \"data-te-datatable-pagination-right-ref\", wv = \"data-te-datatable-pagination-left-ref\", kv = \"data-te-datatable-pagination-start-ref\", xv = \"data-te-datatable-pagination-end-ref\", Ov = ({\n  text: s,\n  entries: t,\n  entriesOptions: e,\n  fullPagination: i,\n  rowsText: n,\n  allText: o,\n  paginationStartIconTemplate: r,\n  paginationLeftIconTemplate: a,\n  paginationRightIconTemplate: l,\n  paginationEndIconTemplate: p,\n  classes: u\n}, _, f) => {\n  const g = e.map((m) => m === \"All\" ? `<option value=\"${m}\" ${m === t ? \"selected\" : \"\"}>${o}</option>` : `<option value=\"${m}\" ${m === t ? \"selected\" : \"\"}>${m}</option>`).join(`\n`);\n  return `\n<div class=\"${u.pagination} ${f ? `${u.paginationBordered}` : \"\"} ${u.borderColor} ${u.color}\">\n  <div class=\"${u.selectItemsWrapper}\">  \n    <p class=\"${u.paginationRowsText} ${_ ? `${u.loadingPaginationRowsText}` : \"\"}\">${n}</p>\n    <div class=\"${u.selectWrapper} ${_ ? `${u.loadingPaginationSelectWrapper}` : \"\"}\">\n      <select name=\"entries\"\n        ${_ ? \"disabled\" : \"\"} class=\"select\" ${Cv}>\n        ${g}\n      </select>\n    </div>\n  </div>\n  <div class=\"${u.paginationNav} ${_ ? `${u.loadingPaginationNav}` : \"\"}\" ${Av}>\n  ${s}\n  </div>\n  <div class=\"${u.paginationButtonsWrapper}\">\n    ${i ? `<button data-te-ripple-init data-te-ripple-color=\"dark\" class=\"${u.paginationStartButton}\" ${kv}>\n           ${r}\n          </button>` : \"\"}\n    <button data-te-ripple-init data-te-ripple-color=\"dark\" class=\"${u.paginationLeftButton}\" ${wv}>\n      ${a}\n  </button>\n    <button data-te-ripple-init data-te-ripple-color=\"dark\" class=\"${u.paginationRightButton}\" ${yv}>\n      ${l}\n  </button>\n    ${i ? `<button data-te-ripple-init data-te-ripple-color=\"dark\" class=\"${u.paginationEndButton}\" ${xv}>\n           ${p}\n          </button>` : \"\"}\n  </div>\n</div>\n`;\n}, Sv = \"data-te-datatable-sort-icon-ref\", Iv = \"data-te-datatable-header-checkbox-ref\", Dv = (s, t, e, i, n, o, r, a) => {\n  const l = e ? `\n  <th scope=\"col\">\n    <div class=\"${a.checkboxHeaderWrapper}\">\n      <input\n        class=\"${a.checkboxHeader}\"\n        type=\"checkbox\"\n        value=\"\"\n        ${Iv}\n        />\n    </div>\n  </th>\n  ` : '<th scope=\"col\"></th>', p = s.map((u, _) => {\n    const f = u.fixed ? s.filter((g, m) => g.fixed === u.fixed && m < _).reduce((g, m) => g + m.width, 0) : null;\n    return `<th class=\"${a.column} ${i ? `${a.tableBordered}` : \"\"} ${a.borderColor} ${n ? `${a.sm}` : \"\"} ${u.fixed ? `${a.fixedHeader} ${a.color}` : \"\"} ${o ? `${a.loadingColumn}` : \"\"}\" style=\"${u.fixed ? `${u.fixed === \"right\" ? \"right\" : \"left\"}: ${f}px;` : \"\"}\" scope=\"col\">${u.sort ? `<div class=\"${a.sortIconWrapper}\"><span class=\"${a.sortIcon} ${o ? \"invisible\" : \"\"}\" data-te-sort=\"${u.field}\" ${Sv}>${r}</span>` : \"\"} <span class=\"${u.sort ? \"\" : \"pl-[18px]\"}\">${u.label}</span></div></th>`;\n  });\n  return [t ? l : \"\", ...p].join(`\n`);\n}, $v = \"data-te-datatable-row-ref\", Lv = \"data-te-datatable-row-checkbox-ref\", Nv = \"data-te-datatable-cell-ref\", Mv = ({\n  rows: s,\n  columns: t,\n  noFoundMessage: e,\n  edit: i,\n  selectable: n,\n  loading: o,\n  bordered: r,\n  borderless: a,\n  striped: l,\n  hover: p,\n  sm: u,\n  classes: _\n}) => {\n  const f = s.map((g) => {\n    const m = `\n      <td data-te-field=\"checkbox\" class=\"${r ? `${_.tableBordered} ${_.borderColor}` : \"\"}\">\n        <div class=\"${_.checkboxRowWrapper}\">\n          <input\n            class=\"${_.checkboxRow}\"\n            type=\"checkbox\"\n            value=\"\"\n            data-te-row-index=\"${g.rowIndex}\"  ${Lv}/>\n        </div>\n      </td>`, b = t.map((v, C) => {\n      const w = {};\n      if (v.width && (w[\"min-width\"] = `${v.width - 1}px`, w[\"max-width\"] = `${v.width}px`, w.width = `${v.width}px`), v.fixed) {\n        const T = t.filter((A, k) => A.fixed === v.fixed && k < C).reduce((A, k) => A + k.width, 0);\n        w[v.fixed === \"right\" ? \"right\" : \"left\"] = `${T}px`;\n      }\n      return `<td style=\"${Object.keys(w).map((T) => `${T}: ${w[T]}`).join(\"; \")}\" class=\"${_.rowItem} ${_.borderColor} ${i ? `${_.edit}` : \"\"} ${r ? `${_.tableBordered}` : \"\"} ${u ? `${_.sm}` : \"\"} ${v.fixed ? `${_.fixedHeader} ${_.color}` : \"\"}\" ${Nv} data-te-field=\"${v.field}\" ${i && 'contenteditable=\"true\"'}>${g[v.field]}</td>`;\n    }).join(\"\");\n    return `<tr scope=\"row\" class=\"${_.row} ${_.borderColor} ${_.rowAnimation} ${l ? `${_.striped}` : \"\"} ${a ? `${_.borderless}` : \"\"} ${p ? `${_.hoverRow}` : \"\"}\" data-te-index=\"${g.rowIndex}\" ${$v}>${n ? m : \"\"}${b}</tr>`;\n  });\n  return s.length > 0 || o ? f.join(`\n`) : `<tr class=\"${_.noFoundMessageWrapper} ${_.borderColor}\"><td class=\"${_.noFoundMessage}\">${e}</td></tr>`;\n}, Rv = \"data-te-datatable-inner-ref\", Pv = \"data-te-datatable-header-ref\", wl = ({\n  columns: s,\n  rows: t,\n  noFoundMessage: e,\n  edit: i,\n  multi: n,\n  selectable: o,\n  loading: r,\n  loadingMessage: a,\n  pagination: l,\n  bordered: p,\n  borderless: u,\n  striped: _,\n  hover: f,\n  fixedHeader: g,\n  sm: m,\n  sortIconTemplate: b,\n  classes: v\n}) => {\n  const C = Mv({\n    rows: t,\n    columns: s,\n    noFoundMessage: e,\n    edit: i,\n    loading: r,\n    selectable: o,\n    bordered: p,\n    borderless: u,\n    striped: _,\n    hover: f,\n    sm: m,\n    classes: v\n  }), w = Dv(\n    s,\n    o,\n    n,\n    p,\n    m,\n    r,\n    b,\n    v\n  );\n  return { table: `\n<div class=\"${v.color}\" ${Rv}>\n  <table class=\"${v.table}\">\n    <thead class=\"${v.tableHeader} ${p ? `${v.tableBordered}` : \"\"} ${u ? `${v.borderless}` : \"\"} ${v.borderColor}\" ${Pv}>\n      <tr>\n        ${w}\n      </tr>\n    </thead>\n    <tbody class=\"${g ? `${v.fixedHeaderBody}` : \"\"}\">\n      ${r ? \"\" : C}\n    </tbody>\n  </table>\n</div>\n${r ? `\n  <div class=\"${v.loadingItemsWrapper}\">\n    <div class=\"${v.loadingProgressBarWrapper}\">\n      <div class=\"${v.loadingProgressBar}\"></div>\n    </div>\n  </div>\n<p class=\"${v.loadingMessage}\">${a}</p>\n` : \"\"}\n${l.enable ? Ov(l, r, p) : \"\"}\n  `, rows: C, column: w };\n}, Bv = ({ rows: s, field: t, order: e }) => s.sort((n, o) => {\n  let r = n[t], a = o[t];\n  return typeof r == \"string\" && (r = r.toLowerCase()), typeof a == \"string\" && (a = a.toLowerCase()), r < a ? e === \"desc\" ? 1 : -1 : r > a ? e === \"desc\" ? -1 : 1 : 0;\n}), Hv = (s, t, e) => {\n  if (!t)\n    return s;\n  const i = (n) => {\n    const o = document.createElement(\"div\");\n    return o.innerHTML = n, n = o.textContent || o.innerText || \"\", n.toString().toLowerCase().match(t.toLowerCase());\n  };\n  return s.filter((n) => {\n    if (e && typeof e == \"string\")\n      return i(n[e]);\n    let o = Object.values(n);\n    return e && Array.isArray(e) && (o = Object.keys(n).filter((r) => e.includes(r)).map((r) => n[r])), o.filter((r) => i(r)).length > 0;\n  });\n}, kl = ({ rows: s, entries: t, activePage: e }) => {\n  const i = e * t;\n  return s.slice(i, i + Number(t));\n}, Ni = \"datatable\", ft = `data-te-${Ni}`, Ei = `te.${Ni}`, _n = `.${Ei}`, Vv = `[${ft}-inner-ref]`, fo = `[${ft}-cell-ref]`, Wv = `[${ft}-header-ref]`, Fv = `[${ft}-header-checkbox-ref]`, Yv = `[${ft}-pagination-right-ref]`, jv = `[${ft}-pagination-left-ref]`, Kv = `[${ft}-pagination-start-ref]`, zv = `[${ft}-pagination-end-ref]`, Uv = `[${ft}-pagination-nav-ref]`, Xv = `[${ft}-select-ref]`, mo = `[${ft}-sort-icon-ref]`, fi = `[${ft}-row-ref]`, go = `[${ft}-row-checkbox-ref]`, Gv = `selectRows${_n}`, xl = `render${_n}`, qv = `rowClick${_n}`, Zv = `update${_n}`, Qv = `<svg xmlns=\"http://www.w3.org/2000/svg\" fill=\"currentColor\" viewBox=\"0 0 24 24\" stroke-width=\"3\" stroke=\"currentColor\">\n  <path stroke-linecap=\"round\" stroke-linejoin=\"round\" d=\"M4.5 10.5L12 3m0 0l7.5 7.5M12 3v18\" />\n</svg>`, Jv = `<svg xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" viewBox=\"0 0 24 24\" stroke-width=\"1.5\" stroke=\"currentColor\" class=\"w-4 h-4\">\n  <path stroke-linecap=\"round\" stroke-linejoin=\"round\" d=\"M18.75 19.5l-7.5-7.5 7.5-7.5m-6 15L5.25 12l7.5-7.5\" />\n</svg>`, tT = `<svg xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" viewBox=\"0 0 24 24\" stroke-width=\"1.5\" stroke=\"currentColor\" class=\"w-4 h-4\">\n  <path stroke-linecap=\"round\" stroke-linejoin=\"round\" d=\"M15.75 19.5L8.25 12l7.5-7.5\" />\n</svg>`, eT = `<svg xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" viewBox=\"0 0 24 24\" stroke-width=\"1.5\" stroke=\"currentColor\" class=\"w-4 h-4\">\n  <path stroke-linecap=\"round\" stroke-linejoin=\"round\" d=\"M8.25 4.5l7.5 7.5-7.5 7.5\" />\n</svg>`, iT = `<svg xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" viewBox=\"0 0 24 24\" stroke-width=\"1.5\" stroke=\"currentColor\" class=\"w-4 h-4\">\n  <path stroke-linecap=\"round\" stroke-linejoin=\"round\" d=\"M11.25 4.5l7.5 7.5-7.5 7.5m-6-15l7.5 7.5-7.5 7.5\"/>\n</svg>`, sT = \"border-neutral-200 dark:border-neutral-500\", nT = \"border-none\", oT = \"relative float-left -ml-[1.5rem] mr-[6px] mt-[0.15rem] h-[1.125rem] w-[1.125rem] appearance-none rounded-[0.25rem] border-[0.125rem] border-solid border-neutral-300 outline-none before:pointer-events-none before:absolute before:h-[0.875rem] before:w-[0.875rem] before:scale-0 before:rounded-full before:bg-transparent before:opacity-0 before:shadow-[0px_0px_0px_13px_transparent] before:content-[''] checked:border-primary checked:bg-primary checked:before:opacity-[0.16] checked:after:absolute checked:after:-mt-px checked:after:ml-[0.25rem] checked:after:block checked:after:h-[0.8125rem] checked:after:w-[0.375rem] checked:after:rotate-45 checked:after:border-[0.125rem] checked:after:border-l-0 checked:after:border-t-0 checked:after:border-solid checked:after:border-white checked:after:bg-transparent checked:after:content-[''] hover:cursor-pointer hover:before:opacity-[0.04] hover:before:shadow-[0px_0px_0px_13px_rgba(0,0,0,0.6)] focus:shadow-none focus:transition-[border-color_0.2s] focus:before:scale-100 focus:before:opacity-[0.12] focus:before:shadow-[0px_0px_0px_13px_rgba(0,0,0,0.6)] focus:before:transition-[box-shadow_0.2s,transform_0.2s] focus:after:absolute focus:after:z-[1] focus:after:block focus:after:h-[0.875rem] focus:after:w-[0.875rem] focus:after:rounded-[0.125rem] focus:after:content-[''] checked:focus:before:scale-100 checked:focus:before:shadow-[0px_0px_0px_13px_#3b71ca] checked:focus:before:transition-[box-shadow_0.2s,transform_0.2s] checked:focus:after:-mt-px checked:focus:after:ml-[0.25rem] checked:focus:after:h-[0.8125rem] checked:focus:after:w-[0.375rem] checked:focus:after:rotate-45 checked:focus:after:rounded-none checked:focus:after:border-[0.125rem] checked:focus:after:border-l-0 checked:focus:after:border-t-0 checked:focus:after:border-solid checked:focus:after:border-white checked:focus:after:bg-transparent dark:border-neutral-600 dark:checked:border-primary dark:checked:bg-primary dark:focus:before:shadow-[0px_0px_0px_13px_rgba(255,255,255,0.4)] dark:checked:focus:before:shadow-[0px_0px_0px_13px_#3b71ca] dark:border-neutral-400\", rT = \"mb-[0.125rem] min-h-[1.5rem] pl-[1.5rem] ml-3 flex items-center\", aT = \"relative float-left -ml-[1.5rem] mr-[6px] mt-[0.15rem] h-[1.125rem] w-[1.125rem] appearance-none rounded-[0.25rem] border-[0.125rem] border-solid border-neutral-300 outline-none before:pointer-events-none before:absolute before:h-[0.875rem] before:w-[0.875rem] before:scale-0 before:rounded-full before:bg-transparent before:opacity-0 before:shadow-[0px_0px_0px_13px_transparent] before:content-[''] checked:border-primary checked:bg-primary checked:before:opacity-[0.16] checked:after:absolute checked:after:-mt-px checked:after:ml-[0.25rem] checked:after:block checked:after:h-[0.8125rem] checked:after:w-[0.375rem] checked:after:rotate-45 checked:after:border-[0.125rem] checked:after:border-l-0 checked:after:border-t-0 checked:after:border-solid checked:after:border-white checked:after:bg-transparent checked:after:content-[''] hover:cursor-pointer hover:before:opacity-[0.04] hover:before:shadow-[0px_0px_0px_13px_rgba(0,0,0,0.6)] focus:shadow-none focus:transition-[border-color_0.2s] focus:before:scale-100 focus:before:opacity-[0.12] focus:before:shadow-[0px_0px_0px_13px_rgba(0,0,0,0.6)] focus:before:transition-[box-shadow_0.2s,transform_0.2s] focus:after:absolute focus:after:z-[1] focus:after:block focus:after:h-[0.875rem] focus:after:w-[0.875rem] focus:after:rounded-[0.125rem] focus:after:content-[''] checked:focus:before:scale-100 checked:focus:before:shadow-[0px_0px_0px_13px_#3b71ca] checked:focus:before:transition-[box-shadow_0.2s,transform_0.2s] checked:focus:after:-mt-px checked:focus:after:ml-[0.25rem] checked:focus:after:h-[0.8125rem] checked:focus:after:w-[0.375rem] checked:focus:after:rotate-45 checked:focus:after:rounded-none checked:focus:after:border-[0.125rem] checked:focus:after:border-l-0 checked:focus:after:border-t-0 checked:focus:after:border-solid checked:focus:after:border-white checked:focus:after:bg-transparent dark:border-neutral-600 dark:checked:border-primary dark:checked:bg-primary dark:focus:before:shadow-[0px_0px_0px_13px_rgba(255,255,255,0.4)] dark:checked:focus:before:shadow-[0px_0px_0px_13px_#3b71ca] dark:border-neutral-400\", lT = \"mb-[0.125rem] min-h-[1.5rem] pl-[1.5rem] ml-3 flex items-center\", cT = \"bg-white dark:bg-neutral-800\", hT = \"py-4 pl-1 text-clip overflow-hidden text-[#212529] dark:text-white\", dT = \"focus:outline-none\", uT = \"sticky top-0 z-30\", pT = \"sticky z-10 bg-inherit\", _T = \"hover:bg-neutral-100 dark:hover:bg-neutral-700\", fT = \"pointer-events-none cursor-none text-neutral-400 dark:text-neutral-300\", mT = \"h-[2px] relative w-full overflow-hidden\", gT = \"text-center text-neutral-500 font-ligh text-sm my-4 dark:text-neutral-400\", bT = \"text-neutral-500 dark:text-neutral-300\", vT = \"text-neutral-500 dark:text-neutral-300\", TT = \"pointer-events-none cursor-none\", ET = \"h-full w-[45%] bg-primary-400 dark:bg-primary-600\", CT = \"h-full animate-[progress_3s_ease-in-out_infinite]\", AT = \"pl-2 py-3 font-light text-sm dark:text-neutral-300\", yT = \"border-b\", wT = \"flex md:flex-row justify-end items-center py-2 space-x-4 text-sm flex-col leading-[1.6]\", kT = \"border border-t-0\", xT = \"order-1 my-3 md:order-none md:my-0 md:pr-1\", OT = \"inline-block rounded p-2.5 text-xs font-medium uppercase leading-normal transition duration-150 ease-in-out hover:bg-neutral-100 hover:text-primary-600 focus:text-primary-600 focus:outline-none focus:ring-0 active:text-primary-700 disabled:text-slate-300 disabled:hover:bg-transparent dark:hover:bg-neutral-500 dark:disabled:hover:bg-transparent dark:disabled:text-neutral-600\", ST = \"inline-block rounded p-2.5 font-medium uppercase leading-normal transition duration-150 ease-in-out hover:bg-neutral-100 hover:text-primary-600 focus:text-primary-600 focus:outline-none focus:ring-0 active:text-primary-700 disabled:text-slate-300 disabled:hover:bg-transparent dark:hover:bg-neutral-500 dark:disabled:hover:bg-transparent dark:disabled:text-neutral-600\", IT = \"font-normal order-2 mb-3 md:order-none md:mb-0\", DT = \"inline-block rounded p-2.5 font-medium uppercase leading-normal transition duration-150 ease-in-out hover:bg-neutral-100 hover:text-primary-600 focus:text-primary-600 focus:outline-none focus:ring-0 active:text-primary-700 disabled:text-slate-300 disabled:hover:bg-transparent dark:hover:bg-neutral-500 dark:disabled:hover:bg-transparent dark:disabled:text-neutral-600\", $T = \"font-light\", LT = \"inline-block rounded p-2.5 font-medium uppercase leading-normal transition duration-150 ease-in-out hover:bg-neutral-100 hover:text-primary-600 focus:text-primary-600 focus:outline-none focus:ring-0 active:text-primary-700 disabled:text-slate-300 disabled:hover:bg-transparent dark:hover:bg-neutral-500 dark:disabled:hover:bg-transparent dark:disabled:text-neutral-600\", NT = \"border-b\", MT = \"transition ease-in-out duration-300 motion-reduce:transition-none\", RT = \"whitespace-nowrap text-clip overflow-hidden px-[1.4rem] py-4\", PT = \"relative\", BT = \"!bg-neutral-100 dark:!bg-neutral-600\", HT = \"flex items-center space-x-4 order-3 md:order-none\", VT = \"w-[70px]\", WT = \"!py-2\", FT = \"w-[15px] h-[10px] origin-bottom font-black mr-1 opacity-0 text-neutral-500 group-hover:opacity-100 transition hover:ease-in-out transform ease-linear duration-300 motion-reduce:transition-none dark:text-neutral-400\", YT = \"flex flex-row group\", jT = \"[&:nth-child(odd)]:bg-neutral-50 [&:nth-child(odd)]:dark:bg-neutral-700\", KT = \"border\", zT = \"border-b font-normal px-[1.4rem]\", UT = \"text-left text-sm font-light w-full leading-[1.6]\", XT = {\n  bordered: \"boolean\",\n  borderless: \"boolean\",\n  clickableRows: \"boolean\",\n  defaultValue: \"string\",\n  edit: \"boolean\",\n  entries: \"(number|string)\",\n  entriesOptions: \"array\",\n  fullPagination: \"boolean\",\n  hover: \"boolean\",\n  loading: \"boolean\",\n  loadingMessage: \"string\",\n  maxWidth: \"(null|number|string)\",\n  maxHeight: \"(null|number|string)\",\n  multi: \"boolean\",\n  noFoundMessage: \"string\",\n  pagination: \"boolean\",\n  selectable: \"boolean\",\n  sm: \"boolean\",\n  sortField: \"(null|string)\",\n  sortOrder: \"string\",\n  fixedHeader: \"boolean\",\n  striped: \"boolean\",\n  rowsText: \"string\",\n  ofText: \"string\",\n  allText: \"string\",\n  forceSort: \"boolean\",\n  sortIconTemplate: \"string\",\n  paginationStartIconTemplate: \"string\",\n  paginationEndIconTemplate: \"string\",\n  paginationLeftIconTemplate: \"string\",\n  paginationRightIconTemplate: \"string\"\n}, GT = {\n  bordered: !1,\n  borderless: !1,\n  clickableRows: !1,\n  defaultValue: \"-\",\n  edit: !1,\n  entries: 10,\n  entriesOptions: [10, 25, 50, 200],\n  fixedHeader: !1,\n  fullPagination: !1,\n  hover: !1,\n  loading: !1,\n  loadingMessage: \"Loading results...\",\n  maxWidth: null,\n  maxHeight: null,\n  multi: !1,\n  noFoundMessage: \"No matching results found\",\n  pagination: !0,\n  selectable: !1,\n  sm: !1,\n  sortField: null,\n  sortOrder: \"asc\",\n  striped: !1,\n  rowsText: \"Rows per page:\",\n  ofText: \"of\",\n  allText: \"All\",\n  forceSort: !1,\n  sortIconTemplate: Qv,\n  paginationStartIconTemplate: Jv,\n  paginationEndIconTemplate: iT,\n  paginationLeftIconTemplate: tT,\n  paginationRightIconTemplate: eT\n}, qT = {\n  label: \"string\",\n  field: \"string\",\n  fixed: \"(boolean|string)\",\n  format: \"(function|null)\",\n  width: \"(number|null)\",\n  sort: \"boolean\",\n  columnIndex: \"number\"\n}, ZT = {\n  label: \"\",\n  field: \"\",\n  fixed: !1,\n  format: null,\n  width: null,\n  sort: !0,\n  columnIndex: 0\n}, QT = {\n  table: UT,\n  tableHeader: zT,\n  column: hT,\n  pagination: wT,\n  selectWrapper: VT,\n  scroll: PT,\n  tableBordered: KT,\n  paginationBordered: kT,\n  borderless: nT,\n  checkboxRowWrapper: lT,\n  checkboxRow: aT,\n  checkboxHeaderWrapper: rT,\n  checkboxHeader: oT,\n  row: NT,\n  rowItem: RT,\n  striped: jT,\n  sortIconWrapper: YT,\n  sortIcon: FT,\n  paginationRowsText: $T,\n  paginationNav: IT,\n  paginationButtonsWrapper: xT,\n  hoverRow: _T,\n  borderColor: sT,\n  color: cT,\n  fixedHeader: uT,\n  fixedHeaderBody: pT,\n  selectableRow: BT,\n  rowAnimation: MT,\n  sm: WT,\n  edit: dT,\n  selectItemsWrapper: HT,\n  paginationStartButton: LT,\n  paginationLeftButton: ST,\n  paginationRightButton: DT,\n  paginationEndButton: OT,\n  loadingItemsWrapper: mT,\n  loadingProgressBarWrapper: CT,\n  loadingProgressBar: ET,\n  loadingMessage: gT,\n  loadingPaginationRowsText: vT,\n  loadingPaginationSelectWrapper: TT,\n  loadingPaginationNav: bT,\n  loadingColumn: fT,\n  noFoundMessageWrapper: yT,\n  noFoundMessage: AT\n}, JT = {\n  table: \"string\",\n  tableHeader: \"string\",\n  column: \"string\",\n  pagination: \"string\",\n  selectWrapper: \"string\",\n  scroll: \"string\",\n  tableBordered: \"string\",\n  paginationBordered: \"string\",\n  borderless: \"string\",\n  checkboxRowWrapper: \"string\",\n  checkboxRow: \"string\",\n  checkboxHeaderWrapper: \"string\",\n  checkboxHeader: \"string\",\n  row: \"string\",\n  rowItem: \"string\",\n  striped: \"string\",\n  sortIconWrapper: \"string\",\n  sortIcon: \"string\",\n  paginationRowsText: \"string\",\n  paginationNav: \"string\",\n  paginationButtonsWrapper: \"string\",\n  hoverRow: \"string\",\n  borderColor: \"string\",\n  color: \"string\",\n  fixedHeader: \"string\",\n  fixedHeaderBody: \"string\",\n  selectableRow: \"string\",\n  rowAnimation: \"string\",\n  sm: \"string\",\n  edit: \"string\",\n  selectItemsWrapper: \"string\",\n  paginationStartButton: \"string\",\n  paginationLeftButton: \"string\",\n  paginationRightButton: \"string\",\n  paginationEndButton: \"string\",\n  loadingItemsWrapper: \"string\",\n  loadingProgressBarWrapper: \"string\",\n  loadingProgressBar: \"string\",\n  loadingMessage: \"string\",\n  loadingPaginationRowsText: \"string\",\n  loadingPaginationSelectWrapper: \"string\",\n  loadingPaginationNav: \"string\",\n  loadingColumn: \"string\",\n  noFoundMessageWrapper: \"string\",\n  noFoundMessage: \"string\"\n};\nclass gh {\n  constructor(t, e = {}, i = {}, n = {}) {\n    this._element = t, this._options = this._getOptions(i), this._classes = this._getClasses(n), this._sortReverse = !1, this._activePage = 0, this._search = \"\", this._searchColumn = null, this._paginationLeft = null, this._paginationRight = null, this._paginationStart = null, this._paginationEnd = null, this._select = null, this._selectInstance = null, this._selected = [], this._checkboxes = null, this._headerCheckbox = null, this._rows = this._getRows(e.rows), this._columns = this._getColumns(e.columns), this._element && (y.setData(t, Ei, this), this._perfectScrollbar = null, this._setup());\n  }\n  // Getters\n  static get NAME() {\n    return Ni;\n  }\n  get columns() {\n    return this._columns.map((t, e) => {\n      let i = {\n        ...ZT,\n        field: `field_${e}`,\n        columnIndex: e\n      };\n      return typeof t == \"string\" ? i.label = t : typeof t == \"object\" && (i = {\n        ...i,\n        ...t\n      }), D(\"column\", i, qT), i;\n    });\n  }\n  get rows() {\n    return this._rows.map((t, e) => {\n      const i = {\n        rowIndex: e\n      };\n      return Array.isArray(t) ? this.columns.forEach((n, o) => {\n        t[o] === 0 ? i[n.field] = t[o] : i[n.field] = t[o] || this._options.defaultValue;\n      }) : typeof t == \"object\" && this.columns.forEach((n) => {\n        t[n.field] === 0 ? i[n.field] = t[n.field] : i[n.field] = t[n.field] || this._options.defaultValue;\n      }), i;\n    });\n  }\n  get searchResult() {\n    return Hv(this.rows, this._search, this._searchColumn);\n  }\n  get computedRows() {\n    let t = [...this.searchResult];\n    return this._options.sortOrder && (t = Bv({\n      rows: t,\n      field: this._options.sortField,\n      order: this._options.sortOrder\n    })), this._options.pagination && (this._options.entries === \"All\" ? t = kl({\n      rows: t,\n      entries: t.length,\n      activePage: this._activePage\n    }) : t = kl({\n      rows: t,\n      entries: this._options.entries,\n      activePage: this._activePage\n    })), t;\n  }\n  get pages() {\n    return this._options.entries === \"All\" ? 1 : Math.ceil(this.searchResult.length / this._options.entries);\n  }\n  get navigationText() {\n    const t = this._activePage * this._options.entries;\n    return this.searchResult.length === 0 ? `0 ${this._options.ofText} 0` : this._options.entries === \"All\" ? `1 - ${this.searchResult.length} ${this._options.ofText} ${this.searchResult.length}` : `${t + 1} - ${this.computedRows.length + t} ${this._options.ofText} ${this.searchResult.length}`;\n  }\n  get tableOptions() {\n    return {\n      classes: this._classes,\n      columns: this.columns,\n      rows: this.computedRows,\n      noFoundMessage: this._options.noFoundMessage,\n      edit: this._options.edit,\n      loading: this._options.loading,\n      loaderClass: this._options.loaderClass,\n      loadingMessage: this._options.loadingMessage,\n      selectable: this._options.selectable,\n      multi: this._options.multi,\n      bordered: this._options.bordered,\n      borderless: this._options.borderless,\n      striped: this._options.striped,\n      hover: this._options.hover,\n      fixedHeader: this._options.fixedHeader,\n      sm: this._options.sm,\n      sortIconTemplate: this._options.sortIconTemplate,\n      pagination: {\n        enable: this._options.pagination,\n        text: this.navigationText,\n        entries: this._options.entries,\n        entriesOptions: this._options.entriesOptions,\n        fullPagination: this._options.fullPagination,\n        rowsText: this._options.rowsText,\n        ofText: this._options.ofText,\n        allText: this._options.allText,\n        paginationStartIconTemplate: this._options.paginationStartIconTemplate,\n        paginationLeftIconTemplate: this._options.paginationLeftIconTemplate,\n        paginationRightIconTemplate: this._options.paginationRightIconTemplate,\n        paginationEndIconTemplate: this._options.paginationEndIconTemplate,\n        classes: this._classes\n      },\n      forceSort: this._options.forceSort\n    };\n  }\n  // Public\n  update(t, e = {}) {\n    t && t.rows && (this._rows = t.rows), t && t.columns && (this._columns = t.columns), this._clearClassList(e), this._options = this._getOptions({ ...this._options, ...e }), this._setup(), this._performSort();\n  }\n  dispose() {\n    this._selectInstance && this._selectInstance.dispose(), y.removeData(this._element, Ei), this._removeEventListeners(), this._perfectScrollbar.destroy(), this._element = null;\n  }\n  search(t, e) {\n    this._search = t, this._searchColumn = e, this._activePage = 0, this._options.pagination && this._toggleDisableState(), this._renderRows(), this._options.maxHeight && (this._perfectScrollbar.element.scrollTop = 0, this._perfectScrollbar.update());\n  }\n  sort(t, e = \"asc\") {\n    this._options.sortOrder = e, typeof t == \"string\" ? this._options.sortField = this.columns.find(\n      (n) => n.label === t\n    ).field : this._options.sortField = t.field;\n    const i = d.findOne(\n      `[data-te-sort=\"${this._options.sortField}\"]`,\n      this._element\n    );\n    this._activePage = 0, this._toggleDisableState(), this._renderRows(), this._setActiveSortIcon(i);\n  }\n  setActivePage(t) {\n    t < this.pages && this._changeActivePage(t);\n  }\n  // Private\n  _getClasses(t) {\n    const e = h.getDataClassAttributes(this._element);\n    return t = {\n      ...QT,\n      ...e,\n      ...t\n    }, D(Ni, t, JT), t;\n  }\n  _changeActivePage(t) {\n    this._activePage = t, this._toggleDisableState(), this._renderRows();\n  }\n  _clearClassList(t) {\n    [\"hover\", \"bordered\", \"borderless\", \"sm\", \"striped\"].forEach((e) => {\n      this._options[e] && !t[e] && h.removeDataAttribute(`data-te-${e}`);\n    });\n  }\n  _emitSelectEvent() {\n    c.trigger(this._element, Gv, {\n      selectedRows: this.rows.filter(\n        (t) => this._selected.indexOf(t.rowIndex) !== -1\n      ),\n      selectedIndexes: this._selected,\n      allSelected: this._selected.length === this.rows.length\n    });\n  }\n  _getRows(t = []) {\n    const e = d.findOne(\"tbody\", this._element);\n    return e ? [...d.find(\"tr\", e).map((n) => d.find(\"td\", n).map((o) => o.innerHTML)), ...t] : t;\n  }\n  _getColumns(t = []) {\n    const e = d.findOne(\"thead\", this._element);\n    if (!e)\n      return t;\n    const i = d.findOne(\"tr\", e);\n    return [...d.find(\"th\", i).map((o) => ({\n      label: o.innerHTML,\n      ...h.getDataAttributes(o)\n    })), ...t];\n  }\n  _getCSSValue(t) {\n    return typeof t == \"string\" ? t : `${t}px`;\n  }\n  _getOptions(t) {\n    const e = {\n      ...GT,\n      ...h.getDataAttributes(this._element),\n      ...t\n    };\n    return D(Ni, e, XT), e;\n  }\n  _setActiveRows() {\n    d.find(fi, this._element).forEach((t) => {\n      this._selected.includes(h.getDataAttribute(t, \"index\")) ? h.addClass(t, `active ${this._classes.selectableRow}`) : h.removeClass(t, `active ${this._classes.selectableRow}`);\n    });\n  }\n  _setEntries(t) {\n    this._options = this._getOptions({\n      ...this._options,\n      entries: t.target.value\n    }), this._activePage > this.pages - 1 && (this._activePage = this.pages - 1), this._toggleDisableState(), this._renderRows();\n  }\n  _setSelected() {\n    d.find(go, this._element).forEach(\n      (t) => {\n        const e = h.getDataAttribute(t, \"rowIndex\");\n        t.checked = this._selected.includes(e);\n      }\n    ), this._setActiveRows();\n  }\n  _setActiveSortIcon(t) {\n    d.find(mo, this._element).forEach((e) => {\n      const i = this._options.sortOrder === \"desc\" && e === t ? 180 : 0;\n      h.style(e, {\n        transform: `rotate(${i}deg)`\n      }), e === t && this._options.sortOrder ? h.addClass(e, \"opacity-100\") : h.removeClass(e, \"opacity-100\");\n    });\n  }\n  _setup() {\n    this._renderTable(), this._options.pagination && this._setupPagination(), this._options.edit && this._setupEditable(), this._options.clickableRows && this._setupClickableRows(), this._options.selectable && this._setupSelectable(), this._setupScroll(), this._setupSort();\n  }\n  _setupClickableRows() {\n    d.find(fi, this._element).forEach((t) => {\n      const e = h.getDataAttribute(t, \"index\");\n      h.addClass(t, \"cursor-pointer\"), c.on(t, \"click\", (i) => {\n        d.matches(i.target, go) || c.trigger(this._element, qv, {\n          index: e,\n          row: this.rows[e]\n        });\n      });\n    });\n  }\n  _setupEditable() {\n    d.find(fi, this._element).forEach((t) => {\n      const e = h.getDataAttribute(t, \"index\");\n      d.find(fo, t).forEach((i) => {\n        c.on(i, \"input\", (n) => this._updateRow(n, e));\n      });\n    });\n  }\n  _setupScroll() {\n    const t = d.findOne(Vv, this._element), e = {};\n    if (this._options.maxHeight && (e.maxHeight = this._getCSSValue(this._options.maxHeight)), this._options.maxWidth) {\n      const i = this._getCSSValue(this._options.maxWidth);\n      e.maxWidth = i, h.style(this._element, { maxWidth: i });\n    }\n    if (h.style(t, e), h.addClass(t, `${this._classes.scroll}`), this._options.fixedHeader) {\n      let i = d.find(Wv, this._element);\n      this._options.selectable && (i = i.filter((n, o) => (h.addClass(\n        n,\n        `${this._classes.fixedHeader} ${this._classes.color}`\n      ), o !== 0))), i.forEach((n, o) => {\n        h.addClass(\n          n,\n          `${this._classes.fixedHeader} ${this._classes.color}`\n        ), this.columns[o].fixed && h.addClass(n, \"!z-40\");\n      });\n    }\n    this._perfectScrollbar = new mh(t);\n  }\n  _setupSort() {\n    d.find(mo, this._element).forEach((t) => {\n      const e = h.getDataAttribute(t, \"sort\"), [i] = d.parents(t, \"th\");\n      if (this.columns.sort)\n        h.addClass(i, \"cursor-pointer\");\n      else\n        return;\n      e === this._options.sortField && this._setActiveSortIcon(t), c.on(i, \"click\", () => {\n        this._options.sortField === e && this._options.sortOrder === \"asc\" ? this._options.sortOrder = \"desc\" : this._options.sortField === e && this._options.sortOrder === \"desc\" ? this._options.sortOrder = this._options.forceSort ? \"asc\" : null : this._options.sortOrder = \"asc\", this._options.sortField = e, this._activePage = 0, this._performSort(), this._setActiveSortIcon(t);\n      });\n    });\n  }\n  _performSort() {\n    this._toggleDisableState(), this._renderRows();\n  }\n  _setupSelectable() {\n    this._checkboxes = d.find(go, this._element), this._headerCheckbox = d.findOne(\n      Fv,\n      this._element\n    ), c.on(\n      this._headerCheckbox,\n      \"input\",\n      (t) => this._toggleSelectAll(t)\n    ), this._checkboxes.forEach((t) => {\n      const e = h.getDataAttribute(t, \"rowIndex\");\n      c.on(\n        t,\n        \"input\",\n        (i) => this._toggleSelectRow(i, e)\n      );\n    });\n  }\n  _setupPagination() {\n    this._paginationRight = d.findOne(\n      Yv,\n      this._element\n    ), this._paginationLeft = d.findOne(\n      jv,\n      this._element\n    ), c.on(\n      this._paginationRight,\n      \"click\",\n      () => this._changeActivePage(this._activePage + 1)\n    ), c.on(\n      this._paginationLeft,\n      \"click\",\n      () => this._changeActivePage(this._activePage - 1)\n    ), this._options.fullPagination && (this._paginationStart = d.findOne(\n      Kv,\n      this._element\n    ), this._paginationEnd = d.findOne(\n      zv,\n      this._element\n    ), c.on(\n      this._paginationStart,\n      \"click\",\n      () => this._changeActivePage(0)\n    ), c.on(\n      this._paginationEnd,\n      \"click\",\n      () => this._changeActivePage(this.pages - 1)\n    )), this._toggleDisableState(), this._setupPaginationSelect();\n  }\n  _setupPaginationSelect() {\n    this._select = d.findOne(Xv, this._element), this._selectInstance = new _r(this._select), c.on(\n      this._select,\n      \"valueChange.te.select\",\n      (t) => this._setEntries(t)\n    );\n  }\n  _removeEventListeners() {\n    this._options.pagination && (c.off(this._paginationRight, \"click\"), c.off(this._paginationLeft, \"click\"), c.off(this._select, \"valueChange.te.select\"), this._options.fullPagination && (c.off(this._paginationStart, \"click\"), c.off(this._paginationEnd, \"click\"))), this._options.edit && d.find(fo, this._element).forEach((t) => {\n      c.off(t, \"input\");\n    }), this._options.clickableRows && d.find(fi, this._element).forEach((t) => {\n      c.off(t, \"click\");\n    }), d.find(mo, this._element).forEach((t) => {\n      const [e] = d.parents(t, \"th\");\n      c.off(e, \"click\");\n    }), this._options.selectable && (c.off(this._headerCheckbox, \"input\"), this._checkboxes.forEach((t) => {\n      c.off(t, \"input\");\n    }));\n  }\n  _renderTable() {\n    this._element.innerHTML = wl(this.tableOptions).table, this._formatCells(), c.trigger(this._element, xl);\n  }\n  _renderRows() {\n    const t = d.findOne(\"tbody\", this._element);\n    if (this._options.pagination) {\n      const e = d.findOne(\n        Uv,\n        this._element\n      );\n      e.innerText = this.navigationText;\n    }\n    t.innerHTML = wl(this.tableOptions).rows, this._formatCells(), this._options.edit && this._setupEditable(), this._options.selectable && (this._setupSelectable(), this._setSelected()), this._options.clickableRows && this._setupClickableRows(), c.trigger(this._element, xl);\n  }\n  _formatCells() {\n    d.find(fi, this._element).forEach((e) => {\n      const i = h.getDataAttribute(e, \"index\");\n      d.find(fo, e).forEach((o) => {\n        const r = h.getDataAttribute(o, \"field\"), a = this.columns.find((l) => l.field === r);\n        a && a.format !== null && a.format(o, this.rows[i][r]);\n      });\n    });\n  }\n  _toggleDisableState() {\n    this._options.pagination !== !1 && (this._activePage === 0 || this._options.loading ? (this._paginationLeft.setAttribute(\"disabled\", \"\"), this._options.fullPagination && this._paginationStart.setAttribute(\"disabled\", \"\")) : (this._paginationLeft.removeAttribute(\"disabled\"), this._options.fullPagination && this._paginationStart.removeAttribute(\"disabled\")), this._activePage === this.pages - 1 || this._options.loading || this.pages === 0 ? (this._paginationRight.setAttribute(\"disabled\", \"\"), this._options.fullPagination && this._paginationEnd.setAttribute(\"disabled\", \"\")) : (this._paginationRight.removeAttribute(\"disabled\"), this._options.fullPagination && this._paginationEnd.removeAttribute(\"disabled\")));\n  }\n  _toggleSelectAll(t) {\n    t.target.checked ? this._selected = this.rows.map((e) => e.rowIndex) : this._selected = [], this._setSelected(), this._emitSelectEvent();\n  }\n  _toggleSelectRow(t, e) {\n    t.target.checked ? this._options.multi && !this._selected.includes(e) ? this._selected = [...this._selected, e] : (this._selected = [e], this._checkboxes.forEach((i) => {\n      i !== t.target && (i.checked = !1);\n    })) : this._selected = this._selected.filter((i) => i !== e), this._options.multi && !t.target.checked && (this._headerCheckbox.checked = !1), this._setActiveRows(), this._emitSelectEvent();\n  }\n  _updateRow(t, e) {\n    const i = h.getDataAttribute(t.target, \"field\"), n = t.target.textContent, o = this._rows[e];\n    if (Array.isArray(o)) {\n      const a = this.columns.find((l) => l.field === i).columnIndex;\n      o[a] = n;\n    } else\n      o[i] = n;\n    c.trigger(this._element, Zv, {\n      rows: this._rows,\n      columns: this._columns\n    });\n  }\n  static jQueryInterface(t, e, i) {\n    return this.each(function() {\n      let n = y.getData(this, Ei);\n      const o = typeof t == \"object\" && t;\n      if (!(!n && /dispose/.test(t)) && (n || (n = new gh(this, o, e)), typeof t == \"string\")) {\n        if (typeof n[t] > \"u\")\n          throw new TypeError(`No method named \"${t}\"`);\n        n[t](e, i);\n      }\n    });\n  }\n  static getInstance(t) {\n    return y.getData(t, Ei);\n  }\n  static getOrCreateInstance(t, e = {}) {\n    return this.getInstance(t) || new this(t, typeof e == \"object\" ? e : null);\n  }\n}\nconst Ol = \"rating\", qs = \"te.rating\", tE = \"data-te-rating-init\", eE = \"[data-te-rating-icon-ref]\", ni = `.${qs}`, iE = \"ArrowLeft\", sE = \"ArrowRight\", nE = {\n  tooltip: \"string\",\n  value: \"(string|number)\",\n  readonly: \"boolean\",\n  after: \"string\",\n  before: \"string\",\n  dynamic: \"boolean\",\n  active: \"string\"\n}, oE = {\n  tooltip: \"top\",\n  value: \"\",\n  readonly: !1,\n  after: \"\",\n  before: \"\",\n  dynamic: !1,\n  active: \"fill-current\"\n}, Sl = `onSelect${ni}`, rE = `onHover${ni}`, Il = `keyup${ni}`, Dl = `focusout${ni}`, $l = `keydown${ni}`, Ll = `mousedown${ni}`;\nclass qC {\n  constructor(t, e) {\n    this._element = t, this._icons = d.find(eE, this._element), this._options = this._getConfig(e), this._index = -1, this._savedIndex = null, this._originalClassList = [], this._originalIcons = [], this._fn = {}, this._tooltips = [], this._element && (y.setData(t, qs, this), this._init());\n  }\n  // Getters\n  static get NAME() {\n    return Ol;\n  }\n  dispose() {\n    y.removeData(this._element, qs), this._options.readonly || (c.off(this._element, Il), c.off(this._element, Dl), c.off(this._element, $l), this._element.removeEventListener(\"mouseleave\", this._fn.mouseleave), this._icons.forEach((t, e) => {\n      c.off(t, Ll), t.removeEventListener(\"mouseenter\", this._fn.mouseenter[e]), h.removeClass(t, \"cursor-pointer\");\n    }), this._tooltips.forEach((t) => {\n      t._element.removeAttribute(tE), t.dispose();\n    }), this._icons.removeAttribute(\"tabIndex\")), this._element = null;\n  }\n  // Private\n  _init() {\n    this._options.readonly || (this._bindMouseEnter(), this._bindMouseLeave(), this._bindMouseDown(), this._bindKeyDown(), this._bindKeyUp(), this._bindFocusLost(), this._icons.forEach((t) => {\n      h.addClass(t, \"cursor-pointer\");\n    })), this._options.dynamic && (this._saveOriginalClassList(), this._saveOriginalIcons()), this._setCustomText(), this._setToolTips(), this._options.value && (this._index = this._options.value - 1, this._updateRating(this._index));\n  }\n  _getConfig(t) {\n    const e = h.getDataAttributes(this._element);\n    return t = {\n      ...oE,\n      ...e,\n      ...t\n    }, D(Ol, t, nE), t;\n  }\n  _bindMouseEnter() {\n    this._fn.mouseenter = [], this._icons.forEach((t, e) => {\n      t.addEventListener(\n        \"mouseenter\",\n        // this._fn.mouseenter[i] is needed to create reference and unpin events after call dispose\n        // prettier-ignore\n        this._fn.mouseenter[e] = (i) => {\n          this._index = this._icons.indexOf(i.target), this._updateRating(this._index), this._triggerEvents(t, rE);\n        }\n      );\n    });\n  }\n  _bindMouseLeave() {\n    this._element.addEventListener(\n      \"mouseleave\",\n      // this._fn.mouseleave is needed to create reference and unpin events after call dispose\n      // prettier-ignore\n      this._fn.mouseleave = () => {\n        this._savedIndex !== null ? (this._updateRating(this._savedIndex), this._index = this._savedIndex) : this._options.value ? (this._updateRating(this._options.value - 1), this._index = this._options.value - 1) : (this._index = -1, this._clearRating());\n      }\n    );\n  }\n  _bindMouseDown() {\n    this._icons.forEach((t) => {\n      c.on(t, Ll, () => {\n        this._setElementOutline(\"none\"), this._savedIndex = this._index, this._triggerEvents(t, Sl);\n      });\n    });\n  }\n  _bindKeyDown() {\n    this._element.tabIndex = 0, c.on(\n      this._element,\n      $l,\n      (t) => this._updateAfterKeyDown(t)\n    );\n  }\n  _bindKeyUp() {\n    c.on(\n      this._element,\n      Il,\n      () => this._setElementOutline(\"auto\")\n    );\n  }\n  _bindFocusLost() {\n    c.on(\n      this._element,\n      Dl,\n      () => this._setElementOutline(\"none\")\n    );\n  }\n  _setElementOutline(t) {\n    this._element.style.outline = t;\n  }\n  _triggerEvents(t, e) {\n    c.trigger(t, e, {\n      value: this._index + 1\n    });\n  }\n  _updateAfterKeyDown(t) {\n    const e = this._icons.length - 1, i = this._index;\n    t.key === sE && this._index < e && (this._index += 1), t.key === iE && this._index > -1 && (this._index -= 1), i !== this._index && (this._savedIndex = this._index, this._updateRating(this._savedIndex), this._triggerEvents(this._icons[this._savedIndex], Sl));\n  }\n  _updateRating(t) {\n    this._clearRating(), this._options.dynamic && this._restoreOriginalIcon(t), this._icons.forEach((e, i) => {\n      i <= t && h.addClass(e.querySelector(\"svg\"), this._options.active);\n    });\n  }\n  _clearRating() {\n    this._icons.forEach((t, e) => {\n      const i = t.querySelector(\"svg\");\n      this._options.dynamic && (t.classList = this._originalClassList[e], i.innerHTML = this._originalIcons[e]), h.removeClass(i, this._options.active);\n    });\n  }\n  _setToolTips() {\n    this._icons.forEach((t, e) => {\n      const i = h.getDataAttribute(t, \"toggle\");\n      t.title && !i && (h.setDataAttribute(t, \"toggle\", \"tooltip\"), this._tooltips[e] = new ii(t, {\n        placement: this._options.tooltip\n      }));\n    });\n  }\n  _setCustomText() {\n    this._icons.forEach((t) => {\n      const e = h.getDataAttribute(t, \"after\"), i = h.getDataAttribute(t, \"before\");\n      e && t.insertAdjacentHTML(\"afterEnd\", e), i && t.insertAdjacentHTML(\"beforeBegin\", i);\n    });\n  }\n  _saveOriginalClassList() {\n    this._icons.forEach((t) => {\n      const e = t.classList.value;\n      this._originalClassList.push(e);\n    });\n  }\n  _saveOriginalIcons() {\n    this._icons.forEach((t) => {\n      const e = t.querySelector(\"svg\").innerHTML;\n      this._originalIcons.push(e);\n    });\n  }\n  _restoreOriginalIcon(t) {\n    const e = this._originalClassList[t], i = this._originalIcons[t];\n    this._icons.forEach((n, o) => {\n      if (o <= t) {\n        const r = n.querySelector(\"svg\");\n        r.innerHTML = i, n.classList = e;\n      }\n    });\n  }\n  // Static\n  static getInstance(t) {\n    return y.getData(t, qs);\n  }\n  static getOrCreateInstance(t, e = {}) {\n    return this.getInstance(t) || new this(t, typeof e == \"object\" ? e : null);\n  }\n}\nconst bo = \"popconfirm\", Ci = \"te.popconfirm\", bh = `.${Ci}`, aE = `cancel${bh}`, lE = `confirm${bh}`, cE = \"[data-te-popconfirm-body]\", vo = \"data-te-popconfirm-popover\", hE = \"data-te-popconfirm-modal\", Nl = \"data-te-popconfirm-backdrop\", dE = {\n  popconfirmMode: \"string\",\n  message: \"string\",\n  cancelText: \"(null|string)\",\n  okText: \"(null|string)\",\n  popconfirmIconTemplate: \"string\",\n  cancelLabel: \"(null|string)\",\n  confirmLabel: \"(null|string)\",\n  position: \"(null|string)\"\n}, uE = {\n  popconfirmMode: \"inline\",\n  message: \"Are you sure?\",\n  cancelText: \"Cancel\",\n  okText: \"OK\",\n  popconfirmIconTemplate: \"\",\n  cancelLabel: \"Cancel\",\n  confirmLabel: \"Confirm\",\n  position: \"bottom\"\n}, pE = {\n  backdrop: \"string\",\n  body: \"string\",\n  btnCancel: \"string\",\n  btnConfirm: \"string\",\n  btnsContainer: \"string\",\n  fade: \"string\",\n  icon: \"string\",\n  message: \"string\",\n  messageText: \"string\",\n  modal: \"string\",\n  popover: \"string\"\n}, _E = {\n  backdrop: \"h-full w-full z-[1070] fixed top-0 left-0 bg-[#00000066] flex justify-center items-center\",\n  body: \"p-[1rem] bg-white rounded-[0.5rem] opacity-0 dark:bg-neutral-700\",\n  btnCancel: \"inline-block rounded bg-primary-100 px-4 pb-[5px] pt-[6px] text-xs font-medium uppercase leading-normal text-primary-700 transition duration-150 ease-in-out hover:bg-primary-accent-100 focus:bg-primary-accent-100 focus:outline-none focus:ring-0 active:bg-primary-accent-200\",\n  btnConfirm: \"inline-block rounded bg-primary px-4 pb-[5px] pt-[6px] text-xs font-medium uppercase leading-normal text-white shadow-[0_4px_9px_-4px_#3b71ca] transition duration-150 ease-in-out hover:bg-primary-600 hover:shadow-[0_8px_9px_-4px_rgba(59,113,202,0.3),0_4px_18px_0_rgba(59,113,202,0.2)] focus:bg-primary-600 focus:shadow-[0_8px_9px_-4px_rgba(59,113,202,0.3),0_4px_18px_0_rgba(59,113,202,0.2)] focus:outline-none focus:ring-0 active:bg-primary-700 active:shadow-[0_8px_9px_-4px_rgba(59,113,202,0.3),0_4px_18px_0_rgba(59,113,202,0.2)] dark:shadow-[0_4px_9px_-4px_rgba(59,113,202,0.5)] dark:hover:shadow-[0_8px_9px_-4px_rgba(59,113,202,0.2),0_4px_18px_0_rgba(59,113,202,0.1)] dark:focus:shadow-[0_8px_9px_-4px_rgba(59,113,202,0.2),0_4px_18px_0_rgba(59,113,202,0.1)] dark:active:shadow-[0_8px_9px_-4px_rgba(59,113,202,0.2),0_4px_18px_0_rgba(59,113,202,0.1)]\",\n  btnsContainer: \"flex justify-end space-x-2\",\n  fade: \"transition-opacity duration-[150ms] ease-linear\",\n  icon: \"pr-2\",\n  message: \"flex mb-3\",\n  messageText: \"text-neutral-600 dark:text-white\",\n  modal: \"absolute w-[300px] z-[1080] shadow-sm rounded-[0.5rem]\",\n  popover: \"w-[300px] border-0 rounded-[0.5rem] z-[1080] shadow-sm\"\n};\nclass vh {\n  constructor(t, e, i) {\n    this._element = t, this._options = this._getConfig(e), this._classes = this._getClasses(i), this._popper = null, this._cancelButton = \"\", this._confirmButton = \"\", this._isOpen = !1, this._uid = this._element.id ? `popconfirm-${this._element.id}` : rt(\"popconfirm-\"), t && y.setData(t, Ci, this), this._clickHandler = this.open.bind(this), c.on(this._element, \"click\", this._clickHandler);\n  }\n  // Getters\n  static get NAME() {\n    return bo;\n  }\n  get container() {\n    return d.findOne(`#${this._uid}`);\n  }\n  get popconfirmBody() {\n    return d.findOne(\n      cE,\n      this.container\n    );\n  }\n  // Public\n  dispose() {\n    (this._isOpen || this.container !== null) && this.close(), y.removeData(this._element, Ci), c.off(this._element, \"click\", this._clickHandler), this._element = null;\n  }\n  open() {\n    this._isOpen || (this._options.popconfirmMode === \"inline\" ? this._openPopover(this._getPopoverTemplate()) : this._openModal(this._getModalTemplate()), this._handleCancelButtonClick(), this._handleConfirmButtonClick(), this._listenToEscapeKey(), this._listenToOutsideClick());\n  }\n  close() {\n    if (this._isOpen) {\n      if (this._popper !== null || d.findOne(`[${vo}]`) !== null)\n        c.on(\n          this.popconfirmBody,\n          \"transitionend\",\n          this._handlePopconfirmTransitionEnd.bind(this)\n        ), h.removeClass(this.popconfirmBody, \"opacity-100\");\n      else {\n        const t = d.findOne(\n          `[${Nl}]`\n        );\n        h.removeClass(this.popconfirmBody, \"opacity-100\"), document.body.removeChild(t), this._isOpen = !1;\n      }\n      c.off(document, \"click\", this._handleOutsideClick.bind(this)), c.off(document, \"keydown\", this._handleEscapeKey.bind(this));\n    }\n  }\n  _handlePopconfirmTransitionEnd(t) {\n    if (t.target !== this.popconfirmBody)\n      return;\n    const e = d.findOne(\n      `[${vo}]`\n    );\n    c.off(this.popconfirmBody, \"transitionend\"), this._isOpen && t && t.propertyName === \"opacity\" && (this._popper.destroy(), e && document.body.removeChild(e), this._isOpen = !1);\n  }\n  // Private\n  _getPopoverTemplate() {\n    const t = $(\"div\"), e = this._getPopconfirmTemplate();\n    return t.setAttribute(vo, \"\"), h.addClass(t, this._classes.popover), t.id = this._uid, t.innerHTML = e, t;\n  }\n  _getModalTemplate() {\n    const t = $(\"div\"), e = this._getPopconfirmTemplate();\n    return t.setAttribute(hE, \"\"), h.addClass(t, `${this._classes.modal}`), t.id = this._uid, t.innerHTML = e, t;\n  }\n  _getPopconfirmTemplate() {\n    return `<div data-te-popconfirm-body class=\"${this._classes.body}\">\n      <p class=\"${this._classes.message}\">\n      ${this._options.popconfirmIconTemplate ? `<span class=\"${this._classes.icon}\">${this._options.popconfirmIconTemplate}</span>` : \"\"}\n      <span class=\"${this._classes.messageText}\">${this._options.message}</span>\n      </p>\n      <div class=\"${this._classes.btnsContainer}\">\n      ${this._options.cancelText ? `<button type=\"button\" data-te-ripple-init data-te-ripple-color=\"light\" id=\"popconfirm-button-cancel\" aria-label=\"${this._options.cancelLabel}\"\n        class=\"${this._classes.btnCancel}\">${this._options.cancelText}</button>` : \"\"}\n      <button type=\"button\" data-te-ripple-init data-te-ripple-color=\"light\" id=\"popconfirm-button-confirm\"\n      aria-label=\"${this._options.confirmLabel}\"\n      class=\"${this._classes.btnConfirm}\">${this._options.okText ? this._options.okText : \"Ok\"}</button>\n      </div>\n    </div>`;\n  }\n  _getConfig(t) {\n    return t = {\n      ...uE,\n      ...h.getDataAttributes(this._element),\n      ...t\n    }, D(bo, t, dE), t;\n  }\n  _getClasses(t) {\n    const e = h.getDataClassAttributes(this._element);\n    return t = {\n      ..._E,\n      ...e,\n      ...t\n    }, D(bo, t, pE), t;\n  }\n  _openPopover(t) {\n    this._popper = Ce(this._element, t, {\n      placement: this._translatePositionValue(),\n      modifiers: [\n        {\n          name: \"offset\",\n          options: {\n            offset: [0, 5]\n          }\n        }\n      ]\n    }), document.body.appendChild(t), setTimeout(() => {\n      h.addClass(\n        this.popconfirmBody,\n        `${this._classes.fade} opacity-100`\n      ), this._isOpen = !0;\n    }, 0);\n  }\n  _openModal(t) {\n    const e = $(\"div\");\n    e.setAttribute(Nl, \"\"), h.addClass(e, this._classes.backdrop), document.body.appendChild(e), e.appendChild(t), h.addClass(this.popconfirmBody, \"opacity-100\"), this._isOpen = !0;\n  }\n  _handleCancelButtonClick() {\n    const t = this.container;\n    this._cancelButton = d.findOne(\n      \"#popconfirm-button-cancel\",\n      t\n    ), Ze.getOrCreateInstance(this._cancelButton, { rippleColor: \"light\" }), this._cancelButton !== null && c.on(this._cancelButton, \"click\", () => {\n      this.close(), c.trigger(this._element, aE);\n    });\n  }\n  _handleConfirmButtonClick() {\n    const t = this.container;\n    this._confirmButton = d.findOne(\n      \"#popconfirm-button-confirm\",\n      t\n    ), Ze.getOrCreateInstance(this._confirmButton, { rippleColor: \"light\" }), c.on(this._confirmButton, \"click\", () => {\n      this.close(), c.trigger(this._element, lE);\n    });\n  }\n  _listenToEscapeKey() {\n    c.on(document, \"keydown\", this._handleEscapeKey.bind(this));\n  }\n  _handleEscapeKey(t) {\n    t.keyCode === Fi && this.close();\n  }\n  _listenToOutsideClick() {\n    c.on(document, \"click\", this._handleOutsideClick.bind(this));\n  }\n  _handleOutsideClick(t) {\n    const e = this.container, i = t.target === e, n = e && e.contains(t.target), o = t.target === this._element, r = this._element && this._element.contains(t.target);\n    !i && !n && !o && !r && this.close();\n  }\n  _translatePositionValue() {\n    switch (this._options.position) {\n      case \"top left\":\n        return \"top-end\";\n      case \"top\":\n        return \"top\";\n      case \"top right\":\n        return \"top-start\";\n      case \"bottom left\":\n        return \"bottom-end\";\n      case \"bottom\":\n        return \"bottom\";\n      case \"bottom right\":\n        return \"bottom-start\";\n      case \"left\":\n        return \"left\";\n      case \"left top\":\n        return \"left-end\";\n      case \"left bottom\":\n        return \"left-start\";\n      case \"right\":\n        return \"right\";\n      case \"right top\":\n        return \"right-end\";\n      case \"right bottom\":\n        return \"right-start\";\n      case void 0:\n        return \"bottom\";\n      default:\n        return \"bottom\";\n    }\n  }\n  // Static\n  static jQueryInterface(t, e) {\n    return this.each(function() {\n      const i = y.getData(this, Ci), n = typeof t == \"object\" && t;\n      if (!(!i && /dispose/.test(t))) {\n        if (!i)\n          return new vh(this, n);\n        if (typeof t == \"string\") {\n          if (typeof i[t] > \"u\")\n            throw new TypeError(`No method named \"${t}\"`);\n          i[t](e);\n        }\n      }\n    });\n  }\n  static getInstance(t) {\n    return y.getData(t, Ci);\n  }\n  static getOrCreateInstance(t, e = {}) {\n    return this.getInstance(t) || new this(t, typeof e == \"object\" ? e : null);\n  }\n}\nconst To = \"lightbox\", Ai = \"te.lightbox\", fE = `.${Ai}`, mE = \".data-api\", Ie = `click${fE}${mE}`, Th = \"[data-te-lightbox-init]\", gE = `${Th} img:not([data-te-lightbox-disabled])`, Ml = \"data-te-lightbox-caption\", bE = \"data-te-lightbox-disabled\", It = \"data-te-lightbox-active\", vE = `<svg xmlns=\"http://www.w3.org/2000/svg\" fill=\"currentColor\" viewBox=\"0 0 24 24\" stroke-width=\"3\" stroke=\"currentColor\" class=\"w-4 h-4\">\n  <path stroke-linecap=\"round\" stroke-linejoin=\"round\" d=\"M19.5 12h-15m0 0l6.75 6.75M4.5 12l6.75-6.75\" />\n</svg>\n`, TE = `<svg xmlns=\"http://www.w3.org/2000/svg\" fill=\"currentColor\" viewBox=\"0 0 24 24\" stroke-width=\"3\" stroke=\"currentColor\" class=\"w-4 h-4\">\n  <path stroke-linecap=\"round\" stroke-linejoin=\"round\" d=\"M4.5 12h15m0 0l-6.75-6.75M19.5 12l-6.75 6.75\" />\n</svg>\n`, EE = `<svg xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" viewBox=\"0 0 24 24\" stroke-width=\"3\" stroke=\"currentColor\" class=\"w-4 h-4\">\n  <path stroke-linecap=\"round\" stroke-linejoin=\"round\" d=\"M3.75 3.75v4.5m0-4.5h4.5m-4.5 0L9 9M3.75 20.25v-4.5m0 4.5h4.5m-4.5 0L9 15M20.25 3.75h-4.5m4.5 0v4.5m0-4.5L15 9m5.25 11.25h-4.5m4.5 0v-4.5m0 4.5L15 15\" />\n</svg>\n`, CE = `<svg xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" viewBox=\"0 0 24 24\" stroke-width=\"3\" stroke=\"currentColor\" class=\"w-4 h-4\">\n  <path stroke-linecap=\"round\" stroke-linejoin=\"round\" d=\"M9 9V4.5M9 9H4.5M9 9L3.75 3.75M9 15v4.5M9 15H4.5M9 15l-5.25 5.25M15 9h4.5M15 9V4.5M15 9l5.25-5.25M15 15h4.5M15 15v4.5m0-4.5l5.25 5.25\" />\n</svg>\n`, AE = `<svg xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" viewBox=\"0 0 24 24\" stroke-width=\"3\" stroke=\"currentColor\" class=\"w-4 h-4\">\n  <path stroke-linecap=\"round\" stroke-linejoin=\"round\" d=\"M21 21l-5.197-5.197m0 0A7.5 7.5 0 105.196 5.196a7.5 7.5 0 0010.607 10.607zM10.5 7.5v6m3-3h-6\" />\n</svg>\n`, yE = `<svg xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" viewBox=\"0 0 24 24\" stroke-width=\"3\" stroke=\"currentColor\" class=\"w-4 h-4\">\n<path stroke-linecap=\"round\" stroke-linejoin=\"round\" d=\"M21 21l-5.197-5.197m0 0A7.5 7.5 0 105.196 5.196a7.5 7.5 0 0010.607 10.607zM13.5 10.5h-6\" />\n</svg>\n`, wE = `<svg xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" viewBox=\"0 0 24 24\" stroke-width=\"3\" stroke=\"currentColor\" class=\"w-4 h-4\">\n  <path stroke-linecap=\"round\" stroke-linejoin=\"round\" d=\"M6 18L18 6M6 6l12 12\" />\n</svg>\n`, kE = {\n  container: \"string\",\n  zoomLevel: \"(number|string)\",\n  prevIconTemplate: \"string\",\n  nextIconTemplate: \"string\",\n  showFullscreenIconTemplate: \"string\",\n  hideFullscreenIconTemplate: \"string\",\n  zoomInIconTemplate: \"string\",\n  closeIconTemplate: \"string\",\n  zoomOutIconTemplate: \"string\",\n  spinnerContent: \"string\"\n}, xE = {\n  container: \"body\",\n  zoomLevel: 1,\n  prevIconTemplate: vE,\n  nextIconTemplate: TE,\n  showFullscreenIconTemplate: EE,\n  hideFullscreenIconTemplate: CE,\n  zoomInIconTemplate: AE,\n  zoomOutIconTemplate: yE,\n  closeIconTemplate: wE,\n  spinnerContent: \"Loading...\"\n}, OE = {\n  caption: \"text-white text-ellipsis overflow-hidden whitespace-nowrap mx-[10px] text-center\",\n  captionWrapper: \"fixed left-0 bottom-0 w-full h-[50px] flex justify-center items-center\",\n  closeBtn: \"border-none bg-transparent w-[50px] h-[50px] px-4 text-[#b3b3b3] transition-colors duration-200 ease-in-out hover:text-white focus:text-white motion-reduce:transition-none outline-none\",\n  fullscreenBtn: \"border-none bg-transparent w-[50px] h-[50px] px-4 text-[#b3b3b3] transition-colors duration-200 ease-in-out hover:text-white focus:text-white motion-reduce:transition-none outline-none\",\n  gallery: \"invisible fixed left-0 top-0 w-full h-full z-[1100] pointer-events-none opacity-0 bg-[#000000e6] transition-all duration-[400ms] motion-reduce:transition-none\",\n  galleryContent: \"fixed top-[50px] left-[50px] w-[calc(100%-100px)] h-[calc(100%-100px)]\",\n  galleryCounter: \"flex justify-center items-center px-[10px] mb-0 h-full text-[#b3b3b3]\",\n  img: \"absolute left-0 top-0 w-full max-h-full h-auto cursor-pointer pointer-events-auto\",\n  imgWrapper: \"absolute top-0 left-0 w-full h-full opacity-0 transform scale-[0.25] transition-all duration-[400ms] ease-out pointer-events-none motion-reduce:transition-none motion-reduce:transform-none\",\n  leftTools: \"float-left h-full\",\n  loader: \"fixed left-0 top-0 z-[2] w-full h-full text-neutral-50 opacity-1 flex justify-center items-center pointer-events-none transition-opacity duration-[1000ms] motion-reduce:transition-none\",\n  nextBtn: \"border-none bg-transparent w-full h-[50px] flex justify-center items-center text-[#b3b3b3] transition-colors duration-200 ease-in-out hover:text-white focus:text-white motion-reduce:transition-none outline-none\",\n  nextBtnWrapper: \"fixed right-0 top-0 w-[50px] h-full flex justify-center items-center transition-opacity duration-[400ms] motion-reduce:transition-none\",\n  prevBtn: \"border-none bg-transparent w-full h-[50px] flex justify-center items-center text-[#b3b3b3] transition-colors duration-200 ease-in-out hover:text-white focus:text-white motion-reduce:transition-none outline-none\",\n  prevBtnWrapper: \"fixed left-0 top-0 w-[50px] h-full flex justify-center items-center transition-opacity duration-[400ms] motion-reduce:transition-none\",\n  rightTools: \"float-right\",\n  spinner: \"inline-block h-8 w-8 animate-[spinner-grow_0.75s_linear_infinite] rounded-full bg-current align-[-0.125em] motion-reduce:animate-[spinner-grow_1.5s_linear_infinite]\",\n  spinnerContent: \"!absolute !-m-px !h-px !w-px !overflow-hidden !whitespace-nowrap !border-0 !p-0 ![clip:rect(0,0,0,0)]\",\n  toolbar: \"absolute top-0 left-0 w-full h-[50px] z-20 transition-opacity duration-[400ms] motion-reduce:transition-none\",\n  vertical: \"h-full max-h-full w-auto\",\n  zoomBtn: \"border-none bg-transparent w-[50px] h-[50px] px-4 text-[#b3b3b3] transition-colors duration-200 ease-in-out hover:text-white focus:text-white motion-reduce:transition-none outline-none\"\n}, SE = {\n  caption: \"string\",\n  captionWrapper: \"string\",\n  closeBtn: \"string\",\n  fullscreenBtn: \"string\",\n  gallery: \"string\",\n  galleryContent: \"string\",\n  galleryCounter: \"string\",\n  img: \"string\",\n  imgWrapper: \"string\",\n  leftTools: \"string\",\n  loader: \"string\",\n  nextBtn: \"string\",\n  nextBtnWrapper: \"string\",\n  prevBtn: \"string\",\n  prevBtnWrapper: \"string\",\n  rightTools: \"string\",\n  spinner: \"string\",\n  spinnerContent: \"string\",\n  toolbar: \"string\",\n  vertical: \"string\",\n  zoomBtn: \"string\"\n};\nclass Zs {\n  constructor(t, e = {}, i) {\n    this._element = t, this._options = e, this._classes = this._getClasses(i), this._getContainer(), this._id = `lightbox-${Math.random().toString(36).substr(2, 9)}`, this._activeImg = 0, this._images = [], this._zoom = 1, this._gallery = null, this._galleryToolbar = null, this._galleryContent = null, this._loader = null, this._imgCounter = null, this._animating = !1, this._fullscreen = !1, this._zoomBtn = null, this._fullscreenBtn = null, this._toolsToggleTimer = 0, this._mousedown = !1, this._mousedownPositionX = 0, this._mousedownPositionY = 0, this._originalPositionX = 0, this._originalPositionY = 0, this._positionX = 0, this._positionY = 0, this._zoomTimer = 0, this._tapCounter = 0, this._tapTime = 0, this._rightArrow = null, this._leftArrowWrapper = null, this._rightArrowWrapper = null, this._initiated = !1, this._multitouch = !1, this._touchZoomPosition = [], this._element && (y.setData(t, Ai, this), this.init());\n  }\n  // Getters\n  static get NAME() {\n    return To;\n  }\n  get activeImg() {\n    return this._activeImg;\n  }\n  get currentImg() {\n    return d.findOne(\n      `[${It}]`,\n      this._galleryContent\n    );\n  }\n  get options() {\n    const t = {\n      ...xE,\n      ...h.getDataAttributes(this._element),\n      ...this._options\n    };\n    return D(To, t, kE), t;\n  }\n  // Public\n  init() {\n    this._initiated || (this._appendTemplate(), this._initiated = !0);\n  }\n  open(t = 0) {\n    this._getImages(), this._setActiveImg(t), this._sortImages(), this._triggerEvents(\"open\", \"opened\"), this._loadImages().then((e) => {\n      this._resizeImages(e), this._toggleTemplate(), this._addEvents(), this._focusFullscreenBtn();\n    });\n  }\n  close() {\n    this.reset(), this._removeEvents(), this._toggleTemplate(), this._triggerEvents(\"close\", \"closed\");\n  }\n  slide(t = \"right\") {\n    this._animating === !0 || this._images.length <= 1 || (this._triggerEvents(\"slide\", \"slided\"), this._beforeSlideEvents(), t === \"right\" && this._slideHorizontally(t), t === \"left\" && this._slideHorizontally(t), t === \"first\" && this._slideToTarget(t), t === \"last\" && this._slideToTarget(t), this._afterSlideEvents());\n  }\n  zoomIn() {\n    this._zoom >= 3 || (this._triggerEvents(\"zoomIn\", \"zoomedIn\"), this._zoom += parseFloat(this.options.zoomLevel), h.style(this.currentImg.parentNode, {\n      transform: `scale(${this._zoom})`\n    }), this._updateZoomBtn());\n  }\n  zoomOut() {\n    this._zoom <= 1 || (this._triggerEvents(\"zoomOut\", \"zoomedOut\"), this._zoom -= parseFloat(this.options.zoomLevel), h.style(this.currentImg.parentNode, {\n      transform: `scale(${this._zoom})`\n    }), this._updateZoomBtn(), this._updateImgPosition());\n  }\n  toggleFullscreen() {\n    this._fullscreen === !1 ? (this._fullscreenBtn.setAttribute(It, \"\"), this._fullscreenBtn.innerHTML = this.options.hideFullscreenIconTemplate, this._gallery.requestFullscreen && this._gallery.requestFullscreen(), this._fullscreen = !0) : (this._fullscreenBtn.removeAttribute(It), document.exitFullscreen && document.exitFullscreen(), this._fullscreen = !1);\n  }\n  reset() {\n    this._restoreDefaultFullscreen(), this._restoreDefaultPosition(), this._restoreDefaultZoom(), clearTimeout(this._toolsToggleTimer), clearTimeout(this._doubleTapTimer);\n  }\n  dispose() {\n    c.off(\n      document,\n      Ie,\n      gE,\n      this.toggle\n    ), this._galleryContent && this._removeEvents(), this._gallery && this._gallery.remove(), y.removeData(this._element, Ai), this._element = null;\n  }\n  // Private\n  _getClasses(t) {\n    const e = h.getDataClassAttributes(this._element);\n    return t = {\n      ...OE,\n      ...e,\n      ...t\n    }, D(To, t, SE), t;\n  }\n  _getImages() {\n    const e = d.find(\"img\", this._element).filter(\n      (i) => !i.hasAttribute(bE)\n    );\n    this._images = e;\n  }\n  _getContainer() {\n    this._container = d.findOne(this.options.container);\n  }\n  _setActiveImg(t) {\n    this._activeImg = typeof t == \"number\" ? t : this._images.indexOf(t.target);\n  }\n  _appendTemplate() {\n    this._gallery = $(\"div\"), h.addClass(this._gallery, `${this._classes.gallery}`), this._element.dataset.id = this._id, this._gallery.id = this._id, this._appendLoader(), this._appendToolbar(), this._appendContent(), this._appendArrows(), this._appendCaption(), this._container.append(this._gallery);\n  }\n  _appendToolbar() {\n    this._galleryToolbar = $(\"div\"), this._imgCounter = $(\"p\"), this._fullscreenBtn = $(\"button\"), this._zoomBtn = $(\"button\");\n    const t = $(\"button\"), e = $(\"div\"), i = $(\"div\");\n    h.addClass(this._galleryToolbar, `${this._classes.toolbar}`), h.addClass(this._imgCounter, `${this._classes.galleryCounter}`), h.addClass(this._fullscreenBtn, `${this._classes.fullscreenBtn}`), h.addClass(this._zoomBtn, `${this._classes.zoomInBtn}`), h.addClass(this._zoomBtn, this._classes.zoomBtn), h.addClass(e, `${this._classes.leftTools}`), h.addClass(i, `${this._classes.rightTools}`), h.addClass(t, `${this._classes.closeBtn}`), this._fullscreenBtn.innerHTML = this.options.showFullscreenIconTemplate, t.innerHTML = this.options.closeIconTemplate, this._zoomBtn.innerHTML = this.options.zoomInIconTemplate, this._fullscreenBtn.setAttribute(\"aria-label\", \"Toggle fullscreen\"), this._zoomBtn.setAttribute(\"aria-label\", \"Zoom in\"), t.setAttribute(\"aria-label\", \"Close\"), c.on(\n      this._fullscreenBtn,\n      Ie,\n      () => this.toggleFullscreen()\n    ), c.on(\n      this._zoomBtn,\n      Ie,\n      () => this._toggleZoom()\n    ), c.on(t, Ie, () => this.close()), e.append(this._imgCounter), i.append(this._fullscreenBtn), i.append(this._zoomBtn), i.append(t), this._galleryToolbar.append(e), this._galleryToolbar.append(i), this._gallery.append(this._galleryToolbar);\n  }\n  _appendContent() {\n    this._galleryContent = $(\"div\"), h.addClass(\n      this._galleryContent,\n      `${this._classes.galleryContent}`\n    ), this._gallery.append(this._galleryContent);\n  }\n  _appendLoader() {\n    this._loader = $(\"div\");\n    const t = $(\"div\"), e = $(\"span\");\n    h.addClass(this._loader, `${this._classes.loader}`), h.addClass(t, `${this._classes.spinner}`), h.addClass(e, `${this._classes.spinnerContent}`), t.setAttribute(\"role\", \"status\"), e.innerHTML = this.options.spinnerContent, t.append(e), this._loader.append(t), this._gallery.append(this._loader);\n  }\n  _appendArrows() {\n    this._leftArrowWrapper = $(\"div\"), h.addClass(\n      this._leftArrowWrapper,\n      `${this._classes.prevBtnWrapper}`\n    );\n    const t = $(\"button\");\n    t.setAttribute(\"aria-label\", \"Previous\"), h.addClass(t, `${this._classes.prevBtn}`), c.on(t, Ie, () => this.slide(\"left\")), this._leftArrowWrapper.append(t), this._rightArrowWrapper = $(\"div\"), h.addClass(\n      this._rightArrowWrapper,\n      `${this._classes.nextBtnWrapper}`\n    ), this._rightArrow = $(\"button\"), this._rightArrow.setAttribute(\"aria-label\", \"Next\"), h.addClass(this._rightArrow, `${this._classes.nextBtn}`), c.on(this._rightArrow, Ie, () => this.slide()), this._rightArrowWrapper.append(this._rightArrow), this._rightArrow.innerHTML = this.options.nextIconTemplate, t.innerHTML = this.options.prevIconTemplate, this._getImages(), !(this._images.length <= 1) && (this._gallery.append(this._leftArrowWrapper), this._gallery.append(this._rightArrowWrapper));\n  }\n  _appendCaption() {\n    const t = $(\"div\"), e = $(\"p\");\n    e.setAttribute(Ml, \"\"), h.addClass(t, `${this._classes.captionWrapper}`), h.addClass(e, `${this._classes.caption}`), t.append(e), this._gallery.append(t);\n  }\n  _sortImages() {\n    for (let t = 0; t < this._activeImg; t++)\n      this._images.push(this._images.shift());\n  }\n  async _loadImages() {\n    const t = [], e = [];\n    this._galleryContent.innerHTML = \"\";\n    let i = 0;\n    return this._images.forEach((n, o) => {\n      t.push(\n        new Promise((r) => {\n          const a = new Image(), l = $(\"div\");\n          h.addClass(l, `${this._classes.imgWrapper}`), h.addClass(a, `${this._classes.img}`), this._addImgStyles(a, l, i, o, n), l.append(a), this._galleryContent.append(l), a.onload = r, a.src = n.dataset.teImg || n.src, e.push(a), i += 100;\n        })\n      );\n    }), await Promise.all(t), e;\n  }\n  _addImgStyles(t, e, i, n, o) {\n    t.alt = o.alt, t.draggable = !1, h.style(e, {\n      position: \"absolute\",\n      left: `${i}%`,\n      top: 0\n    }), (o.dataset.teCaption || o.dataset.teCaption === \"\") && (t.dataset.caption = o.dataset.teCaption), i === 0 ? (o.width < o.height && h.addClass(t, `${this._classes.vertical}`), h.style(e, { opacity: 1 }), t.setAttribute(It, \"\")) : t.removeAttribute(It), n === this._images.length - 1 && this._images.length > 1 && h.style(e, { left: \"-100%\" });\n  }\n  _resizeImages(t) {\n    t.forEach((e) => {\n      this._calculateImgSize(e);\n    });\n  }\n  _calculateImgSize(t) {\n    t.width >= t.height ? (t.style.width = \"100%\", t.style.maxWidth = \"100%\", t.style.height = \"auto\", t.style.top = `${(t.parentNode.offsetHeight - t.height) / 2}px`, t.style.left = 0) : (t.style.height = \"100%\", t.style.maxHeight = \"100%\", t.style.width = \"auto\", t.style.left = `${(t.parentNode.offsetWidth - t.width) / 2}px`, t.style.top = 0), t.width >= t.parentNode.offsetWidth && (t.style.width = `${t.parentNode.offsetWidth}px`, t.style.height = \"auto\", t.style.left = 0, t.style.top = `${(t.parentNode.offsetHeight - t.height) / 2}px`), t.height >= t.parentNode.offsetHeight && (t.style.height = `${t.parentNode.offsetHeight}px`, t.style.width = \"auto\", t.style.top = 0, t.style.left = `${(t.parentNode.offsetWidth - t.width) / 2}px`), this._positionX = parseFloat(t.style.left) || 0, this._positionY = parseFloat(t.style.top) || 0;\n  }\n  _onResize() {\n    this._images = d.find(\"img\", this._galleryContent), this._images.forEach((t) => {\n      this._calculateImgSize(t);\n    });\n  }\n  _onFullscreenChange() {\n    (document.webkitIsFullScreen || document.mozFullScreen || document.msFullscreenElement) === void 0 && (this._fullscreen = !1, this._fullscreenBtn.innerHTML = this.options.showFullscreenIconTemplate, this._fullscreenBtn.removeAttribute(It));\n  }\n  _beforeSlideEvents() {\n    this._animationStart(), this._restoreDefaultZoom(), this._restoreDefaultPosition(), this._resetDoubleTap();\n  }\n  _slideHorizontally(t) {\n    this._images = d.find(\"img\", this._galleryContent), this._images.forEach((e) => {\n      let i;\n      t === \"right\" ? (i = parseInt(e.parentNode.style.left, 10) - 100, i < -100 && (i = (this._images.length - 2) * 100)) : (i = parseInt(e.parentNode.style.left, 10) + 100, i === (this._images.length - 1) * 100 && (i = -100)), this._slideImg(e, i);\n    }), this._updateActiveImg(t);\n  }\n  _slideImg(t, e) {\n    e === 0 ? (t.setAttribute(It, \"\"), h.style(t.parentNode, { opacity: 1, transform: \"scale(1)\" })) : (t.removeAttribute(It), h.style(t.parentNode, {\n      opacity: 0,\n      transform: \"scale(0.25)\"\n    })), t.parentNode.style.left = `${e}%`;\n  }\n  _slideToTarget(t) {\n    t === \"first\" && this._activeImg === 0 || t === \"last\" && this._activeImg === this._images.length - 1 || (this.reset(), this._removeEvents(), this._showLoader(), this._getImages(), this._activeImg = t === \"first\" ? 0 : this._images.length - 1, this._sortImages(), h.style(this.currentImg.parentNode, {\n      transform: \"scale(0.25)\",\n      opacity: 0\n    }), setTimeout(() => {\n      this._loadImages().then((e) => {\n        this._resizeImages(e), this._addEvents(), this._updateCaption(), this._hideLoader(), setTimeout(() => {\n          h.style(this.currentImg.parentNode, {\n            transform: \"scale(1)\",\n            opacity: 1\n          });\n        }, 10);\n      });\n    }, 400));\n  }\n  _updateActiveImg(t) {\n    t === \"right\" && (this._activeImg === this._images.length - 1 ? this._activeImg = 0 : this._activeImg++), t === \"left\" && (this._activeImg === 0 ? this._activeImg = this._images.length - 1 : this._activeImg--);\n  }\n  _afterSlideEvents() {\n    this._updateCounter(), this._updateCaption();\n  }\n  _updateCounter() {\n    this._images.length <= 1 || setTimeout(() => {\n      this._imgCounter.innerHTML = `${this._activeImg + 1} / ${this._images.length}`;\n    }, 200);\n  }\n  _updateCaption() {\n    setTimeout(() => {\n      let t = this.currentImg.alt;\n      (this.currentImg.dataset.caption || this.currentImg.dataset.caption === \"\") && (t = this.currentImg.dataset.caption), d.findOne(\n        `[${Ml}]`,\n        this._gallery\n      ).innerHTML = t;\n    }, 200);\n  }\n  _toggleTemplate() {\n    this._gallery.style.visibility === \"visible\" ? (h.style(this.currentImg.parentNode, {\n      transform: \"scale(0.25)\"\n    }), setTimeout(() => {\n      this._hideGallery(), this._enableScroll(), this._showLoader();\n    }, 100)) : (this._showGallery(), this._disableScroll(), this._updateCounter(), this._updateCaption(), this._setToolsToggleTimout(), this._hideLoader());\n  }\n  _showLoader() {\n    h.style(this._loader, { opacity: 1 });\n  }\n  _hideLoader() {\n    h.style(this._loader, { opacity: 0 });\n  }\n  _hideGallery() {\n    h.style(this._gallery, {\n      opacity: 0,\n      pointerEvents: \"none\",\n      visibility: \"hidden\"\n    });\n  }\n  _showGallery() {\n    h.style(this._gallery, {\n      opacity: 1,\n      pointerEvents: \"initial\",\n      visibility: \"visible\"\n    }), setTimeout(() => {\n      h.style(this.currentImg.parentNode, { transform: \"scale(1)\" });\n    }, 50);\n  }\n  _toggleZoom() {\n    this._zoom !== 1 ? this.zoomOut() : this.zoomIn();\n  }\n  _updateZoomBtn() {\n    this._zoom > 1 ? (this._zoomBtn.setAttribute(It, \"\"), this._zoomBtn.setAttribute(\"aria-label\", \"Zoom out\"), this._zoomBtn.innerHTML = this.options.zoomOutIconTemplate) : (this._zoomBtn.removeAttribute(It), this._zoomBtn.setAttribute(\"aria-label\", \"Zoom in\"), this._zoomBtn.innerHTML = this.options.zoomInIconTemplate);\n  }\n  _updateImgPosition() {\n    this._zoom === 1 && this._restoreDefaultPosition();\n  }\n  _addEvents() {\n    const t = d.find(\"img\", this._galleryContent);\n    this._onWindowTouchmove = this._onWindowTouchmove.bind(this), this._onWindowTouchstart = this._onWindowTouchstart.bind(this), this._onImgMousedown = this._onMousedown.bind(this), this._onImgMousemove = this._onMousemove.bind(this), this._onImgWheel = this._onZoom.bind(this), this._onImgMouseup = this._onMouseup.bind(this), this._onImgTouchend = this._onTouchend.bind(this), this._onImgDoubleClick = this._onDoubleClick.bind(this), this._onWindowResize = this._onResize.bind(this), this._onWindowFullscreenChange = this._onFullscreenChange.bind(this), this._onAnyImgAction = this._resetToolsToggler.bind(this), this._onGalleryClick = this._onBackdropClick.bind(this), this._onKeyupEvent = this._onKeyup.bind(this), this._onRightArrowKeydownEvent = this._onRightArrowKeydown.bind(this), this._onFullscreenBtnKeydownEvent = this._onFullscreenBtnKeydown.bind(this), t.forEach((e) => {\n      c.on(e, \"mousedown\", this._onImgMousedown, {\n        passive: !0\n      }), c.on(e, \"touchstart\", this._onImgMousedown, {\n        passive: !0\n      }), c.on(e, \"mousemove\", this._onImgMousemove, {\n        passive: !0\n      }), c.on(e, \"touchmove\", this._onImgMousemove, {\n        passive: !0\n      }), c.on(e, \"wheel\", this._onImgWheel, { passive: !0 }), c.on(e, \"dblclick\", this._onImgDoubleClick, {\n        passive: !0\n      });\n    }), document.addEventListener(\"touchmove\", this._onWindowTouchmove, {\n      passive: !1\n    }), c.on(window, \"touchstart\", this._onWindowTouchstart), c.on(window, \"mouseup\", this._onImgMouseup), c.on(window, \"touchend\", this._onImgTouchend), c.on(window, \"resize\", this._onWindowResize), c.on(window, \"orientationchange\", this._onWindowResize), c.on(window, \"keyup\", this._onKeyupEvent), c.on(window, \"fullscreenchange\", this._onWindowFullscreenChange), c.on(this._gallery, \"mousemove\", this._onAnyImgAction), c.on(this._gallery, \"click\", this._onGalleryClick), c.on(\n      this._rightArrow,\n      \"keydown\",\n      this._onRightArrowKeydownEvent\n    ), c.on(\n      this._fullscreenBtn,\n      \"keydown\",\n      this._onFullscreenBtnKeydownEvent\n    );\n  }\n  _removeEvents() {\n    d.find(\"img\", this._galleryContent).forEach((e) => {\n      c.off(e, \"mousedown\", this._onImgMousedown), c.off(e, \"touchstart\", this._onImgMousedown), c.off(e, \"mousemove\", this._onImgMousemove), c.off(e, \"touchmove\", this._onImgMousemove), c.off(e, \"wheel\", this._onImgWheel), c.off(e, \"dblclick\", this._onImgDoubleClick);\n    }), document.removeEventListener(\"touchmove\", this._onWindowTouchmove, {\n      passive: !1\n    }), c.off(window, \"touchstart\", this._onWindowTouchstart), c.off(window, \"mouseup\", this._onImgMouseup), c.off(window, \"touchend\", this._onImgTouchend), c.off(window, \"resize\", this._onWindowResize), c.off(window, \"orientationchange\", this._onWindowResize), c.off(window, \"keyup\", this._onKeyupEvent), c.off(\n      window,\n      \"fullscreenchange\",\n      this._onWindowFullscreenChange\n    ), c.off(this._gallery, \"mousemove\", this._onAnyImgAction), c.off(this._gallery, \"click\", this._onGalleryClick), c.off(\n      this._rightArrow,\n      \"keydown\",\n      this._onRightArrowKeydownEvent\n    ), c.off(\n      this._fullscreenBtn,\n      \"keydown\",\n      this._onFullscreenBtnKeydownEvent\n    );\n  }\n  _onMousedown(t) {\n    const e = t.touches, i = e ? e[0].clientX : t.clientX, n = e ? e[0].clientY : t.clientY;\n    this._originalPositionX = parseFloat(this.currentImg.style.left) || 0, this._originalPositionY = parseFloat(this.currentImg.style.top) || 0, this._positionX = this._originalPositionX, this._positionY = this._originalPositionY, this._mousedownPositionX = i * (1 / this._zoom) - this._positionX, this._mousedownPositionY = n * (1 / this._zoom) - this._positionY, this._mousedown = !0, t.type === \"touchstart\" && t.touches.length > 1 && (this._multitouch = !0, this._touchZoomPosition = t.touches);\n  }\n  _onMousemove(t) {\n    if (!this._mousedown)\n      return;\n    const e = t.touches, i = e ? e[0].clientX : t.clientX, n = e ? e[0].clientY : t.clientY;\n    if (e && this._resetToolsToggler(), !this._multitouch)\n      if (this._zoom !== 1)\n        this._positionX = i * (1 / this._zoom) - this._mousedownPositionX, this._positionY = n * (1 / this._zoom) - this._mousedownPositionY, h.style(this.currentImg, {\n          left: `${this._positionX}px`,\n          top: `${this._positionY}px`\n        });\n      else {\n        if (this._images.length <= 1)\n          return;\n        this._positionX = i * (1 / this._zoom) - this._mousedownPositionX, h.style(this.currentImg, { left: `${this._positionX}px` });\n      }\n  }\n  _onMouseup(t) {\n    this._mousedown = !1, this._moveImg(t.target);\n  }\n  _onTouchend(t) {\n    this._mousedown = !1, this._multitouch ? t.targetTouches.length === 0 && (this._multitouch = !1, this._touchZoomPosition = []) : this._multitouch || (this._checkDoubleTap(t), this._moveImg(t.target));\n  }\n  _calculateTouchZoom(t) {\n    const e = Math.hypot(\n      this._touchZoomPosition[1].pageX - this._touchZoomPosition[0].pageX,\n      this._touchZoomPosition[1].pageY - this._touchZoomPosition[0].pageY\n    ), i = Math.hypot(\n      t.touches[1].pageX - t.touches[0].pageX,\n      t.touches[1].pageY - t.touches[0].pageY\n    ), n = Math.abs(e - i), o = t.view.screen.width;\n    n > o * 0.03 && (e <= i ? this.zoomIn() : this.zoomOut(), this._touchZoomPosition = t.touches);\n  }\n  _onWindowTouchstart(t) {\n    t.touches.length > 1 && (this._multitouch = !0, this._touchZoomPosition = t.touches);\n  }\n  _onWindowTouchmove(t) {\n    t.preventDefault(), t.type === \"touchmove\" && t.targetTouches.length > 1 && this._calculateTouchZoom(t);\n  }\n  _onRightArrowKeydown(t) {\n    switch (t.keyCode) {\n      case 9:\n        if (t.shiftKey)\n          break;\n        t.preventDefault(), this._focusFullscreenBtn();\n        break;\n    }\n  }\n  _onFullscreenBtnKeydown(t) {\n    switch (t.keyCode) {\n      case 9:\n        if (!t.shiftKey)\n          break;\n        t.preventDefault(), this._focusRightArrow();\n        break;\n    }\n  }\n  _onKeyup(t) {\n    switch (this._resetToolsToggler(), t.keyCode) {\n      case 39:\n        this.slide();\n        break;\n      case 37:\n        this.slide(\"left\");\n        break;\n      case 27:\n        this.close();\n        break;\n      case 36:\n        this.slide(\"first\");\n        break;\n      case 35:\n        this.slide(\"last\");\n        break;\n      case 38:\n        this.zoomIn();\n        break;\n      case 40:\n        this.zoomOut();\n        break;\n    }\n  }\n  _focusFullscreenBtn() {\n    setTimeout(() => {\n      this._fullscreenBtn.focus();\n    }, 100);\n  }\n  _focusRightArrow() {\n    this._rightArrow.focus();\n  }\n  _moveImg(t) {\n    if (this._multitouch || this._zoom !== 1 || t !== this.currentImg || this._images.length <= 1)\n      return;\n    const e = this._positionX - this._originalPositionX;\n    e > 0 ? this.slide(\"left\") : e < 0 && this.slide();\n  }\n  _checkDoubleTap(t) {\n    clearTimeout(this._doubleTapTimer);\n    const i = (/* @__PURE__ */ new Date()).getTime() - this._tapTime;\n    this._tapCounter > 0 && i < 500 ? (this._onDoubleClick(t), this._doubleTapTimer = setTimeout(() => {\n      this._tapTime = (/* @__PURE__ */ new Date()).getTime(), this._tapCounter = 0;\n    }, 300)) : (this._tapCounter++, this._tapTime = (/* @__PURE__ */ new Date()).getTime());\n  }\n  _resetDoubleTap() {\n    this._tapTime = 0, this._tapCounter = 0, clearTimeout(this._doubleTapTimer);\n  }\n  _onDoubleClick(t) {\n    this._multitouch || (t.touches || this._setNewPositionOnZoomIn(t), this._zoom !== 1 ? this._restoreDefaultZoom() : this.zoomIn());\n  }\n  _onZoom(t) {\n    if (t.deltaY > 0)\n      this.zoomOut();\n    else {\n      if (this._zoom >= 3)\n        return;\n      this._setNewPositionOnZoomIn(t), this.zoomIn();\n    }\n  }\n  _onBackdropClick(t) {\n    this._resetToolsToggler(), t.target.tagName === \"DIV\" && this.close();\n  }\n  _setNewPositionOnZoomIn(t) {\n    clearTimeout(this._zoomTimer), this._positionX = window.innerWidth / 2 - t.offsetX - 50, this._positionY = window.innerHeight / 2 - t.offsetY - 50, this.currentImg.style.transition = \"all 0.5s ease-out\", this.currentImg.style.left = `${this._positionX}px`, this.currentImg.style.top = `${this._positionY}px`, this._zoomTimer = setTimeout(() => {\n      this.currentImg.style.transition = \"none\";\n    }, 500);\n  }\n  _resetToolsToggler() {\n    this._showTools(), clearTimeout(this._toolsToggleTimer), this._setToolsToggleTimout();\n  }\n  _setToolsToggleTimout() {\n    this._toolsToggleTimer = setTimeout(() => {\n      this._hideTools(), clearTimeout(this._toolsToggleTimer);\n    }, 4e3);\n  }\n  _hideTools() {\n    h.style(this._galleryToolbar, { opacity: 0 }), h.style(this._leftArrowWrapper, { opacity: 0 }), h.style(this._rightArrowWrapper, { opacity: 0 });\n  }\n  _showTools() {\n    h.style(this._galleryToolbar, { opacity: 1 }), h.style(this._leftArrowWrapper, { opacity: 1 }), h.style(this._rightArrowWrapper, { opacity: 1 });\n  }\n  _disableScroll() {\n    h.addClass(document.body, \"overflow-y-hidden relative\"), document.documentElement.scrollHeight > document.documentElement.clientHeight && h.addClass(document.body, \"md:pr-[17px]\");\n  }\n  _enableScroll() {\n    setTimeout(() => {\n      h.removeClass(document.body, \"overflow-y-hidden relative\"), h.removeClass(document.body, \"md:pr-[17px]\");\n    }, 300);\n  }\n  _animationStart() {\n    this._animating = !0, setTimeout(() => {\n      this._animating = !1;\n    }, 400);\n  }\n  _restoreDefaultZoom() {\n    this._zoom !== 1 && (this._zoom = 1, h.style(this.currentImg.parentNode, {\n      transform: `scale(${this._zoom})`\n    }), this._updateZoomBtn(), this._updateImgPosition());\n  }\n  _restoreDefaultFullscreen() {\n    this._fullscreen && this.toggleFullscreen();\n  }\n  _restoreDefaultPosition() {\n    clearTimeout(this._zoomTimer);\n    const t = this.currentImg;\n    h.style(this.currentImg.parentNode, { left: 0, top: 0 }), h.style(this.currentImg, {\n      transition: \"all 0.5s ease-out\",\n      left: 0,\n      top: 0\n    }), this._calculateImgSize(t), setTimeout(() => {\n      h.style(this.currentImg, { transition: \"none\" });\n    }, 500);\n  }\n  async _triggerEvents(t, e) {\n    c.trigger(this._element, `${t}.te.lightbox`), e && await setTimeout(() => {\n      c.trigger(this._element, `${e}.te.lightbox`);\n    }, 505);\n  }\n  static getInstance(t) {\n    return y.getData(t, Ai);\n  }\n  static getOrCreateInstance(t, e = {}) {\n    return this.getInstance(t) || new this(t, typeof e == \"object\" ? e : null);\n  }\n  static toggle() {\n    return function(t) {\n      const e = d.closest(\n        t.target,\n        `${Th}`\n      );\n      (Zs.getInstance(e) || new Zs(e)).open(t);\n    };\n  }\n  static jQueryInterface(t, e) {\n    return this.each(function() {\n      let i = y.getData(this, Ai);\n      const n = typeof t == \"object\" && t;\n      if (!(!i && /dispose/.test(t)) && (i || (i = new Zs(this, n)), typeof t == \"string\")) {\n        if (typeof i[t] > \"u\")\n          throw new TypeError(`No method named \"${t}\"`);\n        i[t](e);\n      }\n    });\n  }\n}\nconst IE = {\n  isRequired: \"This is required\",\n  isEmail: \"Please enter a valid email address\",\n  isLongerThan: \"This field must be longer than {length} characters\",\n  isShorterThan: \"This field must be shorter than {length} characters\",\n  isChecked: \"This is required\",\n  isPhone: \"Please enter a valid phone number\",\n  isNumber: \"Expected value with type Number\",\n  isString: \"Expected value with type String\",\n  isBoolean: \"Expected value with type Boolean\",\n  isDate: \"Please enter a valid date\",\n  is12hFormat: \"Please enter a valid time in 12h format\",\n  is24hFormat: \"Please enter a valid time in 24h format\"\n}, DE = {\n  isRequired: (s, t) => (s == null ? void 0 : s.trim()) ? !0 : t,\n  isEmail: (s, t) => /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$/.test(s) ? !0 : t,\n  isLongerThan: (s, t, e) => s.length > e ? !0 : t.replace(\"{length}\", e),\n  isShorterThan: (s, t, e) => s.length < e ? !0 : t.replace(\"{length}\", e),\n  isChecked: (s) => s ? !0 : \"This is required\",\n  isPhone: (s, t) => s.length === 9 ? !0 : t,\n  isNumber: (s, t) => s && !isNaN(Number(s)) ? !0 : t,\n  isString: (s, t) => typeof s == \"string\" ? !0 : t,\n  isBoolean: (s, t) => typeof s == \"boolean\" ? !0 : t,\n  isDate: (s, t) => {\n    const e = /^([0-9]{1,2})\\/([0-9]{1,2})\\/([0-9]{4})$/;\n    return s.match(e) ? !0 : t;\n  },\n  is12hFormat: (s, t) => {\n    const e = /^(0?[1-9]|1[0-2]):[0-5][0-9] [APap][mM]$/;\n    return s.match(e) ? !0 : t;\n  },\n  is24hFormat: (s, t) => {\n    const e = /^(?:[01]\\d|2[0-3]):[0-5][0-9]$/;\n    return s.match(e) ? !0 : t;\n  }\n}, Eo = \"validation\", jo = \"te.validation\", fn = `.${jo}`, Eh = \"data-te-validate\", Os = \"data-te-validated\", Ss = \"data-te-validation-state\", Is = \"data-te-validation-feedback\", Co = \"data-te-valid-feedback\", Ds = \"data-te-invalid-feedback\", Rl = \"data-te-validation-ruleset\", $E = \"data-te-submit-btn-ref\", LE = `[${Eh}]`, NE = \"[data-te-input-notch-ref] div\", ME = `[${$E}]`, RE = `validated${fn}`, PE = `valid${fn}`, BE = `invalid${fn}`, HE = `changed${fn}`, VE = {\n  validFeedback: \"string\",\n  invalidFeedback: \"string\",\n  disableFeedback: \"boolean\",\n  customRules: \"object\",\n  customErrorMessages: \"object\",\n  activeValidation: \"boolean\",\n  submitCallback: \"(function|null)\"\n}, Pl = {\n  validFeedback: \"Looks good!\",\n  invalidFeedback: \"Something is wrong!\",\n  disableFeedback: !1,\n  customRules: {},\n  customErrorMessages: {},\n  activeValidation: !1,\n  submitCallback: null\n}, WE = {\n  // default notch\n  notchLeadingValid: \"border-[#14a44d] dark:border-[#14a44d] group-data-[te-input-focused]:shadow-[-1px_0_0_#14a44d,_0_1px_0_0_#14a44d,_0_-1px_0_0_#14a44d] group-data-[te-input-focused]:border-[#14a44d]\",\n  notchMiddleValid: \"border-[#14a44d] dark:border-[#14a44d] group-data-[te-input-focused]:shadow-[0_1px_0_0_#14a44d] group-data-[te-input-focused]:border-[#14a44d]\",\n  notchTrailingValid: \"border-[#14a44d] dark:border-[#14a44d] group-data-[te-input-focused]:shadow-[1px_0_0_#14a44d,_0_-1px_0_0_#14a44d,_0_1px_0_0_#14a44d] group-data-[te-input-focused]:border-[#14a44d]\",\n  notchLeadingInvalid: \"border-[#dc4c64] dark:border-[#dc4c64] group-data-[te-input-focused]:shadow-[-1px_0_0_#dc4c64,_0_1px_0_0_#dc4c64,_0_-1px_0_0_#dc4c64] group-data-[te-input-focused]:border-[#dc4c64]\",\n  notchMiddleInvalid: \"border-[#dc4c64] dark:border-[#dc4c64] group-data-[te-input-focused]:shadow-[0_1px_0_0_#dc4c64] group-data-[te-input-focused]:border-[#dc4c64]\",\n  notchTrailingInvalid: \"border-[#dc4c64] dark:border-[#dc4c64] group-data-[te-input-focused]:shadow-[1px_0_0_#dc4c64,_0_-1px_0_0_#dc4c64,_0_1px_0_0_#dc4c64] group-data-[te-input-focused]:border-[#dc4c64]\",\n  // basic inputs\n  basicInputValid: \"!border-[#14a44d] focus:!border-[#14a44d] focus:!shadow-[inset_0_0_0_1px_#14a44d]\",\n  basicInputInvalid: \"!border-[#dc4c64] focus:!border-[#dc4c64] focus:!shadow-[inset_0_0_0_1px_#dc4c64]\",\n  // checkbox\n  checkboxValid: \"checked:!border-[#14a44d] checked:!bg-[#14a44d] checked:after:!bg-[#14a44d]\",\n  checkboxInvalid: \"checked:!border-[#dc4c64] checked:!bg-[#dc4c64] checked:after:!bg-[#dc4c64]\",\n  radioValid: \"checked:!border-[#14a44d] checked:after:!bg-[#14a44d]\",\n  radioInvalid: \"checked:!border-[#dc4c64] checked:after:!bg-[#dc4c64]\",\n  // labels\n  labelValid: \"!text-[#14a44d]\",\n  labelInvalid: \"!text-[#dc4c64]\",\n  // feedback\n  validFeedback: \"absolute top-full left-0 m-1 w-auto text-sm text-[#14a44d] animate-[fade-in_0.3s_both]\",\n  invalidFeedback: \"absolute top-full left-0 m-1 w-auto text-sm text-[#dc4c64] animate-[fade-in_0.3s_both]\",\n  // element validated\n  elementValidated: \"mb-8\"\n}, FE = {\n  notchLeadingValid: \"string\",\n  notchMiddleValid: \"string\",\n  notchTrailingValid: \"string\",\n  notchLeadingInvalid: \"string\",\n  notchMiddleInvalid: \"string\",\n  notchTrailingInvalid: \"string\",\n  basicInputValid: \"string\",\n  basicInputInvalid: \"string\",\n  checkboxValid: \"string\",\n  checkboxInvalid: \"string\",\n  radioValid: \"string\",\n  radioInvalid: \"string\",\n  labelValid: \"string\",\n  labelInvalid: \"string\",\n  validFeedback: \"string\",\n  invalidFeedback: \"string\",\n  elementValidated: \"string\"\n};\nclass Ch extends gt {\n  constructor(t, e, i) {\n    super(t), this._element = t, this._element && y.setData(t, jo, this), this._config = this._getConfig(e), this._classes = this._getClasses(i), this._isValid = !0, this._shouldApplyInputEvents = !0, this._submitCallback = null, this._errorMessages = {\n      ...IE,\n      ...this._config.customErrorMessages\n    }, this._validationElements = this._getValidationElements(), this._validationElements.forEach(({ element: n, input: o }) => {\n      this._createFeedbackWrapper(n, o);\n    }), this._validationObserver = this._watchForValidationChanges(), this._validationObserver.observe(this._element, { attributes: !0 }), this._submitButton = null, this._handleSubmitButton(), this._validationResult = [];\n  }\n  // Getters\n  static get DefaultType() {\n    return VE;\n  }\n  static get Default() {\n    return Pl;\n  }\n  static get NAME() {\n    return Eo;\n  }\n  // Public\n  dispose() {\n    var t;\n    (t = this._validationObserver) == null || t.disconnect(), this._validationObserver = null, this._submitCallback = null, this._element.removeAttribute(Os), this._removeValidationTraces(), this._validationResult = [], this._submitButton && c.off(this._submitButton, \"click\"), this._config.activeValidation && (this._validationElements.forEach((e) => {\n      const { input: i } = e;\n      c.off(i, \"input\");\n    }), this._shouldApplyInputEvents = !0);\n  }\n  // Private\n  _removeValidationTraces() {\n    this._removeFeedbackWrapper(), this._validationElements.forEach(({ element: t, classes: e, initialHTML: i }) => {\n      t.className = e, t.innerHTML = i, t.removeAttribute(Ss), t.removeAttribute(Ds), t.removeAttribute(Co);\n    }), this._validationElements = [];\n  }\n  _getValidationElements() {\n    return d.find(\n      LE,\n      this._element\n    ).map((e) => {\n      const i = d.findOne(\"input\", e) || d.findOne(\"textarea\", e);\n      return {\n        id: i.name || i.id || rt(\"validation-\"),\n        element: e,\n        type: e.getAttribute(Eh),\n        input: i,\n        validFeedback: e.getAttribute(Co),\n        invalidFeedback: e.getAttribute(Ds),\n        classes: e.className,\n        initialHTML: e.innerHTML,\n        ruleset: e.getAttribute(Rl)\n      };\n    });\n  }\n  _createFeedbackWrapper(t, e) {\n    if (t.querySelectorAll(`[${Is}]`).length > 0)\n      return;\n    const i = document.createElement(\"span\");\n    i.setAttribute(Is, \"\"), e.parentNode.appendChild(i);\n  }\n  _removeFeedbackWrapper() {\n    d.find(\n      `[${Is}]`,\n      this._element\n    ).forEach((e) => {\n      e.remove();\n    });\n  }\n  _watchForValidationChanges() {\n    return new MutationObserver((e) => {\n      e.forEach((i) => {\n        const { attributeName: n } = i;\n        n === Os && (this._handleValidation(), this._config.activeValidation && this._shouldApplyInputEvents && this._applyInputEvents());\n      });\n    });\n  }\n  _handleValidation() {\n    this._element.getAttribute(Os) && (this._validationResult = [], this._isValid = !0, this._validationElements.forEach(\n      (t) => this._validateSingleElement(t)\n    ), this._emitEvents(this._isValid), this._submitCallback && this._submitCallback(this._isValid));\n  }\n  _validateSingleElement(t) {\n    var p;\n    const { element: e, type: i, input: n, ruleset: o, id: r } = t;\n    o && this._validateByRuleset(t);\n    const a = e.getAttribute(Ss);\n    if (a !== \"valid\" && a !== \"invalid\")\n      return;\n    const l = a.replace(\n      a.charAt(0),\n      a.charAt(0).toUpperCase()\n    );\n    i === \"input\" && this._restyleNotches(e, l), i === \"basic\" && this._restyleBasicInputs(n, l), (i === \"checkbox\" || i === \"radio\") && this._restyleCheckboxes(n, l, i), this._restyleLabels(e, l), a === \"invalid\" && (this._isValid = !1), this._config.disableFeedback || this._applyFeedback(e, a), c.trigger(this._element, HE, {\n      value: {\n        name: r,\n        result: a,\n        validation: (p = this._validationResult[r]) == null ? void 0 : p.validation\n      }\n    });\n  }\n  _validateByRuleset({ element: t, type: e, invalidFeedback: i, input: n, id: o }) {\n    const r = this._getRuleset(t);\n    if (!r.length)\n      return;\n    const a = e === \"checkbox\" || e === \"radio\" ? n.checked : n.value;\n    let l = \"\", p = [];\n    for (const u of r) {\n      const _ = u.callback(\n        a,\n        this._errorMessages[u.name] || this._config.invalidFeedback,\n        u.parameter\n      );\n      p.push({\n        result: _ === !0,\n        name: u.name,\n        fullName: u.fullName\n      }), typeof _ == \"string\" && !l && (l = _);\n    }\n    if (this._validationResult[o] = { element: t, validation: p }, !l) {\n      t.setAttribute(Ss, \"valid\");\n      return;\n    }\n    t.setAttribute(Ss, \"invalid\"), i || t.setAttribute(Ds, l);\n  }\n  _handleInputChange(t) {\n    this._validateSingleElement(t);\n  }\n  _getRuleset(t) {\n    const i = t.getAttribute(Rl).split(\"|\");\n    let n = [];\n    const o = {\n      ...DE,\n      ...this._config.customRules\n    };\n    return i.forEach((r) => {\n      const a = this._getRuleData(r, o);\n      a.callback ? n.push(a) : console.warn(`Rule ${r} does not exist`);\n    }), n;\n  }\n  _getRuleData(t, e) {\n    const i = t.split(\"(\");\n    return {\n      callback: e[i[0]],\n      parameter: i[1] ? i[1].split(\")\")[0] : null,\n      name: i[0],\n      fullName: t\n    };\n  }\n  _applyFeedback(t, e) {\n    const i = d.findOne(\n      `[${Is}]`,\n      t\n    ), n = t.getAttribute(Co) || this._config.validFeedback, o = t.getAttribute(Ds) || this._config.invalidFeedback;\n    h.addClass(t, this._classes.elementValidated), i.textContent = e === \"valid\" ? n : o, i.className = this._classes[e === \"valid\" ? \"validFeedback\" : \"invalidFeedback\"];\n  }\n  _restyleCheckboxes(t, e, i) {\n    h.removeClass(t, this._classes.checkboxValid), h.removeClass(t, this._classes.checkboxInvalid), h.addClass(t, this._classes[`${i}${e}`]);\n  }\n  _restyleBasicInputs(t, e) {\n    h.removeClass(t, this._classes.basicInputValid), h.removeClass(t, this._classes.basicInputInvalid), h.addClass(t, this._classes[`basicInput${e}`]);\n  }\n  _restyleNotches(t, e) {\n    d.find(NE, t).forEach((n, o) => {\n      let r = o === 0 ? \"notchLeading\" : o === 1 ? \"notchMiddle\" : \"notchTrailing\";\n      n.className = \"\", h.addClass(n, Kc[r]), r += e, h.addClass(n, this._classes[r]);\n    });\n  }\n  _restyleLabels(t, e) {\n    const i = d.find(\"label\", t);\n    i.length && i.forEach((n) => {\n      h.removeClass(n, this._classes.labelValid), h.removeClass(n, this._classes.labelInvalid), h.addClass(n, this._classes[`label${e}`]);\n    });\n  }\n  _emitEvents(t) {\n    if (c.trigger(this._element, RE), t) {\n      c.trigger(this._element, PE, {\n        value: this._validationResult\n      });\n      return;\n    }\n    c.trigger(this._element, BE, {\n      value: this._validationResult\n    });\n  }\n  _applyInputEvents() {\n    this._validationElements.forEach((t) => {\n      const { input: e } = t;\n      c.on(\n        e,\n        \"input\",\n        () => this._handleInputChange(t)\n      );\n    }), this._shouldApplyInputEvents = !1;\n  }\n  _handleSubmitButton() {\n    this._submitButton = d.findOne(\n      ME,\n      this._element\n    ), this._submitButton && c.on(\n      this._submitButton,\n      \"click\",\n      (t) => this._handleSubmitButtonClick(t)\n    );\n  }\n  _handleSubmitButtonClick(t) {\n    if (this._element.setAttribute(Os, !0), this._config.submitCallback) {\n      this._submitCallback = (e) => this._config.submitCallback(t, e);\n      return;\n    }\n  }\n  _getConfig(t) {\n    return t = {\n      ...Pl,\n      ...h.getDataAttributes(this._element),\n      ...typeof t == \"object\" && t ? t : {}\n    }, D(Eo, t, this.constructor.DefaultType), t;\n  }\n  _getClasses(t) {\n    const e = h.getDataClassAttributes(this._element);\n    return t = {\n      ...WE,\n      ...e,\n      ...t\n    }, D(Eo, t, FE), t;\n  }\n  // Static\n  static getInstance(t) {\n    return y.getData(t, jo);\n  }\n  static getOrCreateInstance(t, e = {}) {\n    return this.getInstance(t) || new this(t, typeof e == \"object\" ? e : null);\n  }\n  static jQueryInterface(t) {\n    return this.each(function() {\n      const e = Ch.getOrCreateInstance(this);\n      if (typeof t == \"string\") {\n        if (e[t] === void 0 || t.startsWith(\"_\") || t === \"constructor\")\n          throw new TypeError(`No method named \"${t}\"`);\n        e[t](this);\n      }\n    });\n  }\n}\nclass Xi {\n  _getCoordinates(t) {\n    const [e] = t.touches;\n    return {\n      x: e.clientX,\n      y: e.clientY\n    };\n  }\n  _getDirection({ x: t, y: e }) {\n    return {\n      x: {\n        direction: t < 0 ? \"left\" : \"right\",\n        value: Math.abs(t)\n      },\n      y: {\n        direction: e < 0 ? \"up\" : \"down\",\n        value: Math.abs(e)\n      }\n    };\n  }\n  _getOrigin({ x: t, y: e }, { x: i, y: n }) {\n    return {\n      x: t - i,\n      y: e - n\n    };\n  }\n  _getDistanceBetweenTwoPoints(t, e, i, n) {\n    return Math.hypot(e - t, n - i);\n  }\n  _getMidPoint({ x1: t, x2: e, y1: i, y2: n }) {\n    return {\n      x: (t + e) / 2,\n      y: (i + n) / 2\n    };\n  }\n  _getVectorLength({ x1: t, x2: e, y1: i, y2: n }) {\n    return Math.sqrt((e - t) ** 2 + (n - i) ** 2);\n  }\n  _getRightMostTouch(t) {\n    let e = null;\n    const i = Number.MIN_VALUE;\n    return t.forEach((n) => {\n      n.clientX > i && (e = n);\n    }), e;\n  }\n  _getAngle(t, e, i, n) {\n    return Math.atan2(n - e, i - t);\n  }\n  _getAngularDistance(t, e) {\n    return e - t;\n  }\n  _getCenterXY({ x1: t, x2: e, y1: i, y2: n }) {\n    return {\n      x: t + (e - t) / 2,\n      y: i + (n - i) / 2\n    };\n  }\n  _getPinchTouchOrigin(t) {\n    const [e, i] = t, n = {\n      x1: e.clientX,\n      x2: i.clientX,\n      y1: e.clientY,\n      y2: i.clientY\n    };\n    return [this._getVectorLength(n), this._getCenterXY(n)];\n  }\n  _getPosition({ x1: t, x2: e, y1: i, y2: n }) {\n    return { x1: t, x2: e, y1: i, y2: n };\n  }\n}\nconst Ao = \"press\", YE = \"pressup\", jE = {\n  time: \"number\",\n  pointers: \"number\"\n}, KE = {\n  time: 250,\n  pointers: 1\n};\nclass zE extends Xi {\n  constructor(t, e = {}) {\n    super(), this._element = t, this._options = this._getConfig(e), this._timer = null;\n  }\n  // Getters\n  static get NAME() {\n    return Ao;\n  }\n  handleTouchStart(t) {\n    const { time: e, pointers: i } = this._options;\n    t.touches.length === i && (this._timer = setTimeout(() => {\n      c.trigger(this._element, Ao, { touch: t, time: e }), c.trigger(this._element, YE, { touch: t });\n    }, e));\n  }\n  handleTouchEnd() {\n    clearTimeout(this._timer);\n  }\n  _getConfig(t) {\n    const e = {\n      ...KE,\n      ...h.getDataAttributes(this._element),\n      ...t\n    };\n    return D(Ao, e, jE), e;\n  }\n}\nconst UE = \"swipe\", XE = {\n  threshold: \"number\",\n  direction: \"string\"\n}, GE = {\n  threshold: 10,\n  direction: \"all\"\n};\nclass qE {\n  constructor(t, e) {\n    this._element = t, this._startPosition = null, this._options = this._getConfig(e);\n  }\n  handleTouchStart(t) {\n    this._startPosition = this._getCoordinates(t);\n  }\n  handleTouchMove(t) {\n    if (!this._startPosition)\n      return;\n    const e = this._getCoordinates(t), i = {\n      x: e.x - this._startPosition.x,\n      y: e.y - this._startPosition.y\n    }, n = this._getDirection(i);\n    if (this._options.direction === \"all\") {\n      if (n.y.value < this._options.threshold && n.x.value < this._options.threshold)\n        return;\n      const r = n.y.value > n.x.value ? n.y.direction : n.x.direction;\n      c.trigger(this._element, `swipe${r}`, { touch: t }), c.trigger(this._element, \"swipe\", { touch: t, direction: r }), this._startPosition = null;\n      return;\n    }\n    const o = this._options.direction === \"left\" || this._options === \"right\" ? \"x\" : \"y\";\n    n[o].direction === this._options.direction && n[o].value > this._options.threshold && (c.trigger(this._element, `swipe${n[o].direction}`, {\n      touch: t\n    }), this._startPosition = null);\n  }\n  handleTouchEnd() {\n    this._startPosition = null;\n  }\n  _getCoordinates(t) {\n    const [e] = t.touches;\n    return {\n      x: e.clientX,\n      y: e.clientY\n    };\n  }\n  _getDirection(t) {\n    return {\n      x: {\n        direction: t.x < 0 ? \"left\" : \"right\",\n        value: Math.abs(t.x)\n      },\n      y: {\n        direction: t.y < 0 ? \"up\" : \"down\",\n        value: Math.abs(t.y)\n      }\n    };\n  }\n  _getConfig(t) {\n    const e = {\n      ...GE,\n      ...h.getDataAttributes(this._element),\n      ...t\n    };\n    return D(UE, e, XE), e;\n  }\n}\nconst qt = \"pan\", ZE = `${qt}start`, QE = `${qt}end`, JE = `${qt}move`, t0 = \"left\", e0 = \"right\", i0 = {\n  threshold: \"number\",\n  direction: \"string\",\n  pointers: \"number\"\n}, s0 = {\n  threshold: 20,\n  direction: \"all\",\n  pointers: 1\n};\nclass n0 extends Xi {\n  constructor(t, e = {}) {\n    super(), this._element = t, this._options = this._getConfig(e), this._startTouch = null;\n  }\n  // Getters\n  static get NAME() {\n    return qt;\n  }\n  handleTouchStart(t) {\n    this._startTouch = this._getCoordinates(t), this._movedTouch = t, c.trigger(this._element, ZE, { touch: t });\n  }\n  handleTouchMove(t) {\n    t.type === \"touchmove\" && t.preventDefault();\n    const { threshold: e, direction: i } = this._options, n = this._getCoordinates(t), o = this._getCoordinates(this._movedTouch), r = this._getOrigin(n, this._startTouch), a = this._getOrigin(n, o), l = this._getDirection(r), p = this._getDirection(a), { x: u, y: _ } = l;\n    if (i === \"all\" && (_.value > e || u.value > e)) {\n      const g = _.value > u.value ? _.direction : u.direction;\n      c.trigger(this._element, `${qt}${g}`, { touch: t }), c.trigger(this._element, qt, {\n        ...a,\n        touch: t\n      });\n    }\n    const f = i === t0 || i === e0 ? \"x\" : \"y\";\n    p[f].direction === i && l[f].value > e && c.trigger(this._element, `${qt}${i}`, {\n      touch: t,\n      [f]: n[f] - o[f]\n    }), this._movedTouch = t, c.trigger(this._element, JE, { touch: t });\n  }\n  handleTouchEnd(t) {\n    t.type === \"touchend\" && t.preventDefault(), this._movedTouch = null, this._startTouch = null, c.trigger(this._element, QE, { touch: t });\n  }\n  _getConfig(t) {\n    const e = {\n      ...s0,\n      ...h.getDataAttributes(this._element),\n      ...t\n    };\n    return D(qt, e, i0), e;\n  }\n}\nconst Ye = \"pinch\", o0 = `${Ye}end`, r0 = `${Ye}start`, a0 = `${Ye}move`, l0 = {\n  threshold: \"number\",\n  pointers: \"number\"\n}, c0 = {\n  threshold: 10,\n  pointers: 2\n};\nclass h0 extends Xi {\n  constructor(t, e = {}) {\n    super(), this._element = t, this._options = this._getConfig(e), this._startTouch = null, this._origin = null, this._touch = null, this._math = null, this._ratio = null;\n  }\n  // Getters\n  static get NAME() {\n    return Ye;\n  }\n  get isNumber() {\n    return typeof this._startTouch == \"number\" && typeof this._touch == \"number\" && // eslint-disable-next-line no-restricted-globals\n    !isNaN(this._startTouch) && // eslint-disable-next-line no-restricted-globals\n    !isNaN(this._touch);\n  }\n  handleTouchStart(t) {\n    if (t.touches.length !== this._options.pointers)\n      return;\n    t.type === \"touchstart\" && t.preventDefault();\n    const [e, i] = this._getPinchTouchOrigin(t.touches);\n    this._touch = e, this._origin = i, this._startTouch = this._touch, c.trigger(this._element, r0, {\n      touch: t,\n      ratio: this._ratio,\n      origin: this._origin\n    });\n  }\n  handleTouchMove(t) {\n    const { threshold: e, pointers: i } = this._options;\n    t.touches.length === i && (t.type === \"touchmove\" && t.preventDefault(), this._touch = this._getPinchTouchOrigin(t.touches)[0], this._ratio = this._touch / this._startTouch, this.isNumber && (this._origin.x > e || this._origin.y > e) && (this._startTouch = this._touch, c.trigger(this._element, Ye, {\n      touch: t,\n      ratio: this._ratio,\n      origin: this._origin\n    }), c.trigger(this._element, a0, {\n      touch: t,\n      ratio: this._ratio,\n      origin: this._origin\n    })));\n  }\n  handleTouchEnd(t) {\n    this.isNumber && (this._startTouch = null, c.trigger(this._element, o0, {\n      touch: t,\n      ratio: this._ratio,\n      origin: this._origin\n    }));\n  }\n  _getConfig(t) {\n    const e = {\n      ...c0,\n      ...h.getDataAttributes(this._element),\n      ...t\n    };\n    return D(Ye, e, l0), e;\n  }\n}\nconst yo = \"tap\", d0 = {\n  interval: \"number\",\n  time: \"number\",\n  taps: \"number\",\n  pointers: \"number\"\n}, u0 = {\n  interval: 500,\n  time: 250,\n  taps: 1,\n  pointers: 1\n};\nclass p0 extends Xi {\n  constructor(t, e) {\n    super(), this._element = t, this._options = this._getConfig(e), this._timer = null, this._tapCount = 0;\n  }\n  // Getters\n  static get NAME() {\n    return yo;\n  }\n  handleTouchStart(t) {\n    const { x: e, y: i } = this._getCoordinates(t), { interval: n, taps: o, pointers: r } = this._options;\n    return t.touches.length === r && (this._tapCount += 1, this._tapCount === 1 && (this._timer = setTimeout(() => {\n      this._tapCount = 0;\n    }, n)), this._tapCount === o && (clearTimeout(this._timer), this._tapCount = 0, c.trigger(this._element, yo, {\n      touch: t,\n      origin: {\n        x: e,\n        y: i\n      }\n    }))), t;\n  }\n  handleTouchEnd() {\n  }\n  handleTouchMove() {\n  }\n  _getConfig(t) {\n    const e = {\n      ...u0,\n      ...h.getDataAttributes(this._element),\n      ...t\n    };\n    return D(yo, e, d0), e;\n  }\n}\nconst Mi = \"rotate\", _0 = `${Mi}end`, f0 = `${Mi}start`, m0 = {\n  angle: \"number\",\n  pointers: \"number\"\n}, g0 = {\n  angle: 0,\n  pointers: 2\n};\nclass b0 extends Xi {\n  constructor(t, e) {\n    super(), this._element = t, this._options = this._getConfig(e), this._origin = {};\n  }\n  // Getters\n  static get NAME() {\n    return Mi;\n  }\n  handleTouchStart(t) {\n    t.type === \"touchstart\" && t.preventDefault(), !(t.touches.length < 2) && (this._startTouch = t, this._origin = {}, c.trigger(this._element, f0, { touch: t }));\n  }\n  handleTouchMove(t) {\n    t.type === \"touchmove\" && t.preventDefault();\n    let e, i;\n    const n = t.touches;\n    if (n.length === 1 && this._options.pointers === 1) {\n      const { left: o, top: r, width: a, height: l } = this._element.getBoundingClientRect();\n      e = {\n        x: o + a / 2,\n        y: r + l / 2\n      }, i = n[0];\n    } else if (t.touches.length === 2 && this._options.pointers === 2) {\n      const [o, r] = t.touches, a = {\n        x1: r.clientX,\n        x2: o.clientX,\n        y1: r.clientY,\n        y2: o.clientY\n      };\n      e = this._getMidPoint(a), i = this._getRightMostTouch(t.touches);\n    } else\n      return;\n    this.currentAngle = this._getAngle(\n      e.x,\n      e.y,\n      i.clientX,\n      i.clientY\n    ), this._origin.initialAngle ? (this._origin.change = this._getAngularDistance(\n      this._origin.previousAngle,\n      this.currentAngle\n    ), this._origin.distance += this._origin.change) : (this._origin.initialAngle = this._origin.previousAngle = this.currentAngle, this._origin.distance = this._origin.change = 0), this._origin.previousAngle = this.currentAngle, this.rotate = {\n      currentAngle: this.currentAngle,\n      distance: this._origin.distance,\n      change: this._origin.change\n    }, c.trigger(this._element, Mi, { ...this.rotate, touch: t });\n  }\n  handleTouchEnd(t) {\n    t.type === \"touchend\" && t.preventDefault(), this._origin = {}, c.trigger(this._element, _0, { touch: t });\n  }\n  _getConfig(t) {\n    const e = {\n      ...g0,\n      ...h.getDataAttributes(this._element),\n      ...t\n    };\n    return D(Mi, e, m0), e;\n  }\n}\nconst Ko = \"touch\", wo = `te.${Ko}`, v0 = {\n  event: \"string\"\n}, T0 = {\n  event: \"swipe\"\n};\nclass Ah {\n  constructor(t, e = {}) {\n    this._element = t, this._options = this._getConfig(e), this._event = this._options.event, this.swipe = this._event === \"swipe\" ? new qE(t, e) : null, this.press = this._event === \"press\" ? new zE(t, e) : null, this.pan = this._event === \"pan\" ? new n0(t, e) : null, this.pinch = this._event === \"pinch\" ? new h0(t, e) : null, this.tap = this._event === \"tap\" ? new p0(t, e) : null, this.rotate = this._event === \"rotate\" ? new b0(t, e) : null, this._touchStartHandler = (i) => this._handleTouchStart(i), this._touchMoveHandler = (i) => this._handleTouchMove(i), this._touchEndHandler = (i) => this._handleTouchEnd(i), c.on(this._element, \"touchstart\", this._touchStartHandler), c.on(this._element, \"touchmove\", this._touchMoveHandler), c.on(this._element, \"touchend\", this._touchEndHandler), this._element && y.setData(t, wo, this);\n  }\n  // Getters\n  static get NAME() {\n    return Ko;\n  }\n  dispose() {\n    c.off(this._element, \"touchstart\", this._touchStartHandler), c.off(this._element, \"touchmove\", this._touchMoveHandler), c.off(this._element, \"touchend\", this._touchEndHandler), this.swipe = null, this.press = null, this.pan = null, this.pinch = null, this.tap = null, this.rotate = null;\n  }\n  _getConfig(t) {\n    const e = {\n      ...T0,\n      ...h.getDataAttributes(this._element),\n      ...t\n    };\n    return D(Ko, e, v0), e;\n  }\n  _handleTouchStart(t) {\n    this[this._event].handleTouchStart(t);\n  }\n  _handleTouchMove(t) {\n    this[this._event].handleTouchMove && this[this._event].handleTouchMove(t);\n  }\n  _handleTouchEnd(t) {\n    this[this._event].handleTouchEnd(t);\n  }\n  static jQueryInterface(t) {\n    return this.each(function() {\n      let e = y.getData(this, wo);\n      const i = typeof t == \"object\" && t;\n      if (!(!e && /dispose/.test(t)) && (e || (e = new Ah(this, i)), typeof t == \"string\")) {\n        if (typeof e[t] > \"u\")\n          throw new TypeError(`No method named \"${t}\"`);\n        return e[t];\n      }\n    });\n  }\n  static getInstance(t) {\n    return y.getData(t, wo);\n  }\n  static getOrCreateInstance(t, e = {}) {\n    return this.getInstance(t) || new this(t, typeof e == \"object\" ? e : null);\n  }\n}\nconst zo = \"smoothScroll\", yi = `te.${zo}`, mr = `.${yi}`, E0 = {\n  container: \"string\",\n  offset: \"number\",\n  easing: \"string\",\n  duration: \"number\"\n}, C0 = {\n  container: \"body\",\n  offset: 0,\n  easing: \"linear\",\n  duration: 500\n}, A0 = `scrollStart${mr}`, y0 = `scrollEnd${mr}`, w0 = `scrollCancel${mr}`;\nclass yh {\n  constructor(t, e = {}) {\n    this._element = t, this._options = this._getConfig(e), this._href = this._element.getAttribute(\"href\"), this.isCancel = !1, this._element && (y.setData(t, yi, this), this._setup());\n  }\n  // getters\n  static get NAME() {\n    return zo;\n  }\n  get isWindow() {\n    return this._options.container === \"body\";\n  }\n  get containerToScroll() {\n    return this.isWindow ? document.documentElement : d.findOne(\n      this._options.container,\n      document.documentElement\n    );\n  }\n  get elFromHrefExist() {\n    return !!d.findOne(this._href, this.containerToScroll);\n  }\n  get offsetFromEl() {\n    const t = this.containerToScroll.scrollTop, e = d.findOne(this._href, this.containerToScroll);\n    if (this.isWindow)\n      return h.offset(e).top - this._options.offset + t;\n    const i = e.getBoundingClientRect().y, n = this.containerToScroll.getBoundingClientRect().y;\n    return i - n - this._options.offset + t;\n  }\n  get easingFunction() {\n    const t = this._options.easing, e = `_motion${t[0].toUpperCase()}${t.slice(1)}`;\n    return this[e] ? this[e] : this._motionLinear;\n  }\n  // public\n  dispose() {\n    c.off(this._element, \"click\", this._handleClick), y.removeData(this._element, yi), this._element = null;\n  }\n  cancelScroll() {\n    this.isCancel = !0;\n  }\n  // private\n  _getConfig(t) {\n    const e = {\n      ...C0,\n      ...h.getDataAttributes(this._element),\n      ...t\n    };\n    return D(zo, e, E0), e;\n  }\n  _inViewport() {\n    if (this.isWindow)\n      return !0;\n    const t = this.containerToScroll.getBoundingClientRect();\n    return t.top >= 0 && t.bottom <= (window.innerHeight || document.documentElement.clientHeight);\n  }\n  _setup() {\n    const t = typeof this._href < \"u\", e = this._href.includes(\"#\");\n    t && e && this.elFromHrefExist && (this._scrollOnClickEvent(), this._preventNativeScroll());\n  }\n  _scrollOnClickEvent() {\n    c.on(this._element, \"click\", (t) => {\n      this._handleClick(t);\n    });\n  }\n  _handleClick(t) {\n    t.preventDefault(), this.isCancel = !1, c.trigger(this._element, A0);\n    const e = this.containerToScroll, i = this.containerToScroll.scrollTop, n = this.offsetFromEl, o = 0, r = 1 / this._options.duration, a = 4.25, l = this.easingFunction;\n    this._inViewport() ? this._scrollOnNextTick(\n      e,\n      i,\n      n,\n      o,\n      r,\n      a,\n      l\n    ) : (this._scrollOnNextTick(\n      document.documentElement,\n      document.documentElement.scrollTop,\n      this.containerToScroll.offsetTop,\n      o,\n      r,\n      a,\n      l\n    ), setTimeout(() => {\n      this._scrollOnNextTick(\n        e,\n        i,\n        n,\n        o,\n        r,\n        a,\n        l\n      ), this.isCancel = !1;\n    }, this._options.duration));\n  }\n  _scrollOnNextTick(t, e, i, n, o, r, a) {\n    const l = n < 0, p = n > 1, u = o <= 0;\n    if (l || p || u || this.isCancel) {\n      if (this.isCancel) {\n        this.isInViewport && (this.isCancel = !1), c.trigger(this._element, w0);\n        return;\n      }\n      c.trigger(this._element, y0), t.scrollTop = i;\n      return;\n    }\n    t.scrollTo({\n      top: e - (e - i) * a(n)\n    }), n += o * r, setTimeout(() => {\n      this._scrollOnNextTick(\n        t,\n        e,\n        i,\n        n,\n        o,\n        r,\n        a\n      );\n    });\n  }\n  _preventDefault(t) {\n    t.preventDefault();\n  }\n  _preventNativeScroll() {\n    let t = !1;\n    try {\n      window.addEventListener(\n        \"test\",\n        null,\n        Object.defineProperty({}, \"passive\", {\n          get: () => t = !0\n        })\n      );\n    } catch (n) {\n      this._scrollError = n;\n    }\n    const e = t ? { passive: !1 } : !1, i = \"onwheel\" in $(\"div\") ? \"wheel\" : \"mousewheel\";\n    this.isWindow && (this._deleteScrollOnStart(e, i), this._addScrollOnEnd(e, i), this._addScrollOnCancel(e, i));\n  }\n  _deleteScrollOnStart(t, e) {\n    c.on(this._element, \"scrollStart.te.smoothScroll\", () => {\n      window.addEventListener(e, this._preventDefault, t), window.addEventListener(\"touchmove\", this._preventDefault, t);\n    });\n  }\n  _addScrollOnEnd(t, e) {\n    c.on(this._element, \"scrollEnd.te.smoothScroll\", () => {\n      window.removeEventListener(e, this._preventDefault, t), window.removeEventListener(\"touchmove\", this._preventDefault, t);\n    });\n  }\n  _addScrollOnCancel(t, e) {\n    c.on(this._element, \"scrollCancel.te.smoothScroll\", () => {\n      window.removeEventListener(e, this._preventDefault, t), window.removeEventListener(\"touchmove\", this._preventDefault, t);\n    });\n  }\n  // Motions\n  // Linear\n  _motionLinear(t) {\n    return t;\n  }\n  // Ease-In\n  _motionEaseInQuad(t) {\n    return t * t;\n  }\n  _motionEaseInCubic(t) {\n    return t * t * t;\n  }\n  _motionEaseInQuart(t) {\n    return t * t * t * t;\n  }\n  _motionEaseInQuint(t) {\n    return t * t * t * t * t;\n  }\n  // Ease-In-Out\n  _motionEaseInOutQuad(t) {\n    return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;\n  }\n  _motionEaseInOutCubic(t) {\n    return t /= 0.5, t < 1 ? t * t * t / 2 : (t -= 2, (t * t * t + 2) / 2);\n  }\n  _motionEaseInOutQuart(t) {\n    return t /= 0.5, t < 1 ? 0.5 * t * t * t * t : (t -= 2, -(t * t * t * t - 2) / 2);\n  }\n  _motionEaseInOutQuint(t) {\n    return t /= 0.5, t < 1 ? t * t * t * t * t / 2 : (t -= 2, (t * t * t * t * t + 2) / 2);\n  }\n  // Ease-Out\n  _motionEaseOutQuad(t) {\n    return -t * (t - 2);\n  }\n  _motionEaseOutCubic(t) {\n    return t--, t * t * t + 1;\n  }\n  _motionEaseOutQuart(t) {\n    return t--, -(t * t * t * t - 1);\n  }\n  _motionEaseOutQuint(t) {\n    return t--, t * t * t * t * t + 1;\n  }\n  // static\n  static getInstance(t) {\n    return y.getData(t, yi);\n  }\n  static getOrCreateInstance(t, e = {}) {\n    return this.getInstance(t) || new this(t, typeof e == \"object\" ? e : null);\n  }\n  static jQueryInterface(t) {\n    return this.each(function() {\n      let e = y.getData(this, yi);\n      const i = typeof t == \"object\" && t;\n      if (e || (e = new yh(this, i)), typeof t == \"string\") {\n        if (typeof e[t] > \"u\")\n          throw new TypeError(`No method named \"${t}\"`);\n        e[t](this);\n      }\n    });\n  }\n}\nconst Bl = \"lazyLoad\", $s = \"te.lazyLoad\", k0 = \"[data-te-lazy-load-init]\", Hl = \"data-te-lazy-load\", x0 = \"onLoad.te.lazy\", O0 = \"onError.te.lazy\", Vl = [\"img\", \"video\"], S0 = {\n  lazySrc: \"(string|null)\",\n  lazyDelay: \"number\",\n  lazyAnimation: \"string\",\n  lazyOffset: \"number\",\n  lazyPlaceholder: \"(string|undefined)\",\n  lazyError: \"(string|undefined)\"\n}, I0 = {\n  lazySrc: null,\n  lazyDelay: 500,\n  lazyAnimation: \"[fade-in_1s_ease-in-out]\",\n  lazyOffset: 0\n};\nclass Uo {\n  constructor(t, e) {\n    this._element = t, this._element && y.setData(t, $s, this), this._options = this._getConfig(e), this.scrollHandler = this._scrollHandler.bind(this), this.errorHandler = this._setElementError.bind(this), this._childrenInstances = null, this._init();\n  }\n  // Getters\n  static get NAME() {\n    return Bl;\n  }\n  get offsetValues() {\n    return this._element.getBoundingClientRect();\n  }\n  get inViewport() {\n    if (this.parent) {\n      const t = this.parent.getBoundingClientRect();\n      return t.y > 0 && t.y < window.innerHeight && this.offsetValues.y >= t.y && this.offsetValues.y <= t.y + t.height && this.offsetValues.y <= window.innerHeight;\n    }\n    return this.offsetValues.top + this._options.lazyOffset <= window.innerHeight && this.offsetValues.bottom >= 0;\n  }\n  get parent() {\n    const [t] = d.parents(\n      this._element,\n      k0\n    );\n    return t;\n  }\n  get node() {\n    return this._element.nodeName;\n  }\n  get isContainer() {\n    return !d.matches(this._element, Vl);\n  }\n  // Public\n  dispose() {\n    y.removeData(this._element, $s), this._animation && (this._animation.dispose(), this._animation = null), this._element = null, this._childrenInstances && this._childrenInstances.forEach((t) => t.dispose());\n  }\n  // Private\n  _init() {\n    if (this._element.setAttribute(Hl, \"\"), this.isContainer) {\n      this._setupContainer();\n      return;\n    }\n    this._setupElement();\n  }\n  _setupElement() {\n    c.one(this._element, \"error\", this.errorHandler), this._options.lazyPlaceholder && this._setPlaceholder(), this._animation = new pr(this._element, {\n      animation: `${this._options.lazyAnimation}`,\n      animationStart: \"onLoad\"\n    }), c.one(this._element, \"load\", () => this._scrollHandler()), this.parent && c.on(this.parent, \"scroll\", this.scrollHandler), c.on(window, \"scroll\", this.scrollHandler);\n  }\n  _scrollHandler() {\n    this.inViewport && (this._timeout = setTimeout(() => {\n      this._setSrc(), this._element.removeAttribute(Hl), this._removeAttrs(), this._animation.init();\n    }, this._options.lazyDelay), this.parent && c.off(this.parent, \"scroll\", this.scrollHandler), c.off(window, \"scroll\", this.scrollHandler));\n  }\n  _setElementError() {\n    !this._options.lazyError || this._element.src === this._options.lazyError ? this._element.alt = \"404 not found\" : this._element.setAttribute(\"src\", this._options.lazyError), c.trigger(this._element, O0);\n  }\n  _setSrc() {\n    this._element.setAttribute(\"src\", this._options.lazySrc), c.trigger(this._element, x0);\n  }\n  _setPlaceholder() {\n    this.node === \"IMG\" ? this._element.setAttribute(\"src\", this._options.lazyPlaceholder) : this.node === \"VIDEO\" && this._element.setAttribute(\"poster\", this._options.lazyPlaceholder);\n  }\n  _removeAttrs() {\n    [\"src\", \"delay\", \"animation\", \"placeholder\", \"offset\", \"error\"].forEach(\n      (t) => {\n        h.removeDataAttribute(this._element, `lazy-${t}`);\n      }\n    );\n  }\n  _setupContainer() {\n    this._childrenInstances = d.children(\n      this._element,\n      Vl\n    ).map((t) => new Uo(t, this._options));\n  }\n  _getConfig(t) {\n    const e = {\n      ...I0,\n      ...t,\n      ...h.getDataAttributes(this._element)\n    };\n    return D(Bl, e, S0), e;\n  }\n  // Static\n  static getInstance(t) {\n    return y.getData(t, $s);\n  }\n  static getOrCreateInstance(t, e = {}) {\n    return this.getInstance(t) || new this(t, typeof e == \"object\" ? e : null);\n  }\n  static jQueryInterface(t) {\n    return this.each(function() {\n      let e = y.getData(this, $s);\n      const i = typeof t == \"object\" && t;\n      if (e || (e = new Uo(this, i)), typeof t == \"string\") {\n        if (typeof e[t] > \"u\")\n          throw new TypeError(`No method named \"${t}\"`);\n        e[t](this);\n      }\n    });\n  }\n}\nconst Wl = \"clipboard\", wi = \"te.clipboard\", D0 = `.${wi}`, $0 = {\n  clipboardTarget: null\n}, L0 = {\n  clipboardTarget: \"null|string\"\n}, N0 = `copy${D0}`;\nclass wh {\n  constructor(t, e = {}) {\n    this._element = t, this._options = e, this._element && (y.setData(t, wi, this), this._initCopy = this._initCopy.bind(this), this._setup());\n  }\n  // Getters\n  static get NAME() {\n    return Wl;\n  }\n  get options() {\n    const t = {\n      ...$0,\n      ...h.getDataAttributes(this._element),\n      ...this._options\n    };\n    return D(Wl, t, L0), t;\n  }\n  get clipboardTarget() {\n    return d.findOne(this.options.clipboardTarget);\n  }\n  get copyText() {\n    const t = this.clipboardTarget.hasAttribute(\n      \"data-te-clipboard-text\"\n    ), e = this.clipboardTarget.value, i = this.clipboardTarget.textContent;\n    return t ? this.clipboardTarget.getAttribute(\"data-te-clipboard-text\") : e || i;\n  }\n  // Public\n  dispose() {\n    c.off(this._element, \"click\", this._initCopy), y.removeData(this._element, wi), this._element = null;\n  }\n  // Private\n  _setup() {\n    c.on(this._element, \"click\", this._initCopy);\n  }\n  _initCopy() {\n    const t = this._createNewInput();\n    document.body.appendChild(t), this._selectInput(t), c.trigger(this._element, N0, {\n      copyText: this.copyText\n    }), t.remove();\n  }\n  _createNewInput() {\n    const t = this.clipboardTarget.tagName === \"TEXTAREA\" ? \"textarea\" : \"input\", e = $(t);\n    return e.value = this.copyText, h.addClass(e, \"-left-[9999px] absolute\"), e;\n  }\n  _selectInput(t) {\n    t.select(), t.focus(), t.setSelectionRange(0, 99999), document.execCommand(\"copy\");\n  }\n  // Static\n  static jQueryInterface(t) {\n    return this.each(function() {\n      let e = y.getData(this, wi);\n      const i = typeof t == \"object\" && t;\n      if (e || (e = new wh(this, i)), typeof t == \"string\") {\n        if (typeof e[t] > \"u\")\n          throw new TypeError(`No method named \"${t}\"`);\n        e[t](this);\n      }\n    });\n  }\n  static getInstance(t) {\n    return y.getData(t, wi);\n  }\n  static getOrCreateInstance(t, e = {}) {\n    return this.getInstance(t) || new this(t, typeof e == \"object\" ? e : null);\n  }\n}\nconst Xo = \"infiniteScroll\", Ls = `te.${Xo}`, M0 = {\n  infiniteDirection: \"y\"\n}, R0 = {\n  infiniteDirection: \"string\"\n};\nclass kh {\n  constructor(t, e) {\n    this._element = t, this._element && y.setData(t, Ls, this), this._options = this._getConfig(e), this.scrollHandler = this._scrollHandler.bind(this), this._init();\n  }\n  // Getters\n  static get NAME() {\n    return Xo;\n  }\n  get rect() {\n    return this._element.getBoundingClientRect();\n  }\n  get condition() {\n    return this._element === window ? Math.abs(\n      window.scrollY + window.innerHeight - document.documentElement.scrollHeight\n    ) < 1 : this._options.infiniteDirection === \"x\" ? this.rect.width + this._element.scrollLeft + 10 >= this._element.scrollWidth : Math.ceil(this.rect.height + this._element.scrollTop) >= this._element.scrollHeight;\n  }\n  // Public\n  dispose() {\n    c.off(this._element, \"scroll\", this.scrollHandler), y.removeData(this._element, Ls), this._element = null;\n  }\n  // Private\n  _init() {\n    c.on(this._element, \"scroll\", () => this._scrollHandler());\n  }\n  _scrollHandler() {\n    this.condition && c.trigger(this._element, \"complete.te.infiniteScroll\"), c.off(this._element, \"scroll\", this.scrollHandler);\n  }\n  _getConfig(t) {\n    const e = {\n      ...M0,\n      ...this._element !== window ? h.getDataAttributes(this._element) : {},\n      ...t\n    };\n    return D(Xo, e, R0), e;\n  }\n  // Static\n  static getInstance(t) {\n    return y.getData(t, Ls);\n  }\n  static getOrCreateInstance(t, e = {}) {\n    return this.getInstance(t) || new this(t, typeof e == \"object\" ? e : null);\n  }\n  static jQueryInterface(t) {\n    return this.each(function() {\n      let e = y.getData(this, Ls);\n      const i = typeof t == \"object\" && t;\n      if (e || (e = new kh(this, i)), typeof t == \"string\") {\n        if (typeof e[t] > \"u\")\n          throw new TypeError(`No method named \"${t}\"`);\n        e[t](this);\n      }\n    });\n  }\n}\nfunction P0({ backdropID: s }, t) {\n  const e = $(\"div\");\n  return h.addClass(\n    e,\n    `${t.backdrop} ${t.backdropColor}`\n  ), e.id = s, e;\n}\nconst Ri = \"loadingManagement\", Ns = `te.${Ri}`, B0 = \"[data-te-loading-icon-ref]\", H0 = \"[data-te-loading-text-ref]\", V0 = `show.te.${Ri}`, W0 = {\n  backdrop: \"(null|boolean)\",\n  backdropID: \"(null|string|number)\",\n  delay: \"(null|number)\",\n  loader: \"(null|string|number)\",\n  parentSelector: \"(null|string)\",\n  loadingIcon: \"boolean\",\n  loadingText: \"boolean\",\n  scroll: \"boolean\"\n}, F0 = {\n  backdrop: !0,\n  backdropID: null,\n  delay: 0,\n  loader: \"\",\n  parentSelector: null,\n  scroll: !0,\n  loadingText: !0,\n  loadingIcon: !0\n}, Y0 = {\n  loadingSpinner: \"absolute top-[50%] left-[50%] -translate-x-[50%] -translate-y-[50%] flex flex-col justify-center items-center z-40\",\n  spinnerColor: \"text-primary dark:text-primary-400\",\n  backdrop: \"w-full h-full fixed top-0 left-0 bottom-0 right-0 z-30\",\n  backdropColor: \"bg-[rgba(0,0,0,0.4)]\"\n}, j0 = {\n  loadingSpinner: \"string\",\n  spinnerColor: \"string\",\n  backdrop: \"string\",\n  backdropColor: \"string\"\n};\nclass xh {\n  constructor(t, e = {}, i) {\n    this._element = t, this._options = this._getConfig(e), this._classes = this._getClasses(i), this._element && y.setData(t, Ns, this), this._backdropElement = null, this._parentElement = d.findOne(this._options.parentSelector), this._loadingIcon = d.findOne(\n      B0,\n      this._element\n    ), this._loadingText = d.findOne(\n      H0,\n      this._element\n    ), this.init();\n  }\n  // Getters\n  static get NAME() {\n    return Ri;\n  }\n  // Public\n  init() {\n    const t = this._loadingIcon.cloneNode(!0), e = this._loadingText.cloneNode(!0);\n    this._removeElementsOnStart(), setTimeout(() => {\n      h.addClass(\n        this._element,\n        `${this._classes.loadingSpinner} ${this._classes.spinnerColor}`\n      ), this._setBackdrop(), this._setLoadingIcon(t), this._setLoadingText(e), this._setScrollOption(), c.trigger(this._element, V0);\n    }, this._options.delay);\n  }\n  dispose() {\n    y.removeData(this._element, Ns), h.removeClass(\n      this._element,\n      `${this._classes.loadingSpinner} ${this._classes.spinnerColor}`\n    );\n    const t = this._options.delay;\n    setTimeout(() => {\n      this._removeBackdrop(), this._backdropElement = null, this._element = null, this._options = null;\n    }, t);\n  }\n  // Private\n  _setBackdrop() {\n    const { backdrop: t } = this._options;\n    t && (this._backdropElement = P0(this._options, this._classes), this._parentElement !== null ? (h.addClass(this._element, \"absolute\"), h.addClass(this._parentElement, \"relative\"), h.addClass(this._backdropElement, \"absolute\"), this._parentElement.appendChild(this._backdropElement)) : (h.addClass(this._element, \"!fixed\"), document.body.appendChild(this._backdropElement), document.body.appendChild(this._element)));\n  }\n  _removeBackdrop() {\n    const { backdrop: t } = this._options;\n    t && (this._parentElement !== null ? (h.removeClass(this._element, \"absolute\"), h.removeClass(this._parentElement, \"relative\"), this._backdropElement.remove()) : (this._backdropElement.remove(), this._element.remove()));\n  }\n  _setLoadingIcon(t) {\n    if (!this._options.loadingIcon) {\n      t.remove();\n      return;\n    }\n    this._element.appendChild(t), t.id = this._options.loader;\n  }\n  _setLoadingText(t) {\n    if (!this._options.loadingText) {\n      t.remove();\n      return;\n    }\n    this._element.appendChild(t);\n  }\n  _removeElementsOnStart() {\n    this._element !== null && (this._loadingIcon.remove(), this._loadingText.remove());\n  }\n  _setScrollOption() {\n    if (this._options.scroll) {\n      if (this._parentElement === null) {\n        h.addClass(document.body, \"overflow-auto\");\n        return;\n      }\n      h.addClass(this._parentElement, \"overflow-auto\");\n    } else {\n      if (this._parentElement === null) {\n        h.addClass(document.body, \"overflow-hidden\");\n        return;\n      }\n      h.addClass(this._parentElement, \"overflow-hidden\");\n    }\n  }\n  _getConfig(t) {\n    const e = {\n      ...F0,\n      ...h.getDataAttributes(this._element),\n      ...t\n    };\n    return D(Ri, e, W0), e;\n  }\n  _getClasses(t) {\n    const e = h.getDataClassAttributes(this._element);\n    return t = {\n      ...Y0,\n      ...e,\n      ...t\n    }, D(Ri, t, j0), t;\n  }\n  // Static\n  static getInstance(t) {\n    return y.getData(t, Ns);\n  }\n  static getOrCreateInstance(t, e = {}) {\n    return this.getInstance(t) || new this(t, typeof e == \"object\" ? e : null);\n  }\n  static jQueryInterface(t) {\n    return this.each(function() {\n      let e = y.getData(this, Ns);\n      const i = typeof t == \"object\" && t;\n      if (e || (e = new xh(this, i)), typeof t == \"string\") {\n        if (typeof e[t] > \"u\")\n          throw new TypeError(`No method named \"${t}\"`);\n        e[t](this);\n      }\n    });\n  }\n}\nconst K0 = (s) => {\n  const t = /^(0?[1-9]|1[012])(:[0-5]\\d) [APap][mM]$/, e = /^([0-9]|0[0-9]|1[0-9]|2[0-3]):[0-5][0-9](:[0-5][0-9])?$/;\n  return s.match(t) || s.match(e);\n}, z0 = (s) => s && Object.prototype.toString.call(s) === \"[object Date]\" && !isNaN(s), U0 = (s) => s.getMonth(), X0 = (s) => s.getFullYear(), G0 = (s) => s.match(/[^(dmy)]{1,}/g), q0 = (s, t, e, i) => {\n  let n;\n  e[0] !== e[1] ? n = e[0] + e[1] : n = e[0];\n  const o = new RegExp(`[${n}]`), r = s.split(o), a = t.split(o), l = t.indexOf(\"mmm\") !== -1, p = [];\n  for (let b = 0; b < a.length; b++)\n    a[b].indexOf(\"yy\") !== -1 && (p[0] = { value: r[b], format: a[b] }), a[b].indexOf(\"m\") !== -1 && (p[1] = { value: r[b], format: a[b] }), a[b].indexOf(\"d\") !== -1 && a[b].length <= 2 && (p[2] = { value: r[b], format: a[b] });\n  let u;\n  t.indexOf(\"mmmm\") !== -1 ? u = i.monthsFull : u = i.monthsShort;\n  const _ = Number(p[0].value), f = l ? Z0(p[1].value, u) : Number(p[1].value) - 1, g = Number(p[2].value);\n  return Et(_, f, g);\n}, Z0 = (s, t) => t.findIndex((e) => e === s), Q0 = (s, t, e) => `\n  <button type=\"button\" class=\"${e.pickerIcon}\" data-te-datepicker-toggle-button-ref>\n    ${s}\n  </button>\n  <button type=\"button\" class=\"${e.pickerIcon}\" data-te-timepicker-toggle-button-ref>\n    ${t}\n  </button>\n`, J0 = (s, t) => `\n  <button type=\"button\" class=\"${t.toggleButton}\" data-te-date-timepicker-toggle-ref>\n    ${s} \n  </button>\n`, Qs = \"datetimepicker\", ki = `te.${Qs}`, gr = `.${ki}`, Oh = \"data-te-datepicker-init\", Sh = \"data-te-timepicker-init\", tC = \"data-te-datepicker-header\", eC = \"data-te-datepicker-cancel-button-ref\", iC = \"data-te-datepicker-ok-button-ref\", ko = \"data-te-timepicker-wrapper\", Fl = \"data-te-timepicker-cancel\", sC = \"data-te-timepicker-submit\", nC = \"data-te-timepicker-clear\", Yl = \"data-te-buttons-timepicker\", oC = \"data-te-date-timepicker-toggle-ref\", rC = \"data-te-datepicker-toggle-button-ref\", aC = \"data-te-timepicker-toggle-button-ref\", lC = `[${Sh}]`, cC = `[${Oh}]`, hC = `[${oC}]`, dC = `[${aC}]`, uC = \"[data-te-input-notch-ref]\", pC = \"[data-te-date-timepicker-toggle-ref]\", _C = \"[data-te-timepicker-elements-wrapper]\", fC = \"[data-te-timepicker-clock-wrapper]\", mC = `open${gr}`, gC = `close${gr}`, bC = `datetimeChange${gr}`, jl = \"close.te.datepicker\", Kl = \"input.te.timepicker\", De = $(\"div\"), zl = {\n  inline: !1,\n  toggleButton: !0,\n  container: \"body\",\n  disabled: !1,\n  disablePast: !1,\n  disableFuture: !1,\n  defaultTime: \"\",\n  defaultDate: \"\",\n  timepicker: {},\n  datepicker: {},\n  showFormat: !1,\n  dateTimepickerToggleIconTemplate: `<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\" fill=\"currentColor\">\n  <path fill-rule=\"evenodd\" d=\"M6.75 2.25A.75.75 0 017.5 3v1.5h9V3A.75.75 0 0118 3v1.5h.75a3 3 0 013 3v11.25a3 3 0 01-3 3H5.25a3 3 0 01-3-3V7.5a3 3 0 013-3H6V3a.75.75 0 01.75-.75zm13.5 9a1.5 1.5 0 00-1.5-1.5H5.25a1.5 1.5 0 00-1.5 1.5v7.5a1.5 1.5 0 001.5 1.5h13.5a1.5 1.5 0 001.5-1.5v-7.5z\" clip-rule=\"evenodd\" />\n  </svg>`,\n  datepickerToggleIconTemplate: `<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\" fill=\"currentColor\">\n  <path fill-rule=\"evenodd\" d=\"M6.75 2.25A.75.75 0 017.5 3v1.5h9V3A.75.75 0 0118 3v1.5h.75a3 3 0 013 3v11.25a3 3 0 01-3 3H5.25a3 3 0 01-3-3V7.5a3 3 0 013-3H6V3a.75.75 0 01.75-.75zm13.5 9a1.5 1.5 0 00-1.5-1.5H5.25a1.5 1.5 0 00-1.5 1.5v7.5a1.5 1.5 0 001.5 1.5h13.5a1.5 1.5 0 001.5-1.5v-7.5z\" clip-rule=\"evenodd\" />\n  </svg>`,\n  timepickerToggleIconTemplate: `<svg xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" viewBox=\"0 0 24 24\" stroke-width=\"1.5\" stroke=\"currentColor\">\n  <path stroke-linecap=\"round\" stroke-linejoin=\"round\" d=\"M12 6v6h4.5m4.5 0a9 9 0 11-18 0 9 9 0 0118 0z\" />\n  </svg>`\n}, vC = {\n  inline: \"boolean\",\n  toggleButton: \"boolean\",\n  container: \"string\",\n  disabled: \"boolean\",\n  disablePast: \"boolean\",\n  disableFuture: \"boolean\",\n  defaultTime: \"(string|date|number)\",\n  defaultDate: \"(string|date|number)\",\n  timepicker: \"object\",\n  datepicker: \"object\",\n  showFormat: \"boolean\",\n  dateTimepickerToggleIconTemplate: \"string\",\n  datepickerToggleIconTemplate: \"string\",\n  timepickerToggleIconTemplate: \"string\"\n}, TC = {\n  toggleButton: \"flex items-center justify-content-center [&>svg]:w-5 [&>svg]:h-5 absolute outline-none border-none bg-transparent right-0.5 top-1/2 -translate-x-1/2 -translate-y-1/2 hover:text-primary focus:text-primary dark:hover:text-primary-400 dark:focus:text-primary-400 dark:text-neutral-200\",\n  pickerIcon: \"[&>svg]:w-6 [&>svg]:h-6 [&>svg]:mx-auto [&>svg]:pointer-events-none w-1/2 px-1.5 py-[1px] rounded-[10px] min-h-[40px] cursor-pointer outline-none border-none text-white hover:bg-primary-600 dark:hover:bg-neutral-600\",\n  buttonsContainer: \"flex justify-evenly items-end bg-primary dark:bg-zinc-800 dark:data-[te-buttons-timepicker]:bg-zinc-700\",\n  timepicker: {},\n  datepicker: {}\n}, EC = {\n  toggleButton: \"string\",\n  pickerIcon: \"string\",\n  buttonsContainer: \"string\",\n  timepicker: \"object\",\n  datepicker: \"object\"\n};\nclass Ih {\n  constructor(t, e, i) {\n    this._element = t, this._input = d.findOne(\"input\", this._element), this._options = this._getConfig(e), this._classes = this._getClasses(i), this._timepicker = null, this._datepicker = null, this._dateValue = this._options.defaultDate ? this._options.defaultDate : \"\", this._timeValue = this._options.defaultTime ? this._options.defaultTime : \"\", this._isInvalidTimeFormat = !1, this._format = this._options.datepicker.format ? this._options.datepicker.format : \"dd/mm/yyyy\", this._cancel = !1, this._scrollBar = new qe(), this._element && y.setData(t, ki, this), this._init();\n  }\n  // Getters\n  static get NAME() {\n    return Qs;\n  }\n  get toggleButton() {\n    return d.findOne(hC, this._element);\n  }\n  get notch() {\n    return d.findOne(uC, this._element);\n  }\n  dispose() {\n    c.off(this._element, \"click\", this._openDatePicker), c.off(this._input, \"input\", this._handleInput), c.off(this._element, \"click\"), y.removeData(this._element, ki), this._removeTimePicker(), this._removeDatepicker(), this.toggleButton.remove(), this._options = zl, this._timepicker = null, this._datepicker = null, this._dateValue = null, this._timeValue = null, this._isInvalidTimeFormat = null;\n  }\n  update(t = {}) {\n    const e = this._getConfig({ ...this._options, ...t });\n    this.dispose(), this._options = e, this._init();\n  }\n  // Private\n  _init() {\n    this._addDatepicker(), this._addTimePicker(), this._appendToggleButton(), this._listenToToggleClick(), this._listenToUserInput(), this._disableInput(), this._setInitialDefaultInput(), this._applyFormatPlaceholder(), this._options.disablePast && this._handleTimepickerDisablePast(), this._options.disableFuture && this._handleTimepickerDisableFuture();\n  }\n  _removeDatepicker() {\n    const t = this._element.querySelector(cC);\n    t && t.remove();\n  }\n  _addDatepicker() {\n    const t = $(\"div\");\n    t.id = this._element.id ? `datepicker-${this._element.id}` : rt(\"datepicker-\");\n    const e = '<input type=\"text\">';\n    t.innerHTML = e, t.setAttribute(Oh, \"\"), this._element.appendChild(t), h.addClass(t, \"hidden\");\n    let i = {\n      ...this._options.datepicker,\n      container: this._options.container,\n      disablePast: this._options.disablePast,\n      disableFuture: this._options.disableFuture\n    };\n    (this._options.inline || this._options.datepicker.inline) && (i = { ...i, inline: !0 }), this._datepicker = new Nm(t, i, {\n      ...this._classes.datepicker\n    }), this._datepicker._input.value = this._dateValue;\n  }\n  _removeTimePicker() {\n    const t = this._element.querySelector(lC);\n    t && (t.remove(), this._scrollBar.reset());\n  }\n  _addTimePicker() {\n    const t = $(\"div\");\n    t.id = this._element.id ? `timepicker-${this._element.id}` : rt(\"timepicker-\");\n    const e = '<input type=\"text\">';\n    t.innerHTML = e, t.setAttribute(Sh, \"\"), this._element.appendChild(t), h.addClass(t, \"hidden\");\n    let i = {\n      ...this._options.timepicker,\n      container: this._options.container\n    };\n    (this._options.inline || this._options.timepicker.inline) && (i = { timepickerOptions: i, inline: !0 }), this._timepicker = new ng(t, i, {\n      ...this._classes.timepicker\n    }), this._timepicker.input.value = this._timeValue;\n  }\n  _addIconButtons() {\n    if (h.addClass(De, this._classes.buttonsContainer), De.innerHTML = Q0(\n      this._options.datepickerToggleIconTemplate,\n      this._options.timepickerToggleIconTemplate,\n      this._classes\n    ), De.removeAttribute(Yl), !(this._options.inline || this._options.datepicker.inline)) {\n      if (this._scrollBar.hide(), this._datepicker._isOpen)\n        d.findOne(\n          `[${tC}]`,\n          document.body\n        ).appendChild(De);\n      else if (this._timepicker._modal && !this._options.timepicker.inline) {\n        const t = d.findOne(\n          _C,\n          document.body\n        ), e = d.findOne(\n          fC,\n          document.body\n        );\n        De.setAttribute(Yl, \"\"), t.insertBefore(De, e);\n      }\n    }\n  }\n  _enableOrDisableToggleButton() {\n    this._options.disabled ? (this.toggleButton.disabled = !0, h.addClass(this.toggleButton, \"pointer-events-none\")) : (this.toggleButton.disabled = !1, h.removeClass(this.toggleButton, \"pointer-events-none\"));\n  }\n  _appendToggleButton() {\n    this._options.toggleButton && (this._element.insertAdjacentHTML(\n      \"beforeend\",\n      J0(\n        this._options.dateTimepickerToggleIconTemplate,\n        this._classes\n      )\n    ), this._enableOrDisableToggleButton());\n  }\n  _applyFormatPlaceholder() {\n    this._options.showFormat && (this._input.placeholder = this._format);\n  }\n  _listenToCancelClick() {\n    const t = d.findOne(\n      `[${eC}]`,\n      document.body\n    );\n    c.one(t, \"mousedown\", () => {\n      this._cancel = !0, this._scrollBar.reset(), c.off(t, \"mousedown\");\n    });\n  }\n  _listenToToggleClick() {\n    c.on(this._element, \"click\", pC, (t) => {\n      t.preventDefault(), this._openDatePicker();\n    });\n  }\n  _listenToUserInput() {\n    c.on(this._input, \"input\", (t) => {\n      this._handleInput(t.target.value);\n    });\n  }\n  _disableInput() {\n    this._options.disabled && (this._input.disabled = \"true\");\n  }\n  _getConfig(t) {\n    const e = h.getDataAttributes(this._element);\n    return t = {\n      ...zl,\n      ...e,\n      ...t\n    }, D(Qs, t, vC), t;\n  }\n  _getClasses(t) {\n    const e = h.getDataClassAttributes(this._element);\n    return t = {\n      ...TC,\n      ...e,\n      ...t\n    }, D(Qs, t, EC), t;\n  }\n  _handleInput(t) {\n    const e = t.split(\", \"), i = G0(this._format), n = e[0], o = e[1] || \"\", r = q0(\n      n,\n      this._format,\n      i,\n      this._datepicker._options\n    );\n    e.length === 2 && (z0(r) && K0(o) ? (this._dateValue = n, this._timeValue = o, this._datepicker._input.value = this._dateValue, this._datepicker._activeDate = this._dateValue, this._datepicker._selectedYear = X0(r), this._datepicker._selectedMonth = U0(r), this._datepicker._headerDate = r, this._timepicker.input.value = this._timeValue, this._timepicker._isInvalidTimeFormat = !1) : (this._datepicker._activeDate = /* @__PURE__ */ new Date(), this._datepicker._selectedDate = null, this._datepicker._selectedMonth = null, this._datepicker._selectedYear = null, this._datepicker._headerDate = null, this._datepicker._headerMonth = null, this._datepicker._headerYear = null, this._timepicker._isInvalidTimeFormat = !0));\n  }\n  _openDatePicker() {\n    if (c.trigger(this._element, mC).defaultPrevented)\n      return;\n    this._datepicker.open(), this._options.inline || this._scrollBar.hide(), (this._options.inline || this._options.datepicker.inline) && this._openDropdownDate(), this._addIconButtons(), this._listenToCancelClick(), this._options.inline && this._datepicker._isOpen && h.addClass(this.toggleButton, \"pointer-events-none\"), c.one(this._datepicker._element, jl, () => {\n      if (this._dateValue = this._datepicker._input.value, this._updateInputValue(), this._cancel) {\n        this._cancel = !1;\n        return;\n      }\n      c.on(this._datepicker.container, \"click\", (i) => {\n        !this._datepicker._selectedDate && i.target.hasAttribute(iC) || this._openTimePicker();\n      }), setTimeout(() => {\n        d.findOne(\n          `[${ko}]`,\n          document.body\n        ) || this._scrollBar.reset();\n      }, 10), this._options.inline && h.removeClass(this.toggleButton, \"pointer-events-none\");\n    });\n    const e = d.findOne(\n      dC,\n      document.body\n    );\n    c.on(e, \"click\", () => {\n      this._datepicker.close(), this._scrollBar.hide(), c.trigger(this._datepicker._element, jl);\n    });\n  }\n  _handleTimepickerDisablePast() {\n    const t = /* @__PURE__ */ new Date();\n    t.setHours(0, 0, 0, 0), c.on(\n      this._datepicker._element,\n      \"dateChange.te.datepicker\",\n      () => {\n        this._datepicker._selectedDate.getTime() === t.getTime() ? this._timepicker.update({ disablePast: !0 }) : this._timepicker.update({ disablePast: !1 });\n      }\n    );\n  }\n  _handleTimepickerDisableFuture() {\n    const t = /* @__PURE__ */ new Date();\n    t.setHours(0, 0, 0, 0), c.on(\n      this._datepicker._element,\n      \"dateChange.te.datepicker\",\n      () => {\n        this._datepicker._selectedDate.getTime() === t.getTime() ? this._timepicker.update({ disableFuture: !0 }) : this._timepicker.update({ disableFuture: !1 });\n      }\n    );\n  }\n  _handleEscapeKey() {\n    c.one(document.body, \"keyup\", () => {\n      setTimeout(() => {\n        d.findOne(\n          `[${ko}]`,\n          document.body\n        ) || this._scrollBar.reset();\n      }, 250);\n    });\n  }\n  _handleCancelButton() {\n    const t = d.findOne(\n      `[${Fl}]`,\n      document.body\n    );\n    c.one(t, \"mousedown\", () => {\n      this._scrollBar.reset();\n    });\n  }\n  _openDropdownDate() {\n    const t = this._datepicker._popper;\n    t.state.elements.reference = this._input, this._scrollBar.reset();\n  }\n  _openTimePicker() {\n    c.trigger(this._timepicker.elementToggle, \"click\"), setTimeout(() => {\n      if (this._addIconButtons(), (this._options.inline || this._options.timepicker.inline) && this._openDropdownTime(), this._timepicker._modal) {\n        const t = d.findOne(\n          `[${Fl}]`,\n          document.body\n        );\n        this._handleEscapeKey(), this._handleCancelButton(), c.on(this._timepicker._modal, \"click\", (e) => {\n          (e.target.hasAttribute(ko) || e.target.hasAttribute(sC)) && setTimeout(() => {\n            this._scrollBar.reset();\n          }, 200), e.target.hasAttribute(nC) && c.trigger(\n            this._timepicker._element,\n            Kl\n          ), e.target.hasAttribute(rC) && (c.trigger(t, \"click\"), setTimeout(() => {\n            this._openDatePicker(), this._scrollBar.hide();\n          }, 200));\n        });\n      }\n    }), c.one(this._timepicker._element, Kl, () => {\n      this._timeValue = this._timepicker.input.value, this._updateInputValue(), c.trigger(this._element, gC);\n    });\n  }\n  _openDropdownTime() {\n    const t = this._timepicker._popper;\n    t.state.elements.reference = this._input, t.update(), this._scrollBar.reset();\n  }\n  _setInitialDefaultInput() {\n    (this._options.defaultDate || this._options.defaultTime) && this._updateInputValue();\n  }\n  _updateInputValue() {\n    this._timeValue && this._dateValue && (this._input.value = `${this._dateValue}, ${this._timeValue}`, c.trigger(\n      this._element,\n      bC\n    ).defaultPrevented) || (c.trigger(this._input, \"focus\"), this.notch && this.notch.removeAttribute(\"data-te-input-focused\"));\n  }\n  // static\n  static jQueryInterface(t, e) {\n    return this.each(function() {\n      let i = y.getData(this, ki);\n      const n = typeof t == \"object\" && t;\n      if (!(!i && /dispose/.test(t)) && (i || (i = new Ih(this, n)), typeof t == \"string\")) {\n        if (typeof i[t] > \"u\")\n          throw new TypeError(`No method named \"${t}\"`);\n        i[t](e);\n      }\n    });\n  }\n  static getInstance(t) {\n    return y.getData(t, ki);\n  }\n  static getOrCreateInstance(t, e = {}) {\n    return this.getInstance(t) || new this(t, typeof e == \"object\" ? e : null);\n  }\n}\nconst Js = \"sticky\", xi = `te.${Js}`, Dh = `.${xi}`, CC = `active${Dh}`, AC = `inactive${Dh}`, yC = {\n  stickyAnimationSticky: \"\",\n  stickyAnimationUnsticky: \"\",\n  stickyBoundary: !1,\n  stickyDelay: 0,\n  stickyDirection: \"down\",\n  stickyMedia: 0,\n  stickyOffset: 0,\n  stickyPosition: \"top\",\n  stickyZIndex: 100\n}, wC = {\n  stickyAnimationSticky: \"string\",\n  stickyAnimationUnsticky: \"string\",\n  stickyBoundary: \"(boolean|string)\",\n  stickyDelay: \"number\",\n  stickyDirection: \"string\",\n  stickyMedia: \"number\",\n  stickyOffset: \"number\",\n  stickyPosition: \"string\",\n  stickyZIndex: \"(string|number)\"\n}, kC = {\n  stickyActive: \"\"\n}, xC = {\n  stickyActive: \"string\"\n};\nclass $h {\n  constructor(t, e, i) {\n    this._element = t, this._hiddenElement = null, this._elementPositionStyles = {}, this._scrollDirection = \"\", this._isSticked = !1, this._elementOffsetTop = null, this._scrollTop = 0, this._pushPoint = \"\", this._manuallyDeactivated = !1, this._element && (this._options = this._getConfig(e), this._classes = this._getClasses(i), y.setData(t, xi, this), this._init());\n  }\n  // Getters\n  static get NAME() {\n    return Js;\n  }\n  // Public\n  dispose() {\n    const { stickyAnimationUnsticky: t } = this._options;\n    let { animationDuration: e } = getComputedStyle(this._element);\n    e = t !== \"\" ? parseFloat(e) * 1e3 : 0, this._disableSticky(), setTimeout(() => {\n      y.removeData(this._element, xi), this._element = null, this._options = null, this._hiddenElement = null, this._elementPositionStyles = null, this._scrollDirection = null, this._isSticked = null, this._elementOffsetTop = null, this._scrollTop = null, this._pushPoint = null, this._manuallyDeactivated = null;\n    }, e);\n  }\n  active() {\n    this._isSticked || (this._createHiddenElement(), this._enableSticky(), this._changeBoundaryPosition(), this._isSticked = !0, this._manuallyDeactivated = !1);\n  }\n  inactive() {\n    this._isSticked && (this._disableSticky(), this._isSticked = !1, this._manuallyDeactivated = !0);\n  }\n  // Private\n  _init() {\n    this._userActivityListener();\n  }\n  _userActivityListener() {\n    c.on(window, \"resize\", () => {\n      this._updateElementPosition(), this._updateElementOffset();\n    }), c.on(window, \"scroll\", () => {\n      if (!this._element || window.innerWidth <= this._options.stickyMedia || this._manuallyDeactivated)\n        return;\n      const t = document.documentElement, { stickyDirection: e } = this._options, i = window.pageYOffset || t.scrollTop;\n      this._updateElementOffset(), this._updatePushPoint(), this._updateScrollDirection(i), this._clearInProgressAnimations();\n      const n = [this._scrollDirection, \"both\"].includes(\n        e\n      ), o = this._pushPoint <= i, r = o && !this._isSticked && n, a = (!o || !n) && this._isSticked;\n      r && (this._createHiddenElement(), this._enableSticky(), this._changeBoundaryPosition(), this._isSticked = !0), a && (this._disableSticky(), this._isSticked = !1), this._isSticked && (this._updatePosition({ styles: this._elementPositionStyles }), this._changeBoundaryPosition()), this._scrollTop = i <= 0 ? 0 : i;\n    });\n  }\n  _updatePushPoint() {\n    this._options.stickyPosition === \"top\" ? this._pushPoint = this._elementOffsetTop - this._options.stickyDelay : this._pushPoint = this._elementOffsetTop + this._element.height - document.body.scrollHeight + this._options.stickyDelay;\n  }\n  _updateElementOffset() {\n    this._hiddenElement ? this._elementOffsetTop = this._hiddenElement.offsetTop : this._elementOffsetTop = this._element.offsetTop, this._options.stickyAnimationUnsticky && (this._elementOffsetTop += this._element.height || 0);\n  }\n  _updateElementPosition() {\n    if (this._hiddenElement) {\n      const { left: t } = this._hiddenElement.getBoundingClientRect();\n      this._elementPositionStyles = {\n        left: `${t}px`\n      };\n    } else\n      this._elementPositionStyles = {};\n    this._setStyle(this._element, this._elementPositionStyles);\n  }\n  _updateScrollDirection(t) {\n    t > this._scrollTop ? this._scrollDirection = \"down\" : this._scrollDirection = \"up\";\n  }\n  _clearInProgressAnimations() {\n    const t = this._scrollDirection === \"up\", e = this._element.classList.contains(\n      this._options.stickyAnimationUnsticky\n    ), i = window.scrollY <= this._elementOffsetTop - this._element.height;\n    t && e && i && (this._removeUnstickyAnimation(), this._resetStyles(), this._removeHiddenElement());\n  }\n  _enableSticky() {\n    const {\n      stickyAnimationSticky: t,\n      stickyAnimationUnsticky: e,\n      stickyOffset: i,\n      stickyPosition: n,\n      stickyZIndex: o\n    } = this._options, { height: r, left: a, width: l } = this._element.getBoundingClientRect();\n    t !== \"\" && this._toggleClass(\n      t,\n      e,\n      this._element\n    ), this._toggleClass(this._classes.stickyActive, \"\", this._element), this._setStyle(this._element, {\n      top: n === \"top\" && `${0 + i}px`,\n      bottom: n === \"bottom\" && `${0 + i}px`,\n      height: `${r}px`,\n      width: `${l}px`,\n      left: `${a}px`,\n      zIndex: `${o}`,\n      position: \"fixed\"\n    }), this._hiddenElement.hidden = !1, c.trigger(this._element, CC);\n  }\n  _changeBoundaryPosition() {\n    const { stickyPosition: t, stickyBoundary: e, stickyOffset: i } = this._options, { height: n } = this._element.getBoundingClientRect(), o = {\n      height: this._element.parentElement.getBoundingClientRect().height,\n      ...this._getOffset(this._element.parentElement)\n    };\n    let r;\n    const a = d.findOne(e);\n    a ? r = this._getOffset(a).top - n - i : r = o.height + o[t] - n - i;\n    const l = t === \"top\", p = t === \"bottom\", u = e, _ = r < 0, f = r > o.height - n;\n    let g;\n    l && (_ && u ? g = { top: `${i + r}px` } : g = { top: `${i + 0}px` }), p && (_ && u ? g = { bottom: `${i + r}px` } : f && u ? g = { bottom: `${i + o.bottom}px` } : g = { bottom: `${i + 0}px` }), this._setStyle(this._element, g);\n  }\n  _disableSticky() {\n    const { stickyAnimationUnsticky: t, stickyAnimationSticky: e } = this._options;\n    let { animationDuration: i } = getComputedStyle(this._element);\n    i = t !== \"\" ? parseFloat(i) * 1e3 : 0, this._options.stickyAnimationUnsticky !== \"\" && this._toggleClass(\n      t,\n      e,\n      this._element\n    ), setTimeout(() => {\n      this._element.classList.contains(e) || (this._removeUnstickyAnimation(), this._resetStyles(), this._removeHiddenElement(), this._toggleClass(\"\", this._classes.stickyActive, this._element), c.trigger(this._element, AC));\n    }, i);\n  }\n  _createHiddenElement() {\n    this._hiddenElement || (this._hiddenElement = this._copyElement(this._element));\n  }\n  _removeHiddenElement() {\n    this._hiddenElement && (this._hiddenElement.remove(), this._hiddenElement = null);\n  }\n  _removeUnstickyAnimation() {\n    this._toggleClass(\"\", this._options.stickyAnimationUnsticky, this._element);\n  }\n  _resetStyles() {\n    this._setStyle(this._element, {\n      top: null,\n      bottom: null,\n      position: null,\n      left: null,\n      zIndex: null,\n      width: null,\n      height: null\n    });\n  }\n  _updatePosition({ styles: t }) {\n    this._setStyle(this._element, t);\n  }\n  _toggleClass(t, e, i) {\n    t && h.addClass(i, t), e && h.removeClass(i, e);\n  }\n  _getOffset(t) {\n    const e = h.offset(t), i = t.getBoundingClientRect(), n = e.left === 0 && e.top === 0 ? 0 : window.innerHeight - i.bottom;\n    return {\n      ...e,\n      bottom: n\n    };\n  }\n  _copyElement(t) {\n    const { height: e, width: i } = t.getBoundingClientRect(), n = t.cloneNode(!1);\n    return n.hidden = !0, this._setStyle(n, {\n      height: `${e}px`,\n      width: `${i}px`,\n      opacity: \"0\"\n    }), t.parentElement.insertBefore(n, t), n;\n  }\n  _getConfig(t = {}) {\n    const e = h.getDataAttributes(this._element);\n    return t = {\n      ...yC,\n      ...e,\n      ...t\n    }, D(Js, t, wC), t;\n  }\n  _getClasses(t) {\n    const e = h.getDataClassAttributes(this._element);\n    return t = {\n      ...kC,\n      ...e,\n      ...t\n    }, D(Js, t, xC), t;\n  }\n  _setStyle(t, e) {\n    Object.keys(e).forEach((i) => {\n      t.style[i] = e[i];\n    });\n  }\n  static jQueryInterface(t, e) {\n    return this.each(function() {\n      let i = y.getData(this, xi);\n      const n = typeof t == \"object\" && t;\n      if (!(!i && /dispose|hide/.test(t)) && (i || (i = new $h(this, n)), typeof t == \"string\")) {\n        if (typeof i[t] > \"u\")\n          throw new TypeError(`No method named \"${t}\"`);\n        i[t](e);\n      }\n    });\n  }\n  static getInstance(t) {\n    return y.getData(t, xi);\n  }\n  static getOrCreateInstance(t, e = {}) {\n    return this.getInstance(t) || new this(t, typeof e == \"object\" ? e : null);\n  }\n}\nconst OC = (s) => {\n  Zl(() => {\n    const t = ql();\n    if (t) {\n      const e = s.NAME, i = t.fn[e];\n      t.fn[e] = s.jQueryInterface, t.fn[e].Constructor = s, t.fn[e].noConflict = () => (t.fn[e] = i, s.jQueryInterface);\n    }\n  });\n}, SC = (s, t) => {\n  c.on(\n    document,\n    `click.te.${s.NAME}`,\n    t,\n    function(e) {\n      e.preventDefault(), s.getOrCreateInstance(this).toggle();\n    }\n  );\n}, IC = (s, t) => {\n  c.on(\n    document,\n    `click.te.${s.NAME}.data-api`,\n    t,\n    function(e) {\n      if ([\"A\", \"AREA\"].includes(this.tagName) && e.preventDefault(), ge(this))\n        return;\n      s.getOrCreateInstance(this).show();\n    }\n  );\n}, DC = (s, t) => {\n  c.on(\n    document,\n    `click.te.${s.NAME}.data-api`,\n    t,\n    function(e) {\n      const i = Jt(this);\n      if ([\"A\", \"AREA\"].includes(this.tagName) && e.preventDefault(), ge(this))\n        return;\n      c.one(i, s.EVENT_HIDDEN, () => {\n        Nt(this) && this.focus();\n      });\n      const n = d.findOne(s.OPEN_SELECTOR);\n      n && n !== i && s.getInstance(n).hide(), s.getOrCreateInstance(i).toggle(this);\n    }\n  );\n}, $C = (s, t) => {\n  c.on(\n    document,\n    `click.te.${s.NAME}`,\n    t,\n    (e) => {\n      e.preventDefault();\n      const i = e.target.closest(t);\n      s.getOrCreateInstance(i).toggle();\n    }\n  );\n}, LC = (s, t) => {\n  c.on(\n    document,\n    `click.te.${s.NAME}`,\n    t,\n    function(e) {\n      const i = Jt(this);\n      [\"A\", \"AREA\"].includes(this.tagName) && e.preventDefault(), c.one(i, s.EVENT_SHOW, (r) => {\n        r.defaultPrevented || c.one(i, s.EVENT_HIDDEN, () => {\n          Nt(this) && this.focus();\n        });\n      });\n      const n = d.findOne(\n        `[${s.OPEN_SELECTOR}=\"true\"]`\n      );\n      n && s.getInstance(n).hide(), s.getOrCreateInstance(i).toggle(this);\n    }\n  );\n}, NC = (s, t) => {\n  c.one(\n    document,\n    \"mousedown\",\n    t,\n    s.autoInitial(new s())\n  );\n}, MC = (s, t) => {\n  c.on(\n    document,\n    `click.te.${s.NAME}.data-api`,\n    t,\n    function(e) {\n      (e.target.tagName === \"A\" || e.delegateTarget && e.delegateTarget.tagName === \"A\") && e.preventDefault();\n      const i = qo(this);\n      d.find(i).forEach((o) => {\n        s.getOrCreateInstance(o, { toggle: !1 }).toggle();\n      });\n    }\n  );\n}, RC = (s, t) => {\n  [].slice.call(\n    document.querySelectorAll(t)\n  ).map(function(i) {\n    return new s(i);\n  });\n}, PC = (s, t) => {\n  [].slice.call(\n    document.querySelectorAll(t)\n  ).map(function(i) {\n    return new s(i);\n  });\n}, BC = (s, t) => {\n  d.find(t).forEach((e) => {\n    new s(e);\n  }), c.on(\n    document,\n    `click.te.${s.NAME}.data-api`,\n    `${t} img:not([data-te-lightbox-disabled])`,\n    s.toggle()\n  );\n}, HC = (s, t) => {\n  const e = (o) => o[0] === \"{\" && o[o.length - 1] === \"}\" || o[0] === \"[\" && o[o.length - 1] === \"]\", i = (o) => typeof o != \"string\" ? o : e(o) ? JSON.parse(o.replace(/'/g, '\"')) : o, n = (o) => {\n    const r = {};\n    return Object.keys(o).forEach((a) => {\n      if (a.match(/dataset.*/)) {\n        const l = a.slice(7, 8).toLowerCase().concat(a.slice(8));\n        r[l] = i(o[a]);\n      }\n    }), r;\n  };\n  d.find(t).forEach((o) => {\n    if (h.getDataAttribute(o, \"chart\") !== \"bubble\" && h.getDataAttribute(o, \"chart\") !== \"scatter\") {\n      const r = h.getDataAttributes(o), a = {\n        data: {\n          datasets: [n(r)]\n        }\n      };\n      return r.chart && (a.type = r.chart), r.labels && (a.data.labels = JSON.parse(r.labels.replace(/'/g, '\"'))), new s(o, {\n        ...a,\n        ...Ti[a.type]\n      });\n    }\n    return null;\n  });\n};\nclass VC {\n  constructor() {\n    this.inits = [];\n  }\n  get initialized() {\n    return this.inits;\n  }\n  isInited(t) {\n    return this.inits.includes(t);\n  }\n  add(t) {\n    this.isInited(t) || this.inits.push(t);\n  }\n}\nconst Go = new VC(), Oi = {\n  alert: {\n    name: \"Alert\",\n    selector: \"[data-te-alert-init]\",\n    isToggler: !1\n  },\n  animation: {\n    name: \"Animate\",\n    selector: \"[data-te-animation-init]\",\n    isToggler: !1\n  },\n  carousel: {\n    name: \"Carousel\",\n    selector: \"[data-te-carousel-init]\",\n    isToggler: !1\n  },\n  chips: {\n    name: \"ChipsInput\",\n    selector: \"[data-te-chips-input-init]\",\n    isToggler: !1\n  },\n  chip: {\n    name: \"Chip\",\n    selector: \"[data-te-chip-init]\",\n    isToggler: !1,\n    onInit: \"init\"\n  },\n  datepicker: {\n    name: \"Datepicker\",\n    selector: \"[data-te-datepicker-init]\",\n    isToggler: !1\n  },\n  datetimepicker: {\n    name: \"Datetimepicker\",\n    selector: \"[data-te-date-timepicker-init]\",\n    isToggler: !1\n  },\n  input: {\n    name: \"Input\",\n    selector: \"[data-te-input-wrapper-init]\",\n    isToggler: !1\n  },\n  perfectScrollbar: {\n    name: \"PerfectScrollbar\",\n    selector: \"[data-te-perfect-scrollbar-init]\",\n    isToggler: !1\n  },\n  rating: {\n    name: \"Rating\",\n    selector: \"[data-te-rating-init]\",\n    isToggler: !1\n  },\n  scrollspy: {\n    name: \"ScrollSpy\",\n    selector: \"[data-te-spy='scroll']\",\n    isToggler: !1\n  },\n  select: {\n    name: \"Select\",\n    selector: \"[data-te-select-init]\",\n    isToggler: !1\n  },\n  sidenav: {\n    name: \"Sidenav\",\n    selector: \"[data-te-sidenav-init]\",\n    isToggler: !1\n  },\n  stepper: {\n    name: \"Stepper\",\n    selector: \"[data-te-stepper-init]\",\n    isToggler: !1\n  },\n  timepicker: {\n    name: \"Timepicker\",\n    selector: \"[data-te-timepicker-init]\",\n    isToggler: !1\n  },\n  toast: {\n    name: \"Toast\",\n    selector: \"[data-te-toast-init]\",\n    isToggler: !1\n  },\n  datatable: {\n    name: \"Datatable\",\n    selector: \"[data-te-datatable-init]\"\n  },\n  popconfirm: {\n    name: \"Popconfirm\",\n    selector: \"[data-te-toggle='popconfirm']\"\n  },\n  validation: {\n    name: \"Validation\",\n    selector: \"[data-te-validation-init]\"\n  },\n  smoothScroll: {\n    name: \"SmoothScroll\",\n    selector: \"a[data-te-smooth-scroll-init]\"\n  },\n  lazyLoad: {\n    name: \"LazyLoad\",\n    selector: \"[data-te-lazy-load-init]\"\n  },\n  clipboard: {\n    name: \"Clipboard\",\n    selector: \"[data-te-clipboard-init]\"\n  },\n  infiniteScroll: {\n    name: \"InfiniteScroll\",\n    selector: \"[data-te-infinite-scroll-init]\"\n  },\n  loadingManagement: {\n    name: \"LoadingManagement\",\n    selector: \"[data-te-loading-management-init]\"\n  },\n  sticky: {\n    name: \"Sticky\",\n    selector: \"[data-te-sticky-init]\"\n  },\n  // advancedInits\n  chart: {\n    name: \"Chart\",\n    selector: \"[data-te-chart]\",\n    isToggler: !1,\n    advanced: HC\n  },\n  // togglers\n  button: {\n    name: \"Button\",\n    selector: \"[data-te-toggle='button']\",\n    isToggler: !0,\n    callback: $C\n  },\n  collapse: {\n    name: \"Collapse\",\n    selector: \"[data-te-collapse-init]\",\n    isToggler: !0,\n    callback: MC\n  },\n  dropdown: {\n    name: \"Dropdown\",\n    selector: \"[data-te-dropdown-toggle-ref]\",\n    isToggler: !0,\n    callback: SC\n  },\n  modal: {\n    name: \"Modal\",\n    selector: \"[data-te-toggle='modal']\",\n    isToggler: !0,\n    callback: LC\n  },\n  ripple: {\n    name: \"Ripple\",\n    selector: \"[data-te-ripple-init]\",\n    isToggler: !0,\n    callback: NC\n  },\n  offcanvas: {\n    name: \"Offcanvas\",\n    selector: \"[data-te-offcanvas-toggle]\",\n    isToggler: !0,\n    callback: DC\n  },\n  tab: {\n    name: \"Tab\",\n    selector: \"[data-te-toggle='tab'], [data-te-toggle='pill'], [data-te-toggle='list']\",\n    isToggler: !0,\n    callback: IC\n  },\n  tooltip: {\n    name: \"Tooltip\",\n    selector: \"[data-te-toggle='tooltip']\",\n    isToggler: !1,\n    callback: RC\n  },\n  popover: {\n    name: \"Popover\",\n    selector: \"[data-te-toggle='popover']\",\n    isToggler: !0,\n    callback: PC\n  },\n  lightbox: {\n    name: \"Lightbox\",\n    selector: \"[data-te-lightbox-init]\",\n    isToggler: !0,\n    callback: BC\n  },\n  touch: {\n    name: \"Touch\",\n    selector: \"[data-te-touch-init]\"\n  }\n}, WC = (s) => Oi[s.NAME] || null, FC = (s, t) => {\n  if (!s || !t.allowReinits && Go.isInited(s.NAME))\n    return;\n  Go.add(s.NAME);\n  const e = WC(s), i = (e == null ? void 0 : e.isToggler) || !1;\n  if (OC(s), e != null && e.advanced) {\n    e == null || e.advanced(s, e == null ? void 0 : e.selector);\n    return;\n  }\n  if (i) {\n    e == null || e.callback(s, e == null ? void 0 : e.selector);\n    return;\n  }\n  d.find(e == null ? void 0 : e.selector).forEach((n) => {\n    let o = s.getInstance(n);\n    o || (o = new s(n), e != null && e.onInit && o[e.onInit]());\n  });\n}, YC = (s, t) => {\n  s.forEach((e) => FC(e, t));\n}, jC = {\n  allowReinits: !1,\n  checkOtherImports: !1\n}, ZC = (s, t = {}) => {\n  t = { ...jC, ...t };\n  const e = Object.keys(Oi).map((i) => {\n    if (!!document.querySelector(Oi[i].selector)) {\n      const o = s[Oi[i].name];\n      return !o && !Go.isInited(i) && t.checkOtherImports && console.warn(\n        `Please import ${Oi[i].name} from \"tw-elements\" package and add it to a object parameter inside \"initTE\" function`\n      ), o;\n    }\n  });\n  YC(e, t);\n};\n\n//# sourceMappingURL=tw-elements.es.min.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdHctZWxlbWVudHMvZGlzdC9qcy90dy1lbGVtZW50cy5lcy5taW4uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEZBQTRGO0FBQzVGO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQywwREFBMEQ7QUFDcEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxDQUFDLHVFQUF1RSxFQUFFLE1BQU07QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxnQkFBZ0I7QUFDdEU7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLFFBQVEsNENBQTRDO0FBQ3BEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGdCQUFnQixZQUFZLEVBQUUsbUJBQW1CLEVBQUUsdUJBQXVCLEVBQUU7QUFDdkY7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRCxVQUFVLFlBQVk7QUFDdEI7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxXQUFXO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixFQUFFLElBQUksS0FBSztBQUM1QjtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZLEtBQUssaUJBQWlCO0FBQ2pELDZCQUE2QixLQUFLO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLE9BQU87QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxvQkFBb0IsY0FBYztBQUNsQztBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEM7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsVUFBVTtBQUMzQjtBQUNBO0FBQ0EsZUFBZSxjQUFjO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QiwyQkFBMkI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQSxPQUFPLElBQUk7QUFDWDtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qiw4Q0FBOEM7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQywyQ0FBMkM7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLElBQUk7QUFDUDtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsWUFBWTtBQUN2QztBQUNBLHlCQUF5QixZQUFZO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFLHNDQUFzQztBQUNwSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcseUVBQXlFLHFDQUFxQztBQUNqSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsNENBQTRDO0FBQy9DO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLDBCQUEwQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0gsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHLElBQUk7QUFDUDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLLDBHQUEwRyxjQUFjO0FBQzdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPLFdBQVcsUUFBUTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLHdDQUF3QztBQUMzQztBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFHQUFxRztBQUNyRztBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLElBQUk7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyx3TUFBd007QUFDM007QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFD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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyx3Q0FBd0MsR0FBRztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixjQUFjO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsWUFBWTtBQUN4QztBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsRUFBRTtBQUNsQjtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMs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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLE9BQU87QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0hBQStILEdBQUc7QUFDbEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGNBQWM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsR0FBRztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSx3QkFBd0IsRUFBRSwwRUFBMEUsRUFBRTtBQUN0RztBQUNBO0FBQ0Esb0ZBQW9GLEVBQUU7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0UsR0FBRztBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sd0ZBQXdGLEdBQUc7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsYUFBYTtBQUN2QjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsRUFBRTtBQUNsRDtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsOENBQThDLEdBQUc7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUMsY0FBYyxHQUFHLHdCQUF3QixHQUFHLGlCQUFpQixHQUFHLGVBQWUsR0FBRyxnQkFBZ0IsR0FBRyxpQkFBaUIsR0FBRyx3QkFBd0IsR0FBRywwQkFBMEIsR0FBRywwQkFBMEIsR0FBRyw0QkFBNEIsR0FBRztBQUM5TztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsNFhBQTRYLEdBQUc7QUFDL1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwwQ0FBMEM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRkFBaUYsRUFBRSxvRkFBb0YsRUFBRTtBQUN6SztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxFQUFFO0FBQ3BEO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFOQUFxTjtBQUNyTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsT0FBTztBQUN2QztBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxPQUFPO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELEdBQUc7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCLENBQUM7QUFDRCxlQUFlLEdBQUc7QUFDbEIsbUJBQW1CLEdBQUc7QUFDdEIsZUFBZSxHQUFHO0FBQ2xCLGlCQUFpQixHQUFHO0FBQ3BCLHVCQUF1QixHQUFHO0FBQzFCLGlCQUFpQixHQUFHO0FBQ3BCLHFCQUFxQixHQUFHO0FBQ3hCLHVCQUF1QixHQUFHO0FBQzFCLDJCQUEyQixHQUFHO0FBQzlCLDJCQUEyQixHQUFHO0FBQzlCLENBQUMsbUdBQW1HLEdBQUc7QUFDdkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0dBQXNHO0FBQ3RHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsWUFBWSxlQUFlO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixzQkFBc0I7QUFDL0M7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyw0QkFBNEIsR0FBRyx5QkFBeUI7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsNEJBQTRCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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YUFBYSxHQUFHLGFBQWEsR0FBRyxhQUFhLEdBQUc7QUFDemY7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLEVBQUU7QUFDaEM7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxL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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsR0FBRyxJQUFJLHFCQUFxQjtBQUN0QztBQUNBLFVBQVUsR0FBRyxJQUFJLHFCQUFxQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Ysc0NBQXNDLHdCQUF3QjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLEtBQUssSUFBSSxNQUFNLEVBQUUsRUFBRTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxxQkFBcUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlB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LHVCQUF1QixFQUFFLDBCQUEwQixFQUFFLGtCQUFrQixFQUFFLGlCQUFpQixFQUFFLGtCQUFrQixFQUFFLGdCQUFnQixFQUFFLG1CQUFtQixFQUFFLHFCQUFxQixFQUFFLDRCQUE0QixFQUFFLDhCQUE4QixFQUFFLDZCQUE2QixFQUFFLDJDQUEyQyxFQUFFLDRCQUE0QixFQUFFLHNCQUFzQixFQUFFLG1CQUFtQixFQUFFLGtCQUFrQixFQUFFLGlCQUFpQixFQUFFLGlCQUFpQixFQUFFLHVCQUF1QixFQUFFLG1CQUFtQixFQUFFLHlCQUF5QixFQUFFLGdCQUFnQixFQUFFLGtCQUFrQixFQUFFLHVCQUF1QixFQUFFLHFCQUFxQixFQUFFLHdCQUF3QixFQUFFLHNCQUFzQixFQUFFLDhCQUE4QixFQUFFLHNCQUFzQixFQUFFLHdCQUF3QixFQUFFLGtCQUFrQixFQUFFO0FBQ3p4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsRUFBRSx3Q0FBd0MsY0FBYztBQUMvRjtBQUNBO0FBQ0E7QUFDQSw0SEFBNEgsZUFBZTtBQUMzSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFdBQVc7QUFDM0I7QUFDQTtBQUNBLHlCQUF5Qix5QkFBeUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsNkNBQTZDO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBLHVCQUF1QixtQ0FBbUM7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsbUJBQW1CLG1CQUFtQjtBQUN6QztBQUNBO0FBQ0E7QUFDQSxPQUFPLHNCQUFzQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyx3QkFBd0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRGQUE0RixFQUFFLHVCQUF1QixFQUFFO0FBQ3ZIO0FBQ0E7QUFDQTtBQUNBLDRIQUE0SCxFQUFFO0FBQzlIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHFCQUFxQjtBQUNwQyxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxxQkFBcUI7QUFDcEMsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRkFBMEYsV0FBVyxxQkFBcUIsS0FBSztBQUMvSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELEdBQUcsZ0JBQWdCLEdBQUcsZUFBZSxHQUFHLHVCQUF1QixHQUFHLHlCQUF5QixHQUFHLHNCQUFzQixHQUFHLGdyQkFBZ3JCLEdBQUc7QUFDMTFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsZ0JBQWdCO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZUFBZTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGVBQWU7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLG1DQUFtQyxVQUFVO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUpBQXVKLHdDQUF3QyxFQUFFLHdDQUF3QztBQUN6TztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0hBQWtILGtCQUFrQixtQ0FBbUMsaUJBQWlCO0FBQ3hMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFVBQVUsRUFBRSxLQUFLO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsdUJBQXVCLElBQUksSUFBSSxpQkFBaUIsZ0NBQWdDLE1BQU0sZ0NBQWdDO0FBQ2hKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStELFNBQVM7QUFDeEU7QUFDQTtBQUNBLG1DQUFtQztBQUNuQyxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsSUFBSTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixRQUFRO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLFFBQVEsZ05BQXVCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDRRQUEyQztBQUM1RDtBQUNBLG1DQUFtQyxRQUFRO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIscUJBQXFCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLGNBQWMsV0FBVztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxvSUFBb0k7QUFDcEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxFQUFFO0FBQ3REO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxTQUFTO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxTQUFTLFdBQVc7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVkscUJBQXFCO0FBQ2pDO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGNBQWM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxlQUFlO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGdDQUFnQztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNB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QWdDLEdBQUcsd0JBQXdCLEdBQUcsMkJBQTJCLEdBQUcscUJBQXFCLEdBQUcsdUNBQXVDLEdBQUcsaUJBQWlCLEdBQUcsbUJBQW1CLEdBQUcsaUJBQWlCLEdBQUc7QUFDdGpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsRUFBRTtBQUNwRDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLDhHQUE4RyxHQUFHO0FBQ2pIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxrQkFBa0IsR0FBRyxrQkFBa0IsR0FB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QSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxXQUFXLG9CQUFvQjtBQUMvQjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxzQkFBc0I7QUFDMUU7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELHNCQUFzQjtBQUMzRTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxFQUFFO0FBQ3REO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQSxvREFBb0QsR0FBRyxrQ0FBa0MsR0FBRyxFQUFFLEdBQUcsMkNBQTJDLElBQUk7QUFDaEo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsNEhBQTRILHdDQUF3QztBQUNwSztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsR0FBRztBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsV0FBVztBQUNyQyxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLFdBQVc7QUFDckMsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsc0JBQXNCO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLHNCQUFzQixvQ0FBb0MsNkJBQTZCLHVDQUF1Qyw0QkFBNEIsaUNBQWlDLHdCQUF3Qix1RUFBdUUsd0JBQXdCLHFCQUFxQix5QkFBeUIscUJBQXFCLHVCQUF1QjtBQUNwYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLDZCQUE2QjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHFCQUFxQixxQkFBcUIsc0JBQXNCLHFCQUFxQiw2QkFBNkI7QUFDbEo7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLDZCQUE2QjtBQUN0QztBQUNBO0FBQ0EsK0RBQStELHNCQUFzQjtBQUNyRjtBQUNBLFNBQVMsNkJBQTZCO0FBQ3RDLDRIQUE0SCxzQkFBc0I7QUFDbEo7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLDZCQUE2QixxQkFBcUIsc0JBQXNCO0FBQ3JIO0FBQ0E7QUFDQSxvQkFBb0IscUJBQXFCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHlCQUF5QixxQkFBcUIsa0JBQWtCO0FBQzNGLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsRUFBRTtBQUNqQjtBQUNBLEtBQUssdUpBQXVKLHVCQUF1QixpQkFBaUIsWUFBWSw2SEFBNkgsZUFBZTtBQUM1VjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0Esd0hBQXdILDJDQUEyQyx5SEFBeUgseUNBQXlDLGtGQUFrRix5QkFBeUIsaUVBQWlFLDJDQUEyQyxvRUFBb0UsMEJBQTBCLGdFQUFnRSx5Q0FBeUM7QUFDbnVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLCtEQUErRCxtQ0FBbUM7QUFDbEc7QUFDQTtBQUNBLEtBQUssaUNBQWlDLEVBQUU7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVCxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxxQkFBcUIsSUFBSSxvQkFBb0I7QUFDbkYsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLEdBQUc7QUFDZjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSw0QkFBNEIsWUFBWTtBQUN4QztBQUNBO0FBQ0EsNEJBQTRCLFlBQVk7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCw0Q0FBNEMsdUJBQXVCO0FBQ25FLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPLHdDQUF3QyxhQUFhO0FBQzVEO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGdCQUFnQjtBQUNuQyxrQkFBa0IsZ0JBQWdCO0FBQ2xDLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxzR0FBc0csU0FBUyxnQkFBZ0IsS0FBSztBQUNwSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdQQUFnUCxnQkFBZ0Isb0NBQW9DLGdCQUFnQjtBQUNwVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0Esb0NBQW9DLFlBQVkscUNBQXFDLFlBQVksc0NBQXNDLFlBQVk7QUFDbko7QUFDQTtBQUNBLG9DQUFvQyxZQUFZLHFDQUFxQyxZQUFZLHNDQUFzQyxZQUFZO0FBQ25KO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixXQUFXO0FBQ3JDLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxpQkFBaUI7QUFDM0Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGlDQUFpQyxvQkFBb0I7QUFDckQsS0FBSztBQUNMO0FBQ0E7QUFDQSxnQ0FBZ0MsRUFBRTtBQUNsQyxrQ0FBa0MsRUFBRTtBQUNwQyxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsRUFBRTtBQUNwRDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsUUFBUTtBQUN6RCxtREFBbUQsUUFBUTtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0Esa0VBQWtFLEdBQUc7QUFDckUsNkRBQTZELE9BQU87QUFDcEUsOERBQThELE9BQU87QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLElBQUksVUFBVSxJQUFJLFVBQVUsRUFBRTtBQUNyRDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLG9EQUFvRCxHQUFHLHNRQUFzUSxHQUFHLG1EQUFtRCxHQUFHLHFCQUFxQixHQUFHLGdCQUFnQixHQUFHLGtCQUFrQixHQUFHLGtCQUFrQixHQUFHO0FBQzVjO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQix5QkFBeUI7QUFDekI7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLGdHQUFnRyxzQkFBc0I7QUFDM0g7QUFDQSxLQUFLLG1IQUFtSCxnQkFBZ0I7QUFDeEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxXQUFXO0FBQ3pCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RSx3Q0FBd0M7QUFDL0c7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSwrQkFBK0IsR0FBRztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLEdBQUc7QUFDYjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsbUJBQW1CO0FBQ25DO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxtREFBbUQ7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHVCQUF1QiwwREFBMEQ7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0Esc0NBQXNDLDJCQUEyQjtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELEdBQUc7QUFDdkQsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsR0FBRztBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtSUFBbUksRUFBRSxFQUFFLEVBQUU7QUFDekk7QUFDQTtBQUNBLGlKQUFpSixFQUFFO0FBQ25KO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvSUFBb0ksRUFBRTtBQUN0SSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxjQUFjLFdBQVc7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELEVBQUU7QUFDcEQ7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixZQUFZO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsWUFBWSxJQUFJLFlBQVk7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiw0QkFBNEI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiw0QkFBNEI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsNEJBQTRCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsNEJBQTRCO0FBQzdDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx1QkFBdUI7QUFDbkM7QUFDQSxxQ0FBcUMsbUJBQW1CLGtDQUFrQyxVQUFVO0FBQ3BHLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxFQUFFLEtBQUssVUFBVSx1Q0FBdUMsd0JBQXdCO0FBQ3ZIO0FBQ0E7QUFDQTtBQUNBLDRIQUE0SCxlQUFlO0FBQzNJO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixHQUFHLGdCQUFnQixHQUFHLGNBQWMsR0FBRztBQUNqRTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFHQUFxRyxVQUFVO0FBQy9HO0FBQ0E7QUFDQTtBQUNBLFlBQVksNkJBQTZCLHVOQUF1TixhQUFhO0FBQzdRO0FBQ0E7QUFDQSxrQ0FBa0MsR0FBRyxFQUFFLEVBQUUsS0FBSyxVQUFVO0FBQ3hEO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLDBFQUEwRSxHQUFHLEVBQUUsRUFBRTtBQUNqRjtBQUNBO0FBQ0EsS0FBSyx3REFBd0QsVUFBVTtBQUN2RTtBQUNBO0FBQ0Esa0lBQWtJLFVBQVU7QUFDNUk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsR0FBRyxjQUFjLEdBQUcsZ0JBQWdCLEdBQUc7QUFDbkU7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxZQUFZLDRCQUE0QjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxhQUFhLDZCQUE2QixvQ0FBb0M7QUFDMUY7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsR0FBRyxjQUFjLEdBQUc7QUFDakQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzSEFBc0gsaUNBQWlDLFVBQVU7QUFDaks7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyx1Q0FBdUM7QUFDckQ7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssaUNBQWlDLDBCQUEwQjtBQUNoRTtBQUNBO0FBQ0Esa0VBQWtFLGlDQUFpQyxVQUFVO0FBQzdHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLEdBQUc7QUFDbEM7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsRUFBRTtBQUNwRDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxHQUFHLFlBQVksR0FBRztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMscUJBQXFCLEdBQUcsb0JBQW9CLEdBQUcsdUJBQXVCLEdBQUc7QUFDMUU7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxtQkFBbUIsRUFBRSxXQUFXO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxFQUFFO0FBQ3BEO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsNEJBQTRCO0FBQ2hEO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELEVBQUU7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsRUFBRTtBQUNwRDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxzREFBc0QsR0FBRztBQUN6RDtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUMsY0FBYyxHQUFHO0FBQ2xCO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELEVBQUU7QUFDcEQ7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsR0FBRztBQUMzQztBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTJFO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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O0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQyxpQkFBaUI7QUFDbEIsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFlBQVk7QUFDckM7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBd0NFO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3R3LWVsZW1lbnRzL2Rpc3QvanMvdHctZWxlbWVudHMuZXMubWluLmpzP2FlNWIiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4qIFRhaWx3aW5kIEVsZW1lbnRzIDEuMC4wXG4qIFxuKiBUYWlsd2luZCBFbGVtZW50cyBpcyBhbiBvcGVuLXNvdXJjZSBVSSBraXQgb2YgYWR2YW5jZWQgY29tcG9uZW50cyBmb3IgVGFpbHdpbmRDU1MuXG4qIENvcHlyaWdodCDCqSAyMDIzIE1EQm9vdHN0cmFwLmNvbVxuKiBcbiogVW5sZXNzIGEgY3VzdG9tLCBpbmRpdmlkdWFsbHkgYXNzaWduZWQgbGljZW5zZSBoYXMgYmVlbiBncmFudGVkLCB0aGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeSBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBBZmZlcm8gR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnkgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbiogSW4gYWRkaXRpb24sIGEgY3VzdG9tIGxpY2Vuc2UgbWF5IGJlIGF2YWlsYWJsZSB1cG9uIHJlcXVlc3QsIHN1YmplY3QgdG8gdGhlIHRlcm1zIGFuZCBjb25kaXRpb25zIG9mIHRoYXQgbGljZW5zZS4gUGxlYXNlIGNvbnRhY3QgdGFpbHdpbmRAbWRib290c3RyYXAuY29tIGZvciBtb3JlIGluZm9ybWF0aW9uIG9uIG9idGFpbmluZyBhIGN1c3RvbSBsaWNlbnNlLlxuKiBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCwgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiBTZWUgdGhlIEdOVSBBZmZlcm8gR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuKiBcbiovXG52YXIgSGggPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgVmggPSAocywgdCwgZSkgPT4gdCBpbiBzID8gSGgocywgdCwgeyBlbnVtZXJhYmxlOiAhMCwgY29uZmlndXJhYmxlOiAhMCwgd3JpdGFibGU6ICEwLCB2YWx1ZTogZSB9KSA6IHNbdF0gPSBlO1xudmFyIHl0ID0gKHMsIHQsIGUpID0+IChWaChzLCB0eXBlb2YgdCAhPSBcInN5bWJvbFwiID8gdCArIFwiXCIgOiB0LCBlKSwgZSk7XG5jb25zdCBUbiA9ICgoKSA9PiB7XG4gIGNvbnN0IHMgPSB7fTtcbiAgbGV0IHQgPSAxO1xuICByZXR1cm4ge1xuICAgIHNldChlLCBpLCBuKSB7XG4gICAgICB0eXBlb2YgZVtpXSA+IFwidVwiICYmIChlW2ldID0ge1xuICAgICAgICBrZXk6IGksXG4gICAgICAgIGlkOiB0XG4gICAgICB9LCB0KyspLCBzW2VbaV0uaWRdID0gbjtcbiAgICB9LFxuICAgIGdldChlLCBpKSB7XG4gICAgICBpZiAoIWUgfHwgdHlwZW9mIGVbaV0gPiBcInVcIilcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICBjb25zdCBuID0gZVtpXTtcbiAgICAgIHJldHVybiBuLmtleSA9PT0gaSA/IHNbbi5pZF0gOiBudWxsO1xuICAgIH0sXG4gICAgZGVsZXRlKGUsIGkpIHtcbiAgICAgIGlmICh0eXBlb2YgZVtpXSA+IFwidVwiKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCBuID0gZVtpXTtcbiAgICAgIG4ua2V5ID09PSBpICYmIChkZWxldGUgc1tuLmlkXSwgZGVsZXRlIGVbaV0pO1xuICAgIH1cbiAgfTtcbn0pKCksIHkgPSB7XG4gIHNldERhdGEocywgdCwgZSkge1xuICAgIFRuLnNldChzLCB0LCBlKTtcbiAgfSxcbiAgZ2V0RGF0YShzLCB0KSB7XG4gICAgcmV0dXJuIFRuLmdldChzLCB0KTtcbiAgfSxcbiAgcmVtb3ZlRGF0YShzLCB0KSB7XG4gICAgVG4uZGVsZXRlKHMsIHQpO1xuICB9XG59LCBXaCA9IDFlNiwgRmggPSAxZTMsIHhvID0gXCJ0cmFuc2l0aW9uZW5kXCIsIFloID0gKHMpID0+IHMgPT0gbnVsbCA/IGAke3N9YCA6IHt9LnRvU3RyaW5nLmNhbGwocykubWF0Y2goL1xccyhbYS16XSspL2kpWzFdLnRvTG93ZXJDYXNlKCksIHJ0ID0gKHMpID0+IHtcbiAgZG9cbiAgICBzICs9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIFdoKTtcbiAgd2hpbGUgKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHMpKTtcbiAgcmV0dXJuIHM7XG59LCBVbCA9IChzKSA9PiB7XG4gIGxldCB0ID0gcy5nZXRBdHRyaWJ1dGUoXCJkYXRhLXRlLXRhcmdldFwiKTtcbiAgaWYgKCF0IHx8IHQgPT09IFwiI1wiKSB7XG4gICAgbGV0IGUgPSBzLmdldEF0dHJpYnV0ZShcImhyZWZcIik7XG4gICAgaWYgKCFlIHx8ICFlLmluY2x1ZGVzKFwiI1wiKSAmJiAhZS5zdGFydHNXaXRoKFwiLlwiKSlcbiAgICAgIHJldHVybiBudWxsO1xuICAgIGUuaW5jbHVkZXMoXCIjXCIpICYmICFlLnN0YXJ0c1dpdGgoXCIjXCIpICYmIChlID0gYCMke2Uuc3BsaXQoXCIjXCIpWzFdfWApLCB0ID0gZSAmJiBlICE9PSBcIiNcIiA/IGUudHJpbSgpIDogbnVsbDtcbiAgfVxuICByZXR1cm4gdDtcbn0sIHFvID0gKHMpID0+IHtcbiAgY29uc3QgdCA9IFVsKHMpO1xuICByZXR1cm4gdCAmJiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHQpID8gdCA6IG51bGw7XG59LCBKdCA9IChzKSA9PiB7XG4gIGNvbnN0IHQgPSBVbChzKTtcbiAgcmV0dXJuIHQgPyBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHQpIDogbnVsbDtcbn0sIGpoID0gKHMpID0+IHtcbiAgaWYgKCFzKVxuICAgIHJldHVybiAwO1xuICBsZXQgeyB0cmFuc2l0aW9uRHVyYXRpb246IHQsIHRyYW5zaXRpb25EZWxheTogZSB9ID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUocyk7XG4gIGNvbnN0IGkgPSBOdW1iZXIucGFyc2VGbG9hdCh0KSwgbiA9IE51bWJlci5wYXJzZUZsb2F0KGUpO1xuICByZXR1cm4gIWkgJiYgIW4gPyAwIDogKHQgPSB0LnNwbGl0KFwiLFwiKVswXSwgZSA9IGUuc3BsaXQoXCIsXCIpWzBdLCAoTnVtYmVyLnBhcnNlRmxvYXQodCkgKyBOdW1iZXIucGFyc2VGbG9hdChlKSkgKiBGaCk7XG59LCBYbCA9IChzKSA9PiB7XG4gIHMuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoeG8pKTtcbn0sIGplID0gKHMpID0+ICFzIHx8IHR5cGVvZiBzICE9IFwib2JqZWN0XCIgPyAhMSA6ICh0eXBlb2Ygcy5qcXVlcnkgPCBcInVcIiAmJiAocyA9IHNbMF0pLCB0eXBlb2Ygcy5ub2RlVHlwZSA8IFwidVwiKSwgdGUgPSAocykgPT4gamUocykgPyBzLmpxdWVyeSA/IHNbMF0gOiBzIDogdHlwZW9mIHMgPT0gXCJzdHJpbmdcIiAmJiBzLmxlbmd0aCA+IDAgPyBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHMpIDogbnVsbCwgRCA9IChzLCB0LCBlKSA9PiB7XG4gIE9iamVjdC5rZXlzKGUpLmZvckVhY2goKGkpID0+IHtcbiAgICBjb25zdCBuID0gZVtpXSwgbyA9IHRbaV0sIHIgPSBvICYmIGplKG8pID8gXCJlbGVtZW50XCIgOiBZaChvKTtcbiAgICBpZiAoIW5ldyBSZWdFeHAobikudGVzdChyKSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYCR7cy50b1VwcGVyQ2FzZSgpfTogT3B0aW9uIFwiJHtpfVwiIHByb3ZpZGVkIHR5cGUgXCIke3J9XCIgYnV0IGV4cGVjdGVkIHR5cGUgXCIke259XCIuYFxuICAgICAgKTtcbiAgfSk7XG59LCBOdCA9IChzKSA9PiB7XG4gIGlmICghcyB8fCBzLmdldENsaWVudFJlY3RzKCkubGVuZ3RoID09PSAwKVxuICAgIHJldHVybiAhMTtcbiAgaWYgKHMuc3R5bGUgJiYgcy5wYXJlbnROb2RlICYmIHMucGFyZW50Tm9kZS5zdHlsZSkge1xuICAgIGNvbnN0IHQgPSBnZXRDb21wdXRlZFN0eWxlKHMpLCBlID0gZ2V0Q29tcHV0ZWRTdHlsZShzLnBhcmVudE5vZGUpO1xuICAgIHJldHVybiBnZXRDb21wdXRlZFN0eWxlKHMpLmdldFByb3BlcnR5VmFsdWUoXCJ2aXNpYmlsaXR5XCIpID09PSBcInZpc2libGVcIiB8fCB0LmRpc3BsYXkgIT09IFwibm9uZVwiICYmIGUuZGlzcGxheSAhPT0gXCJub25lXCIgJiYgdC52aXNpYmlsaXR5ICE9PSBcImhpZGRlblwiO1xuICB9XG4gIHJldHVybiAhMTtcbn0sIGdlID0gKHMpID0+ICFzIHx8IHMubm9kZVR5cGUgIT09IE5vZGUuRUxFTUVOVF9OT0RFIHx8IHMuY2xhc3NMaXN0LmNvbnRhaW5zKFwiZGlzYWJsZWRcIikgPyAhMCA6IHR5cGVvZiBzLmRpc2FibGVkIDwgXCJ1XCIgPyBzLmRpc2FibGVkIDogcy5oYXNBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiKSAmJiBzLmdldEF0dHJpYnV0ZShcImRpc2FibGVkXCIpICE9PSBcImZhbHNlXCIsIEdsID0gKHMpID0+IHtcbiAgaWYgKCFkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYXR0YWNoU2hhZG93KVxuICAgIHJldHVybiBudWxsO1xuICBpZiAodHlwZW9mIHMuZ2V0Um9vdE5vZGUgPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgY29uc3QgdCA9IHMuZ2V0Um9vdE5vZGUoKTtcbiAgICByZXR1cm4gdCBpbnN0YW5jZW9mIFNoYWRvd1Jvb3QgPyB0IDogbnVsbDtcbiAgfVxuICByZXR1cm4gcyBpbnN0YW5jZW9mIFNoYWRvd1Jvb3QgPyBzIDogcy5wYXJlbnROb2RlID8gR2wocy5wYXJlbnROb2RlKSA6IG51bGw7XG59LCB0biA9ICgpID0+IGZ1bmN0aW9uKCkge1xufSwgSmUgPSAocykgPT4ge1xuICBzLm9mZnNldEhlaWdodDtcbn0sIHFsID0gKCkgPT4ge1xuICBjb25zdCB7IGpRdWVyeTogcyB9ID0gd2luZG93O1xuICByZXR1cm4gcyAmJiAhZG9jdW1lbnQuYm9keS5oYXNBdHRyaWJ1dGUoXCJkYXRhLXRlLW5vLWpxdWVyeVwiKSA/IHMgOiBudWxsO1xufSwgRW4gPSBbXSwgWmwgPSAocykgPT4ge1xuICBkb2N1bWVudC5yZWFkeVN0YXRlID09PSBcImxvYWRpbmdcIiA/IChFbi5sZW5ndGggfHwgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIiwgKCkgPT4ge1xuICAgIEVuLmZvckVhY2goKHQpID0+IHQoKSk7XG4gIH0pLCBFbi5wdXNoKHMpKSA6IHMoKTtcbn0sIEYgPSAoKSA9PiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuZGlyID09PSBcInJ0bFwiLCBLaCA9IChzKSA9PiBBcnJheS5mcm9tKHMpLCAkID0gKHMpID0+IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQocyksIG1lID0gKHMpID0+IHtcbiAgdHlwZW9mIHMgPT0gXCJmdW5jdGlvblwiICYmIHMoKTtcbn0sIFFsID0gKHMsIHQsIGUgPSAhMCkgPT4ge1xuICBpZiAoIWUpIHtcbiAgICBtZShzKTtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgaSA9IDUsIG4gPSBqaCh0KSArIGk7XG4gIGxldCBvID0gITE7XG4gIGNvbnN0IHIgPSAoeyB0YXJnZXQ6IGEgfSkgPT4ge1xuICAgIGEgPT09IHQgJiYgKG8gPSAhMCwgdC5yZW1vdmVFdmVudExpc3RlbmVyKHhvLCByKSwgbWUocykpO1xuICB9O1xuICB0LmFkZEV2ZW50TGlzdGVuZXIoeG8sIHIpLCBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICBvIHx8IFhsKHQpO1xuICB9LCBuKTtcbn0sIEpsID0gKHMsIHQsIGUsIGkpID0+IHtcbiAgbGV0IG4gPSBzLmluZGV4T2YodCk7XG4gIGlmIChuID09PSAtMSlcbiAgICByZXR1cm4gc1shZSAmJiBpID8gcy5sZW5ndGggLSAxIDogMF07XG4gIGNvbnN0IG8gPSBzLmxlbmd0aDtcbiAgcmV0dXJuIG4gKz0gZSA/IDEgOiAtMSwgaSAmJiAobiA9IChuICsgbykgJSBvKSwgc1tNYXRoLm1heCgwLCBNYXRoLm1pbihuLCBvIC0gMSkpXTtcbn0sIHpoID0gL1teLl0qKD89XFwuLiopXFwufC4qLywgVWggPSAvXFwuLiovLCBYaCA9IC86OlxcZCskLywgQ24gPSB7fTtcbmxldCB4ciA9IDE7XG5jb25zdCBHaCA9IHtcbiAgbW91c2VlbnRlcjogXCJtb3VzZW92ZXJcIixcbiAgbW91c2VsZWF2ZTogXCJtb3VzZW91dFwiXG59LCBxaCA9IC9eKG1vdXNlZW50ZXJ8bW91c2VsZWF2ZSkvaSwgdGMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXG4gIFwiY2xpY2tcIixcbiAgXCJkYmxjbGlja1wiLFxuICBcIm1vdXNldXBcIixcbiAgXCJtb3VzZWRvd25cIixcbiAgXCJjb250ZXh0bWVudVwiLFxuICBcIm1vdXNld2hlZWxcIixcbiAgXCJET01Nb3VzZVNjcm9sbFwiLFxuICBcIm1vdXNlb3ZlclwiLFxuICBcIm1vdXNlb3V0XCIsXG4gIFwibW91c2Vtb3ZlXCIsXG4gIFwic2VsZWN0c3RhcnRcIixcbiAgXCJzZWxlY3RlbmRcIixcbiAgXCJrZXlkb3duXCIsXG4gIFwia2V5cHJlc3NcIixcbiAgXCJrZXl1cFwiLFxuICBcIm9yaWVudGF0aW9uY2hhbmdlXCIsXG4gIFwidG91Y2hzdGFydFwiLFxuICBcInRvdWNobW92ZVwiLFxuICBcInRvdWNoZW5kXCIsXG4gIFwidG91Y2hjYW5jZWxcIixcbiAgXCJwb2ludGVyZG93blwiLFxuICBcInBvaW50ZXJtb3ZlXCIsXG4gIFwicG9pbnRlcnVwXCIsXG4gIFwicG9pbnRlcmxlYXZlXCIsXG4gIFwicG9pbnRlcmNhbmNlbFwiLFxuICBcImdlc3R1cmVzdGFydFwiLFxuICBcImdlc3R1cmVjaGFuZ2VcIixcbiAgXCJnZXN0dXJlZW5kXCIsXG4gIFwiZm9jdXNcIixcbiAgXCJibHVyXCIsXG4gIFwiY2hhbmdlXCIsXG4gIFwicmVzZXRcIixcbiAgXCJzZWxlY3RcIixcbiAgXCJzdWJtaXRcIixcbiAgXCJmb2N1c2luXCIsXG4gIFwiZm9jdXNvdXRcIixcbiAgXCJsb2FkXCIsXG4gIFwidW5sb2FkXCIsXG4gIFwiYmVmb3JldW5sb2FkXCIsXG4gIFwicmVzaXplXCIsXG4gIFwibW92ZVwiLFxuICBcIkRPTUNvbnRlbnRMb2FkZWRcIixcbiAgXCJyZWFkeXN0YXRlY2hhbmdlXCIsXG4gIFwiZXJyb3JcIixcbiAgXCJhYm9ydFwiLFxuICBcInNjcm9sbFwiXG5dKTtcbmZ1bmN0aW9uIGVjKHMsIHQpIHtcbiAgcmV0dXJuIHQgJiYgYCR7dH06OiR7eHIrK31gIHx8IHMudWlkRXZlbnQgfHwgeHIrKztcbn1cbmZ1bmN0aW9uIGljKHMpIHtcbiAgY29uc3QgdCA9IGVjKHMpO1xuICByZXR1cm4gcy51aWRFdmVudCA9IHQsIENuW3RdID0gQ25bdF0gfHwge30sIENuW3RdO1xufVxuZnVuY3Rpb24gWmgocywgdCkge1xuICByZXR1cm4gZnVuY3Rpb24gZShpKSB7XG4gICAgcmV0dXJuIGkuZGVsZWdhdGVUYXJnZXQgPSBzLCBlLm9uZU9mZiAmJiBjLm9mZihzLCBpLnR5cGUsIHQpLCB0LmFwcGx5KHMsIFtpXSk7XG4gIH07XG59XG5mdW5jdGlvbiBRaChzLCB0LCBlKSB7XG4gIHJldHVybiBmdW5jdGlvbiBpKG4pIHtcbiAgICBjb25zdCBvID0gcy5xdWVyeVNlbGVjdG9yQWxsKHQpO1xuICAgIGZvciAobGV0IHsgdGFyZ2V0OiByIH0gPSBuOyByICYmIHIgIT09IHRoaXM7IHIgPSByLnBhcmVudE5vZGUpXG4gICAgICBmb3IgKGxldCBhID0gby5sZW5ndGg7IGEtLTsgXCJcIilcbiAgICAgICAgaWYgKG9bYV0gPT09IHIpXG4gICAgICAgICAgcmV0dXJuIG4uZGVsZWdhdGVUYXJnZXQgPSByLCBpLm9uZU9mZiAmJiBjLm9mZihzLCBuLnR5cGUsIGUpLCBlLmFwcGx5KHIsIFtuXSk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG59XG5mdW5jdGlvbiBzYyhzLCB0LCBlID0gbnVsbCkge1xuICBjb25zdCBpID0gT2JqZWN0LmtleXMocyk7XG4gIGZvciAobGV0IG4gPSAwLCBvID0gaS5sZW5ndGg7IG4gPCBvOyBuKyspIHtcbiAgICBjb25zdCByID0gc1tpW25dXTtcbiAgICBpZiAoci5vcmlnaW5hbEhhbmRsZXIgPT09IHQgJiYgci5kZWxlZ2F0aW9uU2VsZWN0b3IgPT09IGUpXG4gICAgICByZXR1cm4gcjtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIG5jKHMsIHQsIGUpIHtcbiAgY29uc3QgaSA9IHR5cGVvZiB0ID09IFwic3RyaW5nXCIsIG4gPSBpID8gZSA6IHQ7XG4gIGxldCBvID0gb2Mocyk7XG4gIHJldHVybiB0Yy5oYXMobykgfHwgKG8gPSBzKSwgW2ksIG4sIG9dO1xufVxuZnVuY3Rpb24gT3IocywgdCwgZSwgaSwgbikge1xuICBpZiAodHlwZW9mIHQgIT0gXCJzdHJpbmdcIiB8fCAhcylcbiAgICByZXR1cm47XG4gIGlmIChlIHx8IChlID0gaSwgaSA9IG51bGwpLCBxaC50ZXN0KHQpKSB7XG4gICAgY29uc3QgZyA9IChtKSA9PiBmdW5jdGlvbihiKSB7XG4gICAgICBpZiAoIWIucmVsYXRlZFRhcmdldCB8fCBiLnJlbGF0ZWRUYXJnZXQgIT09IGIuZGVsZWdhdGVUYXJnZXQgJiYgIWIuZGVsZWdhdGVUYXJnZXQuY29udGFpbnMoYi5yZWxhdGVkVGFyZ2V0KSlcbiAgICAgICAgcmV0dXJuIG0uY2FsbCh0aGlzLCBiKTtcbiAgICB9O1xuICAgIGkgPyBpID0gZyhpKSA6IGUgPSBnKGUpO1xuICB9XG4gIGNvbnN0IFtvLCByLCBhXSA9IG5jKFxuICAgIHQsXG4gICAgZSxcbiAgICBpXG4gICksIGwgPSBpYyhzKSwgcCA9IGxbYV0gfHwgKGxbYV0gPSB7fSksIHUgPSBzYyhcbiAgICBwLFxuICAgIHIsXG4gICAgbyA/IGUgOiBudWxsXG4gICk7XG4gIGlmICh1KSB7XG4gICAgdS5vbmVPZmYgPSB1Lm9uZU9mZiAmJiBuO1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBfID0gZWMoXG4gICAgcixcbiAgICB0LnJlcGxhY2UoemgsIFwiXCIpXG4gICksIGYgPSBvID8gUWgocywgZSwgaSkgOiBaaChzLCBlKTtcbiAgZi5kZWxlZ2F0aW9uU2VsZWN0b3IgPSBvID8gZSA6IG51bGwsIGYub3JpZ2luYWxIYW5kbGVyID0gciwgZi5vbmVPZmYgPSBuLCBmLnVpZEV2ZW50ID0gXywgcFtfXSA9IGYsIHMuYWRkRXZlbnRMaXN0ZW5lcihhLCBmLCBvKTtcbn1cbmZ1bmN0aW9uIE9vKHMsIHQsIGUsIGksIG4pIHtcbiAgY29uc3QgbyA9IHNjKHRbZV0sIGksIG4pO1xuICBvICYmIChzLnJlbW92ZUV2ZW50TGlzdGVuZXIoZSwgbywgISFuKSwgZGVsZXRlIHRbZV1bby51aWRFdmVudF0pO1xufVxuZnVuY3Rpb24gSmgocywgdCwgZSwgaSkge1xuICBjb25zdCBuID0gdFtlXSB8fCB7fTtcbiAgT2JqZWN0LmtleXMobikuZm9yRWFjaCgobykgPT4ge1xuICAgIGlmIChvLmluY2x1ZGVzKGkpKSB7XG4gICAgICBjb25zdCByID0gbltvXTtcbiAgICAgIE9vKFxuICAgICAgICBzLFxuICAgICAgICB0LFxuICAgICAgICBlLFxuICAgICAgICByLm9yaWdpbmFsSGFuZGxlcixcbiAgICAgICAgci5kZWxlZ2F0aW9uU2VsZWN0b3JcbiAgICAgICk7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIG9jKHMpIHtcbiAgcmV0dXJuIHMgPSBzLnJlcGxhY2UoVWgsIFwiXCIpLCBHaFtzXSB8fCBzO1xufVxuY29uc3QgYyA9IHtcbiAgb24ocywgdCwgZSwgaSkge1xuICAgIE9yKHMsIHQsIGUsIGksICExKTtcbiAgfSxcbiAgb25lKHMsIHQsIGUsIGkpIHtcbiAgICBPcihzLCB0LCBlLCBpLCAhMCk7XG4gIH0sXG4gIG9mZihzLCB0LCBlLCBpKSB7XG4gICAgaWYgKHR5cGVvZiB0ICE9IFwic3RyaW5nXCIgfHwgIXMpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgW24sIG8sIHJdID0gbmMoXG4gICAgICB0LFxuICAgICAgZSxcbiAgICAgIGlcbiAgICApLCBhID0gciAhPT0gdCwgbCA9IGljKHMpLCBwID0gdC5zdGFydHNXaXRoKFwiLlwiKTtcbiAgICBpZiAodHlwZW9mIG8gPCBcInVcIikge1xuICAgICAgaWYgKCFsIHx8ICFsW3JdKVxuICAgICAgICByZXR1cm47XG4gICAgICBPbyhcbiAgICAgICAgcyxcbiAgICAgICAgbCxcbiAgICAgICAgcixcbiAgICAgICAgbyxcbiAgICAgICAgbiA/IGUgOiBudWxsXG4gICAgICApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBwICYmIE9iamVjdC5rZXlzKGwpLmZvckVhY2goKF8pID0+IHtcbiAgICAgIEpoKFxuICAgICAgICBzLFxuICAgICAgICBsLFxuICAgICAgICBfLFxuICAgICAgICB0LnNsaWNlKDEpXG4gICAgICApO1xuICAgIH0pO1xuICAgIGNvbnN0IHUgPSBsW3JdIHx8IHt9O1xuICAgIE9iamVjdC5rZXlzKHUpLmZvckVhY2goKF8pID0+IHtcbiAgICAgIGNvbnN0IGYgPSBfLnJlcGxhY2UoWGgsIFwiXCIpO1xuICAgICAgaWYgKCFhIHx8IHQuaW5jbHVkZXMoZikpIHtcbiAgICAgICAgY29uc3QgZyA9IHVbX107XG4gICAgICAgIE9vKFxuICAgICAgICAgIHMsXG4gICAgICAgICAgbCxcbiAgICAgICAgICByLFxuICAgICAgICAgIGcub3JpZ2luYWxIYW5kbGVyLFxuICAgICAgICAgIGcuZGVsZWdhdGlvblNlbGVjdG9yXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG4gIHRyaWdnZXIocywgdCwgZSkge1xuICAgIGlmICh0eXBlb2YgdCAhPSBcInN0cmluZ1wiIHx8ICFzKVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgY29uc3QgaSA9IHFsKCksIG4gPSBvYyh0KSwgbyA9IHQgIT09IG4sIHIgPSB0Yy5oYXMobik7XG4gICAgbGV0IGEsIGwgPSAhMCwgcCA9ICEwLCB1ID0gITEsIF8gPSBudWxsO1xuICAgIHJldHVybiBvICYmIGkgJiYgKGEgPSBpLkV2ZW50KHQsIGUpLCBpKHMpLnRyaWdnZXIoYSksIGwgPSAhYS5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpLCBwID0gIWEuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQoKSwgdSA9IGEuaXNEZWZhdWx0UHJldmVudGVkKCkpLCByID8gKF8gPSBkb2N1bWVudC5jcmVhdGVFdmVudChcIkhUTUxFdmVudHNcIiksIF8uaW5pdEV2ZW50KG4sIGwsICEwKSkgOiBfID0gbmV3IEN1c3RvbUV2ZW50KHQsIHtcbiAgICAgIGJ1YmJsZXM6IGwsXG4gICAgICBjYW5jZWxhYmxlOiAhMFxuICAgIH0pLCB0eXBlb2YgZSA8IFwidVwiICYmIE9iamVjdC5rZXlzKGUpLmZvckVhY2goKGYpID0+IHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfLCBmLCB7XG4gICAgICAgIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gZVtmXTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSksIHUgJiYgXy5wcmV2ZW50RGVmYXVsdCgpLCBwICYmIHMuZGlzcGF0Y2hFdmVudChfKSwgXy5kZWZhdWx0UHJldmVudGVkICYmIHR5cGVvZiBhIDwgXCJ1XCIgJiYgYS5wcmV2ZW50RGVmYXVsdCgpLCBfO1xuICB9XG59LCByZSA9IHtcbiAgb24ocywgdCwgZSwgaSkge1xuICAgIGNvbnN0IG4gPSB0LnNwbGl0KFwiIFwiKTtcbiAgICBmb3IgKGxldCBvID0gMDsgbyA8IG4ubGVuZ3RoOyBvKyspXG4gICAgICBjLm9uKHMsIG5bb10sIGUsIGkpO1xuICB9LFxuICBvZmYocywgdCwgZSwgaSkge1xuICAgIGNvbnN0IG4gPSB0LnNwbGl0KFwiIFwiKTtcbiAgICBmb3IgKGxldCBvID0gMDsgbyA8IG4ubGVuZ3RoOyBvKyspXG4gICAgICBjLm9mZihzLCBuW29dLCBlLCBpKTtcbiAgfVxufSwgdGQgPSBcIjUuMS4zXCI7XG5jbGFzcyBndCB7XG4gIGNvbnN0cnVjdG9yKHQpIHtcbiAgICB0ID0gdGUodCksIHQgJiYgKHRoaXMuX2VsZW1lbnQgPSB0LCB5LnNldERhdGEodGhpcy5fZWxlbWVudCwgdGhpcy5jb25zdHJ1Y3Rvci5EQVRBX0tFWSwgdGhpcykpO1xuICB9XG4gIGRpc3Bvc2UoKSB7XG4gICAgeS5yZW1vdmVEYXRhKHRoaXMuX2VsZW1lbnQsIHRoaXMuY29uc3RydWN0b3IuREFUQV9LRVkpLCBjLm9mZih0aGlzLl9lbGVtZW50LCB0aGlzLmNvbnN0cnVjdG9yLkVWRU5UX0tFWSksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRoaXMpLmZvckVhY2goKHQpID0+IHtcbiAgICAgIHRoaXNbdF0gPSBudWxsO1xuICAgIH0pO1xuICB9XG4gIF9xdWV1ZUNhbGxiYWNrKHQsIGUsIGkgPSAhMCkge1xuICAgIFFsKHQsIGUsIGkpO1xuICB9XG4gIC8qKiBTdGF0aWMgKi9cbiAgc3RhdGljIGdldEluc3RhbmNlKHQpIHtcbiAgICByZXR1cm4geS5nZXREYXRhKHRlKHQpLCB0aGlzLkRBVEFfS0VZKTtcbiAgfVxuICBzdGF0aWMgZ2V0T3JDcmVhdGVJbnN0YW5jZSh0LCBlID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5nZXRJbnN0YW5jZSh0KSB8fCBuZXcgdGhpcyh0LCB0eXBlb2YgZSA9PSBcIm9iamVjdFwiID8gZSA6IG51bGwpO1xuICB9XG4gIHN0YXRpYyBnZXQgVkVSU0lPTigpIHtcbiAgICByZXR1cm4gdGQ7XG4gIH1cbiAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdZb3UgaGF2ZSB0byBpbXBsZW1lbnQgdGhlIHN0YXRpYyBtZXRob2QgXCJOQU1FXCIsIGZvciBlYWNoIGNvbXBvbmVudCEnXG4gICAgKTtcbiAgfVxuICBzdGF0aWMgZ2V0IERBVEFfS0VZKCkge1xuICAgIHJldHVybiBgdGUuJHt0aGlzLk5BTUV9YDtcbiAgfVxuICBzdGF0aWMgZ2V0IEVWRU5UX0tFWSgpIHtcbiAgICByZXR1cm4gYC4ke3RoaXMuREFUQV9LRVl9YDtcbiAgfVxufVxuY29uc3QgZWQgPSBcImJ1dHRvblwiLCBpZCA9IFwiYWN0aXZlXCI7XG5jbGFzcyByYyBleHRlbmRzIGd0IHtcbiAgLy8gR2V0dGVyc1xuICBzdGF0aWMgZ2V0IE5BTUUoKSB7XG4gICAgcmV0dXJuIGVkO1xuICB9XG4gIC8vIFB1YmxpY1xuICB0b2dnbGUoKSB7XG4gICAgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoXG4gICAgICBcImFyaWEtcHJlc3NlZFwiLFxuICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QudG9nZ2xlKGlkKVxuICAgICk7XG4gIH1cbiAgLy8gU3RhdGljXG4gIHN0YXRpYyBqUXVlcnlJbnRlcmZhY2UodCkge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICBjb25zdCBlID0gcmMuZ2V0T3JDcmVhdGVJbnN0YW5jZSh0aGlzKTtcbiAgICAgIHQgPT09IFwidG9nZ2xlXCIgJiYgZVt0XSgpO1xuICAgIH0pO1xuICB9XG59XG52YXIgUSA9IFwidG9wXCIsIGR0ID0gXCJib3R0b21cIiwgdXQgPSBcInJpZ2h0XCIsIEogPSBcImxlZnRcIiwgSGkgPSBcImF1dG9cIiwgdGkgPSBbUSwgZHQsIHV0LCBKXSwgVGUgPSBcInN0YXJ0XCIsIEtlID0gXCJlbmRcIiwgYWMgPSBcImNsaXBwaW5nUGFyZW50c1wiLCBabyA9IFwidmlld3BvcnRcIiwgJGUgPSBcInBvcHBlclwiLCBsYyA9IFwicmVmZXJlbmNlXCIsIFNvID0gLyogQF9fUFVSRV9fICovIHRpLnJlZHVjZShmdW5jdGlvbihzLCB0KSB7XG4gIHJldHVybiBzLmNvbmNhdChbdCArIFwiLVwiICsgVGUsIHQgKyBcIi1cIiArIEtlXSk7XG59LCBbXSksIFFvID0gLyogQF9fUFVSRV9fICovIFtdLmNvbmNhdCh0aSwgW0hpXSkucmVkdWNlKGZ1bmN0aW9uKHMsIHQpIHtcbiAgcmV0dXJuIHMuY29uY2F0KFt0LCB0ICsgXCItXCIgKyBUZSwgdCArIFwiLVwiICsgS2VdKTtcbn0sIFtdKSwgY2MgPSBcImJlZm9yZVJlYWRcIiwgaGMgPSBcInJlYWRcIiwgZGMgPSBcImFmdGVyUmVhZFwiLCB1YyA9IFwiYmVmb3JlTWFpblwiLCBwYyA9IFwibWFpblwiLCBfYyA9IFwiYWZ0ZXJNYWluXCIsIGZjID0gXCJiZWZvcmVXcml0ZVwiLCBtYyA9IFwid3JpdGVcIiwgZ2MgPSBcImFmdGVyV3JpdGVcIiwgZW4gPSBbY2MsIGhjLCBkYywgdWMsIHBjLCBfYywgZmMsIG1jLCBnY107XG5mdW5jdGlvbiBNdChzKSB7XG4gIHJldHVybiBzID8gKHMubm9kZU5hbWUgfHwgXCJcIikudG9Mb3dlckNhc2UoKSA6IG51bGw7XG59XG5mdW5jdGlvbiBwdChzKSB7XG4gIGlmIChzID09IG51bGwpXG4gICAgcmV0dXJuIHdpbmRvdztcbiAgaWYgKHMudG9TdHJpbmcoKSAhPT0gXCJbb2JqZWN0IFdpbmRvd11cIikge1xuICAgIHZhciB0ID0gcy5vd25lckRvY3VtZW50O1xuICAgIHJldHVybiB0ICYmIHQuZGVmYXVsdFZpZXcgfHwgd2luZG93O1xuICB9XG4gIHJldHVybiBzO1xufVxuZnVuY3Rpb24gRWUocykge1xuICB2YXIgdCA9IHB0KHMpLkVsZW1lbnQ7XG4gIHJldHVybiBzIGluc3RhbmNlb2YgdCB8fCBzIGluc3RhbmNlb2YgRWxlbWVudDtcbn1cbmZ1bmN0aW9uIGh0KHMpIHtcbiAgdmFyIHQgPSBwdChzKS5IVE1MRWxlbWVudDtcbiAgcmV0dXJuIHMgaW5zdGFuY2VvZiB0IHx8IHMgaW5zdGFuY2VvZiBIVE1MRWxlbWVudDtcbn1cbmZ1bmN0aW9uIEpvKHMpIHtcbiAgaWYgKHR5cGVvZiBTaGFkb3dSb290ID4gXCJ1XCIpXG4gICAgcmV0dXJuICExO1xuICB2YXIgdCA9IHB0KHMpLlNoYWRvd1Jvb3Q7XG4gIHJldHVybiBzIGluc3RhbmNlb2YgdCB8fCBzIGluc3RhbmNlb2YgU2hhZG93Um9vdDtcbn1cbmZ1bmN0aW9uIHNkKHMpIHtcbiAgdmFyIHQgPSBzLnN0YXRlO1xuICBPYmplY3Qua2V5cyh0LmVsZW1lbnRzKS5mb3JFYWNoKGZ1bmN0aW9uKGUpIHtcbiAgICB2YXIgaSA9IHQuc3R5bGVzW2VdIHx8IHt9LCBuID0gdC5hdHRyaWJ1dGVzW2VdIHx8IHt9LCBvID0gdC5lbGVtZW50c1tlXTtcbiAgICAhaHQobykgfHwgIU10KG8pIHx8IChPYmplY3QuYXNzaWduKG8uc3R5bGUsIGkpLCBPYmplY3Qua2V5cyhuKS5mb3JFYWNoKGZ1bmN0aW9uKHIpIHtcbiAgICAgIHZhciBhID0gbltyXTtcbiAgICAgIGEgPT09ICExID8gby5yZW1vdmVBdHRyaWJ1dGUocikgOiBvLnNldEF0dHJpYnV0ZShyLCBhID09PSAhMCA/IFwiXCIgOiBhKTtcbiAgICB9KSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gbmQocykge1xuICB2YXIgdCA9IHMuc3RhdGUsIGUgPSB7XG4gICAgcG9wcGVyOiB7XG4gICAgICBwb3NpdGlvbjogdC5vcHRpb25zLnN0cmF0ZWd5LFxuICAgICAgbGVmdDogXCIwXCIsXG4gICAgICB0b3A6IFwiMFwiLFxuICAgICAgbWFyZ2luOiBcIjBcIlxuICAgIH0sXG4gICAgYXJyb3c6IHtcbiAgICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCJcbiAgICB9LFxuICAgIHJlZmVyZW5jZToge31cbiAgfTtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24odC5lbGVtZW50cy5wb3BwZXIuc3R5bGUsIGUucG9wcGVyKSwgdC5zdHlsZXMgPSBlLCB0LmVsZW1lbnRzLmFycm93ICYmIE9iamVjdC5hc3NpZ24odC5lbGVtZW50cy5hcnJvdy5zdHlsZSwgZS5hcnJvdyksIGZ1bmN0aW9uKCkge1xuICAgIE9iamVjdC5rZXlzKHQuZWxlbWVudHMpLmZvckVhY2goZnVuY3Rpb24oaSkge1xuICAgICAgdmFyIG4gPSB0LmVsZW1lbnRzW2ldLCBvID0gdC5hdHRyaWJ1dGVzW2ldIHx8IHt9LCByID0gT2JqZWN0LmtleXModC5zdHlsZXMuaGFzT3duUHJvcGVydHkoaSkgPyB0LnN0eWxlc1tpXSA6IGVbaV0pLCBhID0gci5yZWR1Y2UoZnVuY3Rpb24obCwgcCkge1xuICAgICAgICByZXR1cm4gbFtwXSA9IFwiXCIsIGw7XG4gICAgICB9LCB7fSk7XG4gICAgICAhaHQobikgfHwgIU10KG4pIHx8IChPYmplY3QuYXNzaWduKG4uc3R5bGUsIGEpLCBPYmplY3Qua2V5cyhvKS5mb3JFYWNoKGZ1bmN0aW9uKGwpIHtcbiAgICAgICAgbi5yZW1vdmVBdHRyaWJ1dGUobCk7XG4gICAgICB9KSk7XG4gICAgfSk7XG4gIH07XG59XG5jb25zdCB0ciA9IHtcbiAgbmFtZTogXCJhcHBseVN0eWxlc1wiLFxuICBlbmFibGVkOiAhMCxcbiAgcGhhc2U6IFwid3JpdGVcIixcbiAgZm46IHNkLFxuICBlZmZlY3Q6IG5kLFxuICByZXF1aXJlczogW1wiY29tcHV0ZVN0eWxlc1wiXVxufTtcbmZ1bmN0aW9uIFR0KHMpIHtcbiAgcmV0dXJuIHMuc3BsaXQoXCItXCIpWzBdO1xufVxudmFyIGJlID0gTWF0aC5tYXgsIHNuID0gTWF0aC5taW4sIHplID0gTWF0aC5yb3VuZDtcbmZ1bmN0aW9uIElvKCkge1xuICB2YXIgcyA9IG5hdmlnYXRvci51c2VyQWdlbnREYXRhO1xuICByZXR1cm4gcyAhPSBudWxsICYmIHMuYnJhbmRzICYmIEFycmF5LmlzQXJyYXkocy5icmFuZHMpID8gcy5icmFuZHMubWFwKGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gdC5icmFuZCArIFwiL1wiICsgdC52ZXJzaW9uO1xuICB9KS5qb2luKFwiIFwiKSA6IG5hdmlnYXRvci51c2VyQWdlbnQ7XG59XG5mdW5jdGlvbiBiYygpIHtcbiAgcmV0dXJuICEvXigoPyFjaHJvbWV8YW5kcm9pZCkuKSpzYWZhcmkvaS50ZXN0KElvKCkpO1xufVxuZnVuY3Rpb24gVWUocywgdCwgZSkge1xuICB0ID09PSB2b2lkIDAgJiYgKHQgPSAhMSksIGUgPT09IHZvaWQgMCAmJiAoZSA9ICExKTtcbiAgdmFyIGkgPSBzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCBuID0gMSwgbyA9IDE7XG4gIHQgJiYgaHQocykgJiYgKG4gPSBzLm9mZnNldFdpZHRoID4gMCAmJiB6ZShpLndpZHRoKSAvIHMub2Zmc2V0V2lkdGggfHwgMSwgbyA9IHMub2Zmc2V0SGVpZ2h0ID4gMCAmJiB6ZShpLmhlaWdodCkgLyBzLm9mZnNldEhlaWdodCB8fCAxKTtcbiAgdmFyIHIgPSBFZShzKSA/IHB0KHMpIDogd2luZG93LCBhID0gci52aXN1YWxWaWV3cG9ydCwgbCA9ICFiYygpICYmIGUsIHAgPSAoaS5sZWZ0ICsgKGwgJiYgYSA/IGEub2Zmc2V0TGVmdCA6IDApKSAvIG4sIHUgPSAoaS50b3AgKyAobCAmJiBhID8gYS5vZmZzZXRUb3AgOiAwKSkgLyBvLCBfID0gaS53aWR0aCAvIG4sIGYgPSBpLmhlaWdodCAvIG87XG4gIHJldHVybiB7XG4gICAgd2lkdGg6IF8sXG4gICAgaGVpZ2h0OiBmLFxuICAgIHRvcDogdSxcbiAgICByaWdodDogcCArIF8sXG4gICAgYm90dG9tOiB1ICsgZixcbiAgICBsZWZ0OiBwLFxuICAgIHg6IHAsXG4gICAgeTogdVxuICB9O1xufVxuZnVuY3Rpb24gZXIocykge1xuICB2YXIgdCA9IFVlKHMpLCBlID0gcy5vZmZzZXRXaWR0aCwgaSA9IHMub2Zmc2V0SGVpZ2h0O1xuICByZXR1cm4gTWF0aC5hYnModC53aWR0aCAtIGUpIDw9IDEgJiYgKGUgPSB0LndpZHRoKSwgTWF0aC5hYnModC5oZWlnaHQgLSBpKSA8PSAxICYmIChpID0gdC5oZWlnaHQpLCB7XG4gICAgeDogcy5vZmZzZXRMZWZ0LFxuICAgIHk6IHMub2Zmc2V0VG9wLFxuICAgIHdpZHRoOiBlLFxuICAgIGhlaWdodDogaVxuICB9O1xufVxuZnVuY3Rpb24gdmMocywgdCkge1xuICB2YXIgZSA9IHQuZ2V0Um9vdE5vZGUgJiYgdC5nZXRSb290Tm9kZSgpO1xuICBpZiAocy5jb250YWlucyh0KSlcbiAgICByZXR1cm4gITA7XG4gIGlmIChlICYmIEpvKGUpKSB7XG4gICAgdmFyIGkgPSB0O1xuICAgIGRvIHtcbiAgICAgIGlmIChpICYmIHMuaXNTYW1lTm9kZShpKSlcbiAgICAgICAgcmV0dXJuICEwO1xuICAgICAgaSA9IGkucGFyZW50Tm9kZSB8fCBpLmhvc3Q7XG4gICAgfSB3aGlsZSAoaSk7XG4gIH1cbiAgcmV0dXJuICExO1xufVxuZnVuY3Rpb24gQ3Qocykge1xuICByZXR1cm4gcHQocykuZ2V0Q29tcHV0ZWRTdHlsZShzKTtcbn1cbmZ1bmN0aW9uIG9kKHMpIHtcbiAgcmV0dXJuIFtcInRhYmxlXCIsIFwidGRcIiwgXCJ0aFwiXS5pbmRleE9mKE10KHMpKSA+PSAwO1xufVxuZnVuY3Rpb24gZWUocykge1xuICByZXR1cm4gKChFZShzKSA/IHMub3duZXJEb2N1bWVudCA6IChcbiAgICAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cbiAgICBzLmRvY3VtZW50XG4gICkpIHx8IHdpbmRvdy5kb2N1bWVudCkuZG9jdW1lbnRFbGVtZW50O1xufVxuZnVuY3Rpb24gcm4ocykge1xuICByZXR1cm4gTXQocykgPT09IFwiaHRtbFwiID8gcyA6IChcbiAgICAvLyB0aGlzIGlzIGEgcXVpY2tlciAoYnV0IGxlc3MgdHlwZSBzYWZlKSB3YXkgdG8gc2F2ZSBxdWl0ZSBzb21lIGJ5dGVzIGZyb20gdGhlIGJ1bmRsZVxuICAgIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXJldHVybl1cbiAgICAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cbiAgICBzLmFzc2lnbmVkU2xvdCB8fCAvLyBzdGVwIGludG8gdGhlIHNoYWRvdyBET00gb2YgdGhlIHBhcmVudCBvZiBhIHNsb3R0ZWQgbm9kZVxuICAgIHMucGFyZW50Tm9kZSB8fCAvLyBET00gRWxlbWVudCBkZXRlY3RlZFxuICAgIChKbyhzKSA/IHMuaG9zdCA6IG51bGwpIHx8IC8vIFNoYWRvd1Jvb3QgZGV0ZWN0ZWRcbiAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1jYWxsXTogSFRNTEVsZW1lbnQgaXMgYSBOb2RlXG4gICAgZWUocylcbiAgKTtcbn1cbmZ1bmN0aW9uIFNyKHMpIHtcbiAgcmV0dXJuICFodChzKSB8fCAvLyBodHRwczovL2dpdGh1Yi5jb20vcG9wcGVyanMvcG9wcGVyLWNvcmUvaXNzdWVzLzgzN1xuICBDdChzKS5wb3NpdGlvbiA9PT0gXCJmaXhlZFwiID8gbnVsbCA6IHMub2Zmc2V0UGFyZW50O1xufVxuZnVuY3Rpb24gcmQocykge1xuICB2YXIgdCA9IC9maXJlZm94L2kudGVzdChJbygpKSwgZSA9IC9UcmlkZW50L2kudGVzdChJbygpKTtcbiAgaWYgKGUgJiYgaHQocykpIHtcbiAgICB2YXIgaSA9IEN0KHMpO1xuICAgIGlmIChpLnBvc2l0aW9uID09PSBcImZpeGVkXCIpXG4gICAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB2YXIgbiA9IHJuKHMpO1xuICBmb3IgKEpvKG4pICYmIChuID0gbi5ob3N0KTsgaHQobikgJiYgW1wiaHRtbFwiLCBcImJvZHlcIl0uaW5kZXhPZihNdChuKSkgPCAwOyApIHtcbiAgICB2YXIgbyA9IEN0KG4pO1xuICAgIGlmIChvLnRyYW5zZm9ybSAhPT0gXCJub25lXCIgfHwgby5wZXJzcGVjdGl2ZSAhPT0gXCJub25lXCIgfHwgby5jb250YWluID09PSBcInBhaW50XCIgfHwgW1widHJhbnNmb3JtXCIsIFwicGVyc3BlY3RpdmVcIl0uaW5kZXhPZihvLndpbGxDaGFuZ2UpICE9PSAtMSB8fCB0ICYmIG8ud2lsbENoYW5nZSA9PT0gXCJmaWx0ZXJcIiB8fCB0ICYmIG8uZmlsdGVyICYmIG8uZmlsdGVyICE9PSBcIm5vbmVcIilcbiAgICAgIHJldHVybiBuO1xuICAgIG4gPSBuLnBhcmVudE5vZGU7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBWaShzKSB7XG4gIGZvciAodmFyIHQgPSBwdChzKSwgZSA9IFNyKHMpOyBlICYmIG9kKGUpICYmIEN0KGUpLnBvc2l0aW9uID09PSBcInN0YXRpY1wiOyApXG4gICAgZSA9IFNyKGUpO1xuICByZXR1cm4gZSAmJiAoTXQoZSkgPT09IFwiaHRtbFwiIHx8IE10KGUpID09PSBcImJvZHlcIiAmJiBDdChlKS5wb3NpdGlvbiA9PT0gXCJzdGF0aWNcIikgPyB0IDogZSB8fCByZChzKSB8fCB0O1xufVxuZnVuY3Rpb24gaXIocykge1xuICByZXR1cm4gW1widG9wXCIsIFwiYm90dG9tXCJdLmluZGV4T2YocykgPj0gMCA/IFwieFwiIDogXCJ5XCI7XG59XG5mdW5jdGlvbiBTaShzLCB0LCBlKSB7XG4gIHJldHVybiBiZShzLCBzbih0LCBlKSk7XG59XG5mdW5jdGlvbiBhZChzLCB0LCBlKSB7XG4gIHZhciBpID0gU2kocywgdCwgZSk7XG4gIHJldHVybiBpID4gZSA/IGUgOiBpO1xufVxuZnVuY3Rpb24gVGMoKSB7XG4gIHJldHVybiB7XG4gICAgdG9wOiAwLFxuICAgIHJpZ2h0OiAwLFxuICAgIGJvdHRvbTogMCxcbiAgICBsZWZ0OiAwXG4gIH07XG59XG5mdW5jdGlvbiBFYyhzKSB7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBUYygpLCBzKTtcbn1cbmZ1bmN0aW9uIENjKHMsIHQpIHtcbiAgcmV0dXJuIHQucmVkdWNlKGZ1bmN0aW9uKGUsIGkpIHtcbiAgICByZXR1cm4gZVtpXSA9IHMsIGU7XG4gIH0sIHt9KTtcbn1cbnZhciBsZCA9IGZ1bmN0aW9uKHQsIGUpIHtcbiAgcmV0dXJuIHQgPSB0eXBlb2YgdCA9PSBcImZ1bmN0aW9uXCIgPyB0KE9iamVjdC5hc3NpZ24oe30sIGUucmVjdHMsIHtcbiAgICBwbGFjZW1lbnQ6IGUucGxhY2VtZW50XG4gIH0pKSA6IHQsIEVjKHR5cGVvZiB0ICE9IFwibnVtYmVyXCIgPyB0IDogQ2ModCwgdGkpKTtcbn07XG5mdW5jdGlvbiBjZChzKSB7XG4gIHZhciB0LCBlID0gcy5zdGF0ZSwgaSA9IHMubmFtZSwgbiA9IHMub3B0aW9ucywgbyA9IGUuZWxlbWVudHMuYXJyb3csIHIgPSBlLm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cywgYSA9IFR0KGUucGxhY2VtZW50KSwgbCA9IGlyKGEpLCBwID0gW0osIHV0XS5pbmRleE9mKGEpID49IDAsIHUgPSBwID8gXCJoZWlnaHRcIiA6IFwid2lkdGhcIjtcbiAgaWYgKCEoIW8gfHwgIXIpKSB7XG4gICAgdmFyIF8gPSBsZChuLnBhZGRpbmcsIGUpLCBmID0gZXIobyksIGcgPSBsID09PSBcInlcIiA/IFEgOiBKLCBtID0gbCA9PT0gXCJ5XCIgPyBkdCA6IHV0LCBiID0gZS5yZWN0cy5yZWZlcmVuY2VbdV0gKyBlLnJlY3RzLnJlZmVyZW5jZVtsXSAtIHJbbF0gLSBlLnJlY3RzLnBvcHBlclt1XSwgdiA9IHJbbF0gLSBlLnJlY3RzLnJlZmVyZW5jZVtsXSwgQyA9IFZpKG8pLCB3ID0gQyA/IGwgPT09IFwieVwiID8gQy5jbGllbnRIZWlnaHQgfHwgMCA6IEMuY2xpZW50V2lkdGggfHwgMCA6IDAsIEUgPSBiIC8gMiAtIHYgLyAyLCBUID0gX1tnXSwgQSA9IHcgLSBmW3VdIC0gX1ttXSwgayA9IHcgLyAyIC0gZlt1XSAvIDIgKyBFLCBJID0gU2koVCwgaywgQSksIE8gPSBsO1xuICAgIGUubW9kaWZpZXJzRGF0YVtpXSA9ICh0ID0ge30sIHRbT10gPSBJLCB0LmNlbnRlck9mZnNldCA9IEkgLSBrLCB0KTtcbiAgfVxufVxuZnVuY3Rpb24gaGQocykge1xuICB2YXIgdCA9IHMuc3RhdGUsIGUgPSBzLm9wdGlvbnMsIGkgPSBlLmVsZW1lbnQsIG4gPSBpID09PSB2b2lkIDAgPyBcIltkYXRhLXBvcHBlci1hcnJvd11cIiA6IGk7XG4gIGlmIChuICE9IG51bGwgJiYgISh0eXBlb2YgbiA9PSBcInN0cmluZ1wiICYmIChuID0gdC5lbGVtZW50cy5wb3BwZXIucXVlcnlTZWxlY3RvcihuKSwgIW4pKSkge1xuICAgIGlmICh7fS5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgKGh0KG4pIHx8IGNvbnNvbGUuZXJyb3IoWydQb3BwZXI6IFwiYXJyb3dcIiBlbGVtZW50IG11c3QgYmUgYW4gSFRNTEVsZW1lbnQgKG5vdCBhbiBTVkdFbGVtZW50KS4nLCBcIlRvIHVzZSBhbiBTVkcgYXJyb3csIHdyYXAgaXQgaW4gYW4gSFRNTEVsZW1lbnQgdGhhdCB3aWxsIGJlIHVzZWQgYXNcIiwgXCJ0aGUgYXJyb3cuXCJdLmpvaW4oXCIgXCIpKSksICF2Yyh0LmVsZW1lbnRzLnBvcHBlciwgbikpIHtcbiAgICAgICh7fSkuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIGNvbnNvbGUuZXJyb3IoWydQb3BwZXI6IFwiYXJyb3dcIiBtb2RpZmllclxcJ3MgYGVsZW1lbnRgIG11c3QgYmUgYSBjaGlsZCBvZiB0aGUgcG9wcGVyJywgXCJlbGVtZW50LlwiXS5qb2luKFwiIFwiKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHQuZWxlbWVudHMuYXJyb3cgPSBuO1xuICB9XG59XG5jb25zdCBBYyA9IHtcbiAgbmFtZTogXCJhcnJvd1wiLFxuICBlbmFibGVkOiAhMCxcbiAgcGhhc2U6IFwibWFpblwiLFxuICBmbjogY2QsXG4gIGVmZmVjdDogaGQsXG4gIHJlcXVpcmVzOiBbXCJwb3BwZXJPZmZzZXRzXCJdLFxuICByZXF1aXJlc0lmRXhpc3RzOiBbXCJwcmV2ZW50T3ZlcmZsb3dcIl1cbn07XG5mdW5jdGlvbiBYZShzKSB7XG4gIHJldHVybiBzLnNwbGl0KFwiLVwiKVsxXTtcbn1cbnZhciBkZCA9IHtcbiAgdG9wOiBcImF1dG9cIixcbiAgcmlnaHQ6IFwiYXV0b1wiLFxuICBib3R0b206IFwiYXV0b1wiLFxuICBsZWZ0OiBcImF1dG9cIlxufTtcbmZ1bmN0aW9uIHVkKHMsIHQpIHtcbiAgdmFyIGUgPSBzLngsIGkgPSBzLnksIG4gPSB0LmRldmljZVBpeGVsUmF0aW8gfHwgMTtcbiAgcmV0dXJuIHtcbiAgICB4OiB6ZShlICogbikgLyBuIHx8IDAsXG4gICAgeTogemUoaSAqIG4pIC8gbiB8fCAwXG4gIH07XG59XG5mdW5jdGlvbiBJcihzKSB7XG4gIHZhciB0LCBlID0gcy5wb3BwZXIsIGkgPSBzLnBvcHBlclJlY3QsIG4gPSBzLnBsYWNlbWVudCwgbyA9IHMudmFyaWF0aW9uLCByID0gcy5vZmZzZXRzLCBhID0gcy5wb3NpdGlvbiwgbCA9IHMuZ3B1QWNjZWxlcmF0aW9uLCBwID0gcy5hZGFwdGl2ZSwgdSA9IHMucm91bmRPZmZzZXRzLCBfID0gcy5pc0ZpeGVkLCBmID0gci54LCBnID0gZiA9PT0gdm9pZCAwID8gMCA6IGYsIG0gPSByLnksIGIgPSBtID09PSB2b2lkIDAgPyAwIDogbSwgdiA9IHR5cGVvZiB1ID09IFwiZnVuY3Rpb25cIiA/IHUoe1xuICAgIHg6IGcsXG4gICAgeTogYlxuICB9KSA6IHtcbiAgICB4OiBnLFxuICAgIHk6IGJcbiAgfTtcbiAgZyA9IHYueCwgYiA9IHYueTtcbiAgdmFyIEMgPSByLmhhc093blByb3BlcnR5KFwieFwiKSwgdyA9IHIuaGFzT3duUHJvcGVydHkoXCJ5XCIpLCBFID0gSiwgVCA9IFEsIEEgPSB3aW5kb3c7XG4gIGlmIChwKSB7XG4gICAgdmFyIGsgPSBWaShlKSwgSSA9IFwiY2xpZW50SGVpZ2h0XCIsIE8gPSBcImNsaWVudFdpZHRoXCI7XG4gICAgaWYgKGsgPT09IHB0KGUpICYmIChrID0gZWUoZSksIEN0KGspLnBvc2l0aW9uICE9PSBcInN0YXRpY1wiICYmIGEgPT09IFwiYWJzb2x1dGVcIiAmJiAoSSA9IFwic2Nyb2xsSGVpZ2h0XCIsIE8gPSBcInNjcm9sbFdpZHRoXCIpKSwgayA9IGssIG4gPT09IFEgfHwgKG4gPT09IEogfHwgbiA9PT0gdXQpICYmIG8gPT09IEtlKSB7XG4gICAgICBUID0gZHQ7XG4gICAgICB2YXIgeCA9IF8gJiYgayA9PT0gQSAmJiBBLnZpc3VhbFZpZXdwb3J0ID8gQS52aXN1YWxWaWV3cG9ydC5oZWlnaHQgOiAoXG4gICAgICAgIC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuICAgICAgICBrW0ldXG4gICAgICApO1xuICAgICAgYiAtPSB4IC0gaS5oZWlnaHQsIGIgKj0gbCA/IDEgOiAtMTtcbiAgICB9XG4gICAgaWYgKG4gPT09IEogfHwgKG4gPT09IFEgfHwgbiA9PT0gZHQpICYmIG8gPT09IEtlKSB7XG4gICAgICBFID0gdXQ7XG4gICAgICB2YXIgTCA9IF8gJiYgayA9PT0gQSAmJiBBLnZpc3VhbFZpZXdwb3J0ID8gQS52aXN1YWxWaWV3cG9ydC53aWR0aCA6IChcbiAgICAgICAgLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG4gICAgICAgIGtbT11cbiAgICAgICk7XG4gICAgICBnIC09IEwgLSBpLndpZHRoLCBnICo9IGwgPyAxIDogLTE7XG4gICAgfVxuICB9XG4gIHZhciBTID0gT2JqZWN0LmFzc2lnbih7XG4gICAgcG9zaXRpb246IGFcbiAgfSwgcCAmJiBkZCksIE4gPSB1ID09PSAhMCA/IHVkKHtcbiAgICB4OiBnLFxuICAgIHk6IGJcbiAgfSwgcHQoZSkpIDoge1xuICAgIHg6IGcsXG4gICAgeTogYlxuICB9O1xuICBpZiAoZyA9IE4ueCwgYiA9IE4ueSwgbCkge1xuICAgIHZhciBQO1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBTLCAoUCA9IHt9LCBQW1RdID0gdyA/IFwiMFwiIDogXCJcIiwgUFtFXSA9IEMgPyBcIjBcIiA6IFwiXCIsIFAudHJhbnNmb3JtID0gKEEuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxKSA8PSAxID8gXCJ0cmFuc2xhdGUoXCIgKyBnICsgXCJweCwgXCIgKyBiICsgXCJweClcIiA6IFwidHJhbnNsYXRlM2QoXCIgKyBnICsgXCJweCwgXCIgKyBiICsgXCJweCwgMClcIiwgUCkpO1xuICB9XG4gIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBTLCAodCA9IHt9LCB0W1RdID0gdyA/IGIgKyBcInB4XCIgOiBcIlwiLCB0W0VdID0gQyA/IGcgKyBcInB4XCIgOiBcIlwiLCB0LnRyYW5zZm9ybSA9IFwiXCIsIHQpKTtcbn1cbmZ1bmN0aW9uIHBkKHMpIHtcbiAgdmFyIHQgPSBzLnN0YXRlLCBlID0gcy5vcHRpb25zLCBpID0gZS5ncHVBY2NlbGVyYXRpb24sIG4gPSBpID09PSB2b2lkIDAgPyAhMCA6IGksIG8gPSBlLmFkYXB0aXZlLCByID0gbyA9PT0gdm9pZCAwID8gITAgOiBvLCBhID0gZS5yb3VuZE9mZnNldHMsIGwgPSBhID09PSB2b2lkIDAgPyAhMCA6IGE7XG4gIGlmICh7fS5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICB2YXIgcCA9IEN0KHQuZWxlbWVudHMucG9wcGVyKS50cmFuc2l0aW9uUHJvcGVydHkgfHwgXCJcIjtcbiAgICByICYmIFtcInRyYW5zZm9ybVwiLCBcInRvcFwiLCBcInJpZ2h0XCIsIFwiYm90dG9tXCIsIFwibGVmdFwiXS5zb21lKGZ1bmN0aW9uKF8pIHtcbiAgICAgIHJldHVybiBwLmluZGV4T2YoXykgPj0gMDtcbiAgICB9KSAmJiBjb25zb2xlLndhcm4oW1wiUG9wcGVyOiBEZXRlY3RlZCBDU1MgdHJhbnNpdGlvbnMgb24gYXQgbGVhc3Qgb25lIG9mIHRoZSBmb2xsb3dpbmdcIiwgJ0NTUyBwcm9wZXJ0aWVzOiBcInRyYW5zZm9ybVwiLCBcInRvcFwiLCBcInJpZ2h0XCIsIFwiYm90dG9tXCIsIFwibGVmdFwiLicsIGBcblxuYCwgJ0Rpc2FibGUgdGhlIFwiY29tcHV0ZVN0eWxlc1wiIG1vZGlmaWVyXFwncyBgYWRhcHRpdmVgIG9wdGlvbiB0byBhbGxvdycsIFwiZm9yIHNtb290aCB0cmFuc2l0aW9ucywgb3IgcmVtb3ZlIHRoZXNlIHByb3BlcnRpZXMgZnJvbSB0aGUgQ1NTXCIsIFwidHJhbnNpdGlvbiBkZWNsYXJhdGlvbiBvbiB0aGUgcG9wcGVyIGVsZW1lbnQgaWYgb25seSB0cmFuc2l0aW9uaW5nXCIsIFwib3BhY2l0eSBvciBiYWNrZ3JvdW5kLWNvbG9yIGZvciBleGFtcGxlLlwiLCBgXG5cbmAsIFwiV2UgcmVjb21tZW5kIHVzaW5nIHRoZSBwb3BwZXIgZWxlbWVudCBhcyBhIHdyYXBwZXIgYXJvdW5kIGFuIGlubmVyXCIsIFwiZWxlbWVudCB0aGF0IGNhbiBoYXZlIGFueSBDU1MgcHJvcGVydHkgdHJhbnNpdGlvbmVkIGZvciBhbmltYXRpb25zLlwiXS5qb2luKFwiIFwiKSk7XG4gIH1cbiAgdmFyIHUgPSB7XG4gICAgcGxhY2VtZW50OiBUdCh0LnBsYWNlbWVudCksXG4gICAgdmFyaWF0aW9uOiBYZSh0LnBsYWNlbWVudCksXG4gICAgcG9wcGVyOiB0LmVsZW1lbnRzLnBvcHBlcixcbiAgICBwb3BwZXJSZWN0OiB0LnJlY3RzLnBvcHBlcixcbiAgICBncHVBY2NlbGVyYXRpb246IG4sXG4gICAgaXNGaXhlZDogdC5vcHRpb25zLnN0cmF0ZWd5ID09PSBcImZpeGVkXCJcbiAgfTtcbiAgdC5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHMgIT0gbnVsbCAmJiAodC5zdHlsZXMucG9wcGVyID0gT2JqZWN0LmFzc2lnbih7fSwgdC5zdHlsZXMucG9wcGVyLCBJcihPYmplY3QuYXNzaWduKHt9LCB1LCB7XG4gICAgb2Zmc2V0czogdC5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHMsXG4gICAgcG9zaXRpb246IHQub3B0aW9ucy5zdHJhdGVneSxcbiAgICBhZGFwdGl2ZTogcixcbiAgICByb3VuZE9mZnNldHM6IGxcbiAgfSkpKSksIHQubW9kaWZpZXJzRGF0YS5hcnJvdyAhPSBudWxsICYmICh0LnN0eWxlcy5hcnJvdyA9IE9iamVjdC5hc3NpZ24oe30sIHQuc3R5bGVzLmFycm93LCBJcihPYmplY3QuYXNzaWduKHt9LCB1LCB7XG4gICAgb2Zmc2V0czogdC5tb2RpZmllcnNEYXRhLmFycm93LFxuICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXG4gICAgYWRhcHRpdmU6ICExLFxuICAgIHJvdW5kT2Zmc2V0czogbFxuICB9KSkpKSwgdC5hdHRyaWJ1dGVzLnBvcHBlciA9IE9iamVjdC5hc3NpZ24oe30sIHQuYXR0cmlidXRlcy5wb3BwZXIsIHtcbiAgICBcImRhdGEtcG9wcGVyLXBsYWNlbWVudFwiOiB0LnBsYWNlbWVudFxuICB9KTtcbn1cbmNvbnN0IHNyID0ge1xuICBuYW1lOiBcImNvbXB1dGVTdHlsZXNcIixcbiAgZW5hYmxlZDogITAsXG4gIHBoYXNlOiBcImJlZm9yZVdyaXRlXCIsXG4gIGZuOiBwZCxcbiAgZGF0YToge31cbn07XG52YXIgdHMgPSB7XG4gIHBhc3NpdmU6ICEwXG59O1xuZnVuY3Rpb24gX2Qocykge1xuICB2YXIgdCA9IHMuc3RhdGUsIGUgPSBzLmluc3RhbmNlLCBpID0gcy5vcHRpb25zLCBuID0gaS5zY3JvbGwsIG8gPSBuID09PSB2b2lkIDAgPyAhMCA6IG4sIHIgPSBpLnJlc2l6ZSwgYSA9IHIgPT09IHZvaWQgMCA/ICEwIDogciwgbCA9IHB0KHQuZWxlbWVudHMucG9wcGVyKSwgcCA9IFtdLmNvbmNhdCh0LnNjcm9sbFBhcmVudHMucmVmZXJlbmNlLCB0LnNjcm9sbFBhcmVudHMucG9wcGVyKTtcbiAgcmV0dXJuIG8gJiYgcC5mb3JFYWNoKGZ1bmN0aW9uKHUpIHtcbiAgICB1LmFkZEV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgZS51cGRhdGUsIHRzKTtcbiAgfSksIGEgJiYgbC5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIGUudXBkYXRlLCB0cyksIGZ1bmN0aW9uKCkge1xuICAgIG8gJiYgcC5mb3JFYWNoKGZ1bmN0aW9uKHUpIHtcbiAgICAgIHUucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCBlLnVwZGF0ZSwgdHMpO1xuICAgIH0pLCBhICYmIGwucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCBlLnVwZGF0ZSwgdHMpO1xuICB9O1xufVxuY29uc3QgbnIgPSB7XG4gIG5hbWU6IFwiZXZlbnRMaXN0ZW5lcnNcIixcbiAgZW5hYmxlZDogITAsXG4gIHBoYXNlOiBcIndyaXRlXCIsXG4gIGZuOiBmdW5jdGlvbigpIHtcbiAgfSxcbiAgZWZmZWN0OiBfZCxcbiAgZGF0YToge31cbn07XG52YXIgZmQgPSB7XG4gIGxlZnQ6IFwicmlnaHRcIixcbiAgcmlnaHQ6IFwibGVmdFwiLFxuICBib3R0b206IFwidG9wXCIsXG4gIHRvcDogXCJib3R0b21cIlxufTtcbmZ1bmN0aW9uIE1zKHMpIHtcbiAgcmV0dXJuIHMucmVwbGFjZSgvbGVmdHxyaWdodHxib3R0b218dG9wL2csIGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gZmRbdF07XG4gIH0pO1xufVxudmFyIG1kID0ge1xuICBzdGFydDogXCJlbmRcIixcbiAgZW5kOiBcInN0YXJ0XCJcbn07XG5mdW5jdGlvbiBEcihzKSB7XG4gIHJldHVybiBzLnJlcGxhY2UoL3N0YXJ0fGVuZC9nLCBmdW5jdGlvbih0KSB7XG4gICAgcmV0dXJuIG1kW3RdO1xuICB9KTtcbn1cbmZ1bmN0aW9uIG9yKHMpIHtcbiAgdmFyIHQgPSBwdChzKSwgZSA9IHQucGFnZVhPZmZzZXQsIGkgPSB0LnBhZ2VZT2Zmc2V0O1xuICByZXR1cm4ge1xuICAgIHNjcm9sbExlZnQ6IGUsXG4gICAgc2Nyb2xsVG9wOiBpXG4gIH07XG59XG5mdW5jdGlvbiBycihzKSB7XG4gIHJldHVybiBVZShlZShzKSkubGVmdCArIG9yKHMpLnNjcm9sbExlZnQ7XG59XG5mdW5jdGlvbiBnZChzLCB0KSB7XG4gIHZhciBlID0gcHQocyksIGkgPSBlZShzKSwgbiA9IGUudmlzdWFsVmlld3BvcnQsIG8gPSBpLmNsaWVudFdpZHRoLCByID0gaS5jbGllbnRIZWlnaHQsIGEgPSAwLCBsID0gMDtcbiAgaWYgKG4pIHtcbiAgICBvID0gbi53aWR0aCwgciA9IG4uaGVpZ2h0O1xuICAgIHZhciBwID0gYmMoKTtcbiAgICAocCB8fCAhcCAmJiB0ID09PSBcImZpeGVkXCIpICYmIChhID0gbi5vZmZzZXRMZWZ0LCBsID0gbi5vZmZzZXRUb3ApO1xuICB9XG4gIHJldHVybiB7XG4gICAgd2lkdGg6IG8sXG4gICAgaGVpZ2h0OiByLFxuICAgIHg6IGEgKyBycihzKSxcbiAgICB5OiBsXG4gIH07XG59XG5mdW5jdGlvbiBiZChzKSB7XG4gIHZhciB0LCBlID0gZWUocyksIGkgPSBvcihzKSwgbiA9ICh0ID0gcy5vd25lckRvY3VtZW50KSA9PSBudWxsID8gdm9pZCAwIDogdC5ib2R5LCBvID0gYmUoZS5zY3JvbGxXaWR0aCwgZS5jbGllbnRXaWR0aCwgbiA/IG4uc2Nyb2xsV2lkdGggOiAwLCBuID8gbi5jbGllbnRXaWR0aCA6IDApLCByID0gYmUoZS5zY3JvbGxIZWlnaHQsIGUuY2xpZW50SGVpZ2h0LCBuID8gbi5zY3JvbGxIZWlnaHQgOiAwLCBuID8gbi5jbGllbnRIZWlnaHQgOiAwKSwgYSA9IC1pLnNjcm9sbExlZnQgKyBycihzKSwgbCA9IC1pLnNjcm9sbFRvcDtcbiAgcmV0dXJuIEN0KG4gfHwgZSkuZGlyZWN0aW9uID09PSBcInJ0bFwiICYmIChhICs9IGJlKGUuY2xpZW50V2lkdGgsIG4gPyBuLmNsaWVudFdpZHRoIDogMCkgLSBvKSwge1xuICAgIHdpZHRoOiBvLFxuICAgIGhlaWdodDogcixcbiAgICB4OiBhLFxuICAgIHk6IGxcbiAgfTtcbn1cbmZ1bmN0aW9uIGFyKHMpIHtcbiAgdmFyIHQgPSBDdChzKSwgZSA9IHQub3ZlcmZsb3csIGkgPSB0Lm92ZXJmbG93WCwgbiA9IHQub3ZlcmZsb3dZO1xuICByZXR1cm4gL2F1dG98c2Nyb2xsfG92ZXJsYXl8aGlkZGVuLy50ZXN0KGUgKyBuICsgaSk7XG59XG5mdW5jdGlvbiB5YyhzKSB7XG4gIHJldHVybiBbXCJodG1sXCIsIFwiYm9keVwiLCBcIiNkb2N1bWVudFwiXS5pbmRleE9mKE10KHMpKSA+PSAwID8gcy5vd25lckRvY3VtZW50LmJvZHkgOiBodChzKSAmJiBhcihzKSA/IHMgOiB5YyhybihzKSk7XG59XG5mdW5jdGlvbiBJaShzLCB0KSB7XG4gIHZhciBlO1xuICB0ID09PSB2b2lkIDAgJiYgKHQgPSBbXSk7XG4gIHZhciBpID0geWMocyksIG4gPSBpID09PSAoKGUgPSBzLm93bmVyRG9jdW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBlLmJvZHkpLCBvID0gcHQoaSksIHIgPSBuID8gW29dLmNvbmNhdChvLnZpc3VhbFZpZXdwb3J0IHx8IFtdLCBhcihpKSA/IGkgOiBbXSkgOiBpLCBhID0gdC5jb25jYXQocik7XG4gIHJldHVybiBuID8gYSA6IChcbiAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1jYWxsXTogaXNCb2R5IHRlbGxzIHVzIHRhcmdldCB3aWxsIGJlIGFuIEhUTUxFbGVtZW50IGhlcmVcbiAgICBhLmNvbmNhdChJaShybihyKSkpXG4gICk7XG59XG5mdW5jdGlvbiBEbyhzKSB7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBzLCB7XG4gICAgbGVmdDogcy54LFxuICAgIHRvcDogcy55LFxuICAgIHJpZ2h0OiBzLnggKyBzLndpZHRoLFxuICAgIGJvdHRvbTogcy55ICsgcy5oZWlnaHRcbiAgfSk7XG59XG5mdW5jdGlvbiB2ZChzLCB0KSB7XG4gIHZhciBlID0gVWUocywgITEsIHQgPT09IFwiZml4ZWRcIik7XG4gIHJldHVybiBlLnRvcCA9IGUudG9wICsgcy5jbGllbnRUb3AsIGUubGVmdCA9IGUubGVmdCArIHMuY2xpZW50TGVmdCwgZS5ib3R0b20gPSBlLnRvcCArIHMuY2xpZW50SGVpZ2h0LCBlLnJpZ2h0ID0gZS5sZWZ0ICsgcy5jbGllbnRXaWR0aCwgZS53aWR0aCA9IHMuY2xpZW50V2lkdGgsIGUuaGVpZ2h0ID0gcy5jbGllbnRIZWlnaHQsIGUueCA9IGUubGVmdCwgZS55ID0gZS50b3AsIGU7XG59XG5mdW5jdGlvbiAkcihzLCB0LCBlKSB7XG4gIHJldHVybiB0ID09PSBabyA/IERvKGdkKHMsIGUpKSA6IEVlKHQpID8gdmQodCwgZSkgOiBEbyhiZChlZShzKSkpO1xufVxuZnVuY3Rpb24gVGQocykge1xuICB2YXIgdCA9IElpKHJuKHMpKSwgZSA9IFtcImFic29sdXRlXCIsIFwiZml4ZWRcIl0uaW5kZXhPZihDdChzKS5wb3NpdGlvbikgPj0gMCwgaSA9IGUgJiYgaHQocykgPyBWaShzKSA6IHM7XG4gIHJldHVybiBFZShpKSA/IHQuZmlsdGVyKGZ1bmN0aW9uKG4pIHtcbiAgICByZXR1cm4gRWUobikgJiYgdmMobiwgaSkgJiYgTXQobikgIT09IFwiYm9keVwiO1xuICB9KSA6IFtdO1xufVxuZnVuY3Rpb24gRWQocywgdCwgZSwgaSkge1xuICB2YXIgbiA9IHQgPT09IFwiY2xpcHBpbmdQYXJlbnRzXCIgPyBUZChzKSA6IFtdLmNvbmNhdCh0KSwgbyA9IFtdLmNvbmNhdChuLCBbZV0pLCByID0gb1swXSwgYSA9IG8ucmVkdWNlKGZ1bmN0aW9uKGwsIHApIHtcbiAgICB2YXIgdSA9ICRyKHMsIHAsIGkpO1xuICAgIHJldHVybiBsLnRvcCA9IGJlKHUudG9wLCBsLnRvcCksIGwucmlnaHQgPSBzbih1LnJpZ2h0LCBsLnJpZ2h0KSwgbC5ib3R0b20gPSBzbih1LmJvdHRvbSwgbC5ib3R0b20pLCBsLmxlZnQgPSBiZSh1LmxlZnQsIGwubGVmdCksIGw7XG4gIH0sICRyKHMsIHIsIGkpKTtcbiAgcmV0dXJuIGEud2lkdGggPSBhLnJpZ2h0IC0gYS5sZWZ0LCBhLmhlaWdodCA9IGEuYm90dG9tIC0gYS50b3AsIGEueCA9IGEubGVmdCwgYS55ID0gYS50b3AsIGE7XG59XG5mdW5jdGlvbiB3YyhzKSB7XG4gIHZhciB0ID0gcy5yZWZlcmVuY2UsIGUgPSBzLmVsZW1lbnQsIGkgPSBzLnBsYWNlbWVudCwgbiA9IGkgPyBUdChpKSA6IG51bGwsIG8gPSBpID8gWGUoaSkgOiBudWxsLCByID0gdC54ICsgdC53aWR0aCAvIDIgLSBlLndpZHRoIC8gMiwgYSA9IHQueSArIHQuaGVpZ2h0IC8gMiAtIGUuaGVpZ2h0IC8gMiwgbDtcbiAgc3dpdGNoIChuKSB7XG4gICAgY2FzZSBROlxuICAgICAgbCA9IHtcbiAgICAgICAgeDogcixcbiAgICAgICAgeTogdC55IC0gZS5oZWlnaHRcbiAgICAgIH07XG4gICAgICBicmVhaztcbiAgICBjYXNlIGR0OlxuICAgICAgbCA9IHtcbiAgICAgICAgeDogcixcbiAgICAgICAgeTogdC55ICsgdC5oZWlnaHRcbiAgICAgIH07XG4gICAgICBicmVhaztcbiAgICBjYXNlIHV0OlxuICAgICAgbCA9IHtcbiAgICAgICAgeDogdC54ICsgdC53aWR0aCxcbiAgICAgICAgeTogYVxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgSjpcbiAgICAgIGwgPSB7XG4gICAgICAgIHg6IHQueCAtIGUud2lkdGgsXG4gICAgICAgIHk6IGFcbiAgICAgIH07XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgbCA9IHtcbiAgICAgICAgeDogdC54LFxuICAgICAgICB5OiB0LnlcbiAgICAgIH07XG4gIH1cbiAgdmFyIHAgPSBuID8gaXIobikgOiBudWxsO1xuICBpZiAocCAhPSBudWxsKSB7XG4gICAgdmFyIHUgPSBwID09PSBcInlcIiA/IFwiaGVpZ2h0XCIgOiBcIndpZHRoXCI7XG4gICAgc3dpdGNoIChvKSB7XG4gICAgICBjYXNlIFRlOlxuICAgICAgICBsW3BdID0gbFtwXSAtICh0W3VdIC8gMiAtIGVbdV0gLyAyKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEtlOlxuICAgICAgICBsW3BdID0gbFtwXSArICh0W3VdIC8gMiAtIGVbdV0gLyAyKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBsO1xufVxuZnVuY3Rpb24gR2UocywgdCkge1xuICB0ID09PSB2b2lkIDAgJiYgKHQgPSB7fSk7XG4gIHZhciBlID0gdCwgaSA9IGUucGxhY2VtZW50LCBuID0gaSA9PT0gdm9pZCAwID8gcy5wbGFjZW1lbnQgOiBpLCBvID0gZS5zdHJhdGVneSwgciA9IG8gPT09IHZvaWQgMCA/IHMuc3RyYXRlZ3kgOiBvLCBhID0gZS5ib3VuZGFyeSwgbCA9IGEgPT09IHZvaWQgMCA/IGFjIDogYSwgcCA9IGUucm9vdEJvdW5kYXJ5LCB1ID0gcCA9PT0gdm9pZCAwID8gWm8gOiBwLCBfID0gZS5lbGVtZW50Q29udGV4dCwgZiA9IF8gPT09IHZvaWQgMCA/ICRlIDogXywgZyA9IGUuYWx0Qm91bmRhcnksIG0gPSBnID09PSB2b2lkIDAgPyAhMSA6IGcsIGIgPSBlLnBhZGRpbmcsIHYgPSBiID09PSB2b2lkIDAgPyAwIDogYiwgQyA9IEVjKHR5cGVvZiB2ICE9IFwibnVtYmVyXCIgPyB2IDogQ2ModiwgdGkpKSwgdyA9IGYgPT09ICRlID8gbGMgOiAkZSwgRSA9IHMucmVjdHMucG9wcGVyLCBUID0gcy5lbGVtZW50c1ttID8gdyA6IGZdLCBBID0gRWQoRWUoVCkgPyBUIDogVC5jb250ZXh0RWxlbWVudCB8fCBlZShzLmVsZW1lbnRzLnBvcHBlciksIGwsIHUsIHIpLCBrID0gVWUocy5lbGVtZW50cy5yZWZlcmVuY2UpLCBJID0gd2Moe1xuICAgIHJlZmVyZW5jZTogayxcbiAgICBlbGVtZW50OiBFLFxuICAgIHN0cmF0ZWd5OiBcImFic29sdXRlXCIsXG4gICAgcGxhY2VtZW50OiBuXG4gIH0pLCBPID0gRG8oT2JqZWN0LmFzc2lnbih7fSwgRSwgSSkpLCB4ID0gZiA9PT0gJGUgPyBPIDogaywgTCA9IHtcbiAgICB0b3A6IEEudG9wIC0geC50b3AgKyBDLnRvcCxcbiAgICBib3R0b206IHguYm90dG9tIC0gQS5ib3R0b20gKyBDLmJvdHRvbSxcbiAgICBsZWZ0OiBBLmxlZnQgLSB4LmxlZnQgKyBDLmxlZnQsXG4gICAgcmlnaHQ6IHgucmlnaHQgLSBBLnJpZ2h0ICsgQy5yaWdodFxuICB9LCBTID0gcy5tb2RpZmllcnNEYXRhLm9mZnNldDtcbiAgaWYgKGYgPT09ICRlICYmIFMpIHtcbiAgICB2YXIgTiA9IFNbbl07XG4gICAgT2JqZWN0LmtleXMoTCkuZm9yRWFjaChmdW5jdGlvbihQKSB7XG4gICAgICB2YXIgdHQgPSBbdXQsIGR0XS5pbmRleE9mKFApID49IDAgPyAxIDogLTEsIGV0ID0gW1EsIGR0XS5pbmRleE9mKFApID49IDAgPyBcInlcIiA6IFwieFwiO1xuICAgICAgTFtQXSArPSBOW2V0XSAqIHR0O1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBMO1xufVxuZnVuY3Rpb24gQ2QocywgdCkge1xuICB0ID09PSB2b2lkIDAgJiYgKHQgPSB7fSk7XG4gIHZhciBlID0gdCwgaSA9IGUucGxhY2VtZW50LCBuID0gZS5ib3VuZGFyeSwgbyA9IGUucm9vdEJvdW5kYXJ5LCByID0gZS5wYWRkaW5nLCBhID0gZS5mbGlwVmFyaWF0aW9ucywgbCA9IGUuYWxsb3dlZEF1dG9QbGFjZW1lbnRzLCBwID0gbCA9PT0gdm9pZCAwID8gUW8gOiBsLCB1ID0gWGUoaSksIF8gPSB1ID8gYSA/IFNvIDogU28uZmlsdGVyKGZ1bmN0aW9uKG0pIHtcbiAgICByZXR1cm4gWGUobSkgPT09IHU7XG4gIH0pIDogdGksIGYgPSBfLmZpbHRlcihmdW5jdGlvbihtKSB7XG4gICAgcmV0dXJuIHAuaW5kZXhPZihtKSA+PSAwO1xuICB9KTtcbiAgZi5sZW5ndGggPT09IDAgJiYgKGYgPSBfLCB7fS5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgY29uc29sZS5lcnJvcihbXCJQb3BwZXI6IFRoZSBgYWxsb3dlZEF1dG9QbGFjZW1lbnRzYCBvcHRpb24gZGlkIG5vdCBhbGxvdyBhbnlcIiwgXCJwbGFjZW1lbnRzLiBFbnN1cmUgdGhlIGBwbGFjZW1lbnRgIG9wdGlvbiBtYXRjaGVzIHRoZSB2YXJpYXRpb25cIiwgXCJvZiB0aGUgYWxsb3dlZCBwbGFjZW1lbnRzLlwiLCAnRm9yIGV4YW1wbGUsIFwiYXV0b1wiIGNhbm5vdCBiZSB1c2VkIHRvIGFsbG93IFwiYm90dG9tLXN0YXJ0XCIuJywgJ1VzZSBcImF1dG8tc3RhcnRcIiBpbnN0ZWFkLiddLmpvaW4oXCIgXCIpKSk7XG4gIHZhciBnID0gZi5yZWR1Y2UoZnVuY3Rpb24obSwgYikge1xuICAgIHJldHVybiBtW2JdID0gR2Uocywge1xuICAgICAgcGxhY2VtZW50OiBiLFxuICAgICAgYm91bmRhcnk6IG4sXG4gICAgICByb290Qm91bmRhcnk6IG8sXG4gICAgICBwYWRkaW5nOiByXG4gICAgfSlbVHQoYildLCBtO1xuICB9LCB7fSk7XG4gIHJldHVybiBPYmplY3Qua2V5cyhnKS5zb3J0KGZ1bmN0aW9uKG0sIGIpIHtcbiAgICByZXR1cm4gZ1ttXSAtIGdbYl07XG4gIH0pO1xufVxuZnVuY3Rpb24gQWQocykge1xuICBpZiAoVHQocykgPT09IEhpKVxuICAgIHJldHVybiBbXTtcbiAgdmFyIHQgPSBNcyhzKTtcbiAgcmV0dXJuIFtEcihzKSwgdCwgRHIodCldO1xufVxuZnVuY3Rpb24geWQocykge1xuICB2YXIgdCA9IHMuc3RhdGUsIGUgPSBzLm9wdGlvbnMsIGkgPSBzLm5hbWU7XG4gIGlmICghdC5tb2RpZmllcnNEYXRhW2ldLl9za2lwKSB7XG4gICAgZm9yICh2YXIgbiA9IGUubWFpbkF4aXMsIG8gPSBuID09PSB2b2lkIDAgPyAhMCA6IG4sIHIgPSBlLmFsdEF4aXMsIGEgPSByID09PSB2b2lkIDAgPyAhMCA6IHIsIGwgPSBlLmZhbGxiYWNrUGxhY2VtZW50cywgcCA9IGUucGFkZGluZywgdSA9IGUuYm91bmRhcnksIF8gPSBlLnJvb3RCb3VuZGFyeSwgZiA9IGUuYWx0Qm91bmRhcnksIGcgPSBlLmZsaXBWYXJpYXRpb25zLCBtID0gZyA9PT0gdm9pZCAwID8gITAgOiBnLCBiID0gZS5hbGxvd2VkQXV0b1BsYWNlbWVudHMsIHYgPSB0Lm9wdGlvbnMucGxhY2VtZW50LCBDID0gVHQodiksIHcgPSBDID09PSB2LCBFID0gbCB8fCAodyB8fCAhbSA/IFtNcyh2KV0gOiBBZCh2KSksIFQgPSBbdl0uY29uY2F0KEUpLnJlZHVjZShmdW5jdGlvbih5ZSwgSHQpIHtcbiAgICAgIHJldHVybiB5ZS5jb25jYXQoVHQoSHQpID09PSBIaSA/IENkKHQsIHtcbiAgICAgICAgcGxhY2VtZW50OiBIdCxcbiAgICAgICAgYm91bmRhcnk6IHUsXG4gICAgICAgIHJvb3RCb3VuZGFyeTogXyxcbiAgICAgICAgcGFkZGluZzogcCxcbiAgICAgICAgZmxpcFZhcmlhdGlvbnM6IG0sXG4gICAgICAgIGFsbG93ZWRBdXRvUGxhY2VtZW50czogYlxuICAgICAgfSkgOiBIdCk7XG4gICAgfSwgW10pLCBBID0gdC5yZWN0cy5yZWZlcmVuY2UsIGsgPSB0LnJlY3RzLnBvcHBlciwgSSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksIE8gPSAhMCwgeCA9IFRbMF0sIEwgPSAwOyBMIDwgVC5sZW5ndGg7IEwrKykge1xuICAgICAgdmFyIFMgPSBUW0xdLCBOID0gVHQoUyksIFAgPSBYZShTKSA9PT0gVGUsIHR0ID0gW1EsIGR0XS5pbmRleE9mKE4pID49IDAsIGV0ID0gdHQgPyBcIndpZHRoXCIgOiBcImhlaWdodFwiLCBVID0gR2UodCwge1xuICAgICAgICBwbGFjZW1lbnQ6IFMsXG4gICAgICAgIGJvdW5kYXJ5OiB1LFxuICAgICAgICByb290Qm91bmRhcnk6IF8sXG4gICAgICAgIGFsdEJvdW5kYXJ5OiBmLFxuICAgICAgICBwYWRkaW5nOiBwXG4gICAgICB9KSwgYnQgPSB0dCA/IFAgPyB1dCA6IEogOiBQID8gZHQgOiBRO1xuICAgICAgQVtldF0gPiBrW2V0XSAmJiAoYnQgPSBNcyhidCkpO1xuICAgICAgdmFyIEdpID0gTXMoYnQpLCBzZSA9IFtdO1xuICAgICAgaWYgKG8gJiYgc2UucHVzaChVW05dIDw9IDApLCBhICYmIHNlLnB1c2goVVtidF0gPD0gMCwgVVtHaV0gPD0gMCksIHNlLmV2ZXJ5KGZ1bmN0aW9uKHllKSB7XG4gICAgICAgIHJldHVybiB5ZTtcbiAgICAgIH0pKSB7XG4gICAgICAgIHggPSBTLCBPID0gITE7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgSS5zZXQoUywgc2UpO1xuICAgIH1cbiAgICBpZiAoTylcbiAgICAgIGZvciAodmFyIHFpID0gbSA/IDMgOiAxLCBtbiA9IGZ1bmN0aW9uKEh0KSB7XG4gICAgICAgIHZhciByaSA9IFQuZmluZChmdW5jdGlvbihRaSkge1xuICAgICAgICAgIHZhciBuZSA9IEkuZ2V0KFFpKTtcbiAgICAgICAgICBpZiAobmUpXG4gICAgICAgICAgICByZXR1cm4gbmUuc2xpY2UoMCwgSHQpLmV2ZXJ5KGZ1bmN0aW9uKGduKSB7XG4gICAgICAgICAgICAgIHJldHVybiBnbjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHJpKVxuICAgICAgICAgIHJldHVybiB4ID0gcmksIFwiYnJlYWtcIjtcbiAgICAgIH0sIG9pID0gcWk7IG9pID4gMDsgb2ktLSkge1xuICAgICAgICB2YXIgWmkgPSBtbihvaSk7XG4gICAgICAgIGlmIChaaSA9PT0gXCJicmVha1wiKVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIHQucGxhY2VtZW50ICE9PSB4ICYmICh0Lm1vZGlmaWVyc0RhdGFbaV0uX3NraXAgPSAhMCwgdC5wbGFjZW1lbnQgPSB4LCB0LnJlc2V0ID0gITApO1xuICB9XG59XG5jb25zdCBrYyA9IHtcbiAgbmFtZTogXCJmbGlwXCIsXG4gIGVuYWJsZWQ6ICEwLFxuICBwaGFzZTogXCJtYWluXCIsXG4gIGZuOiB5ZCxcbiAgcmVxdWlyZXNJZkV4aXN0czogW1wib2Zmc2V0XCJdLFxuICBkYXRhOiB7XG4gICAgX3NraXA6ICExXG4gIH1cbn07XG5mdW5jdGlvbiBMcihzLCB0LCBlKSB7XG4gIHJldHVybiBlID09PSB2b2lkIDAgJiYgKGUgPSB7XG4gICAgeDogMCxcbiAgICB5OiAwXG4gIH0pLCB7XG4gICAgdG9wOiBzLnRvcCAtIHQuaGVpZ2h0IC0gZS55LFxuICAgIHJpZ2h0OiBzLnJpZ2h0IC0gdC53aWR0aCArIGUueCxcbiAgICBib3R0b206IHMuYm90dG9tIC0gdC5oZWlnaHQgKyBlLnksXG4gICAgbGVmdDogcy5sZWZ0IC0gdC53aWR0aCAtIGUueFxuICB9O1xufVxuZnVuY3Rpb24gTnIocykge1xuICByZXR1cm4gW1EsIHV0LCBkdCwgSl0uc29tZShmdW5jdGlvbih0KSB7XG4gICAgcmV0dXJuIHNbdF0gPj0gMDtcbiAgfSk7XG59XG5mdW5jdGlvbiB3ZChzKSB7XG4gIHZhciB0ID0gcy5zdGF0ZSwgZSA9IHMubmFtZSwgaSA9IHQucmVjdHMucmVmZXJlbmNlLCBuID0gdC5yZWN0cy5wb3BwZXIsIG8gPSB0Lm1vZGlmaWVyc0RhdGEucHJldmVudE92ZXJmbG93LCByID0gR2UodCwge1xuICAgIGVsZW1lbnRDb250ZXh0OiBcInJlZmVyZW5jZVwiXG4gIH0pLCBhID0gR2UodCwge1xuICAgIGFsdEJvdW5kYXJ5OiAhMFxuICB9KSwgbCA9IExyKHIsIGkpLCBwID0gTHIoYSwgbiwgbyksIHUgPSBOcihsKSwgXyA9IE5yKHApO1xuICB0Lm1vZGlmaWVyc0RhdGFbZV0gPSB7XG4gICAgcmVmZXJlbmNlQ2xpcHBpbmdPZmZzZXRzOiBsLFxuICAgIHBvcHBlckVzY2FwZU9mZnNldHM6IHAsXG4gICAgaXNSZWZlcmVuY2VIaWRkZW46IHUsXG4gICAgaGFzUG9wcGVyRXNjYXBlZDogX1xuICB9LCB0LmF0dHJpYnV0ZXMucG9wcGVyID0gT2JqZWN0LmFzc2lnbih7fSwgdC5hdHRyaWJ1dGVzLnBvcHBlciwge1xuICAgIFwiZGF0YS1wb3BwZXItcmVmZXJlbmNlLWhpZGRlblwiOiB1LFxuICAgIFwiZGF0YS1wb3BwZXItZXNjYXBlZFwiOiBfXG4gIH0pO1xufVxuY29uc3QgeGMgPSB7XG4gIG5hbWU6IFwiaGlkZVwiLFxuICBlbmFibGVkOiAhMCxcbiAgcGhhc2U6IFwibWFpblwiLFxuICByZXF1aXJlc0lmRXhpc3RzOiBbXCJwcmV2ZW50T3ZlcmZsb3dcIl0sXG4gIGZuOiB3ZFxufTtcbmZ1bmN0aW9uIGtkKHMsIHQsIGUpIHtcbiAgdmFyIGkgPSBUdChzKSwgbiA9IFtKLCBRXS5pbmRleE9mKGkpID49IDAgPyAtMSA6IDEsIG8gPSB0eXBlb2YgZSA9PSBcImZ1bmN0aW9uXCIgPyBlKE9iamVjdC5hc3NpZ24oe30sIHQsIHtcbiAgICBwbGFjZW1lbnQ6IHNcbiAgfSkpIDogZSwgciA9IG9bMF0sIGEgPSBvWzFdO1xuICByZXR1cm4gciA9IHIgfHwgMCwgYSA9IChhIHx8IDApICogbiwgW0osIHV0XS5pbmRleE9mKGkpID49IDAgPyB7XG4gICAgeDogYSxcbiAgICB5OiByXG4gIH0gOiB7XG4gICAgeDogcixcbiAgICB5OiBhXG4gIH07XG59XG5mdW5jdGlvbiB4ZChzKSB7XG4gIHZhciB0ID0gcy5zdGF0ZSwgZSA9IHMub3B0aW9ucywgaSA9IHMubmFtZSwgbiA9IGUub2Zmc2V0LCBvID0gbiA9PT0gdm9pZCAwID8gWzAsIDBdIDogbiwgciA9IFFvLnJlZHVjZShmdW5jdGlvbih1LCBfKSB7XG4gICAgcmV0dXJuIHVbX10gPSBrZChfLCB0LnJlY3RzLCBvKSwgdTtcbiAgfSwge30pLCBhID0gclt0LnBsYWNlbWVudF0sIGwgPSBhLngsIHAgPSBhLnk7XG4gIHQubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzICE9IG51bGwgJiYgKHQubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzLnggKz0gbCwgdC5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHMueSArPSBwKSwgdC5tb2RpZmllcnNEYXRhW2ldID0gcjtcbn1cbmNvbnN0IE9jID0ge1xuICBuYW1lOiBcIm9mZnNldFwiLFxuICBlbmFibGVkOiAhMCxcbiAgcGhhc2U6IFwibWFpblwiLFxuICByZXF1aXJlczogW1wicG9wcGVyT2Zmc2V0c1wiXSxcbiAgZm46IHhkXG59O1xuZnVuY3Rpb24gT2Qocykge1xuICB2YXIgdCA9IHMuc3RhdGUsIGUgPSBzLm5hbWU7XG4gIHQubW9kaWZpZXJzRGF0YVtlXSA9IHdjKHtcbiAgICByZWZlcmVuY2U6IHQucmVjdHMucmVmZXJlbmNlLFxuICAgIGVsZW1lbnQ6IHQucmVjdHMucG9wcGVyLFxuICAgIHN0cmF0ZWd5OiBcImFic29sdXRlXCIsXG4gICAgcGxhY2VtZW50OiB0LnBsYWNlbWVudFxuICB9KTtcbn1cbmNvbnN0IGxyID0ge1xuICBuYW1lOiBcInBvcHBlck9mZnNldHNcIixcbiAgZW5hYmxlZDogITAsXG4gIHBoYXNlOiBcInJlYWRcIixcbiAgZm46IE9kLFxuICBkYXRhOiB7fVxufTtcbmZ1bmN0aW9uIFNkKHMpIHtcbiAgcmV0dXJuIHMgPT09IFwieFwiID8gXCJ5XCIgOiBcInhcIjtcbn1cbmZ1bmN0aW9uIElkKHMpIHtcbiAgdmFyIHQgPSBzLnN0YXRlLCBlID0gcy5vcHRpb25zLCBpID0gcy5uYW1lLCBuID0gZS5tYWluQXhpcywgbyA9IG4gPT09IHZvaWQgMCA/ICEwIDogbiwgciA9IGUuYWx0QXhpcywgYSA9IHIgPT09IHZvaWQgMCA/ICExIDogciwgbCA9IGUuYm91bmRhcnksIHAgPSBlLnJvb3RCb3VuZGFyeSwgdSA9IGUuYWx0Qm91bmRhcnksIF8gPSBlLnBhZGRpbmcsIGYgPSBlLnRldGhlciwgZyA9IGYgPT09IHZvaWQgMCA/ICEwIDogZiwgbSA9IGUudGV0aGVyT2Zmc2V0LCBiID0gbSA9PT0gdm9pZCAwID8gMCA6IG0sIHYgPSBHZSh0LCB7XG4gICAgYm91bmRhcnk6IGwsXG4gICAgcm9vdEJvdW5kYXJ5OiBwLFxuICAgIHBhZGRpbmc6IF8sXG4gICAgYWx0Qm91bmRhcnk6IHVcbiAgfSksIEMgPSBUdCh0LnBsYWNlbWVudCksIHcgPSBYZSh0LnBsYWNlbWVudCksIEUgPSAhdywgVCA9IGlyKEMpLCBBID0gU2QoVCksIGsgPSB0Lm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cywgSSA9IHQucmVjdHMucmVmZXJlbmNlLCBPID0gdC5yZWN0cy5wb3BwZXIsIHggPSB0eXBlb2YgYiA9PSBcImZ1bmN0aW9uXCIgPyBiKE9iamVjdC5hc3NpZ24oe30sIHQucmVjdHMsIHtcbiAgICBwbGFjZW1lbnQ6IHQucGxhY2VtZW50XG4gIH0pKSA6IGIsIEwgPSB0eXBlb2YgeCA9PSBcIm51bWJlclwiID8ge1xuICAgIG1haW5BeGlzOiB4LFxuICAgIGFsdEF4aXM6IHhcbiAgfSA6IE9iamVjdC5hc3NpZ24oe1xuICAgIG1haW5BeGlzOiAwLFxuICAgIGFsdEF4aXM6IDBcbiAgfSwgeCksIFMgPSB0Lm1vZGlmaWVyc0RhdGEub2Zmc2V0ID8gdC5tb2RpZmllcnNEYXRhLm9mZnNldFt0LnBsYWNlbWVudF0gOiBudWxsLCBOID0ge1xuICAgIHg6IDAsXG4gICAgeTogMFxuICB9O1xuICBpZiAoaykge1xuICAgIGlmIChvKSB7XG4gICAgICB2YXIgUCwgdHQgPSBUID09PSBcInlcIiA/IFEgOiBKLCBldCA9IFQgPT09IFwieVwiID8gZHQgOiB1dCwgVSA9IFQgPT09IFwieVwiID8gXCJoZWlnaHRcIiA6IFwid2lkdGhcIiwgYnQgPSBrW1RdLCBHaSA9IGJ0ICsgdlt0dF0sIHNlID0gYnQgLSB2W2V0XSwgcWkgPSBnID8gLU9bVV0gLyAyIDogMCwgbW4gPSB3ID09PSBUZSA/IElbVV0gOiBPW1VdLCBvaSA9IHcgPT09IFRlID8gLU9bVV0gOiAtSVtVXSwgWmkgPSB0LmVsZW1lbnRzLmFycm93LCB5ZSA9IGcgJiYgWmkgPyBlcihaaSkgOiB7XG4gICAgICAgIHdpZHRoOiAwLFxuICAgICAgICBoZWlnaHQ6IDBcbiAgICAgIH0sIEh0ID0gdC5tb2RpZmllcnNEYXRhW1wiYXJyb3cjcGVyc2lzdGVudFwiXSA/IHQubW9kaWZpZXJzRGF0YVtcImFycm93I3BlcnNpc3RlbnRcIl0ucGFkZGluZyA6IFRjKCksIHJpID0gSHRbdHRdLCBRaSA9IEh0W2V0XSwgbmUgPSBTaSgwLCBJW1VdLCB5ZVtVXSksIGduID0gRSA/IElbVV0gLyAyIC0gcWkgLSBuZSAtIHJpIC0gTC5tYWluQXhpcyA6IG1uIC0gbmUgLSByaSAtIEwubWFpbkF4aXMsIExoID0gRSA/IC1JW1VdIC8gMiArIHFpICsgbmUgKyBRaSArIEwubWFpbkF4aXMgOiBvaSArIG5lICsgUWkgKyBMLm1haW5BeGlzLCBibiA9IHQuZWxlbWVudHMuYXJyb3cgJiYgVmkodC5lbGVtZW50cy5hcnJvdyksIE5oID0gYm4gPyBUID09PSBcInlcIiA/IGJuLmNsaWVudFRvcCB8fCAwIDogYm4uY2xpZW50TGVmdCB8fCAwIDogMCwgYnIgPSAoUCA9IFMgPT0gbnVsbCA/IHZvaWQgMCA6IFNbVF0pICE9IG51bGwgPyBQIDogMCwgTWggPSBidCArIGduIC0gYnIgLSBOaCwgUmggPSBidCArIExoIC0gYnIsIHZyID0gU2koZyA/IHNuKEdpLCBNaCkgOiBHaSwgYnQsIGcgPyBiZShzZSwgUmgpIDogc2UpO1xuICAgICAga1tUXSA9IHZyLCBOW1RdID0gdnIgLSBidDtcbiAgICB9XG4gICAgaWYgKGEpIHtcbiAgICAgIHZhciBUciwgUGggPSBUID09PSBcInhcIiA/IFEgOiBKLCBCaCA9IFQgPT09IFwieFwiID8gZHQgOiB1dCwgb2UgPSBrW0FdLCBKaSA9IEEgPT09IFwieVwiID8gXCJoZWlnaHRcIiA6IFwid2lkdGhcIiwgRXIgPSBvZSArIHZbUGhdLCBDciA9IG9lIC0gdltCaF0sIHZuID0gW1EsIEpdLmluZGV4T2YoQykgIT09IC0xLCBBciA9IChUciA9IFMgPT0gbnVsbCA/IHZvaWQgMCA6IFNbQV0pICE9IG51bGwgPyBUciA6IDAsIHlyID0gdm4gPyBFciA6IG9lIC0gSVtKaV0gLSBPW0ppXSAtIEFyICsgTC5hbHRBeGlzLCB3ciA9IHZuID8gb2UgKyBJW0ppXSArIE9bSmldIC0gQXIgLSBMLmFsdEF4aXMgOiBDciwga3IgPSBnICYmIHZuID8gYWQoeXIsIG9lLCB3cikgOiBTaShnID8geXIgOiBFciwgb2UsIGcgPyB3ciA6IENyKTtcbiAgICAgIGtbQV0gPSBrciwgTltBXSA9IGtyIC0gb2U7XG4gICAgfVxuICAgIHQubW9kaWZpZXJzRGF0YVtpXSA9IE47XG4gIH1cbn1cbmNvbnN0IFNjID0ge1xuICBuYW1lOiBcInByZXZlbnRPdmVyZmxvd1wiLFxuICBlbmFibGVkOiAhMCxcbiAgcGhhc2U6IFwibWFpblwiLFxuICBmbjogSWQsXG4gIHJlcXVpcmVzSWZFeGlzdHM6IFtcIm9mZnNldFwiXVxufTtcbmZ1bmN0aW9uIERkKHMpIHtcbiAgcmV0dXJuIHtcbiAgICBzY3JvbGxMZWZ0OiBzLnNjcm9sbExlZnQsXG4gICAgc2Nyb2xsVG9wOiBzLnNjcm9sbFRvcFxuICB9O1xufVxuZnVuY3Rpb24gJGQocykge1xuICByZXR1cm4gcyA9PT0gcHQocykgfHwgIWh0KHMpID8gb3IocykgOiBEZChzKTtcbn1cbmZ1bmN0aW9uIExkKHMpIHtcbiAgdmFyIHQgPSBzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCBlID0gemUodC53aWR0aCkgLyBzLm9mZnNldFdpZHRoIHx8IDEsIGkgPSB6ZSh0LmhlaWdodCkgLyBzLm9mZnNldEhlaWdodCB8fCAxO1xuICByZXR1cm4gZSAhPT0gMSB8fCBpICE9PSAxO1xufVxuZnVuY3Rpb24gTmQocywgdCwgZSkge1xuICBlID09PSB2b2lkIDAgJiYgKGUgPSAhMSk7XG4gIHZhciBpID0gaHQodCksIG4gPSBodCh0KSAmJiBMZCh0KSwgbyA9IGVlKHQpLCByID0gVWUocywgbiwgZSksIGEgPSB7XG4gICAgc2Nyb2xsTGVmdDogMCxcbiAgICBzY3JvbGxUb3A6IDBcbiAgfSwgbCA9IHtcbiAgICB4OiAwLFxuICAgIHk6IDBcbiAgfTtcbiAgcmV0dXJuIChpIHx8ICFpICYmICFlKSAmJiAoKE10KHQpICE9PSBcImJvZHlcIiB8fCAvLyBodHRwczovL2dpdGh1Yi5jb20vcG9wcGVyanMvcG9wcGVyLWNvcmUvaXNzdWVzLzEwNzhcbiAgYXIobykpICYmIChhID0gJGQodCkpLCBodCh0KSA/IChsID0gVWUodCwgITApLCBsLnggKz0gdC5jbGllbnRMZWZ0LCBsLnkgKz0gdC5jbGllbnRUb3ApIDogbyAmJiAobC54ID0gcnIobykpKSwge1xuICAgIHg6IHIubGVmdCArIGEuc2Nyb2xsTGVmdCAtIGwueCxcbiAgICB5OiByLnRvcCArIGEuc2Nyb2xsVG9wIC0gbC55LFxuICAgIHdpZHRoOiByLndpZHRoLFxuICAgIGhlaWdodDogci5oZWlnaHRcbiAgfTtcbn1cbmZ1bmN0aW9uIE1kKHMpIHtcbiAgdmFyIHQgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLCBlID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSwgaSA9IFtdO1xuICBzLmZvckVhY2goZnVuY3Rpb24obykge1xuICAgIHQuc2V0KG8ubmFtZSwgbyk7XG4gIH0pO1xuICBmdW5jdGlvbiBuKG8pIHtcbiAgICBlLmFkZChvLm5hbWUpO1xuICAgIHZhciByID0gW10uY29uY2F0KG8ucmVxdWlyZXMgfHwgW10sIG8ucmVxdWlyZXNJZkV4aXN0cyB8fCBbXSk7XG4gICAgci5mb3JFYWNoKGZ1bmN0aW9uKGEpIHtcbiAgICAgIGlmICghZS5oYXMoYSkpIHtcbiAgICAgICAgdmFyIGwgPSB0LmdldChhKTtcbiAgICAgICAgbCAmJiBuKGwpO1xuICAgICAgfVxuICAgIH0pLCBpLnB1c2gobyk7XG4gIH1cbiAgcmV0dXJuIHMuZm9yRWFjaChmdW5jdGlvbihvKSB7XG4gICAgZS5oYXMoby5uYW1lKSB8fCBuKG8pO1xuICB9KSwgaTtcbn1cbmZ1bmN0aW9uIFJkKHMpIHtcbiAgdmFyIHQgPSBNZChzKTtcbiAgcmV0dXJuIGVuLnJlZHVjZShmdW5jdGlvbihlLCBpKSB7XG4gICAgcmV0dXJuIGUuY29uY2F0KHQuZmlsdGVyKGZ1bmN0aW9uKG4pIHtcbiAgICAgIHJldHVybiBuLnBoYXNlID09PSBpO1xuICAgIH0pKTtcbiAgfSwgW10pO1xufVxuZnVuY3Rpb24gUGQocykge1xuICB2YXIgdDtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0IHx8ICh0ID0gbmV3IFByb21pc2UoZnVuY3Rpb24oZSkge1xuICAgICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgdCA9IHZvaWQgMCwgZShzKCkpO1xuICAgICAgfSk7XG4gICAgfSkpLCB0O1xuICB9O1xufVxuZnVuY3Rpb24gVnQocykge1xuICBmb3IgKHZhciB0ID0gYXJndW1lbnRzLmxlbmd0aCwgZSA9IG5ldyBBcnJheSh0ID4gMSA/IHQgLSAxIDogMCksIGkgPSAxOyBpIDwgdDsgaSsrKVxuICAgIGVbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICByZXR1cm4gW10uY29uY2F0KGUpLnJlZHVjZShmdW5jdGlvbihuLCBvKSB7XG4gICAgcmV0dXJuIG4ucmVwbGFjZSgvJXMvLCBvKTtcbiAgfSwgcyk7XG59XG52YXIgYWUgPSAnUG9wcGVyOiBtb2RpZmllciBcIiVzXCIgcHJvdmlkZWQgYW4gaW52YWxpZCAlcyBwcm9wZXJ0eSwgZXhwZWN0ZWQgJXMgYnV0IGdvdCAlcycsIEJkID0gJ1BvcHBlcjogbW9kaWZpZXIgXCIlc1wiIHJlcXVpcmVzIFwiJXNcIiwgYnV0IFwiJXNcIiBtb2RpZmllciBpcyBub3QgYXZhaWxhYmxlJywgTXIgPSBbXCJuYW1lXCIsIFwiZW5hYmxlZFwiLCBcInBoYXNlXCIsIFwiZm5cIiwgXCJlZmZlY3RcIiwgXCJyZXF1aXJlc1wiLCBcIm9wdGlvbnNcIl07XG5mdW5jdGlvbiBIZChzKSB7XG4gIHMuZm9yRWFjaChmdW5jdGlvbih0KSB7XG4gICAgW10uY29uY2F0KE9iamVjdC5rZXlzKHQpLCBNcikuZmlsdGVyKGZ1bmN0aW9uKGUsIGksIG4pIHtcbiAgICAgIHJldHVybiBuLmluZGV4T2YoZSkgPT09IGk7XG4gICAgfSkuZm9yRWFjaChmdW5jdGlvbihlKSB7XG4gICAgICBzd2l0Y2ggKGUpIHtcbiAgICAgICAgY2FzZSBcIm5hbWVcIjpcbiAgICAgICAgICB0eXBlb2YgdC5uYW1lICE9IFwic3RyaW5nXCIgJiYgY29uc29sZS5lcnJvcihWdChhZSwgU3RyaW5nKHQubmFtZSksICdcIm5hbWVcIicsICdcInN0cmluZ1wiJywgJ1wiJyArIFN0cmluZyh0Lm5hbWUpICsgJ1wiJykpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiZW5hYmxlZFwiOlxuICAgICAgICAgIHR5cGVvZiB0LmVuYWJsZWQgIT0gXCJib29sZWFuXCIgJiYgY29uc29sZS5lcnJvcihWdChhZSwgdC5uYW1lLCAnXCJlbmFibGVkXCInLCAnXCJib29sZWFuXCInLCAnXCInICsgU3RyaW5nKHQuZW5hYmxlZCkgKyAnXCInKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJwaGFzZVwiOlxuICAgICAgICAgIGVuLmluZGV4T2YodC5waGFzZSkgPCAwICYmIGNvbnNvbGUuZXJyb3IoVnQoYWUsIHQubmFtZSwgJ1wicGhhc2VcIicsIFwiZWl0aGVyIFwiICsgZW4uam9pbihcIiwgXCIpLCAnXCInICsgU3RyaW5nKHQucGhhc2UpICsgJ1wiJykpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiZm5cIjpcbiAgICAgICAgICB0eXBlb2YgdC5mbiAhPSBcImZ1bmN0aW9uXCIgJiYgY29uc29sZS5lcnJvcihWdChhZSwgdC5uYW1lLCAnXCJmblwiJywgJ1wiZnVuY3Rpb25cIicsICdcIicgKyBTdHJpbmcodC5mbikgKyAnXCInKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJlZmZlY3RcIjpcbiAgICAgICAgICB0LmVmZmVjdCAhPSBudWxsICYmIHR5cGVvZiB0LmVmZmVjdCAhPSBcImZ1bmN0aW9uXCIgJiYgY29uc29sZS5lcnJvcihWdChhZSwgdC5uYW1lLCAnXCJlZmZlY3RcIicsICdcImZ1bmN0aW9uXCInLCAnXCInICsgU3RyaW5nKHQuZm4pICsgJ1wiJykpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwicmVxdWlyZXNcIjpcbiAgICAgICAgICB0LnJlcXVpcmVzICE9IG51bGwgJiYgIUFycmF5LmlzQXJyYXkodC5yZXF1aXJlcykgJiYgY29uc29sZS5lcnJvcihWdChhZSwgdC5uYW1lLCAnXCJyZXF1aXJlc1wiJywgJ1wiYXJyYXlcIicsICdcIicgKyBTdHJpbmcodC5yZXF1aXJlcykgKyAnXCInKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJyZXF1aXJlc0lmRXhpc3RzXCI6XG4gICAgICAgICAgQXJyYXkuaXNBcnJheSh0LnJlcXVpcmVzSWZFeGlzdHMpIHx8IGNvbnNvbGUuZXJyb3IoVnQoYWUsIHQubmFtZSwgJ1wicmVxdWlyZXNJZkV4aXN0c1wiJywgJ1wiYXJyYXlcIicsICdcIicgKyBTdHJpbmcodC5yZXF1aXJlc0lmRXhpc3RzKSArICdcIicpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIm9wdGlvbnNcIjpcbiAgICAgICAgY2FzZSBcImRhdGFcIjpcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdQb3BwZXJKUzogYW4gaW52YWxpZCBwcm9wZXJ0eSBoYXMgYmVlbiBwcm92aWRlZCB0byB0aGUgXCInICsgdC5uYW1lICsgJ1wiIG1vZGlmaWVyLCB2YWxpZCBwcm9wZXJ0aWVzIGFyZSAnICsgTXIubWFwKGZ1bmN0aW9uKGkpIHtcbiAgICAgICAgICAgIHJldHVybiAnXCInICsgaSArICdcIic7XG4gICAgICAgICAgfSkuam9pbihcIiwgXCIpICsgJzsgYnV0IFwiJyArIGUgKyAnXCIgd2FzIHByb3ZpZGVkLicpO1xuICAgICAgfVxuICAgICAgdC5yZXF1aXJlcyAmJiB0LnJlcXVpcmVzLmZvckVhY2goZnVuY3Rpb24oaSkge1xuICAgICAgICBzLmZpbmQoZnVuY3Rpb24obikge1xuICAgICAgICAgIHJldHVybiBuLm5hbWUgPT09IGk7XG4gICAgICAgIH0pID09IG51bGwgJiYgY29uc29sZS5lcnJvcihWdChCZCwgU3RyaW5nKHQubmFtZSksIGksIGkpKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcbn1cbmZ1bmN0aW9uIFZkKHMsIHQpIHtcbiAgdmFyIGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICByZXR1cm4gcy5maWx0ZXIoZnVuY3Rpb24oaSkge1xuICAgIHZhciBuID0gdChpKTtcbiAgICBpZiAoIWUuaGFzKG4pKVxuICAgICAgcmV0dXJuIGUuYWRkKG4pLCAhMDtcbiAgfSk7XG59XG5mdW5jdGlvbiBXZChzKSB7XG4gIHZhciB0ID0gcy5yZWR1Y2UoZnVuY3Rpb24oZSwgaSkge1xuICAgIHZhciBuID0gZVtpLm5hbWVdO1xuICAgIHJldHVybiBlW2kubmFtZV0gPSBuID8gT2JqZWN0LmFzc2lnbih7fSwgbiwgaSwge1xuICAgICAgb3B0aW9uczogT2JqZWN0LmFzc2lnbih7fSwgbi5vcHRpb25zLCBpLm9wdGlvbnMpLFxuICAgICAgZGF0YTogT2JqZWN0LmFzc2lnbih7fSwgbi5kYXRhLCBpLmRhdGEpXG4gICAgfSkgOiBpLCBlO1xuICB9LCB7fSk7XG4gIHJldHVybiBPYmplY3Qua2V5cyh0KS5tYXAoZnVuY3Rpb24oZSkge1xuICAgIHJldHVybiB0W2VdO1xuICB9KTtcbn1cbnZhciBSciA9IFwiUG9wcGVyOiBJbnZhbGlkIHJlZmVyZW5jZSBvciBwb3BwZXIgYXJndW1lbnQgcHJvdmlkZWQuIFRoZXkgbXVzdCBiZSBlaXRoZXIgYSBET00gZWxlbWVudCBvciB2aXJ0dWFsIGVsZW1lbnQuXCIsIEZkID0gXCJQb3BwZXI6IEFuIGluZmluaXRlIGxvb3AgaW4gdGhlIG1vZGlmaWVycyBjeWNsZSBoYXMgYmVlbiBkZXRlY3RlZCEgVGhlIGN5Y2xlIGhhcyBiZWVuIGludGVycnVwdGVkIHRvIHByZXZlbnQgYSBicm93c2VyIGNyYXNoLlwiLCBQciA9IHtcbiAgcGxhY2VtZW50OiBcImJvdHRvbVwiLFxuICBtb2RpZmllcnM6IFtdLFxuICBzdHJhdGVneTogXCJhYnNvbHV0ZVwiXG59O1xuZnVuY3Rpb24gQnIoKSB7XG4gIGZvciAodmFyIHMgPSBhcmd1bWVudHMubGVuZ3RoLCB0ID0gbmV3IEFycmF5KHMpLCBlID0gMDsgZSA8IHM7IGUrKylcbiAgICB0W2VdID0gYXJndW1lbnRzW2VdO1xuICByZXR1cm4gIXQuc29tZShmdW5jdGlvbihpKSB7XG4gICAgcmV0dXJuICEoaSAmJiB0eXBlb2YgaS5nZXRCb3VuZGluZ0NsaWVudFJlY3QgPT0gXCJmdW5jdGlvblwiKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBhbihzKSB7XG4gIHMgPT09IHZvaWQgMCAmJiAocyA9IHt9KTtcbiAgdmFyIHQgPSBzLCBlID0gdC5kZWZhdWx0TW9kaWZpZXJzLCBpID0gZSA9PT0gdm9pZCAwID8gW10gOiBlLCBuID0gdC5kZWZhdWx0T3B0aW9ucywgbyA9IG4gPT09IHZvaWQgMCA/IFByIDogbjtcbiAgcmV0dXJuIGZ1bmN0aW9uKGEsIGwsIHApIHtcbiAgICBwID09PSB2b2lkIDAgJiYgKHAgPSBvKTtcbiAgICB2YXIgdSA9IHtcbiAgICAgIHBsYWNlbWVudDogXCJib3R0b21cIixcbiAgICAgIG9yZGVyZWRNb2RpZmllcnM6IFtdLFxuICAgICAgb3B0aW9uczogT2JqZWN0LmFzc2lnbih7fSwgUHIsIG8pLFxuICAgICAgbW9kaWZpZXJzRGF0YToge30sXG4gICAgICBlbGVtZW50czoge1xuICAgICAgICByZWZlcmVuY2U6IGEsXG4gICAgICAgIHBvcHBlcjogbFxuICAgICAgfSxcbiAgICAgIGF0dHJpYnV0ZXM6IHt9LFxuICAgICAgc3R5bGVzOiB7fVxuICAgIH0sIF8gPSBbXSwgZiA9ICExLCBnID0ge1xuICAgICAgc3RhdGU6IHUsXG4gICAgICBzZXRPcHRpb25zOiBmdW5jdGlvbihDKSB7XG4gICAgICAgIHZhciB3ID0gdHlwZW9mIEMgPT0gXCJmdW5jdGlvblwiID8gQyh1Lm9wdGlvbnMpIDogQztcbiAgICAgICAgYigpLCB1Lm9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvLCB1Lm9wdGlvbnMsIHcpLCB1LnNjcm9sbFBhcmVudHMgPSB7XG4gICAgICAgICAgcmVmZXJlbmNlOiBFZShhKSA/IElpKGEpIDogYS5jb250ZXh0RWxlbWVudCA/IElpKGEuY29udGV4dEVsZW1lbnQpIDogW10sXG4gICAgICAgICAgcG9wcGVyOiBJaShsKVxuICAgICAgICB9O1xuICAgICAgICB2YXIgRSA9IFJkKFdkKFtdLmNvbmNhdChpLCB1Lm9wdGlvbnMubW9kaWZpZXJzKSkpO1xuICAgICAgICBpZiAodS5vcmRlcmVkTW9kaWZpZXJzID0gRS5maWx0ZXIoZnVuY3Rpb24oUykge1xuICAgICAgICAgIHJldHVybiBTLmVuYWJsZWQ7XG4gICAgICAgIH0pLCB7fS5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICB2YXIgVCA9IFZkKFtdLmNvbmNhdChFLCB1Lm9wdGlvbnMubW9kaWZpZXJzKSwgZnVuY3Rpb24oUykge1xuICAgICAgICAgICAgdmFyIE4gPSBTLm5hbWU7XG4gICAgICAgICAgICByZXR1cm4gTjtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAoSGQoVCksIFR0KHUub3B0aW9ucy5wbGFjZW1lbnQpID09PSBIaSkge1xuICAgICAgICAgICAgdmFyIEEgPSB1Lm9yZGVyZWRNb2RpZmllcnMuZmluZChmdW5jdGlvbihTKSB7XG4gICAgICAgICAgICAgIHZhciBOID0gUy5uYW1lO1xuICAgICAgICAgICAgICByZXR1cm4gTiA9PT0gXCJmbGlwXCI7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIEEgfHwgY29uc29sZS5lcnJvcihbJ1BvcHBlcjogXCJhdXRvXCIgcGxhY2VtZW50cyByZXF1aXJlIHRoZSBcImZsaXBcIiBtb2RpZmllciBiZScsIFwicHJlc2VudCBhbmQgZW5hYmxlZCB0byB3b3JrLlwiXS5qb2luKFwiIFwiKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBrID0gQ3QobCksIEkgPSBrLm1hcmdpblRvcCwgTyA9IGsubWFyZ2luUmlnaHQsIHggPSBrLm1hcmdpbkJvdHRvbSwgTCA9IGsubWFyZ2luTGVmdDtcbiAgICAgICAgICBbSSwgTywgeCwgTF0uc29tZShmdW5jdGlvbihTKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VGbG9hdChTKTtcbiAgICAgICAgICB9KSAmJiBjb25zb2xlLndhcm4oWydQb3BwZXI6IENTUyBcIm1hcmdpblwiIHN0eWxlcyBjYW5ub3QgYmUgdXNlZCB0byBhcHBseSBwYWRkaW5nJywgXCJiZXR3ZWVuIHRoZSBwb3BwZXIgYW5kIGl0cyByZWZlcmVuY2UgZWxlbWVudCBvciBib3VuZGFyeS5cIiwgXCJUbyByZXBsaWNhdGUgbWFyZ2luLCB1c2UgdGhlIGBvZmZzZXRgIG1vZGlmaWVyLCBhcyB3ZWxsIGFzXCIsIFwidGhlIGBwYWRkaW5nYCBvcHRpb24gaW4gdGhlIGBwcmV2ZW50T3ZlcmZsb3dgIGFuZCBgZmxpcGBcIiwgXCJtb2RpZmllcnMuXCJdLmpvaW4oXCIgXCIpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbSgpLCBnLnVwZGF0ZSgpO1xuICAgICAgfSxcbiAgICAgIC8vIFN5bmMgdXBkYXRlIOKAkyBpdCB3aWxsIGFsd2F5cyBiZSBleGVjdXRlZCwgZXZlbiBpZiBub3QgbmVjZXNzYXJ5LiBUaGlzXG4gICAgICAvLyBpcyB1c2VmdWwgZm9yIGxvdyBmcmVxdWVuY3kgdXBkYXRlcyB3aGVyZSBzeW5jIGJlaGF2aW9yIHNpbXBsaWZpZXMgdGhlXG4gICAgICAvLyBsb2dpYy5cbiAgICAgIC8vIEZvciBoaWdoIGZyZXF1ZW5jeSB1cGRhdGVzIChlLmcuIGByZXNpemVgIGFuZCBgc2Nyb2xsYCBldmVudHMpLCBhbHdheXNcbiAgICAgIC8vIHByZWZlciB0aGUgYXN5bmMgUG9wcGVyI3VwZGF0ZSBtZXRob2RcbiAgICAgIGZvcmNlVXBkYXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCFmKSB7XG4gICAgICAgICAgdmFyIEMgPSB1LmVsZW1lbnRzLCB3ID0gQy5yZWZlcmVuY2UsIEUgPSBDLnBvcHBlcjtcbiAgICAgICAgICBpZiAoIUJyKHcsIEUpKSB7XG4gICAgICAgICAgICAoe30pLk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBjb25zb2xlLmVycm9yKFJyKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdS5yZWN0cyA9IHtcbiAgICAgICAgICAgIHJlZmVyZW5jZTogTmQodywgVmkoRSksIHUub3B0aW9ucy5zdHJhdGVneSA9PT0gXCJmaXhlZFwiKSxcbiAgICAgICAgICAgIHBvcHBlcjogZXIoRSlcbiAgICAgICAgICB9LCB1LnJlc2V0ID0gITEsIHUucGxhY2VtZW50ID0gdS5vcHRpb25zLnBsYWNlbWVudCwgdS5vcmRlcmVkTW9kaWZpZXJzLmZvckVhY2goZnVuY3Rpb24oUykge1xuICAgICAgICAgICAgcmV0dXJuIHUubW9kaWZpZXJzRGF0YVtTLm5hbWVdID0gT2JqZWN0LmFzc2lnbih7fSwgUy5kYXRhKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBmb3IgKHZhciBUID0gMCwgQSA9IDA7IEEgPCB1Lm9yZGVyZWRNb2RpZmllcnMubGVuZ3RoOyBBKyspIHtcbiAgICAgICAgICAgIGlmICh7fS5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgKFQgKz0gMSwgVCA+IDEwMCkpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihGZCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHUucmVzZXQgPT09ICEwKSB7XG4gICAgICAgICAgICAgIHUucmVzZXQgPSAhMSwgQSA9IC0xO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBrID0gdS5vcmRlcmVkTW9kaWZpZXJzW0FdLCBJID0gay5mbiwgTyA9IGsub3B0aW9ucywgeCA9IE8gPT09IHZvaWQgMCA/IHt9IDogTywgTCA9IGsubmFtZTtcbiAgICAgICAgICAgIHR5cGVvZiBJID09IFwiZnVuY3Rpb25cIiAmJiAodSA9IEkoe1xuICAgICAgICAgICAgICBzdGF0ZTogdSxcbiAgICAgICAgICAgICAgb3B0aW9uczogeCxcbiAgICAgICAgICAgICAgbmFtZTogTCxcbiAgICAgICAgICAgICAgaW5zdGFuY2U6IGdcbiAgICAgICAgICAgIH0pIHx8IHUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIC8vIEFzeW5jIGFuZCBvcHRpbWlzdGljYWxseSBvcHRpbWl6ZWQgdXBkYXRlIOKAkyBpdCB3aWxsIG5vdCBiZSBleGVjdXRlZCBpZlxuICAgICAgLy8gbm90IG5lY2Vzc2FyeSAoZGVib3VuY2VkIHRvIHJ1biBhdCBtb3N0IG9uY2UtcGVyLXRpY2spXG4gICAgICB1cGRhdGU6IFBkKGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24odikge1xuICAgICAgICAgIGcuZm9yY2VVcGRhdGUoKSwgdih1KTtcbiAgICAgICAgfSk7XG4gICAgICB9KSxcbiAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuICAgICAgICBiKCksIGYgPSAhMDtcbiAgICAgIH1cbiAgICB9O1xuICAgIGlmICghQnIoYSwgbCkpXG4gICAgICByZXR1cm4ge30uTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIGNvbnNvbGUuZXJyb3IoUnIpLCBnO1xuICAgIGcuc2V0T3B0aW9ucyhwKS50aGVuKGZ1bmN0aW9uKHYpIHtcbiAgICAgICFmICYmIHAub25GaXJzdFVwZGF0ZSAmJiBwLm9uRmlyc3RVcGRhdGUodik7XG4gICAgfSk7XG4gICAgZnVuY3Rpb24gbSgpIHtcbiAgICAgIHUub3JkZXJlZE1vZGlmaWVycy5mb3JFYWNoKGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgdmFyIEMgPSB2Lm5hbWUsIHcgPSB2Lm9wdGlvbnMsIEUgPSB3ID09PSB2b2lkIDAgPyB7fSA6IHcsIFQgPSB2LmVmZmVjdDtcbiAgICAgICAgaWYgKHR5cGVvZiBUID09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIHZhciBBID0gVCh7XG4gICAgICAgICAgICBzdGF0ZTogdSxcbiAgICAgICAgICAgIG5hbWU6IEMsXG4gICAgICAgICAgICBpbnN0YW5jZTogZyxcbiAgICAgICAgICAgIG9wdGlvbnM6IEVcbiAgICAgICAgICB9KSwgayA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIH07XG4gICAgICAgICAgXy5wdXNoKEEgfHwgayk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBiKCkge1xuICAgICAgXy5mb3JFYWNoKGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgcmV0dXJuIHYoKTtcbiAgICAgIH0pLCBfID0gW107XG4gICAgfVxuICAgIHJldHVybiBnO1xuICB9O1xufVxudmFyIFlkID0gLyogQF9fUFVSRV9fICovIGFuKCksIGpkID0gW25yLCBsciwgc3IsIHRyXSwgS2QgPSAvKiBAX19QVVJFX18gKi8gYW4oe1xuICBkZWZhdWx0TW9kaWZpZXJzOiBqZFxufSksIHpkID0gW25yLCBsciwgc3IsIHRyLCBPYywga2MsIFNjLCBBYywgeGNdLCBDZSA9IC8qIEBfX1BVUkVfXyAqLyBhbih7XG4gIGRlZmF1bHRNb2RpZmllcnM6IHpkXG59KTtcbmNvbnN0IEljID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5mcmVlemUoLyogQF9fUFVSRV9fICovIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgYWZ0ZXJNYWluOiBfYyxcbiAgYWZ0ZXJSZWFkOiBkYyxcbiAgYWZ0ZXJXcml0ZTogZ2MsXG4gIGFwcGx5U3R5bGVzOiB0cixcbiAgYXJyb3c6IEFjLFxuICBhdXRvOiBIaSxcbiAgYmFzZVBsYWNlbWVudHM6IHRpLFxuICBiZWZvcmVNYWluOiB1YyxcbiAgYmVmb3JlUmVhZDogY2MsXG4gIGJlZm9yZVdyaXRlOiBmYyxcbiAgYm90dG9tOiBkdCxcbiAgY2xpcHBpbmdQYXJlbnRzOiBhYyxcbiAgY29tcHV0ZVN0eWxlczogc3IsXG4gIGNyZWF0ZVBvcHBlcjogQ2UsXG4gIGNyZWF0ZVBvcHBlckJhc2U6IFlkLFxuICBjcmVhdGVQb3BwZXJMaXRlOiBLZCxcbiAgZGV0ZWN0T3ZlcmZsb3c6IEdlLFxuICBlbmQ6IEtlLFxuICBldmVudExpc3RlbmVyczogbnIsXG4gIGZsaXA6IGtjLFxuICBoaWRlOiB4YyxcbiAgbGVmdDogSixcbiAgbWFpbjogcGMsXG4gIG1vZGlmaWVyUGhhc2VzOiBlbixcbiAgb2Zmc2V0OiBPYyxcbiAgcGxhY2VtZW50czogUW8sXG4gIHBvcHBlcjogJGUsXG4gIHBvcHBlckdlbmVyYXRvcjogYW4sXG4gIHBvcHBlck9mZnNldHM6IGxyLFxuICBwcmV2ZW50T3ZlcmZsb3c6IFNjLFxuICByZWFkOiBoYyxcbiAgcmVmZXJlbmNlOiBsYyxcbiAgcmlnaHQ6IHV0LFxuICBzdGFydDogVGUsXG4gIHRvcDogUSxcbiAgdmFyaWF0aW9uUGxhY2VtZW50czogU28sXG4gIHZpZXdwb3J0OiBabyxcbiAgd3JpdGU6IG1jXG59LCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6IFwiTW9kdWxlXCIgfSkpO1xuZnVuY3Rpb24gQW4ocykge1xuICByZXR1cm4gcyA9PT0gXCJ0cnVlXCIgPyAhMCA6IHMgPT09IFwiZmFsc2VcIiA/ICExIDogcyA9PT0gTnVtYmVyKHMpLnRvU3RyaW5nKCkgPyBOdW1iZXIocykgOiBzID09PSBcIlwiIHx8IHMgPT09IFwibnVsbFwiID8gbnVsbCA6IHM7XG59XG5mdW5jdGlvbiB5bihzKSB7XG4gIHJldHVybiBzLnJlcGxhY2UoL1tBLVpdL2csICh0KSA9PiBgLSR7dC50b0xvd2VyQ2FzZSgpfWApO1xufVxuY29uc3QgaCA9IHtcbiAgc2V0RGF0YUF0dHJpYnV0ZShzLCB0LCBlKSB7XG4gICAgcy5zZXRBdHRyaWJ1dGUoYGRhdGEtdGUtJHt5bih0KX1gLCBlKTtcbiAgfSxcbiAgcmVtb3ZlRGF0YUF0dHJpYnV0ZShzLCB0KSB7XG4gICAgcy5yZW1vdmVBdHRyaWJ1dGUoYGRhdGEtdGUtJHt5bih0KX1gKTtcbiAgfSxcbiAgZ2V0RGF0YUF0dHJpYnV0ZXMocykge1xuICAgIGlmICghcylcbiAgICAgIHJldHVybiB7fTtcbiAgICBjb25zdCB0ID0ge307XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHMuZGF0YXNldCkuZmlsdGVyKChlKSA9PiBlLnN0YXJ0c1dpdGgoXCJ0ZVwiKSkuZm9yRWFjaCgoZSkgPT4ge1xuICAgICAgaWYgKGUuc3RhcnRzV2l0aChcInRlQ2xhc3NcIikpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGxldCBpID0gZS5yZXBsYWNlKC9edGUvLCBcIlwiKTtcbiAgICAgIGkgPSBpLmNoYXJBdCgwKS50b0xvd2VyQ2FzZSgpICsgaS5zbGljZSgxLCBpLmxlbmd0aCksIHRbaV0gPSBBbihzLmRhdGFzZXRbZV0pO1xuICAgIH0pLCB0O1xuICB9LFxuICBnZXREYXRhQ2xhc3NBdHRyaWJ1dGVzKHMpIHtcbiAgICBpZiAoIXMpXG4gICAgICByZXR1cm4ge307XG4gICAgY29uc3QgdCA9IHtcbiAgICAgIC4uLnMuZGF0YXNldFxuICAgIH07XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHQpLmZpbHRlcigoZSkgPT4gZS5zdGFydHNXaXRoKFwidGVDbGFzc1wiKSkuZm9yRWFjaCgoZSkgPT4ge1xuICAgICAgbGV0IGkgPSBlLnJlcGxhY2UoL150ZUNsYXNzLywgXCJcIik7XG4gICAgICBpID0gaS5jaGFyQXQoMCkudG9Mb3dlckNhc2UoKSArIGkuc2xpY2UoMSwgaS5sZW5ndGgpLCB0W2ldID0gQW4odFtlXSk7XG4gICAgfSksIHQ7XG4gIH0sXG4gIGdldERhdGFBdHRyaWJ1dGUocywgdCkge1xuICAgIHJldHVybiBBbihcbiAgICAgIHMuZ2V0QXR0cmlidXRlKGBkYXRhLXRlLSR7eW4odCl9YClcbiAgICApO1xuICB9LFxuICBvZmZzZXQocykge1xuICAgIGNvbnN0IHQgPSBzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHJldHVybiB7XG4gICAgICB0b3A6IHQudG9wICsgZG9jdW1lbnQuYm9keS5zY3JvbGxUb3AsXG4gICAgICBsZWZ0OiB0LmxlZnQgKyBkb2N1bWVudC5ib2R5LnNjcm9sbExlZnRcbiAgICB9O1xuICB9LFxuICBwb3NpdGlvbihzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRvcDogcy5vZmZzZXRUb3AsXG4gICAgICBsZWZ0OiBzLm9mZnNldExlZnRcbiAgICB9O1xuICB9LFxuICBzdHlsZShzLCB0KSB7XG4gICAgT2JqZWN0LmFzc2lnbihzLnN0eWxlLCB0KTtcbiAgfSxcbiAgdG9nZ2xlQ2xhc3MocywgdCkge1xuICAgIHMgJiYgd24odCkuZm9yRWFjaCgoZSkgPT4ge1xuICAgICAgcy5jbGFzc0xpc3QuY29udGFpbnMoZSkgPyBzLmNsYXNzTGlzdC5yZW1vdmUoZSkgOiBzLmNsYXNzTGlzdC5hZGQoZSk7XG4gICAgfSk7XG4gIH0sXG4gIGFkZENsYXNzKHMsIHQpIHtcbiAgICB3bih0KS5mb3JFYWNoKFxuICAgICAgKGUpID0+ICFzLmNsYXNzTGlzdC5jb250YWlucyhlKSAmJiBzLmNsYXNzTGlzdC5hZGQoZSlcbiAgICApO1xuICB9LFxuICBhZGRTdHlsZShzLCB0KSB7XG4gICAgT2JqZWN0LmtleXModCkuZm9yRWFjaCgoZSkgPT4ge1xuICAgICAgcy5zdHlsZVtlXSA9IHRbZV07XG4gICAgfSk7XG4gIH0sXG4gIHJlbW92ZUNsYXNzKHMsIHQpIHtcbiAgICB3bih0KS5mb3JFYWNoKFxuICAgICAgKGUpID0+IHMuY2xhc3NMaXN0LmNvbnRhaW5zKGUpICYmIHMuY2xhc3NMaXN0LnJlbW92ZShlKVxuICAgICk7XG4gIH0sXG4gIGhhc0NsYXNzKHMsIHQpIHtcbiAgICByZXR1cm4gcy5jbGFzc0xpc3QuY29udGFpbnModCk7XG4gIH0sXG4gIG1heE9mZnNldChzKSB7XG4gICAgY29uc3QgdCA9IHMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRvcDogdC50b3AgKyBNYXRoLm1heChcbiAgICAgICAgZG9jdW1lbnQuYm9keS5zY3JvbGxUb3AsXG4gICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3AsXG4gICAgICAgIHdpbmRvdy5zY3JvbGxZXG4gICAgICApLFxuICAgICAgbGVmdDogdC5sZWZ0ICsgTWF0aC5tYXgoXG4gICAgICAgIGRvY3VtZW50LmJvZHkuc2Nyb2xsTGVmdCxcbiAgICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbExlZnQsXG4gICAgICAgIHdpbmRvdy5zY3JvbGxYXG4gICAgICApXG4gICAgfTtcbiAgfVxufTtcbmZ1bmN0aW9uIHduKHMpIHtcbiAgcmV0dXJuIHR5cGVvZiBzID09IFwic3RyaW5nXCIgPyBzLnNwbGl0KFwiIFwiKSA6IEFycmF5LmlzQXJyYXkocykgPyBzIDogITE7XG59XG5jb25zdCBVZCA9IDMsIGQgPSB7XG4gIGNsb3Nlc3QocywgdCkge1xuICAgIHJldHVybiBzLmNsb3Nlc3QodCk7XG4gIH0sXG4gIG1hdGNoZXMocywgdCkge1xuICAgIHJldHVybiBzLm1hdGNoZXModCk7XG4gIH0sXG4gIGZpbmQocywgdCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkge1xuICAgIHJldHVybiBbXS5jb25jYXQoXG4gICAgICAuLi5FbGVtZW50LnByb3RvdHlwZS5xdWVyeVNlbGVjdG9yQWxsLmNhbGwodCwgcylcbiAgICApO1xuICB9LFxuICBmaW5kT25lKHMsIHQgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpIHtcbiAgICByZXR1cm4gRWxlbWVudC5wcm90b3R5cGUucXVlcnlTZWxlY3Rvci5jYWxsKHQsIHMpO1xuICB9LFxuICBjaGlsZHJlbihzLCB0KSB7XG4gICAgcmV0dXJuIFtdLmNvbmNhdCguLi5zLmNoaWxkcmVuKS5maWx0ZXIoKGkpID0+IGkubWF0Y2hlcyh0KSk7XG4gIH0sXG4gIHBhcmVudHMocywgdCkge1xuICAgIGNvbnN0IGUgPSBbXTtcbiAgICBsZXQgaSA9IHMucGFyZW50Tm9kZTtcbiAgICBmb3IgKDsgaSAmJiBpLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSAmJiBpLm5vZGVUeXBlICE9PSBVZDsgKVxuICAgICAgdGhpcy5tYXRjaGVzKGksIHQpICYmIGUucHVzaChpKSwgaSA9IGkucGFyZW50Tm9kZTtcbiAgICByZXR1cm4gZTtcbiAgfSxcbiAgcHJldihzLCB0KSB7XG4gICAgbGV0IGUgPSBzLnByZXZpb3VzRWxlbWVudFNpYmxpbmc7XG4gICAgZm9yICg7IGU7ICkge1xuICAgICAgaWYgKGUubWF0Y2hlcyh0KSlcbiAgICAgICAgcmV0dXJuIFtlXTtcbiAgICAgIGUgPSBlLnByZXZpb3VzRWxlbWVudFNpYmxpbmc7XG4gICAgfVxuICAgIHJldHVybiBbXTtcbiAgfSxcbiAgbmV4dChzLCB0KSB7XG4gICAgbGV0IGUgPSBzLm5leHRFbGVtZW50U2libGluZztcbiAgICBmb3IgKDsgZTsgKSB7XG4gICAgICBpZiAodGhpcy5tYXRjaGVzKGUsIHQpKVxuICAgICAgICByZXR1cm4gW2VdO1xuICAgICAgZSA9IGUubmV4dEVsZW1lbnRTaWJsaW5nO1xuICAgIH1cbiAgICByZXR1cm4gW107XG4gIH0sXG4gIGZvY3VzYWJsZUNoaWxkcmVuKHMpIHtcbiAgICBjb25zdCB0ID0gW1xuICAgICAgXCJhXCIsXG4gICAgICBcImJ1dHRvblwiLFxuICAgICAgXCJpbnB1dFwiLFxuICAgICAgXCJ0ZXh0YXJlYVwiLFxuICAgICAgXCJzZWxlY3RcIixcbiAgICAgIFwiZGV0YWlsc1wiLFxuICAgICAgXCJbdGFiaW5kZXhdXCIsXG4gICAgICAnW2NvbnRlbnRlZGl0YWJsZT1cInRydWVcIl0nXG4gICAgXS5tYXAoKGUpID0+IGAke2V9Om5vdChbdGFiaW5kZXhePVwiLVwiXSlgKS5qb2luKFwiLCBcIik7XG4gICAgcmV0dXJuIHRoaXMuZmluZCh0LCBzKS5maWx0ZXIoXG4gICAgICAoZSkgPT4gIWdlKGUpICYmIE50KGUpXG4gICAgKTtcbiAgfVxufSwga24gPSBcImRyb3Bkb3duXCIsIFhkID0gXCJ0ZS5kcm9wZG93blwiLCBBZSA9IGAuJHtYZH1gLCBjciA9IFwiLmRhdGEtYXBpXCIsIFJzID0gXCJFc2NhcGVcIiwgSHIgPSBcIlNwYWNlXCIsIFZyID0gXCJUYWJcIiwgJG8gPSBcIkFycm93VXBcIiwgUHMgPSBcIkFycm93RG93blwiLCBHZCA9IDIsIHFkID0gbmV3IFJlZ0V4cChcbiAgYCR7JG99fCR7UHN9fCR7UnN9YFxuKSwgWmQgPSBgaGlkZSR7QWV9YCwgUWQgPSBgaGlkZGVuJHtBZX1gLCBKZCA9IGBzaG93JHtBZX1gLCB0dSA9IGBzaG93biR7QWV9YCwgZXUgPSBgY2xpY2ske0FlfSR7Y3J9YCwgV3IgPSBga2V5ZG93biR7QWV9JHtjcn1gLCBpdSA9IGBrZXl1cCR7QWV9JHtjcn1gLCBXdCA9IFwic2hvd1wiLCBzdSA9IFwiZHJvcHVwXCIsIG51ID0gXCJkcm9wZW5kXCIsIG91ID0gXCJkcm9wc3RhcnRcIiwgcnUgPSBcIltkYXRhLXRlLW5hdmJhci1yZWZdXCIsIGVzID0gXCJbZGF0YS10ZS1kcm9wZG93bi10b2dnbGUtcmVmXVwiLCB4biA9IFwiW2RhdGEtdGUtZHJvcGRvd24tbWVudS1yZWZdXCIsIGF1ID0gXCJbZGF0YS10ZS1uYXZiYXItbmF2LXJlZl1cIiwgbHUgPSBcIltkYXRhLXRlLWRyb3Bkb3duLW1lbnUtcmVmXSBbZGF0YS10ZS1kcm9wZG93bi1pdGVtLXJlZl06bm90KC5kaXNhYmxlZCk6bm90KDpkaXNhYmxlZClcIiwgY3UgPSBGKCkgPyBcInRvcC1lbmRcIiA6IFwidG9wLXN0YXJ0XCIsIGh1ID0gRigpID8gXCJ0b3Atc3RhcnRcIiA6IFwidG9wLWVuZFwiLCBkdSA9IEYoKSA/IFwiYm90dG9tLWVuZFwiIDogXCJib3R0b20tc3RhcnRcIiwgdXUgPSBGKCkgPyBcImJvdHRvbS1zdGFydFwiIDogXCJib3R0b20tZW5kXCIsIHB1ID0gRigpID8gXCJsZWZ0LXN0YXJ0XCIgOiBcInJpZ2h0LXN0YXJ0XCIsIF91ID0gRigpID8gXCJyaWdodC1zdGFydFwiIDogXCJsZWZ0LXN0YXJ0XCIsIGZ1ID0gW3sgb3BhY2l0eTogXCIwXCIgfSwgeyBvcGFjaXR5OiBcIjFcIiB9XSwgbXUgPSBbeyBvcGFjaXR5OiBcIjFcIiB9LCB7IG9wYWNpdHk6IFwiMFwiIH1dLCBpcyA9IHtcbiAgZHVyYXRpb246IDU1MCxcbiAgaXRlcmF0aW9uczogMSxcbiAgZWFzaW5nOiBcImVhc2VcIixcbiAgZmlsbDogXCJib3RoXCJcbn0sIGd1ID0ge1xuICBvZmZzZXQ6IFswLCAyXSxcbiAgYm91bmRhcnk6IFwiY2xpcHBpbmdQYXJlbnRzXCIsXG4gIHJlZmVyZW5jZTogXCJ0b2dnbGVcIixcbiAgZGlzcGxheTogXCJkeW5hbWljXCIsXG4gIHBvcHBlckNvbmZpZzogbnVsbCxcbiAgYXV0b0Nsb3NlOiAhMCxcbiAgZHJvcGRvd25BbmltYXRpb246IFwib25cIlxufSwgYnUgPSB7XG4gIG9mZnNldDogXCIoYXJyYXl8c3RyaW5nfGZ1bmN0aW9uKVwiLFxuICBib3VuZGFyeTogXCIoc3RyaW5nfGVsZW1lbnQpXCIsXG4gIHJlZmVyZW5jZTogXCIoc3RyaW5nfGVsZW1lbnR8b2JqZWN0KVwiLFxuICBkaXNwbGF5OiBcInN0cmluZ1wiLFxuICBwb3BwZXJDb25maWc6IFwiKG51bGx8b2JqZWN0fGZ1bmN0aW9uKVwiLFxuICBhdXRvQ2xvc2U6IFwiKGJvb2xlYW58c3RyaW5nKVwiLFxuICBkcm9wZG93bkFuaW1hdGlvbjogXCJzdHJpbmdcIlxufTtcbmNsYXNzIER0IGV4dGVuZHMgZ3Qge1xuICBjb25zdHJ1Y3Rvcih0LCBlKSB7XG4gICAgc3VwZXIodCksIHRoaXMuX3BvcHBlciA9IG51bGwsIHRoaXMuX2NvbmZpZyA9IHRoaXMuX2dldENvbmZpZyhlKSwgdGhpcy5fbWVudSA9IHRoaXMuX2dldE1lbnVFbGVtZW50KCksIHRoaXMuX2luTmF2YmFyID0gdGhpcy5fZGV0ZWN0TmF2YmFyKCksIHRoaXMuX2ZhZGVPdXRBbmltYXRlID0gbnVsbDtcbiAgICBjb25zdCBpID0gd2luZG93Lm1hdGNoTWVkaWEoXG4gICAgICBcIihwcmVmZXJzLXJlZHVjZWQtbW90aW9uOiByZWR1Y2UpXCJcbiAgICApLm1hdGNoZXM7XG4gICAgdGhpcy5fYW5pbWF0aW9uQ2FuUGxheSA9IHRoaXMuX2NvbmZpZy5kcm9wZG93bkFuaW1hdGlvbiA9PT0gXCJvblwiICYmICFpLCB0aGlzLl9kaWRJbml0ID0gITEsIHRoaXMuX2luaXQoKTtcbiAgfVxuICAvLyBHZXR0ZXJzXG4gIHN0YXRpYyBnZXQgRGVmYXVsdCgpIHtcbiAgICByZXR1cm4gZ3U7XG4gIH1cbiAgc3RhdGljIGdldCBEZWZhdWx0VHlwZSgpIHtcbiAgICByZXR1cm4gYnU7XG4gIH1cbiAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgIHJldHVybiBrbjtcbiAgfVxuICAvLyBQdWJsaWNcbiAgdG9nZ2xlKCkge1xuICAgIHJldHVybiB0aGlzLl9pc1Nob3duKCkgPyB0aGlzLmhpZGUoKSA6IHRoaXMuc2hvdygpO1xuICB9XG4gIHNob3coKSB7XG4gICAgaWYgKGdlKHRoaXMuX2VsZW1lbnQpIHx8IHRoaXMuX2lzU2hvd24odGhpcy5fbWVudSkpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgdCA9IHtcbiAgICAgIHJlbGF0ZWRUYXJnZXQ6IHRoaXMuX2VsZW1lbnRcbiAgICB9O1xuICAgIGlmIChjLnRyaWdnZXIoXG4gICAgICB0aGlzLl9lbGVtZW50LFxuICAgICAgSmQsXG4gICAgICB0XG4gICAgKS5kZWZhdWx0UHJldmVudGVkKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGkgPSBEdC5nZXRQYXJlbnRGcm9tRWxlbWVudCh0aGlzLl9lbGVtZW50KTtcbiAgICB0aGlzLl9pbk5hdmJhciA/IGguc2V0RGF0YUF0dHJpYnV0ZSh0aGlzLl9tZW51LCBcInBvcHBlclwiLCBcIm5vbmVcIikgOiB0aGlzLl9jcmVhdGVQb3BwZXIoaSksIFwib250b3VjaHN0YXJ0XCIgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICYmICFpLmNsb3Nlc3QoYXUpICYmIFtdLmNvbmNhdCguLi5kb2N1bWVudC5ib2R5LmNoaWxkcmVuKS5mb3JFYWNoKChuKSA9PiBjLm9uKG4sIFwibW91c2VvdmVyXCIsIHRuKSksIHRoaXMuX2VsZW1lbnQuZm9jdXMoKSwgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWV4cGFuZGVkXCIsICEwKSwgdGhpcy5fbWVudS5zZXRBdHRyaWJ1dGUoYGRhdGEtdGUtZHJvcGRvd24tJHtXdH1gLCBcIlwiKSwgdGhpcy5fYW5pbWF0aW9uQ2FuUGxheSAmJiB0aGlzLl9tZW51LmFuaW1hdGUoZnUsIGlzKSwgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoYGRhdGEtdGUtZHJvcGRvd24tJHtXdH1gLCBcIlwiKSwgc2V0VGltZW91dChcbiAgICAgICgpID0+IHtcbiAgICAgICAgYy50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIHR1LCB0KTtcbiAgICAgIH0sXG4gICAgICB0aGlzLl9hbmltYXRpb25DYW5QbGF5ID8gaXMuZHVyYXRpb24gOiAwXG4gICAgKTtcbiAgfVxuICBoaWRlKCkge1xuICAgIGlmIChnZSh0aGlzLl9lbGVtZW50KSB8fCAhdGhpcy5faXNTaG93bih0aGlzLl9tZW51KSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB0ID0ge1xuICAgICAgcmVsYXRlZFRhcmdldDogdGhpcy5fZWxlbWVudFxuICAgIH07XG4gICAgdGhpcy5fY29tcGxldGVIaWRlKHQpO1xuICB9XG4gIGRpc3Bvc2UoKSB7XG4gICAgdGhpcy5fcG9wcGVyICYmIHRoaXMuX3BvcHBlci5kZXN0cm95KCksIHN1cGVyLmRpc3Bvc2UoKTtcbiAgfVxuICB1cGRhdGUoKSB7XG4gICAgdGhpcy5faW5OYXZiYXIgPSB0aGlzLl9kZXRlY3ROYXZiYXIoKSwgdGhpcy5fcG9wcGVyICYmIHRoaXMuX3BvcHBlci51cGRhdGUoKTtcbiAgfVxuICAvLyBQcml2YXRlXG4gIF9pbml0KCkge1xuICAgIHRoaXMuX2RpZEluaXQgfHwgKGMub24oXG4gICAgICBkb2N1bWVudCxcbiAgICAgIFdyLFxuICAgICAgZXMsXG4gICAgICBEdC5kYXRhQXBpS2V5ZG93bkhhbmRsZXJcbiAgICApLCBjLm9uKFxuICAgICAgZG9jdW1lbnQsXG4gICAgICBXcixcbiAgICAgIHhuLFxuICAgICAgRHQuZGF0YUFwaUtleWRvd25IYW5kbGVyXG4gICAgKSwgYy5vbihkb2N1bWVudCwgZXUsIER0LmNsZWFyTWVudXMpLCBjLm9uKGRvY3VtZW50LCBpdSwgRHQuY2xlYXJNZW51cyksIHRoaXMuX2RpZEluaXQgPSAhMCk7XG4gIH1cbiAgX2NvbXBsZXRlSGlkZSh0KSB7XG4gICAgdGhpcy5fZmFkZU91dEFuaW1hdGUgJiYgdGhpcy5fZmFkZU91dEFuaW1hdGUucGxheVN0YXRlID09PSBcInJ1bm5pbmdcIiB8fCBjLnRyaWdnZXIoXG4gICAgICB0aGlzLl9lbGVtZW50LFxuICAgICAgWmQsXG4gICAgICB0XG4gICAgKS5kZWZhdWx0UHJldmVudGVkIHx8IChcIm9udG91Y2hzdGFydFwiIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCAmJiBbXS5jb25jYXQoLi4uZG9jdW1lbnQuYm9keS5jaGlsZHJlbikuZm9yRWFjaCgoaSkgPT4gYy5vZmYoaSwgXCJtb3VzZW92ZXJcIiwgdG4pKSwgdGhpcy5fYW5pbWF0aW9uQ2FuUGxheSAmJiAodGhpcy5fZmFkZU91dEFuaW1hdGUgPSB0aGlzLl9tZW51LmFuaW1hdGUoXG4gICAgICBtdSxcbiAgICAgIGlzXG4gICAgKSksIHNldFRpbWVvdXQoXG4gICAgICAoKSA9PiB7XG4gICAgICAgIHRoaXMuX3BvcHBlciAmJiB0aGlzLl9wb3BwZXIuZGVzdHJveSgpLCB0aGlzLl9tZW51LnJlbW92ZUF0dHJpYnV0ZShgZGF0YS10ZS1kcm9wZG93bi0ke1d0fWApLCB0aGlzLl9lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShgZGF0YS10ZS1kcm9wZG93bi0ke1d0fWApLCB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZShcImFyaWEtZXhwYW5kZWRcIiwgXCJmYWxzZVwiKSwgaC5yZW1vdmVEYXRhQXR0cmlidXRlKHRoaXMuX21lbnUsIFwicG9wcGVyXCIpLCBjLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgUWQsIHQpO1xuICAgICAgfSxcbiAgICAgIHRoaXMuX2FuaW1hdGlvbkNhblBsYXkgPyBpcy5kdXJhdGlvbiA6IDBcbiAgICApKTtcbiAgfVxuICBfZ2V0Q29uZmlnKHQpIHtcbiAgICBpZiAodCA9IHtcbiAgICAgIC4uLnRoaXMuY29uc3RydWN0b3IuRGVmYXVsdCxcbiAgICAgIC4uLmguZ2V0RGF0YUF0dHJpYnV0ZXModGhpcy5fZWxlbWVudCksXG4gICAgICAuLi50XG4gICAgfSwgRChrbiwgdCwgdGhpcy5jb25zdHJ1Y3Rvci5EZWZhdWx0VHlwZSksIHR5cGVvZiB0LnJlZmVyZW5jZSA9PSBcIm9iamVjdFwiICYmICFqZSh0LnJlZmVyZW5jZSkgJiYgdHlwZW9mIHQucmVmZXJlbmNlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCAhPSBcImZ1bmN0aW9uXCIpXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICBgJHtrbi50b1VwcGVyQ2FzZSgpfTogT3B0aW9uIFwicmVmZXJlbmNlXCIgcHJvdmlkZWQgdHlwZSBcIm9iamVjdFwiIHdpdGhvdXQgYSByZXF1aXJlZCBcImdldEJvdW5kaW5nQ2xpZW50UmVjdFwiIG1ldGhvZC5gXG4gICAgICApO1xuICAgIHJldHVybiB0O1xuICB9XG4gIF9jcmVhdGVQb3BwZXIodCkge1xuICAgIGlmICh0eXBlb2YgSWMgPiBcInVcIilcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgIFwiQm9vdHN0cmFwJ3MgZHJvcGRvd25zIHJlcXVpcmUgUG9wcGVyIChodHRwczovL3BvcHBlci5qcy5vcmcpXCJcbiAgICAgICk7XG4gICAgbGV0IGUgPSB0aGlzLl9lbGVtZW50O1xuICAgIHRoaXMuX2NvbmZpZy5yZWZlcmVuY2UgPT09IFwicGFyZW50XCIgPyBlID0gdCA6IGplKHRoaXMuX2NvbmZpZy5yZWZlcmVuY2UpID8gZSA9IHRlKHRoaXMuX2NvbmZpZy5yZWZlcmVuY2UpIDogdHlwZW9mIHRoaXMuX2NvbmZpZy5yZWZlcmVuY2UgPT0gXCJvYmplY3RcIiAmJiAoZSA9IHRoaXMuX2NvbmZpZy5yZWZlcmVuY2UpO1xuICAgIGNvbnN0IGkgPSB0aGlzLl9nZXRQb3BwZXJDb25maWcoKSwgbiA9IGkubW9kaWZpZXJzLmZpbmQoXG4gICAgICAobykgPT4gby5uYW1lID09PSBcImFwcGx5U3R5bGVzXCIgJiYgby5lbmFibGVkID09PSAhMVxuICAgICk7XG4gICAgdGhpcy5fcG9wcGVyID0gQ2UoXG4gICAgICBlLFxuICAgICAgdGhpcy5fbWVudSxcbiAgICAgIGlcbiAgICApLCBuICYmIGguc2V0RGF0YUF0dHJpYnV0ZSh0aGlzLl9tZW51LCBcInBvcHBlclwiLCBcInN0YXRpY1wiKTtcbiAgfVxuICBfaXNTaG93bih0ID0gdGhpcy5fZWxlbWVudCkge1xuICAgIHJldHVybiB0LmRhdGFzZXRbYHRlRHJvcGRvd24ke1d0LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgV3Quc2xpY2UoMSl9YF0gPT09IFwiXCI7XG4gIH1cbiAgX2dldE1lbnVFbGVtZW50KCkge1xuICAgIHJldHVybiBkLm5leHQodGhpcy5fZWxlbWVudCwgeG4pWzBdO1xuICB9XG4gIF9nZXRQbGFjZW1lbnQoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuX2VsZW1lbnQucGFyZW50Tm9kZTtcbiAgICBpZiAodC5kYXRhc2V0LnRlRHJvcGRvd25Qb3NpdGlvbiA9PT0gbnUpXG4gICAgICByZXR1cm4gcHU7XG4gICAgaWYgKHQuZGF0YXNldC50ZURyb3Bkb3duUG9zaXRpb24gPT09IG91KVxuICAgICAgcmV0dXJuIF91O1xuICAgIGNvbnN0IGUgPSB0LmRhdGFzZXQudGVEcm9wZG93bkFsaWdubWVudCA9PT0gXCJlbmRcIjtcbiAgICByZXR1cm4gdC5kYXRhc2V0LnRlRHJvcGRvd25Qb3NpdGlvbiA9PT0gc3UgPyBlID8gaHUgOiBjdSA6IGUgPyB1dSA6IGR1O1xuICB9XG4gIF9kZXRlY3ROYXZiYXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2VsZW1lbnQuY2xvc2VzdChydSkgIT09IG51bGw7XG4gIH1cbiAgX2dldE9mZnNldCgpIHtcbiAgICBjb25zdCB7IG9mZnNldDogdCB9ID0gdGhpcy5fY29uZmlnO1xuICAgIHJldHVybiB0eXBlb2YgdCA9PSBcInN0cmluZ1wiID8gdC5zcGxpdChcIixcIikubWFwKChlKSA9PiBOdW1iZXIucGFyc2VJbnQoZSwgMTApKSA6IHR5cGVvZiB0ID09IFwiZnVuY3Rpb25cIiA/IChlKSA9PiB0KGUsIHRoaXMuX2VsZW1lbnQpIDogdDtcbiAgfVxuICBfZ2V0UG9wcGVyQ29uZmlnKCkge1xuICAgIGNvbnN0IHQgPSB7XG4gICAgICBwbGFjZW1lbnQ6IHRoaXMuX2dldFBsYWNlbWVudCgpLFxuICAgICAgbW9kaWZpZXJzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiBcInByZXZlbnRPdmVyZmxvd1wiLFxuICAgICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgIGJvdW5kYXJ5OiB0aGlzLl9jb25maWcuYm91bmRhcnlcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiBcIm9mZnNldFwiLFxuICAgICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgIG9mZnNldDogdGhpcy5fZ2V0T2Zmc2V0KClcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIF1cbiAgICB9O1xuICAgIHJldHVybiB0aGlzLl9jb25maWcuZGlzcGxheSA9PT0gXCJzdGF0aWNcIiAmJiAodC5tb2RpZmllcnMgPSBbXG4gICAgICB7XG4gICAgICAgIG5hbWU6IFwiYXBwbHlTdHlsZXNcIixcbiAgICAgICAgZW5hYmxlZDogITFcbiAgICAgIH1cbiAgICBdKSwge1xuICAgICAgLi4udCxcbiAgICAgIC4uLnR5cGVvZiB0aGlzLl9jb25maWcucG9wcGVyQ29uZmlnID09IFwiZnVuY3Rpb25cIiA/IHRoaXMuX2NvbmZpZy5wb3BwZXJDb25maWcodCkgOiB0aGlzLl9jb25maWcucG9wcGVyQ29uZmlnXG4gICAgfTtcbiAgfVxuICBfc2VsZWN0TWVudUl0ZW0oeyBrZXk6IHQsIHRhcmdldDogZSB9KSB7XG4gICAgY29uc3QgaSA9IGQuZmluZChcbiAgICAgIGx1LFxuICAgICAgdGhpcy5fbWVudVxuICAgICkuZmlsdGVyKE50KTtcbiAgICBpLmxlbmd0aCAmJiBKbChcbiAgICAgIGksXG4gICAgICBlLFxuICAgICAgdCA9PT0gUHMsXG4gICAgICAhaS5pbmNsdWRlcyhlKVxuICAgICkuZm9jdXMoKTtcbiAgfVxuICAvLyBTdGF0aWNcbiAgc3RhdGljIGpRdWVyeUludGVyZmFjZSh0KSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgIGNvbnN0IGUgPSBEdC5nZXRPckNyZWF0ZUluc3RhbmNlKHRoaXMsIHQpO1xuICAgICAgaWYgKHR5cGVvZiB0ID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBlW3RdID4gXCJ1XCIpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFwiJHt0fVwiYCk7XG4gICAgICAgIGVbdF0oKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBzdGF0aWMgY2xlYXJNZW51cyh0KSB7XG4gICAgaWYgKHQgJiYgKHQuYnV0dG9uID09PSBHZCB8fCB0LnR5cGUgPT09IFwia2V5dXBcIiAmJiB0LmtleSAhPT0gVnIpKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGUgPSBkLmZpbmQoZXMpO1xuICAgIGZvciAobGV0IGkgPSAwLCBuID0gZS5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgIGNvbnN0IG8gPSBEdC5nZXRJbnN0YW5jZShlW2ldKTtcbiAgICAgIGlmICghbyB8fCBvLl9jb25maWcuYXV0b0Nsb3NlID09PSAhMSB8fCAhby5faXNTaG93bigpKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIGNvbnN0IHIgPSB7XG4gICAgICAgIHJlbGF0ZWRUYXJnZXQ6IG8uX2VsZW1lbnRcbiAgICAgIH07XG4gICAgICBpZiAodCkge1xuICAgICAgICBjb25zdCBhID0gdC5jb21wb3NlZFBhdGgoKSwgbCA9IGEuaW5jbHVkZXMoby5fbWVudSk7XG4gICAgICAgIGlmIChhLmluY2x1ZGVzKG8uX2VsZW1lbnQpIHx8IG8uX2NvbmZpZy5hdXRvQ2xvc2UgPT09IFwiaW5zaWRlXCIgJiYgIWwgfHwgby5fY29uZmlnLmF1dG9DbG9zZSA9PT0gXCJvdXRzaWRlXCIgJiYgbCB8fCBvLl9tZW51LmNvbnRhaW5zKHQudGFyZ2V0KSAmJiAodC50eXBlID09PSBcImtleXVwXCIgJiYgdC5rZXkgPT09IFZyIHx8IC9pbnB1dHxzZWxlY3R8b3B0aW9ufHRleHRhcmVhfGZvcm0vaS50ZXN0KHQudGFyZ2V0LnRhZ05hbWUpKSlcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgdC50eXBlID09PSBcImNsaWNrXCIgJiYgKHIuY2xpY2tFdmVudCA9IHQpO1xuICAgICAgfVxuICAgICAgby5fY29tcGxldGVIaWRlKHIpO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgZ2V0UGFyZW50RnJvbUVsZW1lbnQodCkge1xuICAgIHJldHVybiBKdCh0KSB8fCB0LnBhcmVudE5vZGU7XG4gIH1cbiAgc3RhdGljIGRhdGFBcGlLZXlkb3duSGFuZGxlcih0KSB7XG4gICAgaWYgKC9pbnB1dHx0ZXh0YXJlYS9pLnRlc3QodC50YXJnZXQudGFnTmFtZSkgPyB0LmtleSA9PT0gSHIgfHwgdC5rZXkgIT09IFJzICYmICh0LmtleSAhPT0gUHMgJiYgdC5rZXkgIT09ICRvIHx8IHQudGFyZ2V0LmNsb3Nlc3QoeG4pKSA6ICFxZC50ZXN0KHQua2V5KSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBlID0gdGhpcy5kYXRhc2V0W2B0ZURyb3Bkb3duJHtXdC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIFd0LnNsaWNlKDEpfWBdID09PSBcIlwiO1xuICAgIGlmICghZSAmJiB0LmtleSA9PT0gUnMgfHwgKHQucHJldmVudERlZmF1bHQoKSwgdC5zdG9wUHJvcGFnYXRpb24oKSwgZ2UodGhpcykpKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGkgPSB0aGlzLm1hdGNoZXMoZXMpID8gdGhpcyA6IGQucHJldih0aGlzLCBlcylbMF0sIG4gPSBEdC5nZXRPckNyZWF0ZUluc3RhbmNlKGkpO1xuICAgIGlmICh0LmtleSA9PT0gUnMpIHtcbiAgICAgIG4uaGlkZSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodC5rZXkgPT09ICRvIHx8IHQua2V5ID09PSBQcykge1xuICAgICAgZSB8fCBuLnNob3coKSwgbi5fc2VsZWN0TWVudUl0ZW0odCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgICghZSB8fCB0LmtleSA9PT0gSHIpICYmIER0LmNsZWFyTWVudXMoKTtcbiAgfVxufVxuY29uc3QgT24gPSBcImNvbGxhcHNlXCIsIERjID0gXCJ0ZS5jb2xsYXBzZVwiLCBsbiA9IGAuJHtEY31gLCBGciA9IHtcbiAgdG9nZ2xlOiAhMCxcbiAgcGFyZW50OiBudWxsXG59LCB2dSA9IHtcbiAgdG9nZ2xlOiBcImJvb2xlYW5cIixcbiAgcGFyZW50OiBcIihudWxsfGVsZW1lbnQpXCJcbn0sIFR1ID0gYHNob3cke2xufWAsIEV1ID0gYHNob3duJHtsbn1gLCBDdSA9IGBoaWRlJHtsbn1gLCBBdSA9IGBoaWRkZW4ke2xufWAsIFNuID0gXCJkYXRhLXRlLWNvbGxhcHNlLXNob3dcIiwgWXIgPSBcImRhdGEtdGUtY29sbGFwc2UtY29sbGFwc2VkXCIsIHNzID0gXCJkYXRhLXRlLWNvbGxhcHNlLWNvbGxhcHNpbmdcIiwgeXUgPSBcImRhdGEtdGUtY29sbGFwc2UtaG9yaXpvbnRhbFwiLCBNZSA9IFwiZGF0YS10ZS1jb2xsYXBzZS1pdGVtXCIsIGpyID0gYDpzY29wZSBbJHtNZX1dIFske01lfV1gLCB3dSA9IFwid2lkdGhcIiwga3UgPSBcImhlaWdodFwiLCB4dSA9IFwiW2RhdGEtdGUtY29sbGFwc2UtaXRlbV1bZGF0YS10ZS1jb2xsYXBzZS1zaG93XSwgW2RhdGEtdGUtY29sbGFwc2UtaXRlbV1bZGF0YS10ZS1jb2xsYXBzZS1jb2xsYXBzaW5nXVwiLCBLciA9IFwiW2RhdGEtdGUtY29sbGFwc2UtaW5pdF1cIiwgT3UgPSB7XG4gIHZpc2libGU6IFwiIXZpc2libGVcIixcbiAgaGlkZGVuOiBcImhpZGRlblwiLFxuICBiYXNlVHJhbnNpdGlvbjogXCJvdmVyZmxvdy1oaWRkZW4gZHVyYXRpb24tWzM1MG1zXSBlYXNlLVtjdWJpYy1iZXppZXIoMC4yNSwwLjEsMC4yNSwxLjApXSBtb3Rpb24tcmVkdWNlOnRyYW5zaXRpb24tbm9uZVwiLFxuICBjb2xsYXBzaW5nOiBcImgtMCB0cmFuc2l0aW9uLVtoZWlnaHRdIG92ZXJmbG93LWhpZGRlbiBkdXJhdGlvbi1bMzUwbXNdIGVhc2UtW2N1YmljLWJlemllcigwLjI1LDAuMSwwLjI1LDEuMCldIG1vdGlvbi1yZWR1Y2U6dHJhbnNpdGlvbi1ub25lXCIsXG4gIGNvbGxhcHNpbmdIb3Jpem9udGFsOiBcInctMCBoLWF1dG8gdHJhbnNpdGlvbi1bd2lkdGhdIG92ZXJmbG93LWhpZGRlbiBkdXJhdGlvbi1bMzUwbXNdIGVhc2UtW2N1YmljLWJlemllcigwLjI1LDAuMSwwLjI1LDEuMCldIG1vdGlvbi1yZWR1Y2U6dHJhbnNpdGlvbi1ub25lXCJcbn0sIFN1ID0ge1xuICB2aXNpYmxlOiBcInN0cmluZ1wiLFxuICBoaWRkZW46IFwic3RyaW5nXCIsXG4gIGJhc2VUcmFuc2l0aW9uOiBcInN0cmluZ1wiLFxuICBjb2xsYXBzaW5nOiBcInN0cmluZ1wiLFxuICBjb2xsYXBzaW5nSG9yaXpvbnRhbDogXCJzdHJpbmdcIlxufTtcbmNsYXNzIFp0IGV4dGVuZHMgZ3Qge1xuICBjb25zdHJ1Y3Rvcih0LCBlLCBpKSB7XG4gICAgc3VwZXIodCksIHRoaXMuX2lzVHJhbnNpdGlvbmluZyA9ICExLCB0aGlzLl9jb25maWcgPSB0aGlzLl9nZXRDb25maWcoZSksIHRoaXMuX2NsYXNzZXMgPSB0aGlzLl9nZXRDbGFzc2VzKGkpLCB0aGlzLl90cmlnZ2VyQXJyYXkgPSBbXTtcbiAgICBjb25zdCBuID0gZC5maW5kKEtyKTtcbiAgICBmb3IgKGxldCBvID0gMCwgciA9IG4ubGVuZ3RoOyBvIDwgcjsgbysrKSB7XG4gICAgICBjb25zdCBhID0gbltvXSwgbCA9IHFvKGEpLCBwID0gZC5maW5kKGwpLmZpbHRlcihcbiAgICAgICAgKHUpID0+IHUgPT09IHRoaXMuX2VsZW1lbnRcbiAgICAgICk7XG4gICAgICBsICE9PSBudWxsICYmIHAubGVuZ3RoICYmICh0aGlzLl9zZWxlY3RvciA9IGwsIHRoaXMuX3RyaWdnZXJBcnJheS5wdXNoKGEpKTtcbiAgICB9XG4gICAgdGhpcy5faW5pdGlhbGl6ZUNoaWxkcmVuKCksIHRoaXMuX2NvbmZpZy5wYXJlbnQgfHwgdGhpcy5fYWRkQXJpYUFuZENvbGxhcHNlZENsYXNzKHRoaXMuX3RyaWdnZXJBcnJheSwgdGhpcy5faXNTaG93bigpKSwgdGhpcy5fY29uZmlnLnRvZ2dsZSAmJiB0aGlzLnRvZ2dsZSgpO1xuICB9XG4gIC8vIEdldHRlcnNcbiAgc3RhdGljIGdldCBEZWZhdWx0KCkge1xuICAgIHJldHVybiBGcjtcbiAgfVxuICBzdGF0aWMgZ2V0IE5BTUUoKSB7XG4gICAgcmV0dXJuIE9uO1xuICB9XG4gIC8vIFB1YmxpY1xuICB0b2dnbGUoKSB7XG4gICAgdGhpcy5faXNTaG93bigpID8gdGhpcy5oaWRlKCkgOiB0aGlzLnNob3coKTtcbiAgfVxuICBzaG93KCkge1xuICAgIGlmICh0aGlzLl9pc1RyYW5zaXRpb25pbmcgfHwgdGhpcy5faXNTaG93bigpKVxuICAgICAgcmV0dXJuO1xuICAgIGxldCB0ID0gW10sIGU7XG4gICAgaWYgKHRoaXMuX2NvbmZpZy5wYXJlbnQpIHtcbiAgICAgIGNvbnN0IHUgPSBkLmZpbmQoXG4gICAgICAgIGpyLFxuICAgICAgICB0aGlzLl9jb25maWcucGFyZW50XG4gICAgICApO1xuICAgICAgdCA9IGQuZmluZChcbiAgICAgICAgeHUsXG4gICAgICAgIHRoaXMuX2NvbmZpZy5wYXJlbnRcbiAgICAgICkuZmlsdGVyKChfKSA9PiAhdS5pbmNsdWRlcyhfKSk7XG4gICAgfVxuICAgIGNvbnN0IGkgPSBkLmZpbmRPbmUodGhpcy5fc2VsZWN0b3IpO1xuICAgIGlmICh0Lmxlbmd0aCkge1xuICAgICAgY29uc3QgdSA9IHQuZmluZCgoXykgPT4gaSAhPT0gXyk7XG4gICAgICBpZiAoZSA9IHUgPyBadC5nZXRJbnN0YW5jZSh1KSA6IG51bGwsIGUgJiYgZS5faXNUcmFuc2l0aW9uaW5nKVxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChjLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgVHUpLmRlZmF1bHRQcmV2ZW50ZWQpXG4gICAgICByZXR1cm47XG4gICAgdC5mb3JFYWNoKCh1KSA9PiB7XG4gICAgICBpICE9PSB1ICYmIFp0LmdldE9yQ3JlYXRlSW5zdGFuY2UodSwgeyB0b2dnbGU6ICExIH0pLmhpZGUoKSwgZSB8fCB5LnNldERhdGEodSwgRGMsIG51bGwpO1xuICAgIH0pO1xuICAgIGNvbnN0IG8gPSB0aGlzLl9nZXREaW1lbnNpb24oKSwgciA9IG8gPT09IFwiaGVpZ2h0XCIgPyB0aGlzLl9jbGFzc2VzLmNvbGxhcHNpbmcgOiB0aGlzLl9jbGFzc2VzLmNvbGxhcHNpbmdIb3Jpem9udGFsO1xuICAgIGgucmVtb3ZlQ2xhc3ModGhpcy5fZWxlbWVudCwgdGhpcy5fY2xhc3Nlcy52aXNpYmxlKSwgaC5yZW1vdmVDbGFzcyh0aGlzLl9lbGVtZW50LCB0aGlzLl9jbGFzc2VzLmhpZGRlbiksIGguYWRkQ2xhc3ModGhpcy5fZWxlbWVudCwgciksIHRoaXMuX2VsZW1lbnQucmVtb3ZlQXR0cmlidXRlKE1lKSwgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoc3MsIFwiXCIpLCB0aGlzLl9lbGVtZW50LnN0eWxlW29dID0gMCwgdGhpcy5fYWRkQXJpYUFuZENvbGxhcHNlZENsYXNzKHRoaXMuX3RyaWdnZXJBcnJheSwgITApLCB0aGlzLl9pc1RyYW5zaXRpb25pbmcgPSAhMDtcbiAgICBjb25zdCBhID0gKCkgPT4ge1xuICAgICAgdGhpcy5faXNUcmFuc2l0aW9uaW5nID0gITEsIGgucmVtb3ZlQ2xhc3ModGhpcy5fZWxlbWVudCwgdGhpcy5fY2xhc3Nlcy5oaWRkZW4pLCBoLnJlbW92ZUNsYXNzKHRoaXMuX2VsZW1lbnQsIHIpLCBoLmFkZENsYXNzKHRoaXMuX2VsZW1lbnQsIHRoaXMuX2NsYXNzZXMudmlzaWJsZSksIHRoaXMuX2VsZW1lbnQucmVtb3ZlQXR0cmlidXRlKHNzKSwgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoTWUsIFwiXCIpLCB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZShTbiwgXCJcIiksIHRoaXMuX2VsZW1lbnQuc3R5bGVbb10gPSBcIlwiLCBjLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRXUpO1xuICAgIH0sIHAgPSBgc2Nyb2xsJHtvWzBdLnRvVXBwZXJDYXNlKCkgKyBvLnNsaWNlKDEpfWA7XG4gICAgdGhpcy5fcXVldWVDYWxsYmFjayhhLCB0aGlzLl9lbGVtZW50LCAhMCksIHRoaXMuX2VsZW1lbnQuc3R5bGVbb10gPSBgJHt0aGlzLl9lbGVtZW50W3BdfXB4YDtcbiAgfVxuICBoaWRlKCkge1xuICAgIGlmICh0aGlzLl9pc1RyYW5zaXRpb25pbmcgfHwgIXRoaXMuX2lzU2hvd24oKSB8fCBjLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgQ3UpLmRlZmF1bHRQcmV2ZW50ZWQpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgZSA9IHRoaXMuX2dldERpbWVuc2lvbigpLCBpID0gZSA9PT0gXCJoZWlnaHRcIiA/IHRoaXMuX2NsYXNzZXMuY29sbGFwc2luZyA6IHRoaXMuX2NsYXNzZXMuY29sbGFwc2luZ0hvcml6b250YWw7XG4gICAgdGhpcy5fZWxlbWVudC5zdHlsZVtlXSA9IGAke3RoaXMuX2VsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClbZV19cHhgLCBKZSh0aGlzLl9lbGVtZW50KSwgaC5hZGRDbGFzcyh0aGlzLl9lbGVtZW50LCBpKSwgaC5yZW1vdmVDbGFzcyh0aGlzLl9lbGVtZW50LCB0aGlzLl9jbGFzc2VzLnZpc2libGUpLCBoLnJlbW92ZUNsYXNzKHRoaXMuX2VsZW1lbnQsIHRoaXMuX2NsYXNzZXMuaGlkZGVuKSwgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoc3MsIFwiXCIpLCB0aGlzLl9lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShNZSksIHRoaXMuX2VsZW1lbnQucmVtb3ZlQXR0cmlidXRlKFNuKTtcbiAgICBjb25zdCBuID0gdGhpcy5fdHJpZ2dlckFycmF5Lmxlbmd0aDtcbiAgICBmb3IgKGxldCByID0gMDsgciA8IG47IHIrKykge1xuICAgICAgY29uc3QgYSA9IHRoaXMuX3RyaWdnZXJBcnJheVtyXSwgbCA9IEp0KGEpO1xuICAgICAgbCAmJiAhdGhpcy5faXNTaG93bihsKSAmJiB0aGlzLl9hZGRBcmlhQW5kQ29sbGFwc2VkQ2xhc3MoW2FdLCAhMSk7XG4gICAgfVxuICAgIHRoaXMuX2lzVHJhbnNpdGlvbmluZyA9ICEwO1xuICAgIGNvbnN0IG8gPSAoKSA9PiB7XG4gICAgICB0aGlzLl9pc1RyYW5zaXRpb25pbmcgPSAhMSwgaC5yZW1vdmVDbGFzcyh0aGlzLl9lbGVtZW50LCBpKSwgaC5hZGRDbGFzcyh0aGlzLl9lbGVtZW50LCB0aGlzLl9jbGFzc2VzLnZpc2libGUpLCBoLmFkZENsYXNzKHRoaXMuX2VsZW1lbnQsIHRoaXMuX2NsYXNzZXMuaGlkZGVuKSwgdGhpcy5fZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoc3MpLCB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZShNZSwgXCJcIiksIGMudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBBdSk7XG4gICAgfTtcbiAgICB0aGlzLl9lbGVtZW50LnN0eWxlW2VdID0gXCJcIiwgdGhpcy5fcXVldWVDYWxsYmFjayhvLCB0aGlzLl9lbGVtZW50LCAhMCk7XG4gIH1cbiAgX2lzU2hvd24odCA9IHRoaXMuX2VsZW1lbnQpIHtcbiAgICByZXR1cm4gdC5oYXNBdHRyaWJ1dGUoU24pO1xuICB9XG4gIC8vIFByaXZhdGVcbiAgX2dldENvbmZpZyh0KSB7XG4gICAgcmV0dXJuIHQgPSB7XG4gICAgICAuLi5GcixcbiAgICAgIC4uLmguZ2V0RGF0YUF0dHJpYnV0ZXModGhpcy5fZWxlbWVudCksXG4gICAgICAuLi50XG4gICAgfSwgdC50b2dnbGUgPSAhIXQudG9nZ2xlLCB0LnBhcmVudCA9IHRlKHQucGFyZW50KSwgRChPbiwgdCwgdnUpLCB0O1xuICB9XG4gIF9nZXRDbGFzc2VzKHQpIHtcbiAgICBjb25zdCBlID0gaC5nZXREYXRhQ2xhc3NBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpO1xuICAgIHJldHVybiB0ID0ge1xuICAgICAgLi4uT3UsXG4gICAgICAuLi5lLFxuICAgICAgLi4udFxuICAgIH0sIEQoT24sIHQsIFN1KSwgdDtcbiAgfVxuICBfZ2V0RGltZW5zaW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9lbGVtZW50Lmhhc0F0dHJpYnV0ZSh5dSkgPyB3dSA6IGt1O1xuICB9XG4gIF9pbml0aWFsaXplQ2hpbGRyZW4oKSB7XG4gICAgaWYgKCF0aGlzLl9jb25maWcucGFyZW50KVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHQgPSBkLmZpbmQoXG4gICAgICBqcixcbiAgICAgIHRoaXMuX2NvbmZpZy5wYXJlbnRcbiAgICApO1xuICAgIGQuZmluZChLciwgdGhpcy5fY29uZmlnLnBhcmVudCkuZmlsdGVyKChlKSA9PiAhdC5pbmNsdWRlcyhlKSkuZm9yRWFjaCgoZSkgPT4ge1xuICAgICAgY29uc3QgaSA9IEp0KGUpO1xuICAgICAgaSAmJiB0aGlzLl9hZGRBcmlhQW5kQ29sbGFwc2VkQ2xhc3MoW2VdLCB0aGlzLl9pc1Nob3duKGkpKTtcbiAgICB9KTtcbiAgfVxuICBfYWRkQXJpYUFuZENvbGxhcHNlZENsYXNzKHQsIGUpIHtcbiAgICB0Lmxlbmd0aCAmJiB0LmZvckVhY2goKGkpID0+IHtcbiAgICAgIGUgPyBpLnJlbW92ZUF0dHJpYnV0ZShZcikgOiBpLnNldEF0dHJpYnV0ZShgJHtZcn1gLCBcIlwiKSwgaS5zZXRBdHRyaWJ1dGUoXCJhcmlhLWV4cGFuZGVkXCIsIGUpO1xuICAgIH0pO1xuICB9XG4gIC8vIFN0YXRpY1xuICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKHQpIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgY29uc3QgZSA9IHt9O1xuICAgICAgdHlwZW9mIHQgPT0gXCJzdHJpbmdcIiAmJiAvc2hvd3xoaWRlLy50ZXN0KHQpICYmIChlLnRvZ2dsZSA9ICExKTtcbiAgICAgIGNvbnN0IGkgPSBadC5nZXRPckNyZWF0ZUluc3RhbmNlKHRoaXMsIGUpO1xuICAgICAgaWYgKHR5cGVvZiB0ID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpW3RdID4gXCJ1XCIpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFwiJHt0fVwiYCk7XG4gICAgICAgIGlbdF0oKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuY29uc3QgenIgPSBcIi5maXhlZC10b3AsIC5maXhlZC1ib3R0b20sIC5pcy1maXhlZCwgLnN0aWNreS10b3BcIiwgVXIgPSBcIi5zdGlja3ktdG9wXCI7XG5jbGFzcyBxZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuX2VsZW1lbnQgPSBkb2N1bWVudC5ib2R5O1xuICB9XG4gIGdldFdpZHRoKCkge1xuICAgIGNvbnN0IHQgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGg7XG4gICAgcmV0dXJuIE1hdGguYWJzKHdpbmRvdy5pbm5lcldpZHRoIC0gdCk7XG4gIH1cbiAgaGlkZSgpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5nZXRXaWR0aCgpO1xuICAgIHRoaXMuX2Rpc2FibGVPdmVyRmxvdygpLCB0aGlzLl9zZXRFbGVtZW50QXR0cmlidXRlcyhcbiAgICAgIHRoaXMuX2VsZW1lbnQsXG4gICAgICBcInBhZGRpbmdSaWdodFwiLFxuICAgICAgKGUpID0+IGUgKyB0XG4gICAgKSwgdGhpcy5fc2V0RWxlbWVudEF0dHJpYnV0ZXMoXG4gICAgICB6cixcbiAgICAgIFwicGFkZGluZ1JpZ2h0XCIsXG4gICAgICAoZSkgPT4gZSArIHRcbiAgICApLCB0aGlzLl9zZXRFbGVtZW50QXR0cmlidXRlcyhcbiAgICAgIFVyLFxuICAgICAgXCJtYXJnaW5SaWdodFwiLFxuICAgICAgKGUpID0+IGUgLSB0XG4gICAgKTtcbiAgfVxuICBfZGlzYWJsZU92ZXJGbG93KCkge1xuICAgIHRoaXMuX3NhdmVJbml0aWFsQXR0cmlidXRlKHRoaXMuX2VsZW1lbnQsIFwib3ZlcmZsb3dcIiksIHRoaXMuX2VsZW1lbnQuc3R5bGUub3ZlcmZsb3cgPSBcImhpZGRlblwiO1xuICB9XG4gIF9zZXRFbGVtZW50QXR0cmlidXRlcyh0LCBlLCBpKSB7XG4gICAgY29uc3QgbiA9IHRoaXMuZ2V0V2lkdGgoKSwgbyA9IChyKSA9PiB7XG4gICAgICBpZiAociAhPT0gdGhpcy5fZWxlbWVudCAmJiB3aW5kb3cuaW5uZXJXaWR0aCA+IHIuY2xpZW50V2lkdGggKyBuKVxuICAgICAgICByZXR1cm47XG4gICAgICB0aGlzLl9zYXZlSW5pdGlhbEF0dHJpYnV0ZShyLCBlKTtcbiAgICAgIGNvbnN0IGEgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShyKVtlXTtcbiAgICAgIHIuc3R5bGVbZV0gPSBgJHtpKFxuICAgICAgICBOdW1iZXIucGFyc2VGbG9hdChhKVxuICAgICAgKX1weGA7XG4gICAgfTtcbiAgICB0aGlzLl9hcHBseU1hbmlwdWxhdGlvbkNhbGxiYWNrKHQsIG8pO1xuICB9XG4gIHJlc2V0KCkge1xuICAgIHRoaXMuX3Jlc2V0RWxlbWVudEF0dHJpYnV0ZXModGhpcy5fZWxlbWVudCwgXCJvdmVyZmxvd1wiKSwgdGhpcy5fcmVzZXRFbGVtZW50QXR0cmlidXRlcyh0aGlzLl9lbGVtZW50LCBcInBhZGRpbmdSaWdodFwiKSwgdGhpcy5fcmVzZXRFbGVtZW50QXR0cmlidXRlcyh6ciwgXCJwYWRkaW5nUmlnaHRcIiksIHRoaXMuX3Jlc2V0RWxlbWVudEF0dHJpYnV0ZXMoVXIsIFwibWFyZ2luUmlnaHRcIik7XG4gIH1cbiAgX3NhdmVJbml0aWFsQXR0cmlidXRlKHQsIGUpIHtcbiAgICBjb25zdCBpID0gdC5zdHlsZVtlXTtcbiAgICBpICYmIGguc2V0RGF0YUF0dHJpYnV0ZSh0LCBlLCBpKTtcbiAgfVxuICBfcmVzZXRFbGVtZW50QXR0cmlidXRlcyh0LCBlKSB7XG4gICAgY29uc3QgaSA9IChuKSA9PiB7XG4gICAgICBjb25zdCBvID0gaC5nZXREYXRhQXR0cmlidXRlKG4sIGUpO1xuICAgICAgdHlwZW9mIG8gPiBcInVcIiA/IG4uc3R5bGUucmVtb3ZlUHJvcGVydHkoZSkgOiAoaC5yZW1vdmVEYXRhQXR0cmlidXRlKG4sIGUpLCBuLnN0eWxlW2VdID0gbyk7XG4gICAgfTtcbiAgICB0aGlzLl9hcHBseU1hbmlwdWxhdGlvbkNhbGxiYWNrKHQsIGkpO1xuICB9XG4gIF9hcHBseU1hbmlwdWxhdGlvbkNhbGxiYWNrKHQsIGUpIHtcbiAgICBqZSh0KSA/IGUodCkgOiBkLmZpbmQodCwgdGhpcy5fZWxlbWVudCkuZm9yRWFjaChlKTtcbiAgfVxuICBpc092ZXJmbG93aW5nKCkge1xuICAgIHJldHVybiB0aGlzLmdldFdpZHRoKCkgPiAwO1xuICB9XG59XG5jb25zdCBJdSA9IHtcbiAgaXNWaXNpYmxlOiAhMCxcbiAgLy8gaWYgZmFsc2UsIHdlIHVzZSB0aGUgYmFja2Ryb3AgaGVscGVyIHdpdGhvdXQgYWRkaW5nIGFueSBlbGVtZW50IHRvIHRoZSBkb21cbiAgaXNBbmltYXRlZDogITEsXG4gIHJvb3RFbGVtZW50OiBcImJvZHlcIixcbiAgLy8gZ2l2ZSB0aGUgY2hvaWNlIHRvIHBsYWNlIGJhY2tkcm9wIHVuZGVyIGRpZmZlcmVudCBlbGVtZW50c1xuICBjbGlja0NhbGxiYWNrOiBudWxsLFxuICBiYWNrZHJvcENsYXNzZXM6IG51bGxcbn0sIER1ID0ge1xuICBpc1Zpc2libGU6IFwiYm9vbGVhblwiLFxuICBpc0FuaW1hdGVkOiBcImJvb2xlYW5cIixcbiAgcm9vdEVsZW1lbnQ6IFwiKGVsZW1lbnR8c3RyaW5nKVwiLFxuICBjbGlja0NhbGxiYWNrOiBcIihmdW5jdGlvbnxudWxsKVwiLFxuICBiYWNrZHJvcENsYXNzZXM6IFwiKGFycmF5fG51bGwpXCJcbn0sICRjID0gXCJiYWNrZHJvcFwiLCBYciA9IGBtb3VzZWRvd24udGUuJHskY31gO1xuY2xhc3MgaHIge1xuICBjb25zdHJ1Y3Rvcih0KSB7XG4gICAgdGhpcy5fY29uZmlnID0gdGhpcy5fZ2V0Q29uZmlnKHQpLCB0aGlzLl9pc0FwcGVuZGVkID0gITEsIHRoaXMuX2VsZW1lbnQgPSBudWxsO1xuICB9XG4gIHNob3codCkge1xuICAgIGlmICghdGhpcy5fY29uZmlnLmlzVmlzaWJsZSkge1xuICAgICAgbWUodCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2FwcGVuZCgpLCB0aGlzLl9jb25maWcuaXNBbmltYXRlZCAmJiBKZSh0aGlzLl9nZXRFbGVtZW50KCkpO1xuICAgIGNvbnN0IGUgPSB0aGlzLl9jb25maWcuYmFja2Ryb3BDbGFzc2VzIHx8IFtcbiAgICAgIFwib3BhY2l0eS01MFwiLFxuICAgICAgXCJ0cmFuc2l0aW9uLWFsbFwiLFxuICAgICAgXCJkdXJhdGlvbi0zMDBcIixcbiAgICAgIFwiZWFzZS1pbi1vdXRcIixcbiAgICAgIFwiZml4ZWRcIixcbiAgICAgIFwidG9wLTBcIixcbiAgICAgIFwibGVmdC0wXCIsXG4gICAgICBcInotWzEwNDBdXCIsXG4gICAgICBcImJnLWJsYWNrXCIsXG4gICAgICBcInctc2NyZWVuXCIsXG4gICAgICBcImgtc2NyZWVuXCJcbiAgICBdO1xuICAgIGgucmVtb3ZlQ2xhc3ModGhpcy5fZ2V0RWxlbWVudCgpLCBcIm9wYWNpdHktMFwiKSwgaC5hZGRDbGFzcyh0aGlzLl9nZXRFbGVtZW50KCksIGUpLCB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZShcImRhdGEtdGUtYmFja2Ryb3Atc2hvd1wiLCBcIlwiKSwgdGhpcy5fZW11bGF0ZUFuaW1hdGlvbigoKSA9PiB7XG4gICAgICBtZSh0KTtcbiAgICB9KTtcbiAgfVxuICBoaWRlKHQpIHtcbiAgICBpZiAoIXRoaXMuX2NvbmZpZy5pc1Zpc2libGUpIHtcbiAgICAgIG1lKHQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShcImRhdGEtdGUtYmFja2Ryb3Atc2hvd1wiKSwgdGhpcy5fZ2V0RWxlbWVudCgpLmNsYXNzTGlzdC5hZGQoXCJvcGFjaXR5LTBcIiksIHRoaXMuX2dldEVsZW1lbnQoKS5jbGFzc0xpc3QucmVtb3ZlKFwib3BhY2l0eS01MFwiKSwgdGhpcy5fZW11bGF0ZUFuaW1hdGlvbigoKSA9PiB7XG4gICAgICB0aGlzLmRpc3Bvc2UoKSwgbWUodCk7XG4gICAgfSk7XG4gIH1cbiAgLy8gUHJpdmF0ZVxuICBfZ2V0RWxlbWVudCgpIHtcbiAgICBpZiAoIXRoaXMuX2VsZW1lbnQpIHtcbiAgICAgIGNvbnN0IHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgdC5jbGFzc05hbWUgPSB0aGlzLl9jb25maWcuY2xhc3NOYW1lLCB0aGlzLl9jb25maWcuaXNBbmltYXRlZCAmJiB0LmNsYXNzTGlzdC5hZGQoXCJvcGFjaXR5LTUwXCIpLCB0aGlzLl9lbGVtZW50ID0gdDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2VsZW1lbnQ7XG4gIH1cbiAgX2dldENvbmZpZyh0KSB7XG4gICAgcmV0dXJuIHQgPSB7XG4gICAgICAuLi5JdSxcbiAgICAgIC4uLnR5cGVvZiB0ID09IFwib2JqZWN0XCIgPyB0IDoge31cbiAgICB9LCB0LnJvb3RFbGVtZW50ID0gdGUodC5yb290RWxlbWVudCksIEQoJGMsIHQsIER1KSwgdDtcbiAgfVxuICBfYXBwZW5kKCkge1xuICAgIHRoaXMuX2lzQXBwZW5kZWQgfHwgKHRoaXMuX2NvbmZpZy5yb290RWxlbWVudC5hcHBlbmQodGhpcy5fZ2V0RWxlbWVudCgpKSwgYy5vbih0aGlzLl9nZXRFbGVtZW50KCksIFhyLCAoKSA9PiB7XG4gICAgICBtZSh0aGlzLl9jb25maWcuY2xpY2tDYWxsYmFjayk7XG4gICAgfSksIHRoaXMuX2lzQXBwZW5kZWQgPSAhMCk7XG4gIH1cbiAgZGlzcG9zZSgpIHtcbiAgICB0aGlzLl9pc0FwcGVuZGVkICYmIChjLm9mZih0aGlzLl9lbGVtZW50LCBYciksIHRoaXMuX2VsZW1lbnQucmVtb3ZlKCksIHRoaXMuX2lzQXBwZW5kZWQgPSAhMSk7XG4gIH1cbiAgX2VtdWxhdGVBbmltYXRpb24odCkge1xuICAgIFFsKFxuICAgICAgdCxcbiAgICAgIHRoaXMuX2dldEVsZW1lbnQoKSxcbiAgICAgIHRoaXMuX2NvbmZpZy5pc0FuaW1hdGVkXG4gICAgKTtcbiAgfVxufVxuY2xhc3MgV2kge1xuICBjb25zdHJ1Y3Rvcih0LCBlID0ge30sIGkpIHtcbiAgICB0aGlzLl9lbGVtZW50ID0gdCwgdGhpcy5fdG9nZ2xlciA9IGksIHRoaXMuX2V2ZW50ID0gZS5ldmVudCB8fCBcImJsdXJcIiwgdGhpcy5fY29uZGl0aW9uID0gZS5jb25kaXRpb24gfHwgKCgpID0+ICEwKSwgdGhpcy5fc2VsZWN0b3IgPSBlLnNlbGVjdG9yIHx8ICdidXR0b24sIGEsIGlucHV0LCBzZWxlY3QsIHRleHRhcmVhLCBbdGFiaW5kZXhdOm5vdChbdGFiaW5kZXg9XCItMVwiXSknLCB0aGlzLl9vbmx5VmlzaWJsZSA9IGUub25seVZpc2libGUgfHwgITEsIHRoaXMuX2ZvY3VzYWJsZUVsZW1lbnRzID0gW10sIHRoaXMuX2ZpcnN0RWxlbWVudCA9IG51bGwsIHRoaXMuX2xhc3RFbGVtZW50ID0gbnVsbCwgdGhpcy5oYW5kbGVyID0gKG4pID0+IHtcbiAgICAgIHRoaXMuX2NvbmRpdGlvbihuKSAmJiAhbi5zaGlmdEtleSAmJiBuLnRhcmdldCA9PT0gdGhpcy5fbGFzdEVsZW1lbnQgPyAobi5wcmV2ZW50RGVmYXVsdCgpLCB0aGlzLl9maXJzdEVsZW1lbnQuZm9jdXMoKSkgOiB0aGlzLl9jb25kaXRpb24obikgJiYgbi5zaGlmdEtleSAmJiBuLnRhcmdldCA9PT0gdGhpcy5fZmlyc3RFbGVtZW50ICYmIChuLnByZXZlbnREZWZhdWx0KCksIHRoaXMuX2xhc3RFbGVtZW50LmZvY3VzKCkpO1xuICAgIH07XG4gIH1cbiAgdHJhcCgpIHtcbiAgICB0aGlzLl9zZXRFbGVtZW50cygpLCB0aGlzLl9pbml0KCksIHRoaXMuX3NldEZvY3VzVHJhcCgpO1xuICB9XG4gIGRpc2FibGUoKSB7XG4gICAgdGhpcy5fZm9jdXNhYmxlRWxlbWVudHMuZm9yRWFjaCgodCkgPT4ge1xuICAgICAgdC5yZW1vdmVFdmVudExpc3RlbmVyKHRoaXMuX2V2ZW50LCB0aGlzLmhhbmRsZXIpO1xuICAgIH0pLCB0aGlzLl90b2dnbGVyICYmIHRoaXMuX3RvZ2dsZXIuZm9jdXMoKTtcbiAgfVxuICB1cGRhdGUoKSB7XG4gICAgdGhpcy5fc2V0RWxlbWVudHMoKSwgdGhpcy5fc2V0Rm9jdXNUcmFwKCk7XG4gIH1cbiAgX2luaXQoKSB7XG4gICAgY29uc3QgdCA9IChlKSA9PiB7XG4gICAgICAhdGhpcy5fZmlyc3RFbGVtZW50IHx8IGUua2V5ICE9PSBcIlRhYlwiIHx8IHRoaXMuX2ZvY3VzYWJsZUVsZW1lbnRzLmluY2x1ZGVzKGUudGFyZ2V0KSB8fCAoZS5wcmV2ZW50RGVmYXVsdCgpLCB0aGlzLl9maXJzdEVsZW1lbnQuZm9jdXMoKSwgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHQpKTtcbiAgICB9O1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB0KTtcbiAgfVxuICBfZmlsdGVyVmlzaWJsZSh0KSB7XG4gICAgcmV0dXJuIHQuZmlsdGVyKChlKSA9PiB7XG4gICAgICBpZiAoIU50KGUpKVxuICAgICAgICByZXR1cm4gITE7XG4gICAgICBjb25zdCBpID0gZC5wYXJlbnRzKGUsIFwiKlwiKTtcbiAgICAgIGZvciAobGV0IG4gPSAwOyBuIDwgaS5sZW5ndGg7IG4rKykge1xuICAgICAgICBjb25zdCBvID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoaVtuXSk7XG4gICAgICAgIGlmIChvICYmIChvLmRpc3BsYXkgPT09IFwibm9uZVwiIHx8IG8udmlzaWJpbGl0eSA9PT0gXCJoaWRkZW5cIikpXG4gICAgICAgICAgcmV0dXJuICExO1xuICAgICAgfVxuICAgICAgcmV0dXJuICEwO1xuICAgIH0pO1xuICB9XG4gIF9zZXRFbGVtZW50cygpIHtcbiAgICB0aGlzLl9mb2N1c2FibGVFbGVtZW50cyA9IGQuZm9jdXNhYmxlQ2hpbGRyZW4odGhpcy5fZWxlbWVudCksIHRoaXMuX29ubHlWaXNpYmxlICYmICh0aGlzLl9mb2N1c2FibGVFbGVtZW50cyA9IHRoaXMuX2ZpbHRlclZpc2libGUodGhpcy5fZm9jdXNhYmxlRWxlbWVudHMpKSwgdGhpcy5fZmlyc3RFbGVtZW50ID0gdGhpcy5fZm9jdXNhYmxlRWxlbWVudHNbMF0sIHRoaXMuX2xhc3RFbGVtZW50ID0gdGhpcy5fZm9jdXNhYmxlRWxlbWVudHNbdGhpcy5fZm9jdXNhYmxlRWxlbWVudHMubGVuZ3RoIC0gMV07XG4gIH1cbiAgX3NldEZvY3VzVHJhcCgpIHtcbiAgICB0aGlzLl9mb2N1c2FibGVFbGVtZW50cy5mb3JFYWNoKCh0LCBlKSA9PiB7XG4gICAgICBlID09PSB0aGlzLl9mb2N1c2FibGVFbGVtZW50cy5sZW5ndGggLSAxIHx8IGUgPT09IDAgPyB0LmFkZEV2ZW50TGlzdGVuZXIodGhpcy5fZXZlbnQsIHRoaXMuaGFuZGxlcikgOiB0LnJlbW92ZUV2ZW50TGlzdGVuZXIodGhpcy5fZXZlbnQsIHRoaXMuaGFuZGxlcik7XG4gICAgfSk7XG4gIH1cbn1cbmxldCBHciA9IFtdO1xuY29uc3QgY24gPSAocywgdCA9IFwiaGlkZVwiKSA9PiB7XG4gIGNvbnN0IGUgPSBgY2xpY2suZGlzbWlzcyR7cy5FVkVOVF9LRVl9YCwgaSA9IHMuTkFNRTtcbiAgR3IuaW5jbHVkZXMoaSkgfHwgKEdyLnB1c2goaSksIGMub24oXG4gICAgZG9jdW1lbnQsXG4gICAgZSxcbiAgICBgW2RhdGEtdGUtJHtpfS1kaXNtaXNzXWAsXG4gICAgZnVuY3Rpb24obikge1xuICAgICAgaWYgKFtcIkFcIiwgXCJBUkVBXCJdLmluY2x1ZGVzKHRoaXMudGFnTmFtZSkgJiYgbi5wcmV2ZW50RGVmYXVsdCgpLCBnZSh0aGlzKSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY29uc3QgbyA9IEp0KHRoaXMpIHx8IHRoaXMuY2xvc2VzdChgLiR7aX1gKSB8fCB0aGlzLmNsb3Nlc3QoYFtkYXRhLXRlLSR7aX0taW5pdF1gKTtcbiAgICAgIGlmICghbylcbiAgICAgICAgcmV0dXJuO1xuICAgICAgcy5nZXRPckNyZWF0ZUluc3RhbmNlKG8pW3RdKCk7XG4gICAgfVxuICApKTtcbn0sIHFyID0gXCJvZmZjYW52YXNcIiwgJHUgPSBcInRlLm9mZmNhbnZhc1wiLCBlaSA9IGAuJHskdX1gLCBMdSA9IFwiLmRhdGEtYXBpXCIsIE51ID0gYGxvYWQke2VpfSR7THV9YCwgTXUgPSBcIkVzY2FwZVwiLCBaciA9IHtcbiAgYmFja2Ryb3A6ICEwLFxuICBrZXlib2FyZDogITAsXG4gIHNjcm9sbDogITFcbn0sIFJ1ID0ge1xuICBiYWNrZHJvcDogXCJib29sZWFuXCIsXG4gIGtleWJvYXJkOiBcImJvb2xlYW5cIixcbiAgc2Nyb2xsOiBcImJvb2xlYW5cIlxufSwgUXIgPSBcInNob3dcIiwgUHUgPSBcIltkYXRhLXRlLW9mZmNhbnZhcy1pbml0XVtkYXRhLXRlLW9mZmNhbnZhcy1zaG93XVwiLCBCdSA9IGBzaG93JHtlaX1gLCBIdSA9IGBzaG93biR7ZWl9YCwgVnUgPSBgaGlkZSR7ZWl9YCwgV3UgPSBgaGlkZGVuJHtlaX1gLCBGdSA9IGBrZXlkb3duLmRpc21pc3Mke2VpfWA7XG5jbGFzcyBCcyBleHRlbmRzIGd0IHtcbiAgY29uc3RydWN0b3IodCwgZSkge1xuICAgIHN1cGVyKHQpLCB0aGlzLl9jb25maWcgPSB0aGlzLl9nZXRDb25maWcoZSksIHRoaXMuX2lzU2hvd24gPSAhMSwgdGhpcy5fYmFja2Ryb3AgPSB0aGlzLl9pbml0aWFsaXplQmFja0Ryb3AoKSwgdGhpcy5fZm9jdXN0cmFwID0gdGhpcy5faW5pdGlhbGl6ZUZvY3VzVHJhcCgpLCB0aGlzLl9hZGRFdmVudExpc3RlbmVycygpLCB0aGlzLl9kaWRJbml0ID0gITEsIHRoaXMuX2luaXQoKTtcbiAgfVxuICAvLyBHZXR0ZXJzXG4gIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICByZXR1cm4gcXI7XG4gIH1cbiAgc3RhdGljIGdldCBEZWZhdWx0KCkge1xuICAgIHJldHVybiBacjtcbiAgfVxuICAvLyBQdWJsaWNcbiAgdG9nZ2xlKHQpIHtcbiAgICByZXR1cm4gdGhpcy5faXNTaG93biA/IHRoaXMuaGlkZSgpIDogdGhpcy5zaG93KHQpO1xuICB9XG4gIHNob3codCkge1xuICAgIGlmICh0aGlzLl9pc1Nob3duIHx8IGMudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBCdSwge1xuICAgICAgcmVsYXRlZFRhcmdldDogdFxuICAgIH0pLmRlZmF1bHRQcmV2ZW50ZWQpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5faXNTaG93biA9ICEwLCB0aGlzLl9lbGVtZW50LnN0eWxlLnZpc2liaWxpdHkgPSBcInZpc2libGVcIiwgdGhpcy5fYmFja2Ryb3Auc2hvdygpLCB0aGlzLl9jb25maWcuc2Nyb2xsIHx8IG5ldyBxZSgpLmhpZGUoKSwgdGhpcy5fZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoXCJhcmlhLWhpZGRlblwiKSwgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJhcmlhLW1vZGFsXCIsICEwKSwgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwiZGlhbG9nXCIpLCB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZShgZGF0YS10ZS1vZmZjYW52YXMtJHtRcn1gLCBcIlwiKTtcbiAgICBjb25zdCBpID0gKCkgPT4ge1xuICAgICAgdGhpcy5fY29uZmlnLnNjcm9sbCB8fCB0aGlzLl9mb2N1c3RyYXAudHJhcCgpLCBjLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgSHUsIHsgcmVsYXRlZFRhcmdldDogdCB9KTtcbiAgICB9O1xuICAgIHRoaXMuX3F1ZXVlQ2FsbGJhY2soaSwgdGhpcy5fZWxlbWVudCwgITApO1xuICB9XG4gIGhpZGUoKSB7XG4gICAgaWYgKCF0aGlzLl9pc1Nob3duIHx8IGMudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBWdSkuZGVmYXVsdFByZXZlbnRlZClcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLl9mb2N1c3RyYXAuZGlzYWJsZSgpLCB0aGlzLl9lbGVtZW50LmJsdXIoKSwgdGhpcy5faXNTaG93biA9ICExLCB0aGlzLl9lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShgZGF0YS10ZS1vZmZjYW52YXMtJHtRcn1gKSwgdGhpcy5fYmFja2Ryb3AuaGlkZSgpO1xuICAgIGNvbnN0IGUgPSAoKSA9PiB7XG4gICAgICB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIsICEwKSwgdGhpcy5fZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoXCJhcmlhLW1vZGFsXCIpLCB0aGlzLl9lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShcInJvbGVcIiksIHRoaXMuX2VsZW1lbnQuc3R5bGUudmlzaWJpbGl0eSA9IFwiaGlkZGVuXCIsIHRoaXMuX2NvbmZpZy5zY3JvbGwgfHwgbmV3IHFlKCkucmVzZXQoKSwgYy50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIFd1KTtcbiAgICB9O1xuICAgIHRoaXMuX3F1ZXVlQ2FsbGJhY2soZSwgdGhpcy5fZWxlbWVudCwgITApO1xuICB9XG4gIGRpc3Bvc2UoKSB7XG4gICAgdGhpcy5fYmFja2Ryb3AuZGlzcG9zZSgpLCB0aGlzLl9mb2N1c3RyYXAuZGlzYWJsZSgpLCBzdXBlci5kaXNwb3NlKCk7XG4gIH1cbiAgLy8gUHJpdmF0ZVxuICBfaW5pdCgpIHtcbiAgICB0aGlzLl9kaWRJbml0IHx8IChjLm9uKFxuICAgICAgd2luZG93LFxuICAgICAgTnUsXG4gICAgICAoKSA9PiBkLmZpbmQoUHUpLmZvckVhY2goXG4gICAgICAgICh0KSA9PiBCcy5nZXRPckNyZWF0ZUluc3RhbmNlKHQpLnNob3coKVxuICAgICAgKVxuICAgICksIHRoaXMuX2RpZEluaXQgPSAhMCwgY24oQnMpKTtcbiAgfVxuICBfZ2V0Q29uZmlnKHQpIHtcbiAgICByZXR1cm4gdCA9IHtcbiAgICAgIC4uLlpyLFxuICAgICAgLi4uaC5nZXREYXRhQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KSxcbiAgICAgIC4uLnR5cGVvZiB0ID09IFwib2JqZWN0XCIgPyB0IDoge31cbiAgICB9LCBEKHFyLCB0LCBSdSksIHQ7XG4gIH1cbiAgX2luaXRpYWxpemVCYWNrRHJvcCgpIHtcbiAgICByZXR1cm4gbmV3IGhyKHtcbiAgICAgIGlzVmlzaWJsZTogdGhpcy5fY29uZmlnLmJhY2tkcm9wLFxuICAgICAgaXNBbmltYXRlZDogITAsXG4gICAgICByb290RWxlbWVudDogdGhpcy5fZWxlbWVudC5wYXJlbnROb2RlLFxuICAgICAgY2xpY2tDYWxsYmFjazogKCkgPT4gdGhpcy5oaWRlKClcbiAgICB9KTtcbiAgfVxuICBfaW5pdGlhbGl6ZUZvY3VzVHJhcCgpIHtcbiAgICByZXR1cm4gbmV3IFdpKHRoaXMuX2VsZW1lbnQsIHtcbiAgICAgIGV2ZW50OiBcImtleWRvd25cIixcbiAgICAgIGNvbmRpdGlvbjogKHQpID0+IHQua2V5ID09PSBcIlRhYlwiXG4gICAgfSk7XG4gIH1cbiAgX2FkZEV2ZW50TGlzdGVuZXJzKCkge1xuICAgIGMub24odGhpcy5fZWxlbWVudCwgRnUsICh0KSA9PiB7XG4gICAgICB0aGlzLl9jb25maWcua2V5Ym9hcmQgJiYgdC5rZXkgPT09IE11ICYmIHRoaXMuaGlkZSgpO1xuICAgIH0pO1xuICB9XG4gIC8vIFN0YXRpY1xuICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKHQpIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgY29uc3QgZSA9IEJzLmdldE9yQ3JlYXRlSW5zdGFuY2UodGhpcywgdCk7XG4gICAgICBpZiAodHlwZW9mIHQgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICBpZiAoZVt0XSA9PT0gdm9pZCAwIHx8IHQuc3RhcnRzV2l0aChcIl9cIikgfHwgdCA9PT0gXCJjb25zdHJ1Y3RvclwiKVxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcIiR7dH1cImApO1xuICAgICAgICBlW3RdKHRoaXMpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5jb25zdCBJbiA9IFwiYWxlcnRcIiwgWXUgPSBcInRlLmFsZXJ0XCIsIExjID0gYC4ke1l1fWAsIGp1ID0gYGNsb3NlJHtMY31gLCBLdSA9IGBjbG9zZWQke0xjfWAsIGFpID0gXCJkYXRhLXRlLWFsZXJ0LXNob3dcIiwgenUgPSB7XG4gIGFuaW1hdGlvbjogXCJib29sZWFuXCIsXG4gIGF1dG9oaWRlOiBcImJvb2xlYW5cIixcbiAgZGVsYXk6IFwibnVtYmVyXCJcbn0sIEpyID0ge1xuICBhbmltYXRpb246ICEwLFxuICBhdXRvaGlkZTogITAsXG4gIGRlbGF5OiAxZTNcbn0sIFV1ID0ge1xuICBmYWRlSW46IFwiYW5pbWF0ZS1bZmFkZS1pbl8wLjNzX2JvdGhdIHAtW2F1dG9dIG1vdGlvbi1yZWR1Y2U6dHJhbnNpdGlvbi1ub25lIG1vdGlvbi1yZWR1Y2U6YW5pbWF0ZS1ub25lXCIsXG4gIGZhZGVPdXQ6IFwiYW5pbWF0ZS1bZmFkZS1vdXRfMC4zc19ib3RoXSBwLVthdXRvXSBtb3Rpb24tcmVkdWNlOnRyYW5zaXRpb24tbm9uZSBtb3Rpb24tcmVkdWNlOmFuaW1hdGUtbm9uZVwiXG59LCBYdSA9IHtcbiAgZmFkZUluOiBcInN0cmluZ1wiLFxuICBmYWRlT3V0OiBcInN0cmluZ1wiXG59O1xuY2xhc3MgTG8gZXh0ZW5kcyBndCB7XG4gIGNvbnN0cnVjdG9yKHQsIGUsIGkpIHtcbiAgICBzdXBlcih0KSwgdGhpcy5fZWxlbWVudCA9IHQsIHRoaXMuX2NvbmZpZyA9IHRoaXMuX2dldENvbmZpZyhlKSwgdGhpcy5fY2xhc3NlcyA9IHRoaXMuX2dldENsYXNzZXMoaSksIHRoaXMuX2RpZEluaXQgPSAhMSwgdGhpcy5faW5pdCgpO1xuICB9XG4gIC8vIEdldHRlcnNcbiAgc3RhdGljIGdldCBEZWZhdWx0VHlwZSgpIHtcbiAgICByZXR1cm4genU7XG4gIH1cbiAgc3RhdGljIGdldCBEZWZhdWx0KCkge1xuICAgIHJldHVybiBKcjtcbiAgfVxuICBzdGF0aWMgZ2V0IE5BTUUoKSB7XG4gICAgcmV0dXJuIEluO1xuICB9XG4gIC8vIFB1YmxpY1xuICBjbG9zZSgpIHtcbiAgICBpZiAoYy50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIGp1KS5kZWZhdWx0UHJldmVudGVkKVxuICAgICAgcmV0dXJuO1xuICAgIGxldCBlID0gMDtcbiAgICB0aGlzLl9jb25maWcuYW5pbWF0aW9uICYmIChlID0gMzAwLCBoLmFkZENsYXNzKHRoaXMuX2VsZW1lbnQsIHRoaXMuX2NsYXNzZXMuZmFkZU91dCkpLCB0aGlzLl9lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShhaSksIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5fcXVldWVDYWxsYmFjayhcbiAgICAgICAgKCkgPT4gdGhpcy5fZGVzdHJveUVsZW1lbnQoKSxcbiAgICAgICAgdGhpcy5fZWxlbWVudCxcbiAgICAgICAgdGhpcy5fY29uZmlnLmFuaW1hdGlvblxuICAgICAgKTtcbiAgICB9LCBlKTtcbiAgfVxuICBzaG93KCkge1xuICAgIGlmICh0aGlzLl9lbGVtZW50KSB7XG4gICAgICBpZiAodGhpcy5fY29uZmlnLmF1dG9oaWRlICYmIHRoaXMuX3NldHVwQXV0b2hpZGUoKSwgIXRoaXMuX2VsZW1lbnQuaGFzQXR0cmlidXRlKGFpKSAmJiAoaC5yZW1vdmVDbGFzcyh0aGlzLl9lbGVtZW50LCBcImhpZGRlblwiKSwgaC5hZGRDbGFzcyh0aGlzLl9lbGVtZW50LCBcImJsb2NrXCIpLCBOdCh0aGlzLl9lbGVtZW50KSkpIHtcbiAgICAgICAgY29uc3QgdCA9IChlKSA9PiB7XG4gICAgICAgICAgaC5yZW1vdmVDbGFzcyh0aGlzLl9lbGVtZW50LCBcImhpZGRlblwiKSwgaC5hZGRDbGFzcyh0aGlzLl9lbGVtZW50LCBcImJsb2NrXCIpLCBjLm9mZihlLnRhcmdldCwgXCJhbmltYXRpb25lbmRcIiwgdCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKGFpLCBcIlwiKSwgYy5vbih0aGlzLl9lbGVtZW50LCBcImFuaW1hdGlvbmVuZFwiLCB0KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2NvbmZpZy5hbmltYXRpb24gJiYgKGgucmVtb3ZlQ2xhc3ModGhpcy5fZWxlbWVudCwgdGhpcy5fY2xhc3Nlcy5mYWRlT3V0KSwgaC5hZGRDbGFzcyh0aGlzLl9lbGVtZW50LCB0aGlzLl9jbGFzc2VzLmZhZGVJbikpO1xuICAgIH1cbiAgfVxuICBoaWRlKCkge1xuICAgIGlmICh0aGlzLl9lbGVtZW50ICYmIHRoaXMuX2VsZW1lbnQuaGFzQXR0cmlidXRlKGFpKSkge1xuICAgICAgdGhpcy5fZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoYWkpO1xuICAgICAgY29uc3QgdCA9IChlKSA9PiB7XG4gICAgICAgIGguYWRkQ2xhc3ModGhpcy5fZWxlbWVudCwgXCJoaWRkZW5cIiksIGgucmVtb3ZlQ2xhc3ModGhpcy5fZWxlbWVudCwgXCJibG9ja1wiKSwgdGhpcy5fdGltZW91dCAhPT0gbnVsbCAmJiAoY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVvdXQpLCB0aGlzLl90aW1lb3V0ID0gbnVsbCksIGMub2ZmKGUudGFyZ2V0LCBcImFuaW1hdGlvbmVuZFwiLCB0KTtcbiAgICAgIH07XG4gICAgICBjLm9uKHRoaXMuX2VsZW1lbnQsIFwiYW5pbWF0aW9uZW5kXCIsIHQpLCBoLnJlbW92ZUNsYXNzKHRoaXMuX2VsZW1lbnQsIHRoaXMuX2NsYXNzZXMuZmFkZUluKSwgaC5hZGRDbGFzcyh0aGlzLl9lbGVtZW50LCB0aGlzLl9jbGFzc2VzLmZhZGVPdXQpO1xuICAgIH1cbiAgfVxuICAvLyBQcml2YXRlXG4gIF9pbml0KCkge1xuICAgIHRoaXMuX2RpZEluaXQgfHwgKGNuKExvLCBcImNsb3NlXCIpLCB0aGlzLl9kaWRJbml0ID0gITApO1xuICB9XG4gIF9nZXRDb25maWcodCkge1xuICAgIHJldHVybiB0ID0ge1xuICAgICAgLi4uSnIsXG4gICAgICAuLi5oLmdldERhdGFBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpLFxuICAgICAgLi4udHlwZW9mIHQgPT0gXCJvYmplY3RcIiAmJiB0ID8gdCA6IHt9XG4gICAgfSwgRChJbiwgdCwgdGhpcy5jb25zdHJ1Y3Rvci5EZWZhdWx0VHlwZSksIHQ7XG4gIH1cbiAgX2dldENsYXNzZXModCkge1xuICAgIGNvbnN0IGUgPSBoLmdldERhdGFDbGFzc0F0dHJpYnV0ZXModGhpcy5fZWxlbWVudCk7XG4gICAgcmV0dXJuIHQgPSB7XG4gICAgICAuLi5VdSxcbiAgICAgIC4uLmUsXG4gICAgICAuLi50XG4gICAgfSwgRChJbiwgdCwgWHUpLCB0O1xuICB9XG4gIF9zZXR1cEF1dG9oaWRlKCkge1xuICAgIHRoaXMuX3RpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuaGlkZSgpO1xuICAgIH0sIHRoaXMuX2NvbmZpZy5kZWxheSk7XG4gIH1cbiAgX2Rlc3Ryb3lFbGVtZW50KCkge1xuICAgIHRoaXMuX2VsZW1lbnQucmVtb3ZlKCksIGMudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBLdSksIHRoaXMuZGlzcG9zZSgpO1xuICB9XG4gIC8vIFN0YXRpY1xuICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKHQpIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgY29uc3QgZSA9IExvLmdldE9yQ3JlYXRlSW5zdGFuY2UodGhpcyk7XG4gICAgICBpZiAodHlwZW9mIHQgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICBpZiAoZVt0XSA9PT0gdm9pZCAwIHx8IHQuc3RhcnRzV2l0aChcIl9cIikgfHwgdCA9PT0gXCJjb25zdHJ1Y3RvclwiKVxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcIiR7dH1cImApO1xuICAgICAgICBlW3RdKHRoaXMpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5jb25zdCBEbiA9IFwiY2Fyb3VzZWxcIiwgR3UgPSBcInRlLmNhcm91c2VsXCIsIF90ID0gYC4ke0d1fWAsIE5jID0gXCIuZGF0YS1hcGlcIiwgcXUgPSBcIkFycm93TGVmdFwiLCBadSA9IFwiQXJyb3dSaWdodFwiLCBRdSA9IDUwMCwgSnUgPSA0MCwgdGEgPSB7XG4gIGludGVydmFsOiA1ZTMsXG4gIGtleWJvYXJkOiAhMCxcbiAgcmlkZTogITEsXG4gIHBhdXNlOiBcImhvdmVyXCIsXG4gIHdyYXA6ICEwLFxuICB0b3VjaDogITBcbn0sIHRwID0ge1xuICBpbnRlcnZhbDogXCIobnVtYmVyfGJvb2xlYW4pXCIsXG4gIGtleWJvYXJkOiBcImJvb2xlYW5cIixcbiAgcmlkZTogXCIoYm9vbGVhbnxzdHJpbmcpXCIsXG4gIHBhdXNlOiBcIihzdHJpbmd8Ym9vbGVhbilcIixcbiAgd3JhcDogXCJib29sZWFuXCIsXG4gIHRvdWNoOiBcImJvb2xlYW5cIlxufSwgZXAgPSB7XG4gIHBvaW50ZXI6IFwidG91Y2gtcGFuLXlcIixcbiAgYmxvY2s6IFwiIWJsb2NrXCIsXG4gIHZpc2libGU6IFwiZGF0YS1bdGUtY2Fyb3VzZWwtZmFkZV06b3BhY2l0eS0xMDAgZGF0YS1bdGUtY2Fyb3VzZWwtZmFkZV06ei1bMV1cIixcbiAgaW52aXNpYmxlOiBcImRhdGEtW3RlLWNhcm91c2VsLWZhZGVdOnotMCBkYXRhLVt0ZS1jYXJvdXNlbC1mYWRlXTpvcGFjaXR5LTAgZGF0YS1bdGUtY2Fyb3VzZWwtZmFkZV06ZHVyYXRpb24tWzYwMG1zXSBkYXRhLVt0ZS1jYXJvdXNlbC1mYWRlXTpkZWxheS02MDBcIixcbiAgc2xpZGVSaWdodDogXCJ0cmFuc2xhdGUteC1mdWxsXCIsXG4gIHNsaWRlTGVmdDogXCItdHJhbnNsYXRlLXgtZnVsbFwiXG59LCBpcCA9IHtcbiAgcG9pbnRlcjogXCJzdHJpbmdcIixcbiAgYmxvY2s6IFwic3RyaW5nXCIsXG4gIHZpc2libGU6IFwic3RyaW5nXCIsXG4gIGludmlzaWJsZTogXCJzdHJpbmdcIixcbiAgc2xpZGVSaWdodDogXCJzdHJpbmdcIixcbiAgc2xpZGVMZWZ0OiBcInN0cmluZ1wiXG59LCBsZSA9IFwibmV4dFwiLCBjZSA9IFwicHJldlwiLCBfZSA9IFwibGVmdFwiLCBtaSA9IFwicmlnaHRcIiwgc3AgPSB7XG4gIFtxdV06IG1pLFxuICBbWnVdOiBfZVxufSwgbnAgPSBgc2xpZGUke190fWAsICRuID0gYHNsaWQke190fWAsIG9wID0gYGtleWRvd24ke190fWAsIHJwID0gYG1vdXNlZW50ZXIke190fWAsIGFwID0gYG1vdXNlbGVhdmUke190fWAsIGxwID0gYHRvdWNoc3RhcnQke190fWAsIGNwID0gYHRvdWNobW92ZSR7X3R9YCwgaHAgPSBgdG91Y2hlbmQke190fWAsIGRwID0gYHBvaW50ZXJkb3duJHtfdH1gLCB1cCA9IGBwb2ludGVydXAke190fWAsIHBwID0gYGRyYWdzdGFydCR7X3R9YCwgX3AgPSBgbG9hZCR7X3R9JHtOY31gLCBmcCA9IGBjbGljayR7X3R9JHtOY31gLCBlYSA9IFwiZGF0YS10ZS1jYXJvdXNlbC1pbml0XCIsIGhlID0gXCJkYXRhLXRlLWNhcm91c2VsLWFjdGl2ZVwiLCBtcCA9IFwiZGF0YS10ZS1jYXJvdXNlbC1pdGVtLWVuZFwiLCBMbiA9IFwiZGF0YS10ZS1jYXJvdXNlbC1pdGVtLXN0YXJ0XCIsIGdwID0gXCJkYXRhLXRlLWNhcm91c2VsLWl0ZW0tbmV4dFwiLCBicCA9IFwiZGF0YS10ZS1jYXJvdXNlbC1pdGVtLXByZXZcIiwgdnAgPSBcImRhdGEtdGUtY2Fyb3VzZWwtcG9pbnRlci1ldmVudFwiLCBUcCA9IFwiW2RhdGEtdGUtY2Fyb3VzZWwtaW5pdF1cIiwgTWMgPSBcIltkYXRhLXRlLWNhcm91c2VsLWFjdGl2ZV1cIiwgZHIgPSBcIltkYXRhLXRlLWNhcm91c2VsLWl0ZW1dXCIsIHdlID0gYCR7TWN9JHtkcn1gLCBFcCA9IGAke2RyfSBpbWdgLCBDcCA9IFwiW2RhdGEtdGUtY2Fyb3VzZWwtaXRlbS1uZXh0XSwgW2RhdGEtdGUtY2Fyb3VzZWwtaXRlbS1wcmV2XVwiLCBBcCA9IFwiW2RhdGEtdGUtY2Fyb3VzZWwtaW5kaWNhdG9yc11cIiwgeXAgPSBcIltkYXRhLXRlLXRhcmdldF1cIiwgd3AgPSBcIltkYXRhLXRlLXNsaWRlXSwgW2RhdGEtdGUtc2xpZGUtdG9dXCIsIGtwID0gXCJ0b3VjaFwiLCB4cCA9IFwicGVuXCI7XG5jbGFzcyBVdCBleHRlbmRzIGd0IHtcbiAgY29uc3RydWN0b3IodCwgZSwgaSkge1xuICAgIHN1cGVyKHQpLCB0aGlzLl9pdGVtcyA9IG51bGwsIHRoaXMuX2ludGVydmFsID0gbnVsbCwgdGhpcy5fYWN0aXZlRWxlbWVudCA9IG51bGwsIHRoaXMuX2lzUGF1c2VkID0gITEsIHRoaXMuX2lzU2xpZGluZyA9ICExLCB0aGlzLnRvdWNoVGltZW91dCA9IG51bGwsIHRoaXMudG91Y2hTdGFydFggPSAwLCB0aGlzLnRvdWNoRGVsdGFYID0gMCwgdGhpcy5fY29uZmlnID0gdGhpcy5fZ2V0Q29uZmlnKGUpLCB0aGlzLl9jbGFzc2VzID0gdGhpcy5fZ2V0Q2xhc3NlcyhpKSwgdGhpcy5faW5kaWNhdG9yc0VsZW1lbnQgPSBkLmZpbmRPbmUoXG4gICAgICBBcCxcbiAgICAgIHRoaXMuX2VsZW1lbnRcbiAgICApLCB0aGlzLl90b3VjaFN1cHBvcnRlZCA9IFwib250b3VjaHN0YXJ0XCIgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50IHx8IG5hdmlnYXRvci5tYXhUb3VjaFBvaW50cyA+IDAsIHRoaXMuX3BvaW50ZXJFdmVudCA9ICEhd2luZG93LlBvaW50ZXJFdmVudCwgdGhpcy5fc2V0QWN0aXZlRWxlbWVudENsYXNzKCksIHRoaXMuX2FkZEV2ZW50TGlzdGVuZXJzKCksIHRoaXMuX2RpZEluaXQgPSAhMSwgdGhpcy5faW5pdCgpLCB0aGlzLl9jb25maWcucmlkZSA9PT0gXCJjYXJvdXNlbFwiICYmIHRoaXMuY3ljbGUoKTtcbiAgfVxuICAvLyBHZXR0ZXJzXG4gIHN0YXRpYyBnZXQgRGVmYXVsdCgpIHtcbiAgICByZXR1cm4gdGE7XG4gIH1cbiAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgIHJldHVybiBEbjtcbiAgfVxuICAvLyBQdWJsaWNcbiAgbmV4dCgpIHtcbiAgICB0aGlzLl9zbGlkZShsZSk7XG4gIH1cbiAgbmV4dFdoZW5WaXNpYmxlKCkge1xuICAgICFkb2N1bWVudC5oaWRkZW4gJiYgTnQodGhpcy5fZWxlbWVudCkgJiYgdGhpcy5uZXh0KCk7XG4gIH1cbiAgcHJldigpIHtcbiAgICB0aGlzLl9zbGlkZShjZSk7XG4gIH1cbiAgcGF1c2UodCkge1xuICAgIHQgfHwgKHRoaXMuX2lzUGF1c2VkID0gITApLCBkLmZpbmRPbmUoQ3AsIHRoaXMuX2VsZW1lbnQpICYmIChYbCh0aGlzLl9lbGVtZW50KSwgdGhpcy5jeWNsZSghMCkpLCBjbGVhckludGVydmFsKHRoaXMuX2ludGVydmFsKSwgdGhpcy5faW50ZXJ2YWwgPSBudWxsO1xuICB9XG4gIGN5Y2xlKHQpIHtcbiAgICB0IHx8ICh0aGlzLl9pc1BhdXNlZCA9ICExKSwgdGhpcy5faW50ZXJ2YWwgJiYgKGNsZWFySW50ZXJ2YWwodGhpcy5faW50ZXJ2YWwpLCB0aGlzLl9pbnRlcnZhbCA9IG51bGwpLCB0aGlzLl9jb25maWcgJiYgdGhpcy5fY29uZmlnLmludGVydmFsICYmICF0aGlzLl9pc1BhdXNlZCAmJiAodGhpcy5fdXBkYXRlSW50ZXJ2YWwoKSwgdGhpcy5faW50ZXJ2YWwgPSBzZXRJbnRlcnZhbChcbiAgICAgIChkb2N1bWVudC52aXNpYmlsaXR5U3RhdGUgPyB0aGlzLm5leHRXaGVuVmlzaWJsZSA6IHRoaXMubmV4dCkuYmluZChcbiAgICAgICAgdGhpc1xuICAgICAgKSxcbiAgICAgIHRoaXMuX2NvbmZpZy5pbnRlcnZhbFxuICAgICkpO1xuICB9XG4gIHRvKHQpIHtcbiAgICB0aGlzLl9hY3RpdmVFbGVtZW50ID0gZC5maW5kT25lKFxuICAgICAgd2UsXG4gICAgICB0aGlzLl9lbGVtZW50XG4gICAgKTtcbiAgICBjb25zdCBlID0gdGhpcy5fZ2V0SXRlbUluZGV4KHRoaXMuX2FjdGl2ZUVsZW1lbnQpO1xuICAgIGlmICh0ID4gdGhpcy5faXRlbXMubGVuZ3RoIC0gMSB8fCB0IDwgMClcbiAgICAgIHJldHVybjtcbiAgICBpZiAodGhpcy5faXNTbGlkaW5nKSB7XG4gICAgICBjLm9uZSh0aGlzLl9lbGVtZW50LCAkbiwgKCkgPT4gdGhpcy50byh0KSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChlID09PSB0KSB7XG4gICAgICB0aGlzLnBhdXNlKCksIHRoaXMuY3ljbGUoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaSA9IHQgPiBlID8gbGUgOiBjZTtcbiAgICB0aGlzLl9zbGlkZShpLCB0aGlzLl9pdGVtc1t0XSk7XG4gIH1cbiAgLy8gUHJpdmF0ZVxuICBfaW5pdCgpIHtcbiAgICB0aGlzLl9kaWRJbml0IHx8IChjLm9uKFxuICAgICAgZG9jdW1lbnQsXG4gICAgICBmcCxcbiAgICAgIHdwLFxuICAgICAgVXQuZGF0YUFwaUNsaWNrSGFuZGxlclxuICAgICksIGMub24od2luZG93LCBfcCwgKCkgPT4ge1xuICAgICAgY29uc3QgdCA9IGQuZmluZChUcCk7XG4gICAgICBmb3IgKGxldCBlID0gMCwgaSA9IHQubGVuZ3RoOyBlIDwgaTsgZSsrKVxuICAgICAgICBVdC5jYXJvdXNlbEludGVyZmFjZShcbiAgICAgICAgICB0W2VdLFxuICAgICAgICAgIFV0LmdldEluc3RhbmNlKHRbZV0pXG4gICAgICAgICk7XG4gICAgfSksIHRoaXMuX2RpZEluaXQgPSAhMCk7XG4gIH1cbiAgX2dldENvbmZpZyh0KSB7XG4gICAgcmV0dXJuIHQgPSB7XG4gICAgICAuLi50YSxcbiAgICAgIC4uLmguZ2V0RGF0YUF0dHJpYnV0ZXModGhpcy5fZWxlbWVudCksXG4gICAgICAuLi50eXBlb2YgdCA9PSBcIm9iamVjdFwiID8gdCA6IHt9XG4gICAgfSwgRChEbiwgdCwgdHApLCB0O1xuICB9XG4gIF9nZXRDbGFzc2VzKHQpIHtcbiAgICBjb25zdCBlID0gaC5nZXREYXRhQ2xhc3NBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpO1xuICAgIHJldHVybiB0ID0ge1xuICAgICAgLi4uZXAsXG4gICAgICAuLi5lLFxuICAgICAgLi4udFxuICAgIH0sIEQoRG4sIHQsIGlwKSwgdDtcbiAgfVxuICBfZW5hYmxlQ3ljbGUoKSB7XG4gICAgaWYgKHRoaXMuX2NvbmZpZy5yaWRlKSB7XG4gICAgICBpZiAodGhpcy5faXNTbGlkaW5nKSB7XG4gICAgICAgIGMub25lKHRoaXMuX2VsZW1lbnQsICRuLCAoKSA9PiB0aGlzLmN5Y2xlKCkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLmN5Y2xlKCk7XG4gICAgfVxuICB9XG4gIF9hcHBseUluaXRpYWxDbGFzc2VzKCkge1xuICAgIGNvbnN0IHQgPSBkLmZpbmRPbmUoXG4gICAgICB3ZSxcbiAgICAgIHRoaXMuX2VsZW1lbnRcbiAgICApO1xuICAgIHQuY2xhc3NMaXN0LmFkZChcbiAgICAgIHRoaXMuX2NsYXNzZXMuYmxvY2ssXG4gICAgICAuLi50aGlzLl9jbGFzc2VzLnZpc2libGUuc3BsaXQoXCIgXCIpXG4gICAgKSwgdGhpcy5fc2V0QWN0aXZlSW5kaWNhdG9yRWxlbWVudCh0KTtcbiAgfVxuICBfaGFuZGxlU3dpcGUoKSB7XG4gICAgY29uc3QgdCA9IE1hdGguYWJzKHRoaXMudG91Y2hEZWx0YVgpO1xuICAgIGlmICh0IDw9IEp1KVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGUgPSB0IC8gdGhpcy50b3VjaERlbHRhWDtcbiAgICB0aGlzLnRvdWNoRGVsdGFYID0gMCwgZSAmJiB0aGlzLl9zbGlkZShlID4gMCA/IG1pIDogX2UpO1xuICB9XG4gIF9zZXRBY3RpdmVFbGVtZW50Q2xhc3MoKSB7XG4gICAgdGhpcy5fYWN0aXZlRWxlbWVudCA9IGQuZmluZE9uZShcbiAgICAgIHdlLFxuICAgICAgdGhpcy5fZWxlbWVudFxuICAgICksIGguYWRkQ2xhc3ModGhpcy5fYWN0aXZlRWxlbWVudCwgXCJoaWRkZW5cIik7XG4gIH1cbiAgX2FkZEV2ZW50TGlzdGVuZXJzKCkge1xuICAgIHRoaXMuX2NvbmZpZy5rZXlib2FyZCAmJiBjLm9uKFxuICAgICAgdGhpcy5fZWxlbWVudCxcbiAgICAgIG9wLFxuICAgICAgKHQpID0+IHRoaXMuX2tleWRvd24odClcbiAgICApLCB0aGlzLl9jb25maWcucGF1c2UgPT09IFwiaG92ZXJcIiAmJiAoYy5vbihcbiAgICAgIHRoaXMuX2VsZW1lbnQsXG4gICAgICBycCxcbiAgICAgICh0KSA9PiB0aGlzLnBhdXNlKHQpXG4gICAgKSwgYy5vbihcbiAgICAgIHRoaXMuX2VsZW1lbnQsXG4gICAgICBhcCxcbiAgICAgICh0KSA9PiB0aGlzLl9lbmFibGVDeWNsZSh0KVxuICAgICkpLCB0aGlzLl9jb25maWcudG91Y2ggJiYgdGhpcy5fdG91Y2hTdXBwb3J0ZWQgJiYgdGhpcy5fYWRkVG91Y2hFdmVudExpc3RlbmVycygpLCB0aGlzLl9hcHBseUluaXRpYWxDbGFzc2VzKCk7XG4gIH1cbiAgX2FkZFRvdWNoRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgY29uc3QgdCA9IChvKSA9PiB0aGlzLl9wb2ludGVyRXZlbnQgJiYgKG8ucG9pbnRlclR5cGUgPT09IHhwIHx8IG8ucG9pbnRlclR5cGUgPT09IGtwKSwgZSA9IChvKSA9PiB7XG4gICAgICB0KG8pID8gdGhpcy50b3VjaFN0YXJ0WCA9IG8uY2xpZW50WCA6IHRoaXMuX3BvaW50ZXJFdmVudCB8fCAodGhpcy50b3VjaFN0YXJ0WCA9IG8udG91Y2hlc1swXS5jbGllbnRYKTtcbiAgICB9LCBpID0gKG8pID0+IHtcbiAgICAgIHRoaXMudG91Y2hEZWx0YVggPSBvLnRvdWNoZXMgJiYgby50b3VjaGVzLmxlbmd0aCA+IDEgPyAwIDogby50b3VjaGVzWzBdLmNsaWVudFggLSB0aGlzLnRvdWNoU3RhcnRYO1xuICAgIH0sIG4gPSAobykgPT4ge1xuICAgICAgdChvKSAmJiAodGhpcy50b3VjaERlbHRhWCA9IG8uY2xpZW50WCAtIHRoaXMudG91Y2hTdGFydFgpLCB0aGlzLl9oYW5kbGVTd2lwZSgpLCB0aGlzLl9jb25maWcucGF1c2UgPT09IFwiaG92ZXJcIiAmJiAodGhpcy5wYXVzZSgpLCB0aGlzLnRvdWNoVGltZW91dCAmJiBjbGVhclRpbWVvdXQodGhpcy50b3VjaFRpbWVvdXQpLCB0aGlzLnRvdWNoVGltZW91dCA9IHNldFRpbWVvdXQoXG4gICAgICAgIChyKSA9PiB0aGlzLl9lbmFibGVDeWNsZShyKSxcbiAgICAgICAgUXUgKyB0aGlzLl9jb25maWcuaW50ZXJ2YWxcbiAgICAgICkpO1xuICAgIH07XG4gICAgZC5maW5kKEVwLCB0aGlzLl9lbGVtZW50KS5mb3JFYWNoKFxuICAgICAgKG8pID0+IHtcbiAgICAgICAgYy5vbihcbiAgICAgICAgICBvLFxuICAgICAgICAgIHBwLFxuICAgICAgICAgIChyKSA9PiByLnByZXZlbnREZWZhdWx0KClcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICApLCB0aGlzLl9wb2ludGVyRXZlbnQgPyAoYy5vbihcbiAgICAgIHRoaXMuX2VsZW1lbnQsXG4gICAgICBkcCxcbiAgICAgIChvKSA9PiBlKG8pXG4gICAgKSwgYy5vbih0aGlzLl9lbGVtZW50LCB1cCwgKG8pID0+IG4obykpLCB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5hZGQodGhpcy5fY2xhc3Nlcy5wb2ludGVyKSwgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoYCR7dnB9YCwgXCJcIikpIDogKGMub24odGhpcy5fZWxlbWVudCwgbHAsIChvKSA9PiBlKG8pKSwgYy5vbih0aGlzLl9lbGVtZW50LCBjcCwgKG8pID0+IGkobykpLCBjLm9uKHRoaXMuX2VsZW1lbnQsIGhwLCAobykgPT4gbihvKSkpO1xuICB9XG4gIF9rZXlkb3duKHQpIHtcbiAgICBpZiAoL2lucHV0fHRleHRhcmVhL2kudGVzdCh0LnRhcmdldC50YWdOYW1lKSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBlID0gc3BbdC5rZXldO1xuICAgIGUgJiYgKHQucHJldmVudERlZmF1bHQoKSwgdGhpcy5fc2xpZGUoZSkpO1xuICB9XG4gIF9nZXRJdGVtSW5kZXgodCkge1xuICAgIHJldHVybiB0aGlzLl9pdGVtcyA9IHQgJiYgdC5wYXJlbnROb2RlID8gZC5maW5kKGRyLCB0LnBhcmVudE5vZGUpIDogW10sIHRoaXMuX2l0ZW1zLmluZGV4T2YodCk7XG4gIH1cbiAgX2dldEl0ZW1CeU9yZGVyKHQsIGUpIHtcbiAgICBjb25zdCBpID0gdCA9PT0gbGU7XG4gICAgcmV0dXJuIEpsKFxuICAgICAgdGhpcy5faXRlbXMsXG4gICAgICBlLFxuICAgICAgaSxcbiAgICAgIHRoaXMuX2NvbmZpZy53cmFwXG4gICAgKTtcbiAgfVxuICBfdHJpZ2dlclNsaWRlRXZlbnQodCwgZSkge1xuICAgIGNvbnN0IGkgPSB0aGlzLl9nZXRJdGVtSW5kZXgodCksIG4gPSB0aGlzLl9nZXRJdGVtSW5kZXgoXG4gICAgICBkLmZpbmRPbmUod2UsIHRoaXMuX2VsZW1lbnQpXG4gICAgKTtcbiAgICByZXR1cm4gYy50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIG5wLCB7XG4gICAgICByZWxhdGVkVGFyZ2V0OiB0LFxuICAgICAgZGlyZWN0aW9uOiBlLFxuICAgICAgZnJvbTogbixcbiAgICAgIHRvOiBpXG4gICAgfSk7XG4gIH1cbiAgX3NldEFjdGl2ZUluZGljYXRvckVsZW1lbnQodCkge1xuICAgIGlmICh0aGlzLl9pbmRpY2F0b3JzRWxlbWVudCkge1xuICAgICAgY29uc3QgZSA9IGQuZmluZE9uZShcbiAgICAgICAgTWMsXG4gICAgICAgIHRoaXMuX2luZGljYXRvcnNFbGVtZW50XG4gICAgICApO1xuICAgICAgZS5yZW1vdmVBdHRyaWJ1dGUoaGUpLCBlLnJlbW92ZUF0dHJpYnV0ZShcImFyaWEtY3VycmVudFwiKSwgZS5jbGFzc0xpc3QucmVtb3ZlKFwiIW9wYWNpdHktMTAwXCIpO1xuICAgICAgY29uc3QgaSA9IGQuZmluZChcbiAgICAgICAgeXAsXG4gICAgICAgIHRoaXMuX2luZGljYXRvcnNFbGVtZW50XG4gICAgICApO1xuICAgICAgZm9yIChsZXQgbiA9IDA7IG4gPCBpLmxlbmd0aDsgbisrKVxuICAgICAgICBpZiAoTnVtYmVyLnBhcnNlSW50KFxuICAgICAgICAgIGlbbl0uZ2V0QXR0cmlidXRlKFwiZGF0YS10ZS1zbGlkZS10b1wiKSxcbiAgICAgICAgICAxMFxuICAgICAgICApID09PSB0aGlzLl9nZXRJdGVtSW5kZXgodCkpIHtcbiAgICAgICAgICBpW25dLnNldEF0dHJpYnV0ZShgJHtoZX1gLCBcIlwiKSwgaVtuXS5zZXRBdHRyaWJ1dGUoXCJhcmlhLWN1cnJlbnRcIiwgXCJ0cnVlXCIpLCBpW25dLmNsYXNzTGlzdC5hZGQoXCIhb3BhY2l0eS0xMDBcIik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gIH1cbiAgX3VwZGF0ZUludGVydmFsKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLl9hY3RpdmVFbGVtZW50IHx8IGQuZmluZE9uZSh3ZSwgdGhpcy5fZWxlbWVudCk7XG4gICAgaWYgKCF0KVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGUgPSBOdW1iZXIucGFyc2VJbnQoXG4gICAgICB0LmdldEF0dHJpYnV0ZShcImRhdGEtdGUtaW50ZXJ2YWxcIiksXG4gICAgICAxMFxuICAgICk7XG4gICAgZSA/ICh0aGlzLl9jb25maWcuZGVmYXVsdEludGVydmFsID0gdGhpcy5fY29uZmlnLmRlZmF1bHRJbnRlcnZhbCB8fCB0aGlzLl9jb25maWcuaW50ZXJ2YWwsIHRoaXMuX2NvbmZpZy5pbnRlcnZhbCA9IGUpIDogdGhpcy5fY29uZmlnLmludGVydmFsID0gdGhpcy5fY29uZmlnLmRlZmF1bHRJbnRlcnZhbCB8fCB0aGlzLl9jb25maWcuaW50ZXJ2YWw7XG4gIH1cbiAgX3NsaWRlKHQsIGUpIHtcbiAgICBjb25zdCBpID0gdGhpcy5fZGlyZWN0aW9uVG9PcmRlcih0KSwgbiA9IGQuZmluZE9uZShcbiAgICAgIHdlLFxuICAgICAgdGhpcy5fZWxlbWVudFxuICAgICksIG8gPSB0aGlzLl9nZXRJdGVtSW5kZXgobiksIHIgPSBlIHx8IHRoaXMuX2dldEl0ZW1CeU9yZGVyKGksIG4pLCBhID0gdGhpcy5fZ2V0SXRlbUluZGV4KHIpLCBsID0gISF0aGlzLl9pbnRlcnZhbCwgcCA9IGkgPT09IGxlLCB1ID0gcCA/IExuIDogbXAsIF8gPSBwID8gZ3AgOiBicCwgZiA9IHRoaXMuX29yZGVyVG9EaXJlY3Rpb24oaSksIGcgPSB1ID09PSBMbiA/IHRoaXMuX2NsYXNzZXMuc2xpZGVMZWZ0IDogdGhpcy5fY2xhc3Nlcy5zbGlkZVJpZ2h0LCBtID0gdSAhPT0gTG4gPyB0aGlzLl9jbGFzc2VzLnNsaWRlTGVmdCA6IHRoaXMuX2NsYXNzZXMuc2xpZGVSaWdodDtcbiAgICBpZiAociAmJiByLmhhc0F0dHJpYnV0ZShoZSkpIHtcbiAgICAgIHRoaXMuX2lzU2xpZGluZyA9ICExO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5faXNTbGlkaW5nIHx8IHRoaXMuX3RyaWdnZXJTbGlkZUV2ZW50KHIsIGYpLmRlZmF1bHRQcmV2ZW50ZWQgfHwgIW4gfHwgIXIpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5faXNTbGlkaW5nID0gITAsIGwgJiYgdGhpcy5wYXVzZSgpLCB0aGlzLl9zZXRBY3RpdmVJbmRpY2F0b3JFbGVtZW50KHIpLCB0aGlzLl9hY3RpdmVFbGVtZW50ID0gcjtcbiAgICBjb25zdCB2ID0gKCkgPT4ge1xuICAgICAgYy50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsICRuLCB7XG4gICAgICAgIHJlbGF0ZWRUYXJnZXQ6IHIsXG4gICAgICAgIGRpcmVjdGlvbjogZixcbiAgICAgICAgZnJvbTogbyxcbiAgICAgICAgdG86IGFcbiAgICAgIH0pO1xuICAgIH07XG4gICAgaWYgKHRoaXMuX2VsZW1lbnQuaGFzQXR0cmlidXRlKGVhKSkge1xuICAgICAgci5zZXRBdHRyaWJ1dGUoYCR7X31gLCBcIlwiKSwgci5jbGFzc0xpc3QuYWRkKHRoaXMuX2NsYXNzZXMuYmxvY2ssIG0pLCBKZShyKSwgbi5zZXRBdHRyaWJ1dGUoYCR7dX1gLCBcIlwiKSwgbi5jbGFzc0xpc3QuYWRkKFxuICAgICAgICBnLFxuICAgICAgICAuLi50aGlzLl9jbGFzc2VzLmludmlzaWJsZS5zcGxpdChcIiBcIilcbiAgICAgICksIG4uY2xhc3NMaXN0LnJlbW92ZSguLi50aGlzLl9jbGFzc2VzLnZpc2libGUuc3BsaXQoXCIgXCIpKSwgci5zZXRBdHRyaWJ1dGUoYCR7dX1gLCBcIlwiKSwgci5jbGFzc0xpc3QuYWRkKC4uLnRoaXMuX2NsYXNzZXMudmlzaWJsZS5zcGxpdChcIiBcIikpLCByLmNsYXNzTGlzdC5yZW1vdmUoXG4gICAgICAgIHRoaXMuX2NsYXNzZXMuc2xpZGVSaWdodCxcbiAgICAgICAgdGhpcy5fY2xhc3Nlcy5zbGlkZUxlZnRcbiAgICAgICk7XG4gICAgICBjb25zdCBDID0gKCkgPT4ge1xuICAgICAgICByLnJlbW92ZUF0dHJpYnV0ZSh1KSwgci5yZW1vdmVBdHRyaWJ1dGUoXyksIHIuc2V0QXR0cmlidXRlKGAke2hlfWAsIFwiXCIpLCBuLnJlbW92ZUF0dHJpYnV0ZShoZSksIG4uY2xhc3NMaXN0LnJlbW92ZShcbiAgICAgICAgICBnLFxuICAgICAgICAgIC4uLnRoaXMuX2NsYXNzZXMuaW52aXNpYmxlLnNwbGl0KFwiIFwiKSxcbiAgICAgICAgICB0aGlzLl9jbGFzc2VzLmJsb2NrXG4gICAgICAgICksIG4ucmVtb3ZlQXR0cmlidXRlKF8pLCBuLnJlbW92ZUF0dHJpYnV0ZSh1KSwgdGhpcy5faXNTbGlkaW5nID0gITEsIHNldFRpbWVvdXQodiwgMCk7XG4gICAgICB9O1xuICAgICAgdGhpcy5fcXVldWVDYWxsYmFjayhDLCBuLCAhMCk7XG4gICAgfSBlbHNlXG4gICAgICBuLnJlbW92ZUF0dHJpYnV0ZShoZSksIG4uY2xhc3NMaXN0LnJlbW92ZSh0aGlzLl9jbGFzc2VzLmJsb2NrKSwgci5zZXRBdHRyaWJ1dGUoYCR7aGV9YCwgXCJcIiksIHIuY2xhc3NMaXN0LmFkZCh0aGlzLl9jbGFzc2VzLmJsb2NrKSwgdGhpcy5faXNTbGlkaW5nID0gITEsIHYoKTtcbiAgICBsICYmIHRoaXMuY3ljbGUoKTtcbiAgfVxuICBfZGlyZWN0aW9uVG9PcmRlcih0KSB7XG4gICAgcmV0dXJuIFttaSwgX2VdLmluY2x1ZGVzKHQpID8gRigpID8gdCA9PT0gX2UgPyBjZSA6IGxlIDogdCA9PT0gX2UgPyBsZSA6IGNlIDogdDtcbiAgfVxuICBfb3JkZXJUb0RpcmVjdGlvbih0KSB7XG4gICAgcmV0dXJuIFtsZSwgY2VdLmluY2x1ZGVzKHQpID8gRigpID8gdCA9PT0gY2UgPyBfZSA6IG1pIDogdCA9PT0gY2UgPyBtaSA6IF9lIDogdDtcbiAgfVxuICAvLyBTdGF0aWNcbiAgc3RhdGljIGNhcm91c2VsSW50ZXJmYWNlKHQsIGUpIHtcbiAgICBjb25zdCBpID0gVXQuZ2V0T3JDcmVhdGVJbnN0YW5jZSh0LCBlKTtcbiAgICBsZXQgeyBfY29uZmlnOiBuIH0gPSBpO1xuICAgIHR5cGVvZiBlID09IFwib2JqZWN0XCIgJiYgKG4gPSB7XG4gICAgICAuLi5uLFxuICAgICAgLi4uZVxuICAgIH0pO1xuICAgIGNvbnN0IG8gPSB0eXBlb2YgZSA9PSBcInN0cmluZ1wiID8gZSA6IGUuc2xpZGU7XG4gICAgaWYgKHR5cGVvZiBlID09IFwibnVtYmVyXCIpIHtcbiAgICAgIGkudG8oZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0eXBlb2YgbyA9PSBcInN0cmluZ1wiKSB7XG4gICAgICBpZiAodHlwZW9mIGlbb10gPiBcInVcIilcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFwiJHtvfVwiYCk7XG4gICAgICBpW29dKCk7XG4gICAgfSBlbHNlXG4gICAgICBuLmludGVydmFsICYmIG4ucmlkZSA9PT0gITAgJiYgaS5wYXVzZSgpO1xuICB9XG4gIHN0YXRpYyBqUXVlcnlJbnRlcmZhY2UodCkge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICBVdC5jYXJvdXNlbEludGVyZmFjZSh0aGlzLCB0KTtcbiAgICB9KTtcbiAgfVxuICBzdGF0aWMgZGF0YUFwaUNsaWNrSGFuZGxlcih0KSB7XG4gICAgY29uc3QgZSA9IEp0KHRoaXMpO1xuICAgIGlmICghZSB8fCAhZS5oYXNBdHRyaWJ1dGUoZWEpKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGkgPSB7XG4gICAgICAuLi5oLmdldERhdGFBdHRyaWJ1dGVzKGUpLFxuICAgICAgLi4uaC5nZXREYXRhQXR0cmlidXRlcyh0aGlzKVxuICAgIH0sIG4gPSB0aGlzLmdldEF0dHJpYnV0ZShcImRhdGEtdGUtc2xpZGUtdG9cIik7XG4gICAgbiAmJiAoaS5pbnRlcnZhbCA9ICExKSwgVXQuY2Fyb3VzZWxJbnRlcmZhY2UoZSwgaSksIG4gJiYgVXQuZ2V0SW5zdGFuY2UoZSkudG8obiksIHQucHJldmVudERlZmF1bHQoKTtcbiAgfVxufVxuY29uc3QgTm4gPSBcIm1vZGFsXCIsIE9wID0gXCJ0ZS5tb2RhbFwiLCBBdCA9IGAuJHtPcH1gLCBpYSA9IFwiRXNjYXBlXCIsIHNhID0ge1xuICBiYWNrZHJvcDogITAsXG4gIGtleWJvYXJkOiAhMCxcbiAgZm9jdXM6ICEwLFxuICBtb2RhbE5vbkludmFzaXZlOiAhMVxufSwgU3AgPSB7XG4gIGJhY2tkcm9wOiBcIihib29sZWFufHN0cmluZylcIixcbiAga2V5Ym9hcmQ6IFwiYm9vbGVhblwiLFxuICBmb2N1czogXCJib29sZWFuXCIsXG4gIG1vZGFsTm9uSW52YXNpdmU6IFwiYm9vbGVhblwiXG59LCBJcCA9IHtcbiAgc2hvdzogXCJ0cmFuc2Zvcm0tbm9uZVwiLFxuICBzdGF0aWM6IFwic2NhbGUtWzEuMDJdXCIsXG4gIHN0YXRpY1Byb3BlcnRpZXM6IFwidHJhbnNpdGlvbi1zY2FsZSBkdXJhdGlvbi0zMDAgZWFzZS1pbi1vdXRcIlxufSwgRHAgPSB7XG4gIHNob3c6IFwic3RyaW5nXCIsXG4gIHN0YXRpYzogXCJzdHJpbmdcIixcbiAgc3RhdGljUHJvcGVydGllczogXCJzdHJpbmdcIlxufSwgJHAgPSBgaGlkZSR7QXR9YCwgTHAgPSBgaGlkZVByZXZlbnRlZCR7QXR9YCwgTnAgPSBgaGlkZGVuJHtBdH1gLCBNcCA9IGBzaG93JHtBdH1gLCBScCA9IGBzaG93biR7QXR9YCwgbmEgPSBgcmVzaXplJHtBdH1gLCBvYSA9IGBjbGljay5kaXNtaXNzJHtBdH1gLCByYSA9IGBrZXlkb3duLmRpc21pc3Mke0F0fWAsIFBwID0gYG1vdXNldXAuZGlzbWlzcyR7QXR9YCwgYWEgPSBgbW91c2Vkb3duLmRpc21pc3Mke0F0fWAsIGxhID0gXCJkYXRhLXRlLW1vZGFsLW9wZW5cIiwgY2EgPSBcImRhdGEtdGUtb3BlblwiLCBsaSA9IFwiW2RhdGEtdGUtbW9kYWwtZGlhbG9nLXJlZl1cIiwgQnAgPSBcIltkYXRhLXRlLW1vZGFsLWJvZHktcmVmXVwiO1xuY2xhc3MgTm8gZXh0ZW5kcyBndCB7XG4gIGNvbnN0cnVjdG9yKHQsIGUsIGkpIHtcbiAgICBzdXBlcih0KSwgdGhpcy5fY29uZmlnID0gdGhpcy5fZ2V0Q29uZmlnKGUpLCB0aGlzLl9jbGFzc2VzID0gdGhpcy5fZ2V0Q2xhc3NlcyhpKSwgdGhpcy5fZGlhbG9nID0gZC5maW5kT25lKGxpLCB0aGlzLl9lbGVtZW50KSwgdGhpcy5fYmFja2Ryb3AgPSB0aGlzLl9jb25maWcubW9kYWxOb25JbnZhc2l2ZSA/IG51bGwgOiB0aGlzLl9pbml0aWFsaXplQmFja0Ryb3AoKSwgdGhpcy5fZm9jdXN0cmFwID0gdGhpcy5faW5pdGlhbGl6ZUZvY3VzVHJhcCgpLCB0aGlzLl9pc1Nob3duID0gITEsIHRoaXMuX2lnbm9yZUJhY2tkcm9wQ2xpY2sgPSAhMSwgdGhpcy5faXNUcmFuc2l0aW9uaW5nID0gITEsIHRoaXMuX3Njcm9sbEJhciA9IG5ldyBxZSgpLCB0aGlzLl9kaWRJbml0ID0gITEsIHRoaXMuX2luaXQoKTtcbiAgfVxuICAvLyBHZXR0ZXJzXG4gIHN0YXRpYyBnZXQgRGVmYXVsdCgpIHtcbiAgICByZXR1cm4gc2E7XG4gIH1cbiAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgIHJldHVybiBObjtcbiAgfVxuICAvLyBQdWJsaWNcbiAgdG9nZ2xlKHQpIHtcbiAgICByZXR1cm4gdGhpcy5faXNTaG93biA/IHRoaXMuaGlkZSgpIDogdGhpcy5zaG93KHQpO1xuICB9XG4gIHNob3codCkge1xuICAgIHRoaXMuX2lzU2hvd24gfHwgdGhpcy5faXNUcmFuc2l0aW9uaW5nIHx8IGMudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBNcCwge1xuICAgICAgcmVsYXRlZFRhcmdldDogdFxuICAgIH0pLmRlZmF1bHRQcmV2ZW50ZWQgfHwgKHRoaXMuX2lzU2hvd24gPSAhMCwgdGhpcy5faXNBbmltYXRlZCgpICYmICh0aGlzLl9pc1RyYW5zaXRpb25pbmcgPSAhMCksICF0aGlzLl9jb25maWcubW9kYWxOb25JbnZhc2l2ZSAmJiB0aGlzLl9zY3JvbGxCYXIuaGlkZSgpLCBkb2N1bWVudC5ib2R5LnNldEF0dHJpYnV0ZShsYSwgXCJ0cnVlXCIpLCB0aGlzLl9hZGp1c3REaWFsb2coKSwgdGhpcy5fc2V0RXNjYXBlRXZlbnQoKSwgdGhpcy5fc2V0UmVzaXplRXZlbnQoKSwgYy5vbih0aGlzLl9kaWFsb2csIGFhLCAoKSA9PiB7XG4gICAgICBjLm9uZSh0aGlzLl9lbGVtZW50LCBQcCwgKGkpID0+IHtcbiAgICAgICAgaS50YXJnZXQgPT09IHRoaXMuX2VsZW1lbnQgJiYgKHRoaXMuX2lnbm9yZUJhY2tkcm9wQ2xpY2sgPSAhMCk7XG4gICAgICB9KTtcbiAgICB9KSwgdGhpcy5fc2hvd0VsZW1lbnQodCksICF0aGlzLl9jb25maWcubW9kYWxOb25JbnZhc2l2ZSAmJiB0aGlzLl9zaG93QmFja2Ryb3AoKSk7XG4gIH1cbiAgaGlkZSgpIHtcbiAgICBpZiAoIXRoaXMuX2lzU2hvd24gfHwgdGhpcy5faXNUcmFuc2l0aW9uaW5nIHx8IGMudHJpZ2dlcih0aGlzLl9lbGVtZW50LCAkcCkuZGVmYXVsdFByZXZlbnRlZClcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLl9pc1Nob3duID0gITE7XG4gICAgY29uc3QgZSA9IHRoaXMuX2lzQW5pbWF0ZWQoKTtcbiAgICBlICYmICh0aGlzLl9pc1RyYW5zaXRpb25pbmcgPSAhMCksIHRoaXMuX3NldEVzY2FwZUV2ZW50KCksIHRoaXMuX3NldFJlc2l6ZUV2ZW50KCksIHRoaXMuX2ZvY3VzdHJhcC5kaXNhYmxlKCksIGQuZmluZE9uZShsaSwgdGhpcy5fZWxlbWVudCkuY2xhc3NMaXN0LnJlbW92ZSh0aGlzLl9jbGFzc2VzLnNob3cpLCBjLm9mZih0aGlzLl9lbGVtZW50LCBvYSksIGMub2ZmKHRoaXMuX2RpYWxvZywgYWEpLCB0aGlzLl9xdWV1ZUNhbGxiYWNrKCgpID0+IHRoaXMuX2hpZGVNb2RhbCgpLCB0aGlzLl9lbGVtZW50LCBlKSwgdGhpcy5fZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoY2EpO1xuICB9XG4gIGRpc3Bvc2UoKSB7XG4gICAgW3dpbmRvdywgdGhpcy5fZGlhbG9nXS5mb3JFYWNoKFxuICAgICAgKHQpID0+IGMub2ZmKHQsIEF0KVxuICAgICksIHRoaXMuX2JhY2tkcm9wICYmIHRoaXMuX2JhY2tkcm9wLmRpc3Bvc2UoKSwgdGhpcy5fZm9jdXN0cmFwLmRpc2FibGUoKSwgc3VwZXIuZGlzcG9zZSgpO1xuICB9XG4gIGhhbmRsZVVwZGF0ZSgpIHtcbiAgICB0aGlzLl9hZGp1c3REaWFsb2coKTtcbiAgfVxuICAvLyBQcml2YXRlXG4gIF9pbml0KCkge1xuICAgIHRoaXMuX2RpZEluaXQgfHwgKGNuKE5vKSwgdGhpcy5fZGlkSW5pdCA9ICEwKTtcbiAgfVxuICBfaW5pdGlhbGl6ZUJhY2tEcm9wKCkge1xuICAgIHJldHVybiBuZXcgaHIoe1xuICAgICAgaXNWaXNpYmxlOiAhIXRoaXMuX2NvbmZpZy5iYWNrZHJvcCxcbiAgICAgIC8vICdzdGF0aWMnIG9wdGlvbiB3aWxsIGJlIHRyYW5zbGF0ZWQgdG8gdHJ1ZSwgYW5kIGJvb2xlYW5zIHdpbGwga2VlcCB0aGVpciB2YWx1ZVxuICAgICAgaXNBbmltYXRlZDogdGhpcy5faXNBbmltYXRlZCgpXG4gICAgfSk7XG4gIH1cbiAgX2luaXRpYWxpemVGb2N1c1RyYXAoKSB7XG4gICAgcmV0dXJuIG5ldyBXaSh0aGlzLl9lbGVtZW50LCB7XG4gICAgICBldmVudDogXCJrZXlkb3duXCIsXG4gICAgICBjb25kaXRpb246ICh0KSA9PiB0LmtleSA9PT0gXCJUYWJcIlxuICAgIH0pO1xuICB9XG4gIF9nZXRDb25maWcodCkge1xuICAgIHJldHVybiB0ID0ge1xuICAgICAgLi4uc2EsXG4gICAgICAuLi5oLmdldERhdGFBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpLFxuICAgICAgLi4udHlwZW9mIHQgPT0gXCJvYmplY3RcIiA/IHQgOiB7fVxuICAgIH0sIEQoTm4sIHQsIFNwKSwgdDtcbiAgfVxuICBfZ2V0Q2xhc3Nlcyh0KSB7XG4gICAgY29uc3QgZSA9IGguZ2V0RGF0YUNsYXNzQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KTtcbiAgICByZXR1cm4gdCA9IHtcbiAgICAgIC4uLklwLFxuICAgICAgLi4uZSxcbiAgICAgIC4uLnRcbiAgICB9LCBEKE5uLCB0LCBEcCksIHQ7XG4gIH1cbiAgX3Nob3dFbGVtZW50KHQpIHtcbiAgICBjb25zdCBlID0gdGhpcy5faXNBbmltYXRlZCgpLCBpID0gZC5maW5kT25lKEJwLCB0aGlzLl9kaWFsb2cpO1xuICAgICghdGhpcy5fZWxlbWVudC5wYXJlbnROb2RlIHx8IHRoaXMuX2VsZW1lbnQucGFyZW50Tm9kZS5ub2RlVHlwZSAhPT0gTm9kZS5FTEVNRU5UX05PREUpICYmIGRvY3VtZW50LmJvZHkuYXBwZW5kKHRoaXMuX2VsZW1lbnQpLCB0aGlzLl9lbGVtZW50LnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCIsIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShcImhpZGRlblwiKSwgdGhpcy5fZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoXCJhcmlhLWhpZGRlblwiKSwgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJhcmlhLW1vZGFsXCIsICEwKSwgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwiZGlhbG9nXCIpLCB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZShgJHtjYX1gLCBcInRydWVcIiksIHRoaXMuX2VsZW1lbnQuc2Nyb2xsVG9wID0gMDtcbiAgICBjb25zdCBuID0gZC5maW5kT25lKGxpLCB0aGlzLl9lbGVtZW50KTtcbiAgICBuLmNsYXNzTGlzdC5hZGQodGhpcy5fY2xhc3Nlcy5zaG93KSwgbi5jbGFzc0xpc3QucmVtb3ZlKFwib3BhY2l0eS0wXCIpLCBuLmNsYXNzTGlzdC5hZGQoXCJvcGFjaXR5LTEwMFwiKSwgaSAmJiAoaS5zY3JvbGxUb3AgPSAwKSwgZSAmJiBKZSh0aGlzLl9lbGVtZW50KTtcbiAgICBjb25zdCBvID0gKCkgPT4ge1xuICAgICAgdGhpcy5fY29uZmlnLmZvY3VzICYmIHRoaXMuX2ZvY3VzdHJhcC50cmFwKCksIHRoaXMuX2lzVHJhbnNpdGlvbmluZyA9ICExLCBjLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgUnAsIHtcbiAgICAgICAgcmVsYXRlZFRhcmdldDogdFxuICAgICAgfSk7XG4gICAgfTtcbiAgICB0aGlzLl9xdWV1ZUNhbGxiYWNrKG8sIHRoaXMuX2RpYWxvZywgZSk7XG4gIH1cbiAgX3NldEVzY2FwZUV2ZW50KCkge1xuICAgIHRoaXMuX2lzU2hvd24gPyBjLm9uKGRvY3VtZW50LCByYSwgKHQpID0+IHtcbiAgICAgIHRoaXMuX2NvbmZpZy5rZXlib2FyZCAmJiB0LmtleSA9PT0gaWEgPyAodC5wcmV2ZW50RGVmYXVsdCgpLCB0aGlzLmhpZGUoKSkgOiAhdGhpcy5fY29uZmlnLmtleWJvYXJkICYmIHQua2V5ID09PSBpYSAmJiB0aGlzLl90cmlnZ2VyQmFja2Ryb3BUcmFuc2l0aW9uKCk7XG4gICAgfSkgOiBjLm9mZih0aGlzLl9lbGVtZW50LCByYSk7XG4gIH1cbiAgX3NldFJlc2l6ZUV2ZW50KCkge1xuICAgIHRoaXMuX2lzU2hvd24gPyBjLm9uKHdpbmRvdywgbmEsICgpID0+IHRoaXMuX2FkanVzdERpYWxvZygpKSA6IGMub2ZmKHdpbmRvdywgbmEpO1xuICB9XG4gIF9oaWRlTW9kYWwoKSB7XG4gICAgY29uc3QgdCA9IGQuZmluZE9uZShsaSwgdGhpcy5fZWxlbWVudCk7XG4gICAgdC5jbGFzc0xpc3QucmVtb3ZlKHRoaXMuX2NsYXNzZXMuc2hvdyksIHQuY2xhc3NMaXN0LnJlbW92ZShcIm9wYWNpdHktMTAwXCIpLCB0LmNsYXNzTGlzdC5hZGQoXCJvcGFjaXR5LTBcIiksIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5fZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgfSwgMzAwKSwgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWhpZGRlblwiLCAhMCksIHRoaXMuX2VsZW1lbnQucmVtb3ZlQXR0cmlidXRlKFwiYXJpYS1tb2RhbFwiKSwgdGhpcy5fZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoXCJyb2xlXCIpLCB0aGlzLl9pc1RyYW5zaXRpb25pbmcgPSAhMSwgdGhpcy5fYmFja2Ryb3AgJiYgdGhpcy5fYmFja2Ryb3AuaGlkZSgoKSA9PiB7XG4gICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUF0dHJpYnV0ZShsYSksIHRoaXMuX3Jlc2V0QWRqdXN0bWVudHMoKSwgIXRoaXMuX2NvbmZpZy5tb2RhbE5vbkludmFzaXZlICYmIHRoaXMuX3Njcm9sbEJhci5yZXNldCgpLCBjLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgTnApO1xuICAgIH0pO1xuICB9XG4gIF9zaG93QmFja2Ryb3AodCkge1xuICAgIGMub24odGhpcy5fZWxlbWVudCwgb2EsIChlKSA9PiB7XG4gICAgICBpZiAodGhpcy5faWdub3JlQmFja2Ryb3BDbGljaykge1xuICAgICAgICB0aGlzLl9pZ25vcmVCYWNrZHJvcENsaWNrID0gITE7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGUudGFyZ2V0ID09PSBlLmN1cnJlbnRUYXJnZXQgJiYgKHRoaXMuX2NvbmZpZy5iYWNrZHJvcCA9PT0gITAgPyB0aGlzLmhpZGUoKSA6IHRoaXMuX2NvbmZpZy5iYWNrZHJvcCA9PT0gXCJzdGF0aWNcIiAmJiB0aGlzLl90cmlnZ2VyQmFja2Ryb3BUcmFuc2l0aW9uKCkpO1xuICAgIH0pLCB0aGlzLl9iYWNrZHJvcCAmJiB0aGlzLl9iYWNrZHJvcC5zaG93KHQpO1xuICB9XG4gIF9pc0FuaW1hdGVkKCkge1xuICAgIHJldHVybiAhIWQuZmluZE9uZShsaSwgdGhpcy5fZWxlbWVudCk7XG4gIH1cbiAgX3RyaWdnZXJCYWNrZHJvcFRyYW5zaXRpb24oKSB7XG4gICAgaWYgKGMudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBMcCkuZGVmYXVsdFByZXZlbnRlZClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB7IGNsYXNzTGlzdDogZSwgc2Nyb2xsSGVpZ2h0OiBpLCBzdHlsZTogbiB9ID0gdGhpcy5fZWxlbWVudCwgbyA9IGkgPiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0O1xuICAgICFvICYmIG4ub3ZlcmZsb3dZID09PSBcImhpZGRlblwiIHx8IGUuY29udGFpbnModGhpcy5fY2xhc3Nlcy5zdGF0aWMpIHx8IChvIHx8IChuLm92ZXJmbG93WSA9IFwiaGlkZGVuXCIpLCBlLmFkZCguLi50aGlzLl9jbGFzc2VzLnN0YXRpYy5zcGxpdChcIiBcIikpLCBlLmFkZCguLi50aGlzLl9jbGFzc2VzLnN0YXRpY1Byb3BlcnRpZXMuc3BsaXQoXCIgXCIpKSwgdGhpcy5fcXVldWVDYWxsYmFjaygoKSA9PiB7XG4gICAgICBlLnJlbW92ZSh0aGlzLl9jbGFzc2VzLnN0YXRpYyksIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBlLnJlbW92ZSguLi50aGlzLl9jbGFzc2VzLnN0YXRpY1Byb3BlcnRpZXMuc3BsaXQoXCIgXCIpKTtcbiAgICAgIH0sIDMwMCksIG8gfHwgdGhpcy5fcXVldWVDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIG4ub3ZlcmZsb3dZID0gXCJcIjtcbiAgICAgIH0sIHRoaXMuX2RpYWxvZyk7XG4gICAgfSwgdGhpcy5fZGlhbG9nKSwgdGhpcy5fZWxlbWVudC5mb2N1cygpKTtcbiAgfVxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIHRoZSBmb2xsb3dpbmcgbWV0aG9kcyBhcmUgdXNlZCB0byBoYW5kbGUgb3ZlcmZsb3dpbmcgbW9kYWxzXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgX2FkanVzdERpYWxvZygpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5fZWxlbWVudC5zY3JvbGxIZWlnaHQgPiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0LCBlID0gdGhpcy5fc2Nyb2xsQmFyLmdldFdpZHRoKCksIGkgPSBlID4gMDtcbiAgICAoIWkgJiYgdCAmJiAhRigpIHx8IGkgJiYgIXQgJiYgRigpKSAmJiAodGhpcy5fZWxlbWVudC5zdHlsZS5wYWRkaW5nTGVmdCA9IGAke2V9cHhgKSwgKGkgJiYgIXQgJiYgIUYoKSB8fCAhaSAmJiB0ICYmIEYoKSkgJiYgKHRoaXMuX2VsZW1lbnQuc3R5bGUucGFkZGluZ1JpZ2h0ID0gYCR7ZX1weGApO1xuICB9XG4gIF9yZXNldEFkanVzdG1lbnRzKCkge1xuICAgIHRoaXMuX2VsZW1lbnQuc3R5bGUucGFkZGluZ0xlZnQgPSBcIlwiLCB0aGlzLl9lbGVtZW50LnN0eWxlLnBhZGRpbmdSaWdodCA9IFwiXCI7XG4gIH1cbiAgLy8gU3RhdGljXG4gIHN0YXRpYyBqUXVlcnlJbnRlcmZhY2UodCwgZSkge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICBjb25zdCBpID0gTm8uZ2V0T3JDcmVhdGVJbnN0YW5jZSh0aGlzLCB0KTtcbiAgICAgIGlmICh0eXBlb2YgdCA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaVt0XSA+IFwidVwiKVxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcIiR7dH1cImApO1xuICAgICAgICBpW3RdKGUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5jb25zdCBIcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcbiAgXCJiYWNrZ3JvdW5kXCIsXG4gIFwiY2l0ZVwiLFxuICBcImhyZWZcIixcbiAgXCJpdGVtdHlwZVwiLFxuICBcImxvbmdkZXNjXCIsXG4gIFwicG9zdGVyXCIsXG4gIFwic3JjXCIsXG4gIFwieGxpbms6aHJlZlwiXG5dKSwgVnAgPSAvXmFyaWEtW1xcdy1dKiQvaSwgV3AgPSAvXig/Oig/Omh0dHBzP3xtYWlsdG98ZnRwfHRlbHxmaWxlfHNtcyk6fFteIyYvOj9dKig/OlsjLz9dfCQpKS9pLCBGcCA9IC9eZGF0YTooPzppbWFnZVxcLyg/OmJtcHxnaWZ8anBlZ3xqcGd8cG5nfHRpZmZ8d2VicCl8dmlkZW9cXC8oPzptcGVnfG1wNHxvZ2d8d2VibSl8YXVkaW9cXC8oPzptcDN8b2dhfG9nZ3xvcHVzKSk7YmFzZTY0LFtcXGQrL2Etel0rPSokL2ksIFlwID0gKHMsIHQpID0+IHtcbiAgY29uc3QgZSA9IHMubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgaWYgKHQuaW5jbHVkZXMoZSkpXG4gICAgcmV0dXJuIEhwLmhhcyhlKSA/ICEhKFdwLnRlc3Qocy5ub2RlVmFsdWUpIHx8IEZwLnRlc3Qocy5ub2RlVmFsdWUpKSA6ICEwO1xuICBjb25zdCBpID0gdC5maWx0ZXIoXG4gICAgKG4pID0+IG4gaW5zdGFuY2VvZiBSZWdFeHBcbiAgKTtcbiAgZm9yIChsZXQgbiA9IDAsIG8gPSBpLmxlbmd0aDsgbiA8IG87IG4rKylcbiAgICBpZiAoaVtuXS50ZXN0KGUpKVxuICAgICAgcmV0dXJuICEwO1xuICByZXR1cm4gITE7XG59LCBqcCA9IHtcbiAgLy8gR2xvYmFsIGF0dHJpYnV0ZXMgYWxsb3dlZCBvbiBhbnkgc3VwcGxpZWQgZWxlbWVudCBiZWxvdy5cbiAgXCIqXCI6IFtcImNsYXNzXCIsIFwiZGlyXCIsIFwiaWRcIiwgXCJsYW5nXCIsIFwicm9sZVwiLCBWcF0sXG4gIGE6IFtcInRhcmdldFwiLCBcImhyZWZcIiwgXCJ0aXRsZVwiLCBcInJlbFwiXSxcbiAgYXJlYTogW10sXG4gIGI6IFtdLFxuICBicjogW10sXG4gIGNvbDogW10sXG4gIGNvZGU6IFtdLFxuICBkaXY6IFtdLFxuICBlbTogW10sXG4gIGhyOiBbXSxcbiAgaDE6IFtdLFxuICBoMjogW10sXG4gIGgzOiBbXSxcbiAgaDQ6IFtdLFxuICBoNTogW10sXG4gIGg2OiBbXSxcbiAgaTogW10sXG4gIGltZzogW1wic3JjXCIsIFwic3Jjc2V0XCIsIFwiYWx0XCIsIFwidGl0bGVcIiwgXCJ3aWR0aFwiLCBcImhlaWdodFwiXSxcbiAgbGk6IFtdLFxuICBvbDogW10sXG4gIHA6IFtdLFxuICBwcmU6IFtdLFxuICBzOiBbXSxcbiAgc21hbGw6IFtdLFxuICBzcGFuOiBbXSxcbiAgc3ViOiBbXSxcbiAgc3VwOiBbXSxcbiAgc3Ryb25nOiBbXSxcbiAgdTogW10sXG4gIHVsOiBbXVxufTtcbmZ1bmN0aW9uIGhhKHMsIHQsIGUpIHtcbiAgaWYgKCFzLmxlbmd0aClcbiAgICByZXR1cm4gcztcbiAgaWYgKGUgJiYgdHlwZW9mIGUgPT0gXCJmdW5jdGlvblwiKVxuICAgIHJldHVybiBlKHMpO1xuICBjb25zdCBuID0gbmV3IHdpbmRvdy5ET01QYXJzZXIoKS5wYXJzZUZyb21TdHJpbmcocywgXCJ0ZXh0L2h0bWxcIiksIG8gPSBbXS5jb25jYXQoLi4ubi5ib2R5LnF1ZXJ5U2VsZWN0b3JBbGwoXCIqXCIpKTtcbiAgZm9yIChsZXQgciA9IDAsIGEgPSBvLmxlbmd0aDsgciA8IGE7IHIrKykge1xuICAgIGNvbnN0IGwgPSBvW3JdLCBwID0gbC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIGlmICghT2JqZWN0LmtleXModCkuaW5jbHVkZXMocCkpIHtcbiAgICAgIGwucmVtb3ZlKCk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgdSA9IFtdLmNvbmNhdCguLi5sLmF0dHJpYnV0ZXMpLCBfID0gW10uY29uY2F0KFxuICAgICAgdFtcIipcIl0gfHwgW10sXG4gICAgICB0W3BdIHx8IFtdXG4gICAgKTtcbiAgICB1LmZvckVhY2goKGYpID0+IHtcbiAgICAgIFlwKGYsIF8pIHx8IGwucmVtb3ZlQXR0cmlidXRlKGYubm9kZU5hbWUpO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBuLmJvZHkuaW5uZXJIVE1MO1xufVxuY29uc3QgZGEgPSBcInRvb2x0aXBcIiwgS3AgPSBcInRlLnRvb2x0aXBcIiwgd3QgPSBgLiR7S3B9YCwgenAgPSBcInRlLXRvb2x0aXBcIiwgVXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXCJzYW5pdGl6ZVwiLCBcImFsbG93TGlzdFwiLCBcInNhbml0aXplRm5cIl0pLCBYcCA9IHtcbiAgYW5pbWF0aW9uOiBcImJvb2xlYW5cIixcbiAgdGVtcGxhdGU6IFwic3RyaW5nXCIsXG4gIHRpdGxlOiBcIihzdHJpbmd8ZWxlbWVudHxmdW5jdGlvbilcIixcbiAgdHJpZ2dlcjogXCJzdHJpbmdcIixcbiAgZGVsYXk6IFwiKG51bWJlcnxvYmplY3QpXCIsXG4gIGh0bWw6IFwiYm9vbGVhblwiLFxuICBzZWxlY3RvcjogXCIoc3RyaW5nfGJvb2xlYW4pXCIsXG4gIHBsYWNlbWVudDogXCIoc3RyaW5nfGZ1bmN0aW9uKVwiLFxuICBvZmZzZXQ6IFwiKGFycmF5fHN0cmluZ3xmdW5jdGlvbilcIixcbiAgY29udGFpbmVyOiBcIihzdHJpbmd8ZWxlbWVudHxib29sZWFuKVwiLFxuICBmYWxsYmFja1BsYWNlbWVudHM6IFwiYXJyYXlcIixcbiAgYm91bmRhcnk6IFwiKHN0cmluZ3xlbGVtZW50KVwiLFxuICBjdXN0b21DbGFzczogXCIoc3RyaW5nfGZ1bmN0aW9uKVwiLFxuICBzYW5pdGl6ZTogXCJib29sZWFuXCIsXG4gIHNhbml0aXplRm46IFwiKG51bGx8ZnVuY3Rpb24pXCIsXG4gIGFsbG93TGlzdDogXCJvYmplY3RcIixcbiAgcG9wcGVyQ29uZmlnOiBcIihudWxsfG9iamVjdHxmdW5jdGlvbilcIlxufSwgR3AgPSB7XG4gIEFVVE86IFwiYXV0b1wiLFxuICBUT1A6IFwidG9wXCIsXG4gIFJJR0hUOiBGKCkgPyBcImxlZnRcIiA6IFwicmlnaHRcIixcbiAgQk9UVE9NOiBcImJvdHRvbVwiLFxuICBMRUZUOiBGKCkgPyBcInJpZ2h0XCIgOiBcImxlZnRcIlxufSwgcXAgPSB7XG4gIGFuaW1hdGlvbjogITAsXG4gIHRlbXBsYXRlOiAnPGRpdiBjbGFzcz1cIm9wYWNpdHktMCB0cmFuc2l0aW9uLW9wYWNpdHkgZHVyYXRpb24tMzAwIGVhc2UtaW4tb3V0IGFic29sdXRlIHotWzEwODBdIGJsb2NrIG0tMCB0ZXh0LXNtIG5vdC1pdGFsaWMgZm9udC1ub3JtYWwgdGV4dC1sZWZ0IG5vLXVuZGVybGluZSB1bmRlcmxpbmUtb2Zmc2V0LWF1dG8gbm9ybWFsLWNhc2UgbGVhZGluZy02IHRyYWNraW5nLW5vcm1hbCBicmVhay1ub3JtYWwgd2hpdGVzcGFjZS1ub3JtYWxcIiByb2xlPVwidG9vbHRpcFwiPjxkaXYgZGF0YS10ZS10b29sdGlwLWlubmVyLXJlZiBjbGFzcz1cInRvb2x0aXAtaW5uZXIgbWF4LXctWzIwMHB4XSB0ZXh0LXNtIHB5LTEuNSBweC00IHRleHQtd2hpdGUgdGV4dC1jZW50ZXIgYmctWyM2ZDZkNmRdIHJvdW5kZWRcIj48L2Rpdj48L2Rpdj4nLFxuICB0cmlnZ2VyOiBcImhvdmVyIGZvY3VzXCIsXG4gIHRpdGxlOiBcIlwiLFxuICBkZWxheTogMCxcbiAgaHRtbDogITEsXG4gIHNlbGVjdG9yOiAhMSxcbiAgcGxhY2VtZW50OiBcInRvcFwiLFxuICBvZmZzZXQ6IFswLCAwXSxcbiAgY29udGFpbmVyOiAhMSxcbiAgZmFsbGJhY2tQbGFjZW1lbnRzOiBbXCJ0b3BcIiwgXCJyaWdodFwiLCBcImJvdHRvbVwiLCBcImxlZnRcIl0sXG4gIGJvdW5kYXJ5OiBcImNsaXBwaW5nUGFyZW50c1wiLFxuICBjdXN0b21DbGFzczogXCJcIixcbiAgc2FuaXRpemU6ICEwLFxuICBzYW5pdGl6ZUZuOiBudWxsLFxuICBhbGxvd0xpc3Q6IGpwLFxuICBwb3BwZXJDb25maWc6IHsgaGlkZTogITAgfVxufSwgWnAgPSB7XG4gIEhJREU6IGBoaWRlJHt3dH1gLFxuICBISURERU46IGBoaWRkZW4ke3d0fWAsXG4gIFNIT1c6IGBzaG93JHt3dH1gLFxuICBTSE9XTjogYHNob3duJHt3dH1gLFxuICBJTlNFUlRFRDogYGluc2VydGVkJHt3dH1gLFxuICBDTElDSzogYGNsaWNrJHt3dH1gLFxuICBGT0NVU0lOOiBgZm9jdXNpbiR7d3R9YCxcbiAgRk9DVVNPVVQ6IGBmb2N1c291dCR7d3R9YCxcbiAgTU9VU0VFTlRFUjogYG1vdXNlZW50ZXIke3d0fWAsXG4gIE1PVVNFTEVBVkU6IGBtb3VzZWxlYXZlJHt3dH1gXG59LCBRcCA9IFwiZmFkZVwiLCBKcCA9IFwibW9kYWxcIiwgTW4gPSBcInNob3dcIiwgY2kgPSBcInNob3dcIiwgUm4gPSBcIm91dFwiLCB1YSA9IFwiLnRvb2x0aXAtaW5uZXJcIiwgcGEgPSBgLiR7SnB9YCwgX2EgPSBcImhpZGUudGUubW9kYWxcIiwgaGkgPSBcImhvdmVyXCIsIFBuID0gXCJmb2N1c1wiLCB0XyA9IFwiY2xpY2tcIiwgZV8gPSBcIm1hbnVhbFwiO1xuY2xhc3MgaWkgZXh0ZW5kcyBndCB7XG4gIGNvbnN0cnVjdG9yKHQsIGUpIHtcbiAgICBpZiAodHlwZW9mIEljID4gXCJ1XCIpXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICBcIkJvb3RzdHJhcCdzIHRvb2x0aXBzIHJlcXVpcmUgUG9wcGVyIChodHRwczovL3BvcHBlci5qcy5vcmcpXCJcbiAgICAgICk7XG4gICAgc3VwZXIodCksIHRoaXMuX2lzRW5hYmxlZCA9ICEwLCB0aGlzLl90aW1lb3V0ID0gMCwgdGhpcy5faG92ZXJTdGF0ZSA9IFwiXCIsIHRoaXMuX2FjdGl2ZVRyaWdnZXIgPSB7fSwgdGhpcy5fcG9wcGVyID0gbnVsbCwgdGhpcy5fY29uZmlnID0gdGhpcy5fZ2V0Q29uZmlnKGUpLCB0aGlzLnRpcCA9IG51bGwsIHRoaXMuX3NldExpc3RlbmVycygpO1xuICB9XG4gIC8vIEdldHRlcnNcbiAgc3RhdGljIGdldCBEZWZhdWx0KCkge1xuICAgIHJldHVybiBxcDtcbiAgfVxuICBzdGF0aWMgZ2V0IE5BTUUoKSB7XG4gICAgcmV0dXJuIGRhO1xuICB9XG4gIHN0YXRpYyBnZXQgRXZlbnQoKSB7XG4gICAgcmV0dXJuIFpwO1xuICB9XG4gIHN0YXRpYyBnZXQgRGVmYXVsdFR5cGUoKSB7XG4gICAgcmV0dXJuIFhwO1xuICB9XG4gIC8vIFB1YmxpY1xuICBlbmFibGUoKSB7XG4gICAgdGhpcy5faXNFbmFibGVkID0gITA7XG4gIH1cbiAgZGlzYWJsZSgpIHtcbiAgICB0aGlzLl9pc0VuYWJsZWQgPSAhMTtcbiAgfVxuICB0b2dnbGVFbmFibGVkKCkge1xuICAgIHRoaXMuX2lzRW5hYmxlZCA9ICF0aGlzLl9pc0VuYWJsZWQ7XG4gIH1cbiAgdG9nZ2xlKHQpIHtcbiAgICBpZiAodGhpcy5faXNFbmFibGVkKVxuICAgICAgaWYgKHQpIHtcbiAgICAgICAgY29uc3QgZSA9IHRoaXMuX2luaXRpYWxpemVPbkRlbGVnYXRlZFRhcmdldCh0KTtcbiAgICAgICAgZS5fYWN0aXZlVHJpZ2dlci5jbGljayA9ICFlLl9hY3RpdmVUcmlnZ2VyLmNsaWNrLCBlLl9pc1dpdGhBY3RpdmVUcmlnZ2VyKCkgPyBlLl9lbnRlcihudWxsLCBlKSA6IGUuX2xlYXZlKG51bGwsIGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMuZ2V0VGlwRWxlbWVudCgpLmNsYXNzTGlzdC5jb250YWlucyhNbikpIHtcbiAgICAgICAgICB0aGlzLl9sZWF2ZShudWxsLCB0aGlzKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZW50ZXIobnVsbCwgdGhpcyk7XG4gICAgICB9XG4gIH1cbiAgZGlzcG9zZSgpIHtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5fdGltZW91dCksIGMub2ZmKFxuICAgICAgdGhpcy5fZWxlbWVudC5jbG9zZXN0KHBhKSxcbiAgICAgIF9hLFxuICAgICAgdGhpcy5faGlkZU1vZGFsSGFuZGxlclxuICAgICksIHRoaXMudGlwICYmIHRoaXMudGlwLnJlbW92ZSgpLCB0aGlzLl9kaXNwb3NlUG9wcGVyKCksIHN1cGVyLmRpc3Bvc2UoKTtcbiAgfVxuICBzaG93KCkge1xuICAgIGlmICh0aGlzLl9lbGVtZW50LnN0eWxlLmRpc3BsYXkgPT09IFwibm9uZVwiKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUGxlYXNlIHVzZSBzaG93IG9uIHZpc2libGUgZWxlbWVudHNcIik7XG4gICAgaWYgKCEodGhpcy5pc1dpdGhDb250ZW50KCkgJiYgdGhpcy5faXNFbmFibGVkKSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB0ID0gYy50cmlnZ2VyKFxuICAgICAgdGhpcy5fZWxlbWVudCxcbiAgICAgIHRoaXMuY29uc3RydWN0b3IuRXZlbnQuU0hPV1xuICAgICksIGUgPSBHbCh0aGlzLl9lbGVtZW50KSwgaSA9IGUgPT09IG51bGwgPyB0aGlzLl9lbGVtZW50Lm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNvbnRhaW5zKHRoaXMuX2VsZW1lbnQpIDogZS5jb250YWlucyh0aGlzLl9lbGVtZW50KTtcbiAgICBpZiAodC5kZWZhdWx0UHJldmVudGVkIHx8ICFpKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuY29uc3RydWN0b3IuTkFNRSA9PT0gXCJ0b29sdGlwXCIgJiYgdGhpcy50aXAgJiYgdGhpcy5nZXRUaXRsZSgpICE9PSB0aGlzLnRpcC5xdWVyeVNlbGVjdG9yKHVhKS5pbm5lckhUTUwgJiYgKHRoaXMuX2Rpc3Bvc2VQb3BwZXIoKSwgdGhpcy50aXAucmVtb3ZlKCksIHRoaXMudGlwID0gbnVsbCk7XG4gICAgY29uc3QgbiA9IHRoaXMuZ2V0VGlwRWxlbWVudCgpLCBvID0gcnQodGhpcy5jb25zdHJ1Y3Rvci5OQU1FKTtcbiAgICBuLnNldEF0dHJpYnV0ZShcImlkXCIsIG8pLCB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZShcImFyaWEtZGVzY3JpYmVkYnlcIiwgbyksIHRoaXMuX2NvbmZpZy5hbmltYXRpb24gJiYgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLnRpcC5jbGFzc0xpc3QuYWRkKFwib3BhY2l0eS0xMDBcIiksIHRoaXMudGlwLmNsYXNzTGlzdC5yZW1vdmUoXCJvcGFjaXR5LTBcIik7XG4gICAgfSwgMTAwKTtcbiAgICBjb25zdCByID0gdHlwZW9mIHRoaXMuX2NvbmZpZy5wbGFjZW1lbnQgPT0gXCJmdW5jdGlvblwiID8gdGhpcy5fY29uZmlnLnBsYWNlbWVudC5jYWxsKHRoaXMsIG4sIHRoaXMuX2VsZW1lbnQpIDogdGhpcy5fY29uZmlnLnBsYWNlbWVudCwgYSA9IHRoaXMuX2dldEF0dGFjaG1lbnQocik7XG4gICAgdGhpcy5fYWRkQXR0YWNobWVudENsYXNzKGEpO1xuICAgIGNvbnN0IHsgY29udGFpbmVyOiBsIH0gPSB0aGlzLl9jb25maWc7XG4gICAgaWYgKHkuc2V0RGF0YShuLCB0aGlzLmNvbnN0cnVjdG9yLkRBVEFfS0VZLCB0aGlzKSwgdGhpcy5fZWxlbWVudC5vd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jb250YWlucyh0aGlzLnRpcCkgfHwgKGwuYXBwZW5kKG4pLCBjLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgdGhpcy5jb25zdHJ1Y3Rvci5FdmVudC5JTlNFUlRFRCkpLCB0aGlzLl9wb3BwZXIgPyB0aGlzLl9wb3BwZXIudXBkYXRlKCkgOiB0aGlzLl9wb3BwZXIgPSBDZShcbiAgICAgIHRoaXMuX2VsZW1lbnQsXG4gICAgICBuLFxuICAgICAgdGhpcy5fZ2V0UG9wcGVyQ29uZmlnKGEpXG4gICAgKSwgbi5nZXRBdHRyaWJ1dGUoXCJpZFwiKS5pbmNsdWRlcyhcInRvb2x0aXBcIikpXG4gICAgICBzd2l0Y2ggKHIpIHtcbiAgICAgICAgY2FzZSBcImJvdHRvbVwiOlxuICAgICAgICAgIG4uY2xhc3NMaXN0LmFkZChcInB5LVswLjRyZW1dXCIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwibGVmdFwiOlxuICAgICAgICAgIG4uY2xhc3NMaXN0LmFkZChcInB4LVswLjRyZW1dXCIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwicmlnaHRcIjpcbiAgICAgICAgICBuLmNsYXNzTGlzdC5hZGQoXCJweC1bMC40cmVtXVwiKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBuLmNsYXNzTGlzdC5hZGQoXCJweS1bMC40cmVtXVwiKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICBjb25zdCB1ID0gdGhpcy5fcmVzb2x2ZVBvc3NpYmxlRnVuY3Rpb24odGhpcy5fY29uZmlnLmN1c3RvbUNsYXNzKTtcbiAgICB1ICYmIG4uY2xhc3NMaXN0LmFkZCguLi51LnNwbGl0KFwiIFwiKSksIFwib250b3VjaHN0YXJ0XCIgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICYmIFtdLmNvbmNhdCguLi5kb2N1bWVudC5ib2R5LmNoaWxkcmVuKS5mb3JFYWNoKChnKSA9PiB7XG4gICAgICBjLm9uKGcsIFwibW91c2VvdmVyXCIsIHRuKTtcbiAgICB9KTtcbiAgICBjb25zdCBfID0gKCkgPT4ge1xuICAgICAgY29uc3QgZyA9IHRoaXMuX2hvdmVyU3RhdGU7XG4gICAgICB0aGlzLl9ob3ZlclN0YXRlID0gbnVsbCwgYy50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIHRoaXMuY29uc3RydWN0b3IuRXZlbnQuU0hPV04pLCBnID09PSBSbiAmJiB0aGlzLl9sZWF2ZShudWxsLCB0aGlzKTtcbiAgICB9LCBmID0gdGhpcy50aXAuY2xhc3NMaXN0LmNvbnRhaW5zKFwidHJhbnNpdGlvbi1vcGFjaXR5XCIpO1xuICAgIHRoaXMuX3F1ZXVlQ2FsbGJhY2soXywgdGhpcy50aXAsIGYpO1xuICB9XG4gIGhpZGUoKSB7XG4gICAgaWYgKCF0aGlzLl9wb3BwZXIpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgdCA9IHRoaXMuZ2V0VGlwRWxlbWVudCgpLCBlID0gKCkgPT4ge1xuICAgICAgdGhpcy5faXNXaXRoQWN0aXZlVHJpZ2dlcigpIHx8ICh0aGlzLl9ob3ZlclN0YXRlICE9PSBjaSAmJiB0LnJlbW92ZSgpLCB0aGlzLl9jbGVhblRpcENsYXNzKCksIHRoaXMuX2VsZW1lbnQucmVtb3ZlQXR0cmlidXRlKFwiYXJpYS1kZXNjcmliZWRieVwiKSwgYy50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIHRoaXMuY29uc3RydWN0b3IuRXZlbnQuSElEREVOKSwgdGhpcy5fZGlzcG9zZVBvcHBlcigpKTtcbiAgICB9O1xuICAgIGlmIChjLnRyaWdnZXIoXG4gICAgICB0aGlzLl9lbGVtZW50LFxuICAgICAgdGhpcy5jb25zdHJ1Y3Rvci5FdmVudC5ISURFXG4gICAgKS5kZWZhdWx0UHJldmVudGVkKVxuICAgICAgcmV0dXJuO1xuICAgIHQuY2xhc3NMaXN0LmFkZChcIm9wYWNpdHktMFwiKSwgdC5jbGFzc0xpc3QucmVtb3ZlKFwib3BhY2l0eS0xMDBcIiksIFwib250b3VjaHN0YXJ0XCIgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICYmIFtdLmNvbmNhdCguLi5kb2N1bWVudC5ib2R5LmNoaWxkcmVuKS5mb3JFYWNoKChvKSA9PiBjLm9mZihvLCBcIm1vdXNlb3ZlclwiLCB0bikpLCB0aGlzLl9hY3RpdmVUcmlnZ2VyW3RfXSA9ICExLCB0aGlzLl9hY3RpdmVUcmlnZ2VyW1BuXSA9ICExLCB0aGlzLl9hY3RpdmVUcmlnZ2VyW2hpXSA9ICExO1xuICAgIGNvbnN0IG4gPSB0aGlzLnRpcC5jbGFzc0xpc3QuY29udGFpbnMoXCJvcGFjaXR5LTBcIik7XG4gICAgdGhpcy5fcXVldWVDYWxsYmFjayhlLCB0aGlzLnRpcCwgbiksIHRoaXMuX2hvdmVyU3RhdGUgPSBcIlwiO1xuICB9XG4gIHVwZGF0ZSgpIHtcbiAgICB0aGlzLl9wb3BwZXIgIT09IG51bGwgJiYgdGhpcy5fcG9wcGVyLnVwZGF0ZSgpO1xuICB9XG4gIC8vIFByb3RlY3RlZFxuICBpc1dpdGhDb250ZW50KCkge1xuICAgIHJldHVybiAhIXRoaXMuZ2V0VGl0bGUoKTtcbiAgfVxuICBnZXRUaXBFbGVtZW50KCkge1xuICAgIGlmICh0aGlzLnRpcClcbiAgICAgIHJldHVybiB0aGlzLnRpcDtcbiAgICBjb25zdCB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICB0LmlubmVySFRNTCA9IHRoaXMuX2NvbmZpZy50ZW1wbGF0ZTtcbiAgICBjb25zdCBlID0gdC5jaGlsZHJlblswXTtcbiAgICByZXR1cm4gdGhpcy5zZXRDb250ZW50KGUpLCBlLmNsYXNzTGlzdC5yZW1vdmUoUXAsIE1uKSwgdGhpcy50aXAgPSBlLCB0aGlzLnRpcDtcbiAgfVxuICBzZXRDb250ZW50KHQpIHtcbiAgICB0aGlzLl9zYW5pdGl6ZUFuZFNldENvbnRlbnQodCwgdGhpcy5nZXRUaXRsZSgpLCB1YSk7XG4gIH1cbiAgX3Nhbml0aXplQW5kU2V0Q29udGVudCh0LCBlLCBpKSB7XG4gICAgY29uc3QgbiA9IGQuZmluZE9uZShpLCB0KTtcbiAgICBpZiAoIWUgJiYgbikge1xuICAgICAgbi5yZW1vdmUoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5zZXRFbGVtZW50Q29udGVudChuLCBlKTtcbiAgfVxuICBzZXRFbGVtZW50Q29udGVudCh0LCBlKSB7XG4gICAgaWYgKHQgIT09IG51bGwpIHtcbiAgICAgIGlmIChqZShlKSkge1xuICAgICAgICBlID0gdGUoZSksIHRoaXMuX2NvbmZpZy5odG1sID8gZS5wYXJlbnROb2RlICE9PSB0ICYmICh0LmlubmVySFRNTCA9IFwiXCIsIHQuYXBwZW5kKGUpKSA6IHQudGV4dENvbnRlbnQgPSBlLnRleHRDb250ZW50O1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLl9jb25maWcuaHRtbCA/ICh0aGlzLl9jb25maWcuc2FuaXRpemUgJiYgKGUgPSBoYShcbiAgICAgICAgZSxcbiAgICAgICAgdGhpcy5fY29uZmlnLmFsbG93TGlzdCxcbiAgICAgICAgdGhpcy5fY29uZmlnLnNhbml0aXplRm5cbiAgICAgICkpLCB0LmlubmVySFRNTCA9IGUpIDogdC50ZXh0Q29udGVudCA9IGU7XG4gICAgfVxuICB9XG4gIGdldFRpdGxlKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLl9lbGVtZW50LmdldEF0dHJpYnV0ZShcImRhdGEtdGUtb3JpZ2luYWwtdGl0bGVcIikgfHwgdGhpcy5fY29uZmlnLnRpdGxlO1xuICAgIHJldHVybiB0aGlzLl9yZXNvbHZlUG9zc2libGVGdW5jdGlvbih0KTtcbiAgfVxuICB1cGRhdGVBdHRhY2htZW50KHQpIHtcbiAgICByZXR1cm4gdCA9PT0gXCJyaWdodFwiID8gXCJlbmRcIiA6IHQgPT09IFwibGVmdFwiID8gXCJzdGFydFwiIDogdDtcbiAgfVxuICAvLyBQcml2YXRlXG4gIF9pbml0aWFsaXplT25EZWxlZ2F0ZWRUYXJnZXQodCwgZSkge1xuICAgIHJldHVybiBlIHx8IHRoaXMuY29uc3RydWN0b3IuZ2V0T3JDcmVhdGVJbnN0YW5jZShcbiAgICAgIHQuZGVsZWdhdGVUYXJnZXQsXG4gICAgICB0aGlzLl9nZXREZWxlZ2F0ZUNvbmZpZygpXG4gICAgKTtcbiAgfVxuICBfZ2V0T2Zmc2V0KCkge1xuICAgIGNvbnN0IHsgb2Zmc2V0OiB0IH0gPSB0aGlzLl9jb25maWc7XG4gICAgcmV0dXJuIHR5cGVvZiB0ID09IFwic3RyaW5nXCIgPyB0LnNwbGl0KFwiLFwiKS5tYXAoKGUpID0+IE51bWJlci5wYXJzZUludChlLCAxMCkpIDogdHlwZW9mIHQgPT0gXCJmdW5jdGlvblwiID8gKGUpID0+IHQoZSwgdGhpcy5fZWxlbWVudCkgOiB0O1xuICB9XG4gIF9yZXNvbHZlUG9zc2libGVGdW5jdGlvbih0KSB7XG4gICAgcmV0dXJuIHR5cGVvZiB0ID09IFwiZnVuY3Rpb25cIiA/IHQuY2FsbCh0aGlzLl9lbGVtZW50KSA6IHQ7XG4gIH1cbiAgX2dldFBvcHBlckNvbmZpZyh0KSB7XG4gICAgY29uc3QgZSA9IHtcbiAgICAgIHBsYWNlbWVudDogdCxcbiAgICAgIG1vZGlmaWVyczogW1xuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogXCJmbGlwXCIsXG4gICAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgZmFsbGJhY2tQbGFjZW1lbnRzOiB0aGlzLl9jb25maWcuZmFsbGJhY2tQbGFjZW1lbnRzXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogXCJvZmZzZXRcIixcbiAgICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICBvZmZzZXQ6IHRoaXMuX2dldE9mZnNldCgpXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogXCJwcmV2ZW50T3ZlcmZsb3dcIixcbiAgICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICBib3VuZGFyeTogdGhpcy5fY29uZmlnLmJvdW5kYXJ5XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogXCJhcnJvd1wiLFxuICAgICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgIGVsZW1lbnQ6IGAuJHt0aGlzLmNvbnN0cnVjdG9yLk5BTUV9LWFycm93YFxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6IFwib25DaGFuZ2VcIixcbiAgICAgICAgICBlbmFibGVkOiAhMCxcbiAgICAgICAgICBwaGFzZTogXCJhZnRlcldyaXRlXCIsXG4gICAgICAgICAgZm46IChpKSA9PiB0aGlzLl9oYW5kbGVQb3BwZXJQbGFjZW1lbnRDaGFuZ2UoaSlcbiAgICAgICAgfVxuICAgICAgXSxcbiAgICAgIG9uRmlyc3RVcGRhdGU6IChpKSA9PiB7XG4gICAgICAgIGkub3B0aW9ucy5wbGFjZW1lbnQgIT09IGkucGxhY2VtZW50ICYmIHRoaXMuX2hhbmRsZVBvcHBlclBsYWNlbWVudENoYW5nZShpKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICAuLi5lLFxuICAgICAgLi4udHlwZW9mIHRoaXMuX2NvbmZpZy5wb3BwZXJDb25maWcgPT0gXCJmdW5jdGlvblwiID8gdGhpcy5fY29uZmlnLnBvcHBlckNvbmZpZyhlKSA6IHRoaXMuX2NvbmZpZy5wb3BwZXJDb25maWdcbiAgICB9O1xuICB9XG4gIF9hZGRBdHRhY2htZW50Q2xhc3ModCkge1xuICAgIHRoaXMuZ2V0VGlwRWxlbWVudCgpLmNsYXNzTGlzdC5hZGQoXG4gICAgICBgJHt0aGlzLl9nZXRCYXNpY0NsYXNzUHJlZml4KCl9LSR7dGhpcy51cGRhdGVBdHRhY2htZW50KHQpfWBcbiAgICApO1xuICB9XG4gIF9nZXRBdHRhY2htZW50KHQpIHtcbiAgICByZXR1cm4gR3BbdC50b1VwcGVyQ2FzZSgpXTtcbiAgfVxuICBfc2V0TGlzdGVuZXJzKCkge1xuICAgIHRoaXMuX2NvbmZpZy50cmlnZ2VyLnNwbGl0KFwiIFwiKS5mb3JFYWNoKChlKSA9PiB7XG4gICAgICBpZiAoZSA9PT0gXCJjbGlja1wiKVxuICAgICAgICBjLm9uKFxuICAgICAgICAgIHRoaXMuX2VsZW1lbnQsXG4gICAgICAgICAgdGhpcy5jb25zdHJ1Y3Rvci5FdmVudC5DTElDSyxcbiAgICAgICAgICB0aGlzLl9jb25maWcuc2VsZWN0b3IsXG4gICAgICAgICAgKGkpID0+IHRoaXMudG9nZ2xlKGkpXG4gICAgICAgICk7XG4gICAgICBlbHNlIGlmIChlICE9PSBlXykge1xuICAgICAgICBjb25zdCBpID0gZSA9PT0gaGkgPyB0aGlzLmNvbnN0cnVjdG9yLkV2ZW50Lk1PVVNFRU5URVIgOiB0aGlzLmNvbnN0cnVjdG9yLkV2ZW50LkZPQ1VTSU4sIG4gPSBlID09PSBoaSA/IHRoaXMuY29uc3RydWN0b3IuRXZlbnQuTU9VU0VMRUFWRSA6IHRoaXMuY29uc3RydWN0b3IuRXZlbnQuRk9DVVNPVVQ7XG4gICAgICAgIGMub24oXG4gICAgICAgICAgdGhpcy5fZWxlbWVudCxcbiAgICAgICAgICBpLFxuICAgICAgICAgIHRoaXMuX2NvbmZpZy5zZWxlY3RvcixcbiAgICAgICAgICAobykgPT4gdGhpcy5fZW50ZXIobylcbiAgICAgICAgKSwgYy5vbihcbiAgICAgICAgICB0aGlzLl9lbGVtZW50LFxuICAgICAgICAgIG4sXG4gICAgICAgICAgdGhpcy5fY29uZmlnLnNlbGVjdG9yLFxuICAgICAgICAgIChvKSA9PiB0aGlzLl9sZWF2ZShvKVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0pLCB0aGlzLl9oaWRlTW9kYWxIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgdGhpcy5fZWxlbWVudCAmJiB0aGlzLmhpZGUoKTtcbiAgICB9LCBjLm9uKFxuICAgICAgdGhpcy5fZWxlbWVudC5jbG9zZXN0KHBhKSxcbiAgICAgIF9hLFxuICAgICAgdGhpcy5faGlkZU1vZGFsSGFuZGxlclxuICAgICksIHRoaXMuX2NvbmZpZy5zZWxlY3RvciA/IHRoaXMuX2NvbmZpZyA9IHtcbiAgICAgIC4uLnRoaXMuX2NvbmZpZyxcbiAgICAgIHRyaWdnZXI6IFwibWFudWFsXCIsXG4gICAgICBzZWxlY3RvcjogXCJcIlxuICAgIH0gOiB0aGlzLl9maXhUaXRsZSgpO1xuICB9XG4gIF9maXhUaXRsZSgpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5fZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJ0aXRsZVwiKSwgZSA9IHR5cGVvZiB0aGlzLl9lbGVtZW50LmdldEF0dHJpYnV0ZShcbiAgICAgIFwiZGF0YS10ZS1vcmlnaW5hbC10aXRsZVwiXG4gICAgKTtcbiAgICAodCB8fCBlICE9PSBcInN0cmluZ1wiKSAmJiAodGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJkYXRhLXRlLW9yaWdpbmFsLXRpdGxlXCIsIHQgfHwgXCJcIiksIHQgJiYgIXRoaXMuX2VsZW1lbnQuZ2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiKSAmJiAhdGhpcy5fZWxlbWVudC50ZXh0Q29udGVudCAmJiB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIiwgdCksIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKFwidGl0bGVcIiwgXCJcIikpO1xuICB9XG4gIF9lbnRlcih0LCBlKSB7XG4gICAgaWYgKGUgPSB0aGlzLl9pbml0aWFsaXplT25EZWxlZ2F0ZWRUYXJnZXQodCwgZSksIHQgJiYgKGUuX2FjdGl2ZVRyaWdnZXJbdC50eXBlID09PSBcImZvY3VzaW5cIiA/IFBuIDogaGldID0gITApLCBlLmdldFRpcEVsZW1lbnQoKS5jbGFzc0xpc3QuY29udGFpbnMoTW4pIHx8IGUuX2hvdmVyU3RhdGUgPT09IGNpKSB7XG4gICAgICBlLl9ob3ZlclN0YXRlID0gY2k7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChjbGVhclRpbWVvdXQoZS5fdGltZW91dCksIGUuX2hvdmVyU3RhdGUgPSBjaSwgIWUuX2NvbmZpZy5kZWxheSB8fCAhZS5fY29uZmlnLmRlbGF5LnNob3cpIHtcbiAgICAgIGUuc2hvdygpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlLl90aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBlLl9ob3ZlclN0YXRlID09PSBjaSAmJiBlLnNob3coKTtcbiAgICB9LCBlLl9jb25maWcuZGVsYXkuc2hvdyk7XG4gIH1cbiAgX2xlYXZlKHQsIGUpIHtcbiAgICBpZiAoZSA9IHRoaXMuX2luaXRpYWxpemVPbkRlbGVnYXRlZFRhcmdldCh0LCBlKSwgdCAmJiAoZS5fYWN0aXZlVHJpZ2dlclt0LnR5cGUgPT09IFwiZm9jdXNvdXRcIiA/IFBuIDogaGldID0gZS5fZWxlbWVudC5jb250YWlucyh0LnJlbGF0ZWRUYXJnZXQpKSwgIWUuX2lzV2l0aEFjdGl2ZVRyaWdnZXIoKSkge1xuICAgICAgaWYgKGNsZWFyVGltZW91dChlLl90aW1lb3V0KSwgZS5faG92ZXJTdGF0ZSA9IFJuLCAhZS5fY29uZmlnLmRlbGF5IHx8ICFlLl9jb25maWcuZGVsYXkuaGlkZSkge1xuICAgICAgICBlLmhpZGUoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZS5fdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBlLl9ob3ZlclN0YXRlID09PSBSbiAmJiBlLmhpZGUoKTtcbiAgICAgIH0sIGUuX2NvbmZpZy5kZWxheS5oaWRlKTtcbiAgICB9XG4gIH1cbiAgX2lzV2l0aEFjdGl2ZVRyaWdnZXIoKSB7XG4gICAgZm9yIChjb25zdCB0IGluIHRoaXMuX2FjdGl2ZVRyaWdnZXIpXG4gICAgICBpZiAodGhpcy5fYWN0aXZlVHJpZ2dlclt0XSlcbiAgICAgICAgcmV0dXJuICEwO1xuICAgIHJldHVybiAhMTtcbiAgfVxuICBfZ2V0Q29uZmlnKHQpIHtcbiAgICBjb25zdCBlID0gaC5nZXREYXRhQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KTtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMoZSkuZm9yRWFjaCgoaSkgPT4ge1xuICAgICAgVXAuaGFzKGkpICYmIGRlbGV0ZSBlW2ldO1xuICAgIH0pLCB0ID0ge1xuICAgICAgLi4udGhpcy5jb25zdHJ1Y3Rvci5EZWZhdWx0LFxuICAgICAgLi4uZSxcbiAgICAgIC4uLnR5cGVvZiB0ID09IFwib2JqZWN0XCIgJiYgdCA/IHQgOiB7fVxuICAgIH0sIHQuY29udGFpbmVyID0gdC5jb250YWluZXIgPT09ICExID8gZG9jdW1lbnQuYm9keSA6IHRlKHQuY29udGFpbmVyKSwgdHlwZW9mIHQuZGVsYXkgPT0gXCJudW1iZXJcIiAmJiAodC5kZWxheSA9IHtcbiAgICAgIHNob3c6IHQuZGVsYXksXG4gICAgICBoaWRlOiB0LmRlbGF5XG4gICAgfSksIHR5cGVvZiB0LnRpdGxlID09IFwibnVtYmVyXCIgJiYgKHQudGl0bGUgPSB0LnRpdGxlLnRvU3RyaW5nKCkpLCB0eXBlb2YgdC5jb250ZW50ID09IFwibnVtYmVyXCIgJiYgKHQuY29udGVudCA9IHQuY29udGVudC50b1N0cmluZygpKSwgRChkYSwgdCwgdGhpcy5jb25zdHJ1Y3Rvci5EZWZhdWx0VHlwZSksIHQuc2FuaXRpemUgJiYgKHQudGVtcGxhdGUgPSBoYShcbiAgICAgIHQudGVtcGxhdGUsXG4gICAgICB0LmFsbG93TGlzdCxcbiAgICAgIHQuc2FuaXRpemVGblxuICAgICkpLCB0O1xuICB9XG4gIF9nZXREZWxlZ2F0ZUNvbmZpZygpIHtcbiAgICBjb25zdCB0ID0ge307XG4gICAgZm9yIChjb25zdCBlIGluIHRoaXMuX2NvbmZpZylcbiAgICAgIHRoaXMuY29uc3RydWN0b3IuRGVmYXVsdFtlXSAhPT0gdGhpcy5fY29uZmlnW2VdICYmICh0W2VdID0gdGhpcy5fY29uZmlnW2VdKTtcbiAgICByZXR1cm4gdDtcbiAgfVxuICBfY2xlYW5UaXBDbGFzcygpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5nZXRUaXBFbGVtZW50KCksIGUgPSBuZXcgUmVnRXhwKFxuICAgICAgYChefFxcXFxzKSR7dGhpcy5fZ2V0QmFzaWNDbGFzc1ByZWZpeCgpfVxcXFxTK2AsXG4gICAgICBcImdcIlxuICAgICksIGkgPSB0LmdldEF0dHJpYnV0ZShcImNsYXNzXCIpLm1hdGNoKGUpO1xuICAgIGkgIT09IG51bGwgJiYgaS5sZW5ndGggPiAwICYmIGkubWFwKChuKSA9PiBuLnRyaW0oKSkuZm9yRWFjaCgobikgPT4gdC5jbGFzc0xpc3QucmVtb3ZlKG4pKTtcbiAgfVxuICBfZ2V0QmFzaWNDbGFzc1ByZWZpeCgpIHtcbiAgICByZXR1cm4genA7XG4gIH1cbiAgX2hhbmRsZVBvcHBlclBsYWNlbWVudENoYW5nZSh0KSB7XG4gICAgY29uc3QgeyBzdGF0ZTogZSB9ID0gdDtcbiAgICBlICYmICh0aGlzLnRpcCA9IGUuZWxlbWVudHMucG9wcGVyLCB0aGlzLl9jbGVhblRpcENsYXNzKCksIHRoaXMuX2FkZEF0dGFjaG1lbnRDbGFzcyh0aGlzLl9nZXRBdHRhY2htZW50KGUucGxhY2VtZW50KSkpO1xuICB9XG4gIF9kaXNwb3NlUG9wcGVyKCkge1xuICAgIHRoaXMuX3BvcHBlciAmJiAodGhpcy5fcG9wcGVyLmRlc3Ryb3koKSwgdGhpcy5fcG9wcGVyID0gbnVsbCk7XG4gIH1cbiAgLy8gU3RhdGljXG4gIHN0YXRpYyBqUXVlcnlJbnRlcmZhY2UodCkge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICBjb25zdCBlID0gaWkuZ2V0T3JDcmVhdGVJbnN0YW5jZSh0aGlzLCB0KTtcbiAgICAgIGlmICh0eXBlb2YgdCA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZVt0XSA+IFwidVwiKVxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcIiR7dH1cImApO1xuICAgICAgICBlW3RdKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cbmNvbnN0IGlfID0gXCJwb3BvdmVyXCIsIHNfID0gXCJ0ZS5wb3BvdmVyXCIsIGt0ID0gYC4ke3NffWAsIG5fID0gXCJ0ZS1wb3BvdmVyXCIsIG9fID0ge1xuICAuLi5paS5EZWZhdWx0LFxuICBwbGFjZW1lbnQ6IFwicmlnaHRcIixcbiAgb2Zmc2V0OiBbMCwgOF0sXG4gIHRyaWdnZXI6IFwiY2xpY2tcIixcbiAgY29udGVudDogXCJcIixcbiAgdGVtcGxhdGU6ICc8ZGl2IGNsYXNzPVwib3BhY2l0eS0wIHRyYW5zaXRpb24tb3BhY2l0eSBkdXJhdGlvbi0xNTAgZWFzZS1pbi1vdXQgYWJzb2x1dGUgdG9wLTAgbGVmdC0wIHotWzEwNzBdIGJsb2NrIG1heC13LVsyNjdweF0gYnJlYWstd29yZHMgYmctd2hpdGUgYmctY2xpcC1wYWRkaW5nIGJvcmRlciBib3JkZXItbmV1dHJhbC0xMDAgcm91bmRlZC1sZyBzaGFkb3ctWzBfMHB4XzNweF8wX3JnYmEoMCwwLDAsMC4wNyksMF8ycHhfMnB4XzBfcmdiYSgwLDAsMCwwLjA0KV0gdGV4dC1zbSBub3QtaXRhbGljIGZvbnQtbm9ybWFsIHRleHQtbGVmdCBuby11bmRlcmxpbmUgdW5kZXJsaW5lLW9mZnNldC1hdXRvIG5vcm1hbC1jYXNlIGxlYWRpbmctNiB0cmFja2luZy1ub3JtYWwgYnJlYWstbm9ybWFsIHdoaXRlc3BhY2Utbm9ybWFsIGRhcms6YmctbmV1dHJhbC03MDAgZGFyazpib3JkZXItMCBkYXJrOnRleHQtd2hpdGUgZGF0YS1bcG9wcGVyLXJlZmVyZW5jZS1oaWRkZW5dOmhpZGRlblwiIHJvbGU9XCJ0b29sdGlwXCI+PGgzIGNsYXNzPVwicG9wb3Zlci1oZWFkZXIgcHktMiBweC00IG1iLTAgYm9yZGVyLWItMiBib3JkZXItbmV1dHJhbC0xMDAgcm91bmRlZC10LWxnIGZvbnQtbWVkaXVtIGVtcHR5OmhpZGRlbiBkYXJrOmJvcmRlci1uZXV0cmFsLTUwMFwiPjwvaDM+PGRpdiBjbGFzcz1cInBvcG92ZXItYm9keSBwLTQgdGV4dC1bIzIxMjUyOV0gZGFyazp0ZXh0LXdoaXRlXCI+PC9kaXY+PC9kaXY+J1xufSwgcl8gPSB7XG4gIC4uLmlpLkRlZmF1bHRUeXBlLFxuICBjb250ZW50OiBcIihzdHJpbmd8ZWxlbWVudHxmdW5jdGlvbilcIlxufSwgYV8gPSB7XG4gIEhJREU6IGBoaWRlJHtrdH1gLFxuICBISURERU46IGBoaWRkZW4ke2t0fWAsXG4gIFNIT1c6IGBzaG93JHtrdH1gLFxuICBTSE9XTjogYHNob3duJHtrdH1gLFxuICBJTlNFUlRFRDogYGluc2VydGVkJHtrdH1gLFxuICBDTElDSzogYGNsaWNrJHtrdH1gLFxuICBGT0NVU0lOOiBgZm9jdXNpbiR7a3R9YCxcbiAgRk9DVVNPVVQ6IGBmb2N1c291dCR7a3R9YCxcbiAgTU9VU0VFTlRFUjogYG1vdXNlZW50ZXIke2t0fWAsXG4gIE1PVVNFTEVBVkU6IGBtb3VzZWxlYXZlJHtrdH1gXG59LCBsXyA9IFwiLnBvcG92ZXItaGVhZGVyXCIsIGNfID0gXCIucG9wb3Zlci1ib2R5XCI7XG5jbGFzcyBSYyBleHRlbmRzIGlpIHtcbiAgLy8gR2V0dGVyc1xuICBzdGF0aWMgZ2V0IERlZmF1bHQoKSB7XG4gICAgcmV0dXJuIG9fO1xuICB9XG4gIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICByZXR1cm4gaV87XG4gIH1cbiAgc3RhdGljIGdldCBFdmVudCgpIHtcbiAgICByZXR1cm4gYV87XG4gIH1cbiAgc3RhdGljIGdldCBEZWZhdWx0VHlwZSgpIHtcbiAgICByZXR1cm4gcl87XG4gIH1cbiAgLy8gT3ZlcnJpZGVzXG4gIGlzV2l0aENvbnRlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0VGl0bGUoKSB8fCB0aGlzLl9nZXRDb250ZW50KCk7XG4gIH1cbiAgc2V0Q29udGVudCh0KSB7XG4gICAgdGhpcy5fc2FuaXRpemVBbmRTZXRDb250ZW50KHQsIHRoaXMuZ2V0VGl0bGUoKSwgbF8pLCB0aGlzLl9zYW5pdGl6ZUFuZFNldENvbnRlbnQodCwgdGhpcy5fZ2V0Q29udGVudCgpLCBjXyk7XG4gIH1cbiAgLy8gUHJpdmF0ZVxuICBfZ2V0Q29udGVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVzb2x2ZVBvc3NpYmxlRnVuY3Rpb24odGhpcy5fY29uZmlnLmNvbnRlbnQpO1xuICB9XG4gIF9nZXRCYXNpY0NsYXNzUHJlZml4KCkge1xuICAgIHJldHVybiBuXztcbiAgfVxuICAvLyBTdGF0aWNcbiAgc3RhdGljIGpRdWVyeUludGVyZmFjZSh0KSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgIGNvbnN0IGUgPSBSYy5nZXRPckNyZWF0ZUluc3RhbmNlKHRoaXMsIHQpO1xuICAgICAgaWYgKHR5cGVvZiB0ID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBlW3RdID4gXCJ1XCIpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFwiJHt0fVwiYCk7XG4gICAgICAgIGVbdF0oKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuY29uc3QgQm4gPSBcInNjcm9sbHNweVwiLCBoXyA9IFwidGUuc2Nyb2xsc3B5XCIsIHVyID0gYC4ke2hffWAsIGZhID0ge1xuICBvZmZzZXQ6IDEwLFxuICBtZXRob2Q6IFwiYXV0b1wiLFxuICB0YXJnZXQ6IFwiXCJcbn0sIGRfID0ge1xuICBvZmZzZXQ6IFwibnVtYmVyXCIsXG4gIG1ldGhvZDogXCJzdHJpbmdcIixcbiAgdGFyZ2V0OiBcIihzdHJpbmd8ZWxlbWVudClcIlxufSwgdV8gPSB7XG4gIGFjdGl2ZTogXCIhdGV4dC1wcmltYXJ5IGRhcms6IXRleHQtcHJpbWFyeS00MDAgZm9udC1zZW1pYm9sZCBib3JkZXItbC1bMC4xMjVyZW1dIGJvcmRlci1zb2xpZCBib3JkZXItcHJpbWFyeSBkYXJrOmJvcmRlci1wcmltYXJ5LTQwMFwiXG59LCBwXyA9IHtcbiAgYWN0aXZlOiBcInN0cmluZ1wiXG59LCBfXyA9IGBhY3RpdmF0ZSR7dXJ9YCwgZl8gPSBgc2Nyb2xsJHt1cn1gLCBIbiA9IFwiZGF0YS10ZS1uYXYtbGluay1hY3RpdmVcIiwgUGMgPSBcIltkYXRhLXRlLWRyb3Bkb3duLWl0ZW0tcmVmXVwiLCBtXyA9IFwiW2RhdGEtdGUtbmF2LWxpc3QtcmVmXVwiLCBNbyA9IFwiW2RhdGEtdGUtbmF2LWxpbmstcmVmXVwiLCBnXyA9IFwiW2RhdGEtdGUtbmF2LWl0ZW0tcmVmXVwiLCBCYyA9IFwiW2RhdGEtdGUtbGlzdC1ncm91cC1pdGVtLXJlZl1cIiwgVm4gPSBgJHtNb30sICR7QmN9LCAke1BjfWAsIGJfID0gXCJbZGF0YS10ZS1kcm9wZG93bi1yZWZdXCIsIHZfID0gXCJbZGF0YS10ZS1kcm9wZG93bi10b2dnbGUtcmVmXVwiLCBUXyA9IFwibWF4T2Zmc2V0XCIsIG1hID0gXCJwb3NpdGlvblwiO1xuY2xhc3MgSGMgZXh0ZW5kcyBndCB7XG4gIGNvbnN0cnVjdG9yKHQsIGUsIGkpIHtcbiAgICBzdXBlcih0KSwgdGhpcy5fc2Nyb2xsRWxlbWVudCA9IHRoaXMuX2VsZW1lbnQudGFnTmFtZSA9PT0gXCJCT0RZXCIgPyB3aW5kb3cgOiB0aGlzLl9lbGVtZW50LCB0aGlzLl9jb25maWcgPSB0aGlzLl9nZXRDb25maWcoZSksIHRoaXMuX2NsYXNzZXMgPSB0aGlzLl9nZXRDbGFzc2VzKGkpLCB0aGlzLl9vZmZzZXRzID0gW10sIHRoaXMuX3RhcmdldHMgPSBbXSwgdGhpcy5fYWN0aXZlVGFyZ2V0ID0gbnVsbCwgdGhpcy5fc2Nyb2xsSGVpZ2h0ID0gMCwgYy5vbih0aGlzLl9zY3JvbGxFbGVtZW50LCBmXywgKCkgPT4gdGhpcy5fcHJvY2VzcygpKSwgdGhpcy5yZWZyZXNoKCksIHRoaXMuX3Byb2Nlc3MoKTtcbiAgfVxuICAvLyBHZXR0ZXJzXG4gIHN0YXRpYyBnZXQgRGVmYXVsdCgpIHtcbiAgICByZXR1cm4gZmE7XG4gIH1cbiAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgIHJldHVybiBCbjtcbiAgfVxuICAvLyBQdWJsaWNcbiAgcmVmcmVzaCgpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5fc2Nyb2xsRWxlbWVudCA9PT0gdGhpcy5fc2Nyb2xsRWxlbWVudC53aW5kb3cgPyBUXyA6IG1hLCBlID0gdGhpcy5fY29uZmlnLm1ldGhvZCA9PT0gXCJhdXRvXCIgPyB0IDogdGhpcy5fY29uZmlnLm1ldGhvZCwgaSA9IGUgPT09IG1hID8gdGhpcy5fZ2V0U2Nyb2xsVG9wKCkgOiAwO1xuICAgIHRoaXMuX29mZnNldHMgPSBbXSwgdGhpcy5fdGFyZ2V0cyA9IFtdLCB0aGlzLl9zY3JvbGxIZWlnaHQgPSB0aGlzLl9nZXRTY3JvbGxIZWlnaHQoKSwgZC5maW5kKFxuICAgICAgVm4sXG4gICAgICB0aGlzLl9jb25maWcudGFyZ2V0XG4gICAgKS5tYXAoKG8pID0+IHtcbiAgICAgIGNvbnN0IHIgPSBxbyhvKSwgYSA9IHIgPyBkLmZpbmRPbmUocikgOiBudWxsO1xuICAgICAgaWYgKGEpIHtcbiAgICAgICAgY29uc3QgbCA9IGEuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGlmIChsLndpZHRoIHx8IGwuaGVpZ2h0KVxuICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBoW2VdKGEpLnRvcCArIGksXG4gICAgICAgICAgICByXG4gICAgICAgICAgXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0pLmZpbHRlcigobykgPT4gbykuc29ydCgobywgcikgPT4gb1swXSAtIHJbMF0pLmZvckVhY2goKG8pID0+IHtcbiAgICAgIHRoaXMuX29mZnNldHMucHVzaChvWzBdKSwgdGhpcy5fdGFyZ2V0cy5wdXNoKG9bMV0pO1xuICAgIH0pO1xuICB9XG4gIGRpc3Bvc2UoKSB7XG4gICAgYy5vZmYodGhpcy5fc2Nyb2xsRWxlbWVudCwgdXIpLCBzdXBlci5kaXNwb3NlKCk7XG4gIH1cbiAgLy8gUHJpdmF0ZVxuICBfZ2V0Q29uZmlnKHQpIHtcbiAgICByZXR1cm4gdCA9IHtcbiAgICAgIC4uLmZhLFxuICAgICAgLi4uaC5nZXREYXRhQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KSxcbiAgICAgIC4uLnR5cGVvZiB0ID09IFwib2JqZWN0XCIgJiYgdCA/IHQgOiB7fVxuICAgIH0sIHQudGFyZ2V0ID0gdGUodC50YXJnZXQpIHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgRChCbiwgdCwgZF8pLCB0O1xuICB9XG4gIF9nZXRDbGFzc2VzKHQpIHtcbiAgICBjb25zdCBlID0gaC5nZXREYXRhQ2xhc3NBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpO1xuICAgIHJldHVybiB0ID0ge1xuICAgICAgLi4udV8sXG4gICAgICAuLi5lLFxuICAgICAgLi4udFxuICAgIH0sIEQoQm4sIHQsIHBfKSwgdDtcbiAgfVxuICBfZ2V0U2Nyb2xsVG9wKCkge1xuICAgIHJldHVybiB0aGlzLl9zY3JvbGxFbGVtZW50ID09PSB3aW5kb3cgPyB0aGlzLl9zY3JvbGxFbGVtZW50LnBhZ2VZT2Zmc2V0IDogdGhpcy5fc2Nyb2xsRWxlbWVudC5zY3JvbGxUb3A7XG4gIH1cbiAgX2dldFNjcm9sbEhlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy5fc2Nyb2xsRWxlbWVudC5zY3JvbGxIZWlnaHQgfHwgTWF0aC5tYXgoXG4gICAgICBkb2N1bWVudC5ib2R5LnNjcm9sbEhlaWdodCxcbiAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxIZWlnaHRcbiAgICApO1xuICB9XG4gIF9nZXRPZmZzZXRIZWlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Njcm9sbEVsZW1lbnQgPT09IHdpbmRvdyA/IHdpbmRvdy5pbm5lckhlaWdodCA6IHRoaXMuX3Njcm9sbEVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0O1xuICB9XG4gIF9wcm9jZXNzKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLl9nZXRTY3JvbGxUb3AoKSArIHRoaXMuX2NvbmZpZy5vZmZzZXQsIGUgPSB0aGlzLl9nZXRTY3JvbGxIZWlnaHQoKSwgaSA9IHRoaXMuX2NvbmZpZy5vZmZzZXQgKyBlIC0gdGhpcy5fZ2V0T2Zmc2V0SGVpZ2h0KCk7XG4gICAgaWYgKHRoaXMuX3Njcm9sbEhlaWdodCAhPT0gZSAmJiB0aGlzLnJlZnJlc2goKSwgdCA+PSBpKSB7XG4gICAgICBjb25zdCBuID0gdGhpcy5fdGFyZ2V0c1t0aGlzLl90YXJnZXRzLmxlbmd0aCAtIDFdO1xuICAgICAgdGhpcy5fYWN0aXZlVGFyZ2V0ICE9PSBuICYmIHRoaXMuX2FjdGl2YXRlKG4pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5fYWN0aXZlVGFyZ2V0ICYmIHQgPCB0aGlzLl9vZmZzZXRzWzBdICYmIHRoaXMuX29mZnNldHNbMF0gPiAwKSB7XG4gICAgICB0aGlzLl9hY3RpdmVUYXJnZXQgPSBudWxsLCB0aGlzLl9jbGVhcigpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKGxldCBuID0gdGhpcy5fb2Zmc2V0cy5sZW5ndGg7IG4tLTsgKVxuICAgICAgdGhpcy5fYWN0aXZlVGFyZ2V0ICE9PSB0aGlzLl90YXJnZXRzW25dICYmIHQgPj0gdGhpcy5fb2Zmc2V0c1tuXSAmJiAodHlwZW9mIHRoaXMuX29mZnNldHNbbiArIDFdID4gXCJ1XCIgfHwgdCA8IHRoaXMuX29mZnNldHNbbiArIDFdKSAmJiB0aGlzLl9hY3RpdmF0ZSh0aGlzLl90YXJnZXRzW25dKTtcbiAgfVxuICBfYWN0aXZhdGUodCkge1xuICAgIHRoaXMuX2FjdGl2ZVRhcmdldCA9IHQsIHRoaXMuX2NsZWFyKCk7XG4gICAgY29uc3QgZSA9IFZuLnNwbGl0KFwiLFwiKS5tYXAoXG4gICAgICAobikgPT4gYCR7bn1bZGF0YS10ZS10YXJnZXQ9XCIke3R9XCJdLCR7bn1baHJlZj1cIiR7dH1cIl1gXG4gICAgKSwgaSA9IGQuZmluZE9uZShlLmpvaW4oXCIsXCIpLCB0aGlzLl9jb25maWcudGFyZ2V0KTtcbiAgICBpLmNsYXNzTGlzdC5hZGQoLi4udGhpcy5fY2xhc3Nlcy5hY3RpdmUuc3BsaXQoXCIgXCIpKSwgaS5zZXRBdHRyaWJ1dGUoSG4sIFwiXCIpLCBpLmdldEF0dHJpYnV0ZShQYykgPyBkLmZpbmRPbmUoXG4gICAgICB2XyxcbiAgICAgIGkuY2xvc2VzdChiXylcbiAgICApLmNsYXNzTGlzdC5hZGQoLi4udGhpcy5fY2xhc3Nlcy5hY3RpdmUuc3BsaXQoXCIgXCIpKSA6IGQucGFyZW50cyhpLCBtXykuZm9yRWFjaChcbiAgICAgIChuKSA9PiB7XG4gICAgICAgIGQucHJldihcbiAgICAgICAgICBuLFxuICAgICAgICAgIGAke01vfSwgJHtCY31gXG4gICAgICAgICkuZm9yRWFjaCgobykgPT4ge1xuICAgICAgICAgIG8uY2xhc3NMaXN0LmFkZCguLi50aGlzLl9jbGFzc2VzLmFjdGl2ZS5zcGxpdChcIiBcIikpLCBvLnNldEF0dHJpYnV0ZShIbiwgXCJcIik7XG4gICAgICAgIH0pLCBkLnByZXYobiwgZ18pLmZvckVhY2goXG4gICAgICAgICAgKG8pID0+IHtcbiAgICAgICAgICAgIGQuY2hpbGRyZW4obywgTW8pLmZvckVhY2goXG4gICAgICAgICAgICAgIChyKSA9PiByLmNsYXNzTGlzdC5hZGQoLi4udGhpcy5fY2xhc3Nlcy5hY3RpdmUuc3BsaXQoXCIgXCIpKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgICB9XG4gICAgKSwgYy50cmlnZ2VyKHRoaXMuX3Njcm9sbEVsZW1lbnQsIF9fLCB7XG4gICAgICByZWxhdGVkVGFyZ2V0OiB0XG4gICAgfSk7XG4gIH1cbiAgX2NsZWFyKCkge1xuICAgIGQuZmluZChWbiwgdGhpcy5fY29uZmlnLnRhcmdldCkuZmlsdGVyKFxuICAgICAgKHQpID0+IHQuY2xhc3NMaXN0LmNvbnRhaW5zKC4uLnRoaXMuX2NsYXNzZXMuYWN0aXZlLnNwbGl0KFwiIFwiKSlcbiAgICApLmZvckVhY2goKHQpID0+IHtcbiAgICAgIHQuY2xhc3NMaXN0LnJlbW92ZSguLi50aGlzLl9jbGFzc2VzLmFjdGl2ZS5zcGxpdChcIiBcIikpLCB0LnJlbW92ZUF0dHJpYnV0ZShIbik7XG4gICAgfSk7XG4gIH1cbiAgLy8gU3RhdGljXG4gIHN0YXRpYyBqUXVlcnlJbnRlcmZhY2UodCkge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICBjb25zdCBlID0gSGMuZ2V0T3JDcmVhdGVJbnN0YW5jZSh0aGlzLCB0KTtcbiAgICAgIGlmICh0eXBlb2YgdCA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZVt0XSA+IFwidVwiKVxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcIiR7dH1cImApO1xuICAgICAgICBlW3RdKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cbmNvbnN0IGdhID0gXCJ0YWJcIiwgRV8gPSBcInRlLnRhYlwiLCBobiA9IGAuJHtFX31gLCBDXyA9IGBoaWRlJHtobn1gLCBBXyA9IGBoaWRkZW4ke2hufWAsIHlfID0gYHNob3cke2hufWAsIHdfID0gYHNob3duJHtobn1gLCBrXyA9IFwiZGF0YS10ZS1kcm9wZG93bi1tZW51LXJlZlwiLCBMZSA9IFwiZGF0YS10ZS10YWItYWN0aXZlXCIsIEhzID0gXCJkYXRhLXRlLW5hdi1hY3RpdmVcIiwgeF8gPSBcIltkYXRhLXRlLWRyb3Bkb3duLXJlZl1cIiwgT18gPSBcIltkYXRhLXRlLW5hdi1yZWZdXCIsIGJhID0gYFske0xlfV1gLCBTXyA9IGBbJHtIc31dYCwgdmEgPSBcIjpzY29wZSA+IGxpID4gLmFjdGl2ZVwiLCBJXyA9IFwiW2RhdGEtdGUtZHJvcGRvd24tdG9nZ2xlLXJlZl1cIiwgRF8gPSBcIjpzY29wZSA+IFtkYXRhLXRlLWRyb3Bkb3duLW1lbnUtcmVmXSBbZGF0YS10ZS1kcm9wZG93bi1zaG93XVwiLCAkXyA9IHtcbiAgc2hvdzogXCJvcGFjaXR5LTEwMFwiLFxuICBoaWRlOiBcIm9wYWNpdHktMFwiXG59LCBMXyA9IHtcbiAgc2hvdzogXCJzdHJpbmdcIixcbiAgaGlkZTogXCJzdHJpbmdcIlxufTtcbmNsYXNzIFZjIGV4dGVuZHMgZ3Qge1xuICBjb25zdHJ1Y3Rvcih0LCBlKSB7XG4gICAgc3VwZXIodCksIHRoaXMuX2NsYXNzZXMgPSB0aGlzLl9nZXRDbGFzc2VzKGUpO1xuICB9XG4gIC8vIEdldHRlcnNcbiAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgIHJldHVybiBnYTtcbiAgfVxuICAvLyBQdWJsaWNcbiAgc2hvdygpIHtcbiAgICBpZiAodGhpcy5fZWxlbWVudC5wYXJlbnROb2RlICYmIHRoaXMuX2VsZW1lbnQucGFyZW50Tm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUgJiYgdGhpcy5fZWxlbWVudC5nZXRBdHRyaWJ1dGUoSHMpID09PSBcIlwiKVxuICAgICAgcmV0dXJuO1xuICAgIGxldCB0O1xuICAgIGNvbnN0IGUgPSBKdCh0aGlzLl9lbGVtZW50KSwgaSA9IHRoaXMuX2VsZW1lbnQuY2xvc2VzdChPXyksIG4gPSBkLmZpbmRPbmUoXG4gICAgICBTXyxcbiAgICAgIGlcbiAgICApO1xuICAgIGlmIChpKSB7XG4gICAgICBjb25zdCBsID0gaS5ub2RlTmFtZSA9PT0gXCJVTFwiIHx8IGkubm9kZU5hbWUgPT09IFwiT0xcIiA/IHZhIDogYmE7XG4gICAgICB0ID0gZC5maW5kKGwsIGkpLCB0ID0gdFt0Lmxlbmd0aCAtIDFdO1xuICAgIH1cbiAgICBjb25zdCBvID0gdCA/IGMudHJpZ2dlcih0LCBDXywge1xuICAgICAgcmVsYXRlZFRhcmdldDogdGhpcy5fZWxlbWVudFxuICAgIH0pIDogbnVsbDtcbiAgICBpZiAoYy50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIHlfLCB7XG4gICAgICByZWxhdGVkVGFyZ2V0OiB0XG4gICAgfSkuZGVmYXVsdFByZXZlbnRlZCB8fCBvICE9PSBudWxsICYmIG8uZGVmYXVsdFByZXZlbnRlZClcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLl9hY3RpdmF0ZShcbiAgICAgIHRoaXMuX2VsZW1lbnQsXG4gICAgICBpLFxuICAgICAgbnVsbCxcbiAgICAgIG4sXG4gICAgICB0aGlzLl9lbGVtZW50XG4gICAgKTtcbiAgICBjb25zdCBhID0gKCkgPT4ge1xuICAgICAgYy50cmlnZ2VyKHQsIEFfLCB7XG4gICAgICAgIHJlbGF0ZWRUYXJnZXQ6IHRoaXMuX2VsZW1lbnRcbiAgICAgIH0pLCBjLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgd18sIHtcbiAgICAgICAgcmVsYXRlZFRhcmdldDogdFxuICAgICAgfSk7XG4gICAgfTtcbiAgICBlID8gdGhpcy5fYWN0aXZhdGUoXG4gICAgICBlLFxuICAgICAgZS5wYXJlbnROb2RlLFxuICAgICAgYSxcbiAgICAgIG4sXG4gICAgICB0aGlzLl9lbGVtZW50XG4gICAgKSA6IGEoKTtcbiAgfVxuICAvLyBQcml2YXRlXG4gIF9nZXRDbGFzc2VzKHQpIHtcbiAgICBjb25zdCBlID0gaC5nZXREYXRhQ2xhc3NBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpO1xuICAgIHJldHVybiB0ID0ge1xuICAgICAgLi4uJF8sXG4gICAgICAuLi5lLFxuICAgICAgLi4udFxuICAgIH0sIEQoZ2EsIHQsIExfKSwgdDtcbiAgfVxuICBfYWN0aXZhdGUodCwgZSwgaSwgbiwgbykge1xuICAgIGNvbnN0IGEgPSAoZSAmJiAoZS5ub2RlTmFtZSA9PT0gXCJVTFwiIHx8IGUubm9kZU5hbWUgPT09IFwiT0xcIikgPyBkLmZpbmQodmEsIGUpIDogZC5jaGlsZHJlbihlLCBiYSkpWzBdLCBsID0gaSAmJiBhICYmIGEuaGFzQXR0cmlidXRlKExlKSwgcCA9ICgpID0+IHRoaXMuX3RyYW5zaXRpb25Db21wbGV0ZShcbiAgICAgIHQsXG4gICAgICBhLFxuICAgICAgaSxcbiAgICAgIG4sXG4gICAgICBvXG4gICAgKTtcbiAgICBhICYmIGwgPyAoaC5yZW1vdmVDbGFzcyhhLCB0aGlzLl9jbGFzc2VzLnNob3cpLCBoLmFkZENsYXNzKGEsIHRoaXMuX2NsYXNzZXMuaGlkZSksIHRoaXMuX3F1ZXVlQ2FsbGJhY2socCwgdCwgITApKSA6IHAoKTtcbiAgfVxuICBfdHJhbnNpdGlvbkNvbXBsZXRlKHQsIGUsIGksIG4sIG8pIHtcbiAgICBpZiAoZSAmJiBuKSB7XG4gICAgICBlLnJlbW92ZUF0dHJpYnV0ZShMZSksIG4ucmVtb3ZlQXR0cmlidXRlKEhzKTtcbiAgICAgIGNvbnN0IGEgPSBkLmZpbmRPbmUoXG4gICAgICAgIERfLFxuICAgICAgICBlLnBhcmVudE5vZGVcbiAgICAgICk7XG4gICAgICBhICYmIGEucmVtb3ZlQXR0cmlidXRlKExlKSwgZS5nZXRBdHRyaWJ1dGUoXCJyb2xlXCIpID09PSBcInRhYlwiICYmIGUuc2V0QXR0cmlidXRlKFwiYXJpYS1zZWxlY3RlZFwiLCAhMSk7XG4gICAgfVxuICAgIHQuc2V0QXR0cmlidXRlKExlLCBcIlwiKSwgby5zZXRBdHRyaWJ1dGUoSHMsIFwiXCIpLCB0LmdldEF0dHJpYnV0ZShcInJvbGVcIikgPT09IFwidGFiXCIgJiYgdC5zZXRBdHRyaWJ1dGUoXCJhcmlhLXNlbGVjdGVkXCIsICEwKSwgSmUodCksIHQuY2xhc3NMaXN0LmNvbnRhaW5zKHRoaXMuX2NsYXNzZXMuaGlkZSkgJiYgKGgucmVtb3ZlQ2xhc3ModCwgdGhpcy5fY2xhc3Nlcy5oaWRlKSwgaC5hZGRDbGFzcyh0LCB0aGlzLl9jbGFzc2VzLnNob3cpKTtcbiAgICBsZXQgciA9IHQucGFyZW50Tm9kZTtcbiAgICBpZiAociAmJiByLm5vZGVOYW1lID09PSBcIkxJXCIgJiYgKHIgPSByLnBhcmVudE5vZGUpLCByICYmIHIuaGFzQXR0cmlidXRlKGtfKSkge1xuICAgICAgY29uc3QgYSA9IHQuY2xvc2VzdCh4Xyk7XG4gICAgICBhICYmIGQuZmluZChJXywgYSkuZm9yRWFjaChcbiAgICAgICAgKGwpID0+IGwuc2V0QXR0cmlidXRlKExlLCBcIlwiKVxuICAgICAgKSwgdC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWV4cGFuZGVkXCIsICEwKTtcbiAgICB9XG4gICAgaSAmJiBpKCk7XG4gIH1cbiAgLy8gU3RhdGljXG4gIHN0YXRpYyBqUXVlcnlJbnRlcmZhY2UodCkge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICBjb25zdCBlID0gVmMuZ2V0T3JDcmVhdGVJbnN0YW5jZSh0aGlzKTtcbiAgICAgIGlmICh0eXBlb2YgdCA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZVt0XSA+IFwidVwiKVxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcIiR7dH1cImApO1xuICAgICAgICBlW3RdKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cbmNvbnN0IFduID0gXCJ0b2FzdFwiLCBOXyA9IFwidGUudG9hc3RcIiwgaWUgPSBgLiR7Tl99YCwgTV8gPSBgbW91c2VvdmVyJHtpZX1gLCBSXyA9IGBtb3VzZW91dCR7aWV9YCwgUF8gPSBgZm9jdXNpbiR7aWV9YCwgQl8gPSBgZm9jdXNvdXQke2llfWAsIEhfID0gYGhpZGUke2llfWAsIFZfID0gYGhpZGRlbiR7aWV9YCwgV18gPSBgc2hvdyR7aWV9YCwgRl8gPSBgc2hvd24ke2llfWAsIFRhID0gXCJkYXRhLXRlLXRvYXN0LWhpZGVcIiwgRm4gPSBcImRhdGEtdGUtdG9hc3Qtc2hvd1wiLCBucyA9IFwiZGF0YS10ZS10b2FzdC1zaG93aW5nXCIsIFlfID0ge1xuICBhbmltYXRpb246IFwiYm9vbGVhblwiLFxuICBhdXRvaGlkZTogXCJib29sZWFuXCIsXG4gIGRlbGF5OiBcIm51bWJlclwiXG59LCBFYSA9IHtcbiAgYW5pbWF0aW9uOiAhMCxcbiAgYXV0b2hpZGU6ICEwLFxuICBkZWxheTogNWUzXG59LCBqXyA9IHtcbiAgZmFkZUluOiBcImFuaW1hdGUtW2ZhZGUtaW5fMC4zc19ib3RoXSBwLVthdXRvXSBtb3Rpb24tcmVkdWNlOnRyYW5zaXRpb24tbm9uZSBtb3Rpb24tcmVkdWNlOmFuaW1hdGUtbm9uZVwiLFxuICBmYWRlT3V0OiBcImFuaW1hdGUtW2ZhZGUtb3V0XzAuM3NfYm90aF0gcC1bYXV0b10gbW90aW9uLXJlZHVjZTp0cmFuc2l0aW9uLW5vbmUgbW90aW9uLXJlZHVjZTphbmltYXRlLW5vbmVcIlxufSwgS18gPSB7XG4gIGZhZGVJbjogXCJzdHJpbmdcIixcbiAgZmFkZU91dDogXCJzdHJpbmdcIlxufTtcbmNsYXNzIFJvIGV4dGVuZHMgZ3Qge1xuICBjb25zdHJ1Y3Rvcih0LCBlLCBpKSB7XG4gICAgc3VwZXIodCksIHRoaXMuX2NvbmZpZyA9IHRoaXMuX2dldENvbmZpZyhlKSwgdGhpcy5fY2xhc3NlcyA9IHRoaXMuX2dldENsYXNzZXMoaSksIHRoaXMuX3RpbWVvdXQgPSBudWxsLCB0aGlzLl9oYXNNb3VzZUludGVyYWN0aW9uID0gITEsIHRoaXMuX2hhc0tleWJvYXJkSW50ZXJhY3Rpb24gPSAhMSwgdGhpcy5fc2V0TGlzdGVuZXJzKCksIHRoaXMuX2RpZEluaXQgPSAhMSwgdGhpcy5faW5pdCgpO1xuICB9XG4gIC8vIEdldHRlcnNcbiAgc3RhdGljIGdldCBEZWZhdWx0VHlwZSgpIHtcbiAgICByZXR1cm4gWV87XG4gIH1cbiAgc3RhdGljIGdldCBEZWZhdWx0KCkge1xuICAgIHJldHVybiBFYTtcbiAgfVxuICBzdGF0aWMgZ2V0IE5BTUUoKSB7XG4gICAgcmV0dXJuIFduO1xuICB9XG4gIC8vIFB1YmxpY1xuICBzaG93KCkge1xuICAgIGlmIChjLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgV18pLmRlZmF1bHRQcmV2ZW50ZWQpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5fY2xlYXJUaW1lb3V0KCksIHRoaXMuX2NvbmZpZy5hbmltYXRpb24gJiYgKGgucmVtb3ZlQ2xhc3ModGhpcy5fZWxlbWVudCwgdGhpcy5fY2xhc3Nlcy5mYWRlT3V0KSwgaC5hZGRDbGFzcyh0aGlzLl9lbGVtZW50LCB0aGlzLl9jbGFzc2VzLmZhZGVJbikpO1xuICAgIGNvbnN0IGUgPSAoKSA9PiB7XG4gICAgICB0aGlzLl9lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShucyksIGMudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBGXyksIHRoaXMuX21heWJlU2NoZWR1bGVIaWRlKCk7XG4gICAgfTtcbiAgICB0aGlzLl9lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShUYSksIEplKHRoaXMuX2VsZW1lbnQpLCB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZShGbiwgXCJcIiksIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKG5zLCBcIlwiKSwgdGhpcy5fcXVldWVDYWxsYmFjayhlLCB0aGlzLl9lbGVtZW50LCB0aGlzLl9jb25maWcuYW5pbWF0aW9uKTtcbiAgfVxuICBoaWRlKCkge1xuICAgIGlmICghdGhpcy5fZWxlbWVudCB8fCB0aGlzLl9lbGVtZW50LmRhdGFzZXQudGVUb2FzdFNob3cgPT09IHZvaWQgMCB8fCBjLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgSF8pLmRlZmF1bHRQcmV2ZW50ZWQpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgZSA9ICgpID0+IHtcbiAgICAgIGxldCBpID0gMDtcbiAgICAgIHRoaXMuX2NvbmZpZy5hbmltYXRpb24gJiYgKGkgPSAzMDAsIGgucmVtb3ZlQ2xhc3ModGhpcy5fZWxlbWVudCwgdGhpcy5fY2xhc3Nlcy5mYWRlSW4pLCBoLmFkZENsYXNzKHRoaXMuX2VsZW1lbnQsIHRoaXMuX2NsYXNzZXMuZmFkZU91dCkpLCBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoVGEsIFwiXCIpLCB0aGlzLl9lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShucyksIHRoaXMuX2VsZW1lbnQucmVtb3ZlQXR0cmlidXRlKEZuKSwgYy50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIFZfKTtcbiAgICAgIH0sIGkpO1xuICAgIH07XG4gICAgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUobnMsIFwiXCIpLCB0aGlzLl9xdWV1ZUNhbGxiYWNrKGUsIHRoaXMuX2VsZW1lbnQsIHRoaXMuX2NvbmZpZy5hbmltYXRpb24pO1xuICB9XG4gIGRpc3Bvc2UoKSB7XG4gICAgdGhpcy5fY2xlYXJUaW1lb3V0KCksIHRoaXMuX2VsZW1lbnQuZGF0YXNldC50ZVRvYXN0U2hvdyAhPT0gdm9pZCAwICYmIHRoaXMuX2VsZW1lbnQucmVtb3ZlQXR0cmlidXRlKEZuKSwgc3VwZXIuZGlzcG9zZSgpO1xuICB9XG4gIC8vIFByaXZhdGVcbiAgX2luaXQoKSB7XG4gICAgdGhpcy5fZGlkSW5pdCB8fCAoY24oUm8pLCB0aGlzLl9kaWRJbml0ID0gITApO1xuICB9XG4gIF9nZXRDb25maWcodCkge1xuICAgIHJldHVybiB0ID0ge1xuICAgICAgLi4uRWEsXG4gICAgICAuLi5oLmdldERhdGFBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpLFxuICAgICAgLi4udHlwZW9mIHQgPT0gXCJvYmplY3RcIiAmJiB0ID8gdCA6IHt9XG4gICAgfSwgRChXbiwgdCwgdGhpcy5jb25zdHJ1Y3Rvci5EZWZhdWx0VHlwZSksIHQ7XG4gIH1cbiAgX2dldENsYXNzZXModCkge1xuICAgIGNvbnN0IGUgPSBoLmdldERhdGFDbGFzc0F0dHJpYnV0ZXModGhpcy5fZWxlbWVudCk7XG4gICAgcmV0dXJuIHQgPSB7XG4gICAgICAuLi5qXyxcbiAgICAgIC4uLmUsXG4gICAgICAuLi50XG4gICAgfSwgRChXbiwgdCwgS18pLCB0O1xuICB9XG4gIF9tYXliZVNjaGVkdWxlSGlkZSgpIHtcbiAgICB0aGlzLl9jb25maWcuYXV0b2hpZGUgJiYgKHRoaXMuX2hhc01vdXNlSW50ZXJhY3Rpb24gfHwgdGhpcy5faGFzS2V5Ym9hcmRJbnRlcmFjdGlvbiB8fCAodGhpcy5fdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5oaWRlKCk7XG4gICAgfSwgdGhpcy5fY29uZmlnLmRlbGF5KSkpO1xuICB9XG4gIF9vbkludGVyYWN0aW9uKHQsIGUpIHtcbiAgICBzd2l0Y2ggKHQudHlwZSkge1xuICAgICAgY2FzZSBcIm1vdXNlb3ZlclwiOlxuICAgICAgY2FzZSBcIm1vdXNlb3V0XCI6XG4gICAgICAgIHRoaXMuX2hhc01vdXNlSW50ZXJhY3Rpb24gPSBlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJmb2N1c2luXCI6XG4gICAgICBjYXNlIFwiZm9jdXNvdXRcIjpcbiAgICAgICAgdGhpcy5faGFzS2V5Ym9hcmRJbnRlcmFjdGlvbiA9IGU7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpZiAoZSkge1xuICAgICAgdGhpcy5fY2xlYXJUaW1lb3V0KCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGkgPSB0LnJlbGF0ZWRUYXJnZXQ7XG4gICAgdGhpcy5fZWxlbWVudCA9PT0gaSB8fCB0aGlzLl9lbGVtZW50LmNvbnRhaW5zKGkpIHx8IHRoaXMuX21heWJlU2NoZWR1bGVIaWRlKCk7XG4gIH1cbiAgX3NldExpc3RlbmVycygpIHtcbiAgICBjLm9uKFxuICAgICAgdGhpcy5fZWxlbWVudCxcbiAgICAgIE1fLFxuICAgICAgKHQpID0+IHRoaXMuX29uSW50ZXJhY3Rpb24odCwgITApXG4gICAgKSwgYy5vbihcbiAgICAgIHRoaXMuX2VsZW1lbnQsXG4gICAgICBSXyxcbiAgICAgICh0KSA9PiB0aGlzLl9vbkludGVyYWN0aW9uKHQsICExKVxuICAgICksIGMub24oXG4gICAgICB0aGlzLl9lbGVtZW50LFxuICAgICAgUF8sXG4gICAgICAodCkgPT4gdGhpcy5fb25JbnRlcmFjdGlvbih0LCAhMClcbiAgICApLCBjLm9uKFxuICAgICAgdGhpcy5fZWxlbWVudCxcbiAgICAgIEJfLFxuICAgICAgKHQpID0+IHRoaXMuX29uSW50ZXJhY3Rpb24odCwgITEpXG4gICAgKTtcbiAgfVxuICBfY2xlYXJUaW1lb3V0KCkge1xuICAgIGNsZWFyVGltZW91dCh0aGlzLl90aW1lb3V0KSwgdGhpcy5fdGltZW91dCA9IG51bGw7XG4gIH1cbiAgLy8gU3RhdGljXG4gIHN0YXRpYyBqUXVlcnlJbnRlcmZhY2UodCkge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICBjb25zdCBlID0gUm8uZ2V0T3JDcmVhdGVJbnN0YW5jZSh0aGlzLCB0KTtcbiAgICAgIGlmICh0eXBlb2YgdCA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZVt0XSA+IFwidVwiKVxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcIiR7dH1cImApO1xuICAgICAgICBlW3RdKHRoaXMpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG4oKCkgPT4ge1xuICB2YXIgcyA9IHsgNDU0OiAoaSwgbiwgbykgPT4ge1xuICAgIG8uZChuLCB7IFo6ICgpID0+IGwgfSk7XG4gICAgdmFyIHIgPSBvKDY0NSksIGEgPSBvLm4ocikoKShmdW5jdGlvbihwKSB7XG4gICAgICByZXR1cm4gcFsxXTtcbiAgICB9KTtcbiAgICBhLnB1c2goW2kuaWQsIFwiSU5QVVQ6LXdlYmtpdC1hdXRvZmlsbCxTRUxFQ1Q6LXdlYmtpdC1hdXRvZmlsbCxURVhUQVJFQTotd2Via2l0LWF1dG9maWxse2FuaW1hdGlvbi1uYW1lOm9uYXV0b2ZpbGxzdGFydH1JTlBVVDpub3QoOi13ZWJraXQtYXV0b2ZpbGwpLFNFTEVDVDpub3QoOi13ZWJraXQtYXV0b2ZpbGwpLFRFWFRBUkVBOm5vdCg6LXdlYmtpdC1hdXRvZmlsbCl7YW5pbWF0aW9uLW5hbWU6b25hdXRvZmlsbGNhbmNlbH1Aa2V5ZnJhbWVzIG9uYXV0b2ZpbGxzdGFydHt9QGtleWZyYW1lcyBvbmF1dG9maWxsY2FuY2Vse31cIiwgXCJcIl0pO1xuICAgIGNvbnN0IGwgPSBhO1xuICB9LCA2NDU6IChpKSA9PiB7XG4gICAgaS5leHBvcnRzID0gZnVuY3Rpb24obikge1xuICAgICAgdmFyIG8gPSBbXTtcbiAgICAgIHJldHVybiBvLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1hcChmdW5jdGlvbihyKSB7XG4gICAgICAgICAgdmFyIGEgPSBuKHIpO1xuICAgICAgICAgIHJldHVybiByWzJdID8gXCJAbWVkaWEgXCIuY29uY2F0KHJbMl0sIFwiIHtcIikuY29uY2F0KGEsIFwifVwiKSA6IGE7XG4gICAgICAgIH0pLmpvaW4oXCJcIik7XG4gICAgICB9LCBvLmkgPSBmdW5jdGlvbihyLCBhLCBsKSB7XG4gICAgICAgIHR5cGVvZiByID09IFwic3RyaW5nXCIgJiYgKHIgPSBbW251bGwsIHIsIFwiXCJdXSk7XG4gICAgICAgIHZhciBwID0ge307XG4gICAgICAgIGlmIChsKVxuICAgICAgICAgIGZvciAodmFyIHUgPSAwOyB1IDwgdGhpcy5sZW5ndGg7IHUrKykge1xuICAgICAgICAgICAgdmFyIF8gPSB0aGlzW3VdWzBdO1xuICAgICAgICAgICAgXyAhPSBudWxsICYmIChwW19dID0gITApO1xuICAgICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgZiA9IDA7IGYgPCByLmxlbmd0aDsgZisrKSB7XG4gICAgICAgICAgdmFyIGcgPSBbXS5jb25jYXQocltmXSk7XG4gICAgICAgICAgbCAmJiBwW2dbMF1dIHx8IChhICYmIChnWzJdID8gZ1syXSA9IFwiXCIuY29uY2F0KGEsIFwiIGFuZCBcIikuY29uY2F0KGdbMl0pIDogZ1syXSA9IGEpLCBvLnB1c2goZykpO1xuICAgICAgICB9XG4gICAgICB9LCBvO1xuICAgIH07XG4gIH0sIDgxMDogKCkgPT4ge1xuICAgIChmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0eXBlb2Ygd2luZG93IDwgXCJ1XCIpXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdmFyIGkgPSBuZXcgd2luZG93LkN1c3RvbUV2ZW50KFwidGVzdFwiLCB7IGNhbmNlbGFibGU6ICEwIH0pO1xuICAgICAgICAgIGlmIChpLnByZXZlbnREZWZhdWx0KCksIGkuZGVmYXVsdFByZXZlbnRlZCAhPT0gITApXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgcHJldmVudCBkZWZhdWx0XCIpO1xuICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICB2YXIgbiA9IGZ1bmN0aW9uKHIsIGEpIHtcbiAgICAgICAgICAgIHZhciBsLCBwO1xuICAgICAgICAgICAgcmV0dXJuIChhID0gYSB8fCB7fSkuYnViYmxlcyA9ICEhYS5idWJibGVzLCBhLmNhbmNlbGFibGUgPSAhIWEuY2FuY2VsYWJsZSwgKGwgPSBkb2N1bWVudC5jcmVhdGVFdmVudChcIkN1c3RvbUV2ZW50XCIpKS5pbml0Q3VzdG9tRXZlbnQociwgYS5idWJibGVzLCBhLmNhbmNlbGFibGUsIGEuZGV0YWlsKSwgcCA9IGwucHJldmVudERlZmF1bHQsIGwucHJldmVudERlZmF1bHQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgcC5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImRlZmF1bHRQcmV2ZW50ZWRcIiwgeyBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuICEwO1xuICAgICAgICAgICAgICAgIH0gfSk7XG4gICAgICAgICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgICAgICAgIHRoaXMuZGVmYXVsdFByZXZlbnRlZCA9ICEwO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBsO1xuICAgICAgICAgIH07XG4gICAgICAgICAgbi5wcm90b3R5cGUgPSB3aW5kb3cuRXZlbnQucHJvdG90eXBlLCB3aW5kb3cuQ3VzdG9tRXZlbnQgPSBuO1xuICAgICAgICB9XG4gICAgfSkoKTtcbiAgfSwgMzc5OiAoaSwgbiwgbykgPT4ge1xuICAgIHZhciByLCBhID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgRSA9IHt9O1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKFQpIHtcbiAgICAgICAgaWYgKEVbVF0gPT09IHZvaWQgMCkge1xuICAgICAgICAgIHZhciBBID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihUKTtcbiAgICAgICAgICBpZiAod2luZG93LkhUTUxJRnJhbWVFbGVtZW50ICYmIEEgaW5zdGFuY2VvZiB3aW5kb3cuSFRNTElGcmFtZUVsZW1lbnQpXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBBID0gQS5jb250ZW50RG9jdW1lbnQuaGVhZDtcbiAgICAgICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgICAgICBBID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBFW1RdID0gQTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gRVtUXTtcbiAgICAgIH07XG4gICAgfSgpLCBsID0gW107XG4gICAgZnVuY3Rpb24gcChFKSB7XG4gICAgICBmb3IgKHZhciBUID0gLTEsIEEgPSAwOyBBIDwgbC5sZW5ndGg7IEErKylcbiAgICAgICAgaWYgKGxbQV0uaWRlbnRpZmllciA9PT0gRSkge1xuICAgICAgICAgIFQgPSBBO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICByZXR1cm4gVDtcbiAgICB9XG4gICAgZnVuY3Rpb24gdShFLCBUKSB7XG4gICAgICBmb3IgKHZhciBBID0ge30sIGsgPSBbXSwgSSA9IDA7IEkgPCBFLmxlbmd0aDsgSSsrKSB7XG4gICAgICAgIHZhciBPID0gRVtJXSwgeCA9IFQuYmFzZSA/IE9bMF0gKyBULmJhc2UgOiBPWzBdLCBMID0gQVt4XSB8fCAwLCBTID0gXCJcIi5jb25jYXQoeCwgXCIgXCIpLmNvbmNhdChMKTtcbiAgICAgICAgQVt4XSA9IEwgKyAxO1xuICAgICAgICB2YXIgTiA9IHAoUyksIFAgPSB7IGNzczogT1sxXSwgbWVkaWE6IE9bMl0sIHNvdXJjZU1hcDogT1szXSB9O1xuICAgICAgICBOICE9PSAtMSA/IChsW05dLnJlZmVyZW5jZXMrKywgbFtOXS51cGRhdGVyKFApKSA6IGwucHVzaCh7IGlkZW50aWZpZXI6IFMsIHVwZGF0ZXI6IHcoUCwgVCksIHJlZmVyZW5jZXM6IDEgfSksIGsucHVzaChTKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBrO1xuICAgIH1cbiAgICBmdW5jdGlvbiBfKEUpIHtcbiAgICAgIHZhciBUID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpLCBBID0gRS5hdHRyaWJ1dGVzIHx8IHt9O1xuICAgICAgaWYgKEEubm9uY2UgPT09IHZvaWQgMCkge1xuICAgICAgICB2YXIgayA9IG8ubmM7XG4gICAgICAgIGsgJiYgKEEubm9uY2UgPSBrKTtcbiAgICAgIH1cbiAgICAgIGlmIChPYmplY3Qua2V5cyhBKS5mb3JFYWNoKGZ1bmN0aW9uKE8pIHtcbiAgICAgICAgVC5zZXRBdHRyaWJ1dGUoTywgQVtPXSk7XG4gICAgICB9KSwgdHlwZW9mIEUuaW5zZXJ0ID09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgRS5pbnNlcnQoVCk7XG4gICAgICBlbHNlIHtcbiAgICAgICAgdmFyIEkgPSBhKEUuaW5zZXJ0IHx8IFwiaGVhZFwiKTtcbiAgICAgICAgaWYgKCFJKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkbid0IGZpbmQgYSBzdHlsZSB0YXJnZXQuIFRoaXMgcHJvYmFibHkgbWVhbnMgdGhhdCB0aGUgdmFsdWUgZm9yIHRoZSAnaW5zZXJ0JyBwYXJhbWV0ZXIgaXMgaW52YWxpZC5cIik7XG4gICAgICAgIEkuYXBwZW5kQ2hpbGQoVCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gVDtcbiAgICB9XG4gICAgdmFyIGYsIGcgPSAoZiA9IFtdLCBmdW5jdGlvbihFLCBUKSB7XG4gICAgICByZXR1cm4gZltFXSA9IFQsIGYuZmlsdGVyKEJvb2xlYW4pLmpvaW4oYFxuYCk7XG4gICAgfSk7XG4gICAgZnVuY3Rpb24gbShFLCBULCBBLCBrKSB7XG4gICAgICB2YXIgSSA9IEEgPyBcIlwiIDogay5tZWRpYSA/IFwiQG1lZGlhIFwiLmNvbmNhdChrLm1lZGlhLCBcIiB7XCIpLmNvbmNhdChrLmNzcywgXCJ9XCIpIDogay5jc3M7XG4gICAgICBpZiAoRS5zdHlsZVNoZWV0KVxuICAgICAgICBFLnN0eWxlU2hlZXQuY3NzVGV4dCA9IGcoVCwgSSk7XG4gICAgICBlbHNlIHtcbiAgICAgICAgdmFyIE8gPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShJKSwgeCA9IEUuY2hpbGROb2RlcztcbiAgICAgICAgeFtUXSAmJiBFLnJlbW92ZUNoaWxkKHhbVF0pLCB4Lmxlbmd0aCA/IEUuaW5zZXJ0QmVmb3JlKE8sIHhbVF0pIDogRS5hcHBlbmRDaGlsZChPKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gYihFLCBULCBBKSB7XG4gICAgICB2YXIgayA9IEEuY3NzLCBJID0gQS5tZWRpYSwgTyA9IEEuc291cmNlTWFwO1xuICAgICAgaWYgKEkgPyBFLnNldEF0dHJpYnV0ZShcIm1lZGlhXCIsIEkpIDogRS5yZW1vdmVBdHRyaWJ1dGUoXCJtZWRpYVwiKSwgTyAmJiB0eXBlb2YgYnRvYSA8IFwidVwiICYmIChrICs9IGBcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsYC5jb25jYXQoYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoTykpKSksIFwiICovXCIpKSwgRS5zdHlsZVNoZWV0KVxuICAgICAgICBFLnN0eWxlU2hlZXQuY3NzVGV4dCA9IGs7XG4gICAgICBlbHNlIHtcbiAgICAgICAgZm9yICg7IEUuZmlyc3RDaGlsZDsgKVxuICAgICAgICAgIEUucmVtb3ZlQ2hpbGQoRS5maXJzdENoaWxkKTtcbiAgICAgICAgRS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShrKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciB2ID0gbnVsbCwgQyA9IDA7XG4gICAgZnVuY3Rpb24gdyhFLCBUKSB7XG4gICAgICB2YXIgQSwgaywgSTtcbiAgICAgIGlmIChULnNpbmdsZXRvbikge1xuICAgICAgICB2YXIgTyA9IEMrKztcbiAgICAgICAgQSA9IHYgfHwgKHYgPSBfKFQpKSwgayA9IG0uYmluZChudWxsLCBBLCBPLCAhMSksIEkgPSBtLmJpbmQobnVsbCwgQSwgTywgITApO1xuICAgICAgfSBlbHNlXG4gICAgICAgIEEgPSBfKFQpLCBrID0gYi5iaW5kKG51bGwsIEEsIFQpLCBJID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgKGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgICAgIGlmICh4LnBhcmVudE5vZGUgPT09IG51bGwpXG4gICAgICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgICAgICAgIHgucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh4KTtcbiAgICAgICAgICB9KShBKTtcbiAgICAgICAgfTtcbiAgICAgIHJldHVybiBrKEUpLCBmdW5jdGlvbih4KSB7XG4gICAgICAgIGlmICh4KSB7XG4gICAgICAgICAgaWYgKHguY3NzID09PSBFLmNzcyAmJiB4Lm1lZGlhID09PSBFLm1lZGlhICYmIHguc291cmNlTWFwID09PSBFLnNvdXJjZU1hcClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICBrKEUgPSB4KTtcbiAgICAgICAgfSBlbHNlXG4gICAgICAgICAgSSgpO1xuICAgICAgfTtcbiAgICB9XG4gICAgaS5leHBvcnRzID0gZnVuY3Rpb24oRSwgVCkge1xuICAgICAgKFQgPSBUIHx8IHt9KS5zaW5nbGV0b24gfHwgdHlwZW9mIFQuc2luZ2xldG9uID09IFwiYm9vbGVhblwiIHx8IChULnNpbmdsZXRvbiA9IChyID09PSB2b2lkIDAgJiYgKHIgPSAhISh3aW5kb3cgJiYgZG9jdW1lbnQgJiYgZG9jdW1lbnQuYWxsICYmICF3aW5kb3cuYXRvYikpLCByKSk7XG4gICAgICB2YXIgQSA9IHUoRSA9IEUgfHwgW10sIFQpO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGspIHtcbiAgICAgICAgaWYgKGsgPSBrIHx8IFtdLCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaykgPT09IFwiW29iamVjdCBBcnJheV1cIikge1xuICAgICAgICAgIGZvciAodmFyIEkgPSAwOyBJIDwgQS5sZW5ndGg7IEkrKykge1xuICAgICAgICAgICAgdmFyIE8gPSBwKEFbSV0pO1xuICAgICAgICAgICAgbFtPXS5yZWZlcmVuY2VzLS07XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAodmFyIHggPSB1KGssIFQpLCBMID0gMDsgTCA8IEEubGVuZ3RoOyBMKyspIHtcbiAgICAgICAgICAgIHZhciBTID0gcChBW0xdKTtcbiAgICAgICAgICAgIGxbU10ucmVmZXJlbmNlcyA9PT0gMCAmJiAobFtTXS51cGRhdGVyKCksIGwuc3BsaWNlKFMsIDEpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgQSA9IHg7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfTtcbiAgfSB9LCB0ID0ge307XG4gIGZ1bmN0aW9uIGUoaSkge1xuICAgIHZhciBuID0gdFtpXTtcbiAgICBpZiAobiAhPT0gdm9pZCAwKVxuICAgICAgcmV0dXJuIG4uZXhwb3J0cztcbiAgICB2YXIgbyA9IHRbaV0gPSB7IGlkOiBpLCBleHBvcnRzOiB7fSB9O1xuICAgIHJldHVybiBzW2ldKG8sIG8uZXhwb3J0cywgZSksIG8uZXhwb3J0cztcbiAgfVxuICBlLm4gPSAoaSkgPT4ge1xuICAgIHZhciBuID0gaSAmJiBpLl9fZXNNb2R1bGUgPyAoKSA9PiBpLmRlZmF1bHQgOiAoKSA9PiBpO1xuICAgIHJldHVybiBlLmQobiwgeyBhOiBuIH0pLCBuO1xuICB9LCBlLmQgPSAoaSwgbikgPT4ge1xuICAgIGZvciAodmFyIG8gaW4gbilcbiAgICAgIGUubyhuLCBvKSAmJiAhZS5vKGksIG8pICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShpLCBvLCB7IGVudW1lcmFibGU6ICEwLCBnZXQ6IG5bb10gfSk7XG4gIH0sIGUubyA9IChpLCBuKSA9PiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoaSwgbiksICgoKSA9PiB7XG4gICAgdmFyIGkgPSBlKDM3OSksIG4gPSBlLm4oaSksIG8gPSBlKDQ1NCk7XG4gICAgZnVuY3Rpb24gcihsKSB7XG4gICAgICBpZiAoIWwuaGFzQXR0cmlidXRlKFwiYXV0b2NvbXBsZXRlZFwiKSkge1xuICAgICAgICBsLnNldEF0dHJpYnV0ZShcImF1dG9jb21wbGV0ZWRcIiwgXCJcIik7XG4gICAgICAgIHZhciBwID0gbmV3IHdpbmRvdy5DdXN0b21FdmVudChcIm9uYXV0b2NvbXBsZXRlXCIsIHsgYnViYmxlczogITAsIGNhbmNlbGFibGU6ICEwLCBkZXRhaWw6IG51bGwgfSk7XG4gICAgICAgIGwuZGlzcGF0Y2hFdmVudChwKSB8fCAobC52YWx1ZSA9IFwiXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBhKGwpIHtcbiAgICAgIGwuaGFzQXR0cmlidXRlKFwiYXV0b2NvbXBsZXRlZFwiKSAmJiAobC5yZW1vdmVBdHRyaWJ1dGUoXCJhdXRvY29tcGxldGVkXCIpLCBsLmRpc3BhdGNoRXZlbnQobmV3IHdpbmRvdy5DdXN0b21FdmVudChcIm9uYXV0b2NvbXBsZXRlXCIsIHsgYnViYmxlczogITAsIGNhbmNlbGFibGU6ICExLCBkZXRhaWw6IG51bGwgfSkpKTtcbiAgICB9XG4gICAgbigpKG8uWiwgeyBpbnNlcnQ6IFwiaGVhZFwiLCBzaW5nbGV0b246ICExIH0pLCBvLloubG9jYWxzLCBlKDgxMCksIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJhbmltYXRpb25zdGFydFwiLCBmdW5jdGlvbihsKSB7XG4gICAgICBsLmFuaW1hdGlvbk5hbWUgPT09IFwib25hdXRvZmlsbHN0YXJ0XCIgPyByKGwudGFyZ2V0KSA6IGEobC50YXJnZXQpO1xuICAgIH0sICEwKSwgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImlucHV0XCIsIGZ1bmN0aW9uKGwpIHtcbiAgICAgIGwuaW5wdXRUeXBlICE9PSBcImluc2VydFJlcGxhY2VtZW50VGV4dFwiICYmIFwiZGF0YVwiIGluIGwgPyBhKGwudGFyZ2V0KSA6IHIobC50YXJnZXQpO1xuICAgIH0sICEwKTtcbiAgfSkoKTtcbn0pKCk7XG5jb25zdCBZbiA9IFwiaW5wdXRcIiwgb3MgPSBcInRlLmlucHV0XCIsIFdjID0gXCJkYXRhLXRlLWlucHV0LXdyYXBwZXItaW5pdFwiLCBGYyA9IFwiZGF0YS10ZS1pbnB1dC1ub3RjaC1yZWZcIiwgWWMgPSBcImRhdGEtdGUtaW5wdXQtbm90Y2gtbGVhZGluZy1yZWZcIiwgamMgPSBcImRhdGEtdGUtaW5wdXQtbm90Y2gtbWlkZGxlLXJlZlwiLCB6XyA9IFwiZGF0YS10ZS1pbnB1dC1ub3RjaC10cmFpbGluZy1yZWZcIiwgVV8gPSBcImRhdGEtdGUtaW5wdXQtaGVscGVyLXJlZlwiLCBYXyA9IFwiZGF0YS10ZS1pbnB1dC1wbGFjZWhvbGRlci1hY3RpdmVcIiwgRnQgPSBcImRhdGEtdGUtaW5wdXQtc3RhdGUtYWN0aXZlXCIsIENhID0gXCJkYXRhLXRlLWlucHV0LWZvY3VzZWRcIiwgQWEgPSBcImRhdGEtdGUtaW5wdXQtZm9ybS1jb3VudGVyXCIsIGRlID0gYFske1djfV0gaW5wdXRgLCB1ZSA9IGBbJHtXY31dIHRleHRhcmVhYCwga2UgPSBgWyR7RmN9XWAsIHlhID0gYFske1ljfV1gLCB3YSA9IGBbJHtqY31dYCwgR18gPSBgWyR7VV99XWAsIHFfID0ge1xuICBpbnB1dEZvcm1XaGl0ZTogITFcbn0sIFpfID0ge1xuICBpbnB1dEZvcm1XaGl0ZTogXCIoYm9vbGVhbilcIlxufSwgS2MgPSB7XG4gIG5vdGNoOiBcImdyb3VwIGZsZXggYWJzb2x1dGUgbGVmdC0wIHRvcC0wIHctZnVsbCBtYXgtdy1mdWxsIGgtZnVsbCB0ZXh0LWxlZnQgcG9pbnRlci1ldmVudHMtbm9uZVwiLFxuICBub3RjaExlYWRpbmc6IFwicG9pbnRlci1ldmVudHMtbm9uZSBib3JkZXIgYm9yZGVyLXNvbGlkIGJveC1ib3JkZXIgYmctdHJhbnNwYXJlbnQgdHJhbnNpdGlvbi1hbGwgZHVyYXRpb24tMjAwIGVhc2UtbGluZWFyIG1vdGlvbi1yZWR1Y2U6dHJhbnNpdGlvbi1ub25lIGxlZnQtMCB0b3AtMCBoLWZ1bGwgdy0yIGJvcmRlci1yLTAgcm91bmRlZC1sLVswLjI1cmVtXSBncm91cC1kYXRhLVt0ZS1pbnB1dC1mb2N1c2VkXTpib3JkZXItci0wIGdyb3VwLWRhdGEtW3RlLWlucHV0LXN0YXRlLWFjdGl2ZV06Ym9yZGVyLXItMFwiLFxuICBub3RjaExlYWRpbmdOb3JtYWw6IFwiYm9yZGVyLW5ldXRyYWwtMzAwIGRhcms6Ym9yZGVyLW5ldXRyYWwtNjAwIGdyb3VwLWRhdGEtW3RlLWlucHV0LWZvY3VzZWRdOnNoYWRvdy1bLTFweF8wXzBfIzNiNzFjYSxfMF8xcHhfMF8wXyMzYjcxY2EsXzBfLTFweF8wXzBfIzNiNzFjYV0gZ3JvdXAtZGF0YS1bdGUtaW5wdXQtZm9jdXNlZF06Ym9yZGVyLXByaW1hcnlcIixcbiAgbm90Y2hMZWFkaW5nV2hpdGU6IFwiYm9yZGVyLW5ldXRyYWwtMjAwIGdyb3VwLWRhdGEtW3RlLWlucHV0LWZvY3VzZWRdOnNoYWRvdy1bLTFweF8wXzBfI2ZmZmZmZixfMF8xcHhfMF8wXyNmZmZmZmYsXzBfLTFweF8wXzBfI2ZmZmZmZl0gZ3JvdXAtZGF0YS1bdGUtaW5wdXQtZm9jdXNlZF06Ym9yZGVyLXdoaXRlXCIsXG4gIG5vdGNoTWlkZGxlOiBcInBvaW50ZXItZXZlbnRzLW5vbmUgYm9yZGVyIGJvcmRlci1zb2xpZCBib3gtYm9yZGVyIGJnLXRyYW5zcGFyZW50IHRyYW5zaXRpb24tYWxsIGR1cmF0aW9uLTIwMCBlYXNlLWxpbmVhciBtb3Rpb24tcmVkdWNlOnRyYW5zaXRpb24tbm9uZSBncm93LTAgc2hyaW5rLTAgYmFzaXMtYXV0byB3LWF1dG8gbWF4LXctW2NhbGMoMTAwJS0xcmVtKV0gaC1mdWxsIGJvcmRlci1yLTAgYm9yZGVyLWwtMCBncm91cC1kYXRhLVt0ZS1pbnB1dC1mb2N1c2VkXTpib3JkZXIteC0wIGdyb3VwLWRhdGEtW3RlLWlucHV0LXN0YXRlLWFjdGl2ZV06Ym9yZGVyLXgtMCBncm91cC1kYXRhLVt0ZS1pbnB1dC1mb2N1c2VkXTpib3JkZXItdCBncm91cC1kYXRhLVt0ZS1pbnB1dC1zdGF0ZS1hY3RpdmVdOmJvcmRlci10IGdyb3VwLWRhdGEtW3RlLWlucHV0LWZvY3VzZWRdOmJvcmRlci1zb2xpZCBncm91cC1kYXRhLVt0ZS1pbnB1dC1zdGF0ZS1hY3RpdmVdOmJvcmRlci1zb2xpZCBncm91cC1kYXRhLVt0ZS1pbnB1dC1mb2N1c2VkXTpib3JkZXItdC10cmFuc3BhcmVudCBncm91cC1kYXRhLVt0ZS1pbnB1dC1zdGF0ZS1hY3RpdmVdOmJvcmRlci10LXRyYW5zcGFyZW50XCIsXG4gIG5vdGNoTWlkZGxlTm9ybWFsOiBcImJvcmRlci1uZXV0cmFsLTMwMCBkYXJrOmJvcmRlci1uZXV0cmFsLTYwMCBncm91cC1kYXRhLVt0ZS1pbnB1dC1mb2N1c2VkXTpzaGFkb3ctWzBfMXB4XzBfMF8jM2I3MWNhXSBncm91cC1kYXRhLVt0ZS1pbnB1dC1mb2N1c2VkXTpib3JkZXItcHJpbWFyeVwiLFxuICBub3RjaE1pZGRsZVdoaXRlOiBcImJvcmRlci1uZXV0cmFsLTIwMCBncm91cC1kYXRhLVt0ZS1pbnB1dC1mb2N1c2VkXTpzaGFkb3ctWzBfMXB4XzBfMF8jZmZmZmZmXSBncm91cC1kYXRhLVt0ZS1pbnB1dC1mb2N1c2VkXTpib3JkZXItd2hpdGVcIixcbiAgbm90Y2hUcmFpbGluZzogXCJwb2ludGVyLWV2ZW50cy1ub25lIGJvcmRlciBib3JkZXItc29saWQgYm94LWJvcmRlciBiZy10cmFuc3BhcmVudCB0cmFuc2l0aW9uLWFsbCBkdXJhdGlvbi0yMDAgZWFzZS1saW5lYXIgbW90aW9uLXJlZHVjZTp0cmFuc2l0aW9uLW5vbmUgZ3JvdyBoLWZ1bGwgYm9yZGVyLWwtMCByb3VuZGVkLXItWzAuMjVyZW1dIGdyb3VwLWRhdGEtW3RlLWlucHV0LWZvY3VzZWRdOmJvcmRlci1sLTAgZ3JvdXAtZGF0YS1bdGUtaW5wdXQtc3RhdGUtYWN0aXZlXTpib3JkZXItbC0wXCIsXG4gIG5vdGNoVHJhaWxpbmdOb3JtYWw6IFwiYm9yZGVyLW5ldXRyYWwtMzAwIGRhcms6Ym9yZGVyLW5ldXRyYWwtNjAwIGdyb3VwLWRhdGEtW3RlLWlucHV0LWZvY3VzZWRdOnNoYWRvdy1bMXB4XzBfMF8jM2I3MWNhLF8wXy0xcHhfMF8wXyMzYjcxY2EsXzBfMXB4XzBfMF8jM2I3MWNhXSBncm91cC1kYXRhLVt0ZS1pbnB1dC1mb2N1c2VkXTpib3JkZXItcHJpbWFyeVwiLFxuICBub3RjaFRyYWlsaW5nV2hpdGU6IFwiYm9yZGVyLW5ldXRyYWwtMjAwIGdyb3VwLWRhdGEtW3RlLWlucHV0LWZvY3VzZWRdOnNoYWRvdy1bMXB4XzBfMF8jZmZmZmZmLF8wXy0xcHhfMF8wXyNmZmZmZmYsXzBfMXB4XzBfMF8jZmZmZmZmXSBncm91cC1kYXRhLVt0ZS1pbnB1dC1mb2N1c2VkXTpib3JkZXItd2hpdGVcIixcbiAgY291bnRlcjogXCJ0ZXh0LXJpZ2h0IGxlYWRpbmctWzEuNl1cIlxufSwgUV8gPSB7XG4gIG5vdGNoOiBcInN0cmluZ1wiLFxuICBub3RjaExlYWRpbmc6IFwic3RyaW5nXCIsXG4gIG5vdGNoTGVhZGluZ05vcm1hbDogXCJzdHJpbmdcIixcbiAgbm90Y2hMZWFkaW5nV2hpdGU6IFwic3RyaW5nXCIsXG4gIG5vdGNoTWlkZGxlOiBcInN0cmluZ1wiLFxuICBub3RjaE1pZGRsZU5vcm1hbDogXCJzdHJpbmdcIixcbiAgbm90Y2hNaWRkbGVXaGl0ZTogXCJzdHJpbmdcIixcbiAgbm90Y2hUcmFpbGluZzogXCJzdHJpbmdcIixcbiAgbm90Y2hUcmFpbGluZ05vcm1hbDogXCJzdHJpbmdcIixcbiAgbm90Y2hUcmFpbGluZ1doaXRlOiBcInN0cmluZ1wiLFxuICBjb3VudGVyOiBcInN0cmluZ1wiXG59O1xuY2xhc3MgViB7XG4gIGNvbnN0cnVjdG9yKHQsIGUsIGkpIHtcbiAgICB0aGlzLl9jb25maWcgPSB0aGlzLl9nZXRDb25maWcoZSwgdCksIHRoaXMuX2VsZW1lbnQgPSB0LCB0aGlzLl9jbGFzc2VzID0gdGhpcy5fZ2V0Q2xhc3NlcyhpKSwgdGhpcy5fbGFiZWwgPSBudWxsLCB0aGlzLl9sYWJlbFdpZHRoID0gMCwgdGhpcy5fbGFiZWxNYXJnaW5MZWZ0ID0gMCwgdGhpcy5fbm90Y2hMZWFkaW5nID0gbnVsbCwgdGhpcy5fbm90Y2hNaWRkbGUgPSBudWxsLCB0aGlzLl9ub3RjaFRyYWlsaW5nID0gbnVsbCwgdGhpcy5faW5pdGlhdGVkID0gITEsIHRoaXMuX2hlbHBlciA9IG51bGwsIHRoaXMuX2NvdW50ZXIgPSAhMSwgdGhpcy5fY291bnRlckVsZW1lbnQgPSBudWxsLCB0aGlzLl9tYXhMZW5ndGggPSAwLCB0aGlzLl9sZWFkaW5nSWNvbiA9IG51bGwsIHRoaXMuX2VsZW1lbnQgJiYgKHkuc2V0RGF0YSh0LCBvcywgdGhpcyksIHRoaXMuaW5pdCgpKTtcbiAgfVxuICAvLyBHZXR0ZXJzXG4gIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICByZXR1cm4gWW47XG4gIH1cbiAgZ2V0IGlucHV0KCkge1xuICAgIHJldHVybiBkLmZpbmRPbmUoXCJpbnB1dFwiLCB0aGlzLl9lbGVtZW50KSB8fCBkLmZpbmRPbmUoXCJ0ZXh0YXJlYVwiLCB0aGlzLl9lbGVtZW50KTtcbiAgfVxuICAvLyBQdWJsaWNcbiAgaW5pdCgpIHtcbiAgICB0aGlzLl9pbml0aWF0ZWQgfHwgKHRoaXMuX2dldExhYmVsRGF0YSgpLCB0aGlzLl9hcHBseURpdnMoKSwgdGhpcy5fYXBwbHlOb3RjaCgpLCB0aGlzLl9hY3RpdmF0ZSgpLCB0aGlzLl9nZXRIZWxwZXIoKSwgdGhpcy5fZ2V0Q291bnRlcigpLCB0aGlzLl9nZXRFdmVudHMoKSwgdGhpcy5faW5pdGlhdGVkID0gITApO1xuICB9XG4gIHVwZGF0ZSgpIHtcbiAgICB0aGlzLl9nZXRMYWJlbERhdGEoKSwgdGhpcy5fZ2V0Tm90Y2hEYXRhKCksIHRoaXMuX2FwcGx5Tm90Y2goKSwgdGhpcy5fYWN0aXZhdGUoKSwgdGhpcy5fZ2V0SGVscGVyKCksIHRoaXMuX2dldENvdW50ZXIoKTtcbiAgfVxuICBmb3JjZUFjdGl2ZSgpIHtcbiAgICB0aGlzLmlucHV0LnNldEF0dHJpYnV0ZShGdCwgXCJcIiksIGQuZmluZE9uZShrZSwgdGhpcy5pbnB1dC5wYXJlbnROb2RlKS5zZXRBdHRyaWJ1dGUoXG4gICAgICBGdCxcbiAgICAgIFwiXCJcbiAgICApO1xuICB9XG4gIGZvcmNlSW5hY3RpdmUoKSB7XG4gICAgdGhpcy5pbnB1dC5yZW1vdmVBdHRyaWJ1dGUoRnQpLCBkLmZpbmRPbmUoXG4gICAgICBrZSxcbiAgICAgIHRoaXMuaW5wdXQucGFyZW50Tm9kZVxuICAgICkucmVtb3ZlQXR0cmlidXRlKEZ0KTtcbiAgfVxuICBkaXNwb3NlKCkge1xuICAgIHRoaXMuX3JlbW92ZUJvcmRlcigpLCB5LnJlbW92ZURhdGEodGhpcy5fZWxlbWVudCwgb3MpLCB0aGlzLl9lbGVtZW50ID0gbnVsbDtcbiAgfVxuICAvLyBQcml2YXRlXG4gIF9nZXRDb25maWcodCwgZSkge1xuICAgIHJldHVybiB0ID0ge1xuICAgICAgLi4ucV8sXG4gICAgICAuLi5oLmdldERhdGFBdHRyaWJ1dGVzKGUpLFxuICAgICAgLi4udHlwZW9mIHQgPT0gXCJvYmplY3RcIiA/IHQgOiB7fVxuICAgIH0sIEQoWW4sIHQsIFpfKSwgdDtcbiAgfVxuICBfZ2V0Q2xhc3Nlcyh0KSB7XG4gICAgY29uc3QgZSA9IGguZ2V0RGF0YUNsYXNzQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KTtcbiAgICByZXR1cm4gdCA9IHtcbiAgICAgIC4uLktjLFxuICAgICAgLi4uZSxcbiAgICAgIC4uLnRcbiAgICB9LCBEKFluLCB0LCBRXyksIHQ7XG4gIH1cbiAgX2dldExhYmVsRGF0YSgpIHtcbiAgICB0aGlzLl9sYWJlbCA9IGQuZmluZE9uZShcImxhYmVsXCIsIHRoaXMuX2VsZW1lbnQpLCB0aGlzLl9sYWJlbCA9PT0gbnVsbCA/IHRoaXMuX3Nob3dQbGFjZWhvbGRlcigpIDogKHRoaXMuX2dldExhYmVsV2lkdGgoKSwgdGhpcy5fZ2V0TGFiZWxQb3NpdGlvbkluSW5wdXRHcm91cCgpLCB0aGlzLl90b2dnbGVEZWZhdWx0RGF0ZVBsYWNlaG9sZGVyKCkpO1xuICB9XG4gIF9nZXRIZWxwZXIoKSB7XG4gICAgdGhpcy5faGVscGVyID0gZC5maW5kT25lKEdfLCB0aGlzLl9lbGVtZW50KTtcbiAgfVxuICBfZ2V0Q291bnRlcigpIHtcbiAgICB0aGlzLl9jb3VudGVyID0gaC5nZXREYXRhQXR0cmlidXRlKFxuICAgICAgdGhpcy5pbnB1dCxcbiAgICAgIFwiaW5wdXRTaG93Y291bnRlclwiXG4gICAgKSwgdGhpcy5fY291bnRlciAmJiAodGhpcy5fbWF4TGVuZ3RoID0gdGhpcy5pbnB1dC5tYXhMZW5ndGgsIHRoaXMuX3Nob3dDb3VudGVyKCkpO1xuICB9XG4gIF9nZXRFdmVudHMoKSB7XG4gICAgYy5vbihcbiAgICAgIGRvY3VtZW50LFxuICAgICAgXCJmb2N1c1wiLFxuICAgICAgZGUsXG4gICAgICBWLmFjdGl2YXRlKG5ldyBWKCkpXG4gICAgKSwgYy5vbihcbiAgICAgIGRvY3VtZW50LFxuICAgICAgXCJpbnB1dFwiLFxuICAgICAgZGUsXG4gICAgICBWLmFjdGl2YXRlKG5ldyBWKCkpXG4gICAgKSwgYy5vbihcbiAgICAgIGRvY3VtZW50LFxuICAgICAgXCJibHVyXCIsXG4gICAgICBkZSxcbiAgICAgIFYuZGVhY3RpdmF0ZShuZXcgVigpKVxuICAgICksIGMub24oXG4gICAgICBkb2N1bWVudCxcbiAgICAgIFwiZm9jdXNcIixcbiAgICAgIHVlLFxuICAgICAgVi5hY3RpdmF0ZShuZXcgVigpKVxuICAgICksIGMub24oXG4gICAgICBkb2N1bWVudCxcbiAgICAgIFwiaW5wdXRcIixcbiAgICAgIHVlLFxuICAgICAgVi5hY3RpdmF0ZShuZXcgVigpKVxuICAgICksIGMub24oXG4gICAgICBkb2N1bWVudCxcbiAgICAgIFwiYmx1clwiLFxuICAgICAgdWUsXG4gICAgICBWLmRlYWN0aXZhdGUobmV3IFYoKSlcbiAgICApLCBjLm9uKHdpbmRvdywgXCJzaG93bi50ZS5tb2RhbFwiLCAodCkgPT4ge1xuICAgICAgZC5maW5kKGRlLCB0LnRhcmdldCkuZm9yRWFjaChcbiAgICAgICAgKGUpID0+IHtcbiAgICAgICAgICBjb25zdCBpID0gVi5nZXRJbnN0YW5jZShlLnBhcmVudE5vZGUpO1xuICAgICAgICAgIGkgJiYgaS51cGRhdGUoKTtcbiAgICAgICAgfVxuICAgICAgKSwgZC5maW5kKHVlLCB0LnRhcmdldCkuZm9yRWFjaChcbiAgICAgICAgKGUpID0+IHtcbiAgICAgICAgICBjb25zdCBpID0gVi5nZXRJbnN0YW5jZShlLnBhcmVudE5vZGUpO1xuICAgICAgICAgIGkgJiYgaS51cGRhdGUoKTtcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9KSwgYy5vbih3aW5kb3csIFwic2hvd24udGUuZHJvcGRvd25cIiwgKHQpID0+IHtcbiAgICAgIGNvbnN0IGUgPSB0LnRhcmdldC5wYXJlbnROb2RlLnF1ZXJ5U2VsZWN0b3IoXG4gICAgICAgIFwiW2RhdGEtdGUtZHJvcGRvd24tbWVudS1yZWZdXCJcbiAgICAgICk7XG4gICAgICBlICYmIChkLmZpbmQoZGUsIGUpLmZvckVhY2goXG4gICAgICAgIChpKSA9PiB7XG4gICAgICAgICAgY29uc3QgbiA9IFYuZ2V0SW5zdGFuY2UoaS5wYXJlbnROb2RlKTtcbiAgICAgICAgICBuICYmIG4udXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICAgICksIGQuZmluZCh1ZSwgZSkuZm9yRWFjaChcbiAgICAgICAgKGkpID0+IHtcbiAgICAgICAgICBjb25zdCBuID0gVi5nZXRJbnN0YW5jZShpLnBhcmVudE5vZGUpO1xuICAgICAgICAgIG4gJiYgbi51cGRhdGUoKTtcbiAgICAgICAgfVxuICAgICAgKSk7XG4gICAgfSksIGMub24od2luZG93LCBcInNob3duLnRlLnRhYlwiLCAodCkgPT4ge1xuICAgICAgbGV0IGU7XG4gICAgICB0LnRhcmdldC5ocmVmID8gZSA9IHQudGFyZ2V0LmhyZWYuc3BsaXQoXCIjXCIpWzFdIDogZSA9IGguZ2V0RGF0YUF0dHJpYnV0ZSh0LnRhcmdldCwgXCJ0YXJnZXRcIikuc3BsaXQoXG4gICAgICAgIFwiI1wiXG4gICAgICApWzFdO1xuICAgICAgY29uc3QgaSA9IGQuZmluZE9uZShgIyR7ZX1gKTtcbiAgICAgIGQuZmluZChkZSwgaSkuZm9yRWFjaCgobikgPT4ge1xuICAgICAgICBjb25zdCBvID0gVi5nZXRJbnN0YW5jZShuLnBhcmVudE5vZGUpO1xuICAgICAgICBvICYmIG8udXBkYXRlKCk7XG4gICAgICB9KSwgZC5maW5kKHVlLCBpKS5mb3JFYWNoKFxuICAgICAgICAobikgPT4ge1xuICAgICAgICAgIGNvbnN0IG8gPSBWLmdldEluc3RhbmNlKG4ucGFyZW50Tm9kZSk7XG4gICAgICAgICAgbyAmJiBvLnVwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgICApO1xuICAgIH0pLCBjLm9uKHdpbmRvdywgXCJyZXNldFwiLCAodCkgPT4ge1xuICAgICAgZC5maW5kKGRlLCB0LnRhcmdldCkuZm9yRWFjaChcbiAgICAgICAgKGUpID0+IHtcbiAgICAgICAgICBjb25zdCBpID0gVi5nZXRJbnN0YW5jZShlLnBhcmVudE5vZGUpO1xuICAgICAgICAgIGkgJiYgaS5mb3JjZUluYWN0aXZlKCk7XG4gICAgICAgIH1cbiAgICAgICksIGQuZmluZCh1ZSwgdC50YXJnZXQpLmZvckVhY2goXG4gICAgICAgIChlKSA9PiB7XG4gICAgICAgICAgY29uc3QgaSA9IFYuZ2V0SW5zdGFuY2UoZS5wYXJlbnROb2RlKTtcbiAgICAgICAgICBpICYmIGkuZm9yY2VJbmFjdGl2ZSgpO1xuICAgICAgICB9XG4gICAgICApO1xuICAgIH0pLCBjLm9uKHdpbmRvdywgXCJvbmF1dG9jb21wbGV0ZVwiLCAodCkgPT4ge1xuICAgICAgY29uc3QgZSA9IFYuZ2V0SW5zdGFuY2UodC50YXJnZXQucGFyZW50Tm9kZSk7XG4gICAgICAhZSB8fCAhdC5jYW5jZWxhYmxlIHx8IGUuZm9yY2VBY3RpdmUoKTtcbiAgICB9KTtcbiAgfVxuICBfc2hvd0NvdW50ZXIoKSB7XG4gICAgaWYgKGQuZmluZChcbiAgICAgIGBbJHtBYX1dYCxcbiAgICAgIHRoaXMuX2VsZW1lbnRcbiAgICApLmxlbmd0aCA+IDApXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5fY291bnRlckVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLCBoLmFkZENsYXNzKHRoaXMuX2NvdW50ZXJFbGVtZW50LCB0aGlzLl9jbGFzc2VzLmNvdW50ZXIpLCB0aGlzLl9jb3VudGVyRWxlbWVudC5zZXRBdHRyaWJ1dGUoQWEsIFwiXCIpO1xuICAgIGNvbnN0IGUgPSB0aGlzLmlucHV0LnZhbHVlLmxlbmd0aDtcbiAgICB0aGlzLl9jb3VudGVyRWxlbWVudC5pbm5lckhUTUwgPSBgJHtlfSAvICR7dGhpcy5fbWF4TGVuZ3RofWAsIHRoaXMuX2hlbHBlci5hcHBlbmRDaGlsZCh0aGlzLl9jb3VudGVyRWxlbWVudCksIHRoaXMuX2JpbmRDb3VudGVyKCk7XG4gIH1cbiAgX2JpbmRDb3VudGVyKCkge1xuICAgIGMub24odGhpcy5pbnB1dCwgXCJpbnB1dFwiLCAoKSA9PiB7XG4gICAgICBjb25zdCB0ID0gdGhpcy5pbnB1dC52YWx1ZS5sZW5ndGg7XG4gICAgICB0aGlzLl9jb3VudGVyRWxlbWVudC5pbm5lckhUTUwgPSBgJHt0fSAvICR7dGhpcy5fbWF4TGVuZ3RofWA7XG4gICAgfSk7XG4gIH1cbiAgX3RvZ2dsZURlZmF1bHREYXRlUGxhY2Vob2xkZXIodCA9IHRoaXMuaW5wdXQpIHtcbiAgICBpZiAoISh0LmdldEF0dHJpYnV0ZShcInR5cGVcIikgPT09IFwiZGF0ZVwiKSlcbiAgICAgIHJldHVybjtcbiAgICAhKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IHQpICYmICF0LnZhbHVlID8gdC5zdHlsZS5vcGFjaXR5ID0gMCA6IHQuc3R5bGUub3BhY2l0eSA9IDE7XG4gIH1cbiAgX3Nob3dQbGFjZWhvbGRlcigpIHtcbiAgICB0aGlzLmlucHV0LnNldEF0dHJpYnV0ZShYXywgXCJcIik7XG4gIH1cbiAgX2dldE5vdGNoRGF0YSgpIHtcbiAgICB0aGlzLl9ub3RjaE1pZGRsZSA9IGQuZmluZE9uZShcbiAgICAgIHdhLFxuICAgICAgdGhpcy5fZWxlbWVudFxuICAgICksIHRoaXMuX25vdGNoTGVhZGluZyA9IGQuZmluZE9uZShcbiAgICAgIHlhLFxuICAgICAgdGhpcy5fZWxlbWVudFxuICAgICk7XG4gIH1cbiAgX2dldExhYmVsV2lkdGgoKSB7XG4gICAgdGhpcy5fbGFiZWxXaWR0aCA9IHRoaXMuX2xhYmVsLmNsaWVudFdpZHRoICogMC44ICsgODtcbiAgfVxuICBfZ2V0TGFiZWxQb3NpdGlvbkluSW5wdXRHcm91cCgpIHtcbiAgICBpZiAodGhpcy5fbGFiZWxNYXJnaW5MZWZ0ID0gMCwgIXRoaXMuX2VsZW1lbnQuaGFzQXR0cmlidXRlKFwiZGF0YS10ZS1pbnB1dC1ncm91cC1yZWZcIikpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgdCA9IHRoaXMuaW5wdXQsIGUgPSBkLnByZXYoXG4gICAgICB0LFxuICAgICAgXCJbZGF0YS10ZS1pbnB1dC1ncm91cC10ZXh0LXJlZl1cIlxuICAgIClbMF07XG4gICAgZSA9PT0gdm9pZCAwID8gdGhpcy5fbGFiZWxNYXJnaW5MZWZ0ID0gMCA6IHRoaXMuX2xhYmVsTWFyZ2luTGVmdCA9IGUub2Zmc2V0V2lkdGggLSAxO1xuICB9XG4gIF9hcHBseURpdnMoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuX2NvbmZpZy5pbnB1dEZvcm1XaGl0ZSA/IHRoaXMuX2NsYXNzZXMubm90Y2hMZWFkaW5nV2hpdGUgOiB0aGlzLl9jbGFzc2VzLm5vdGNoTGVhZGluZ05vcm1hbCwgZSA9IHRoaXMuX2NvbmZpZy5pbnB1dEZvcm1XaGl0ZSA/IHRoaXMuX2NsYXNzZXMubm90Y2hNaWRkbGVXaGl0ZSA6IHRoaXMuX2NsYXNzZXMubm90Y2hNaWRkbGVOb3JtYWwsIGkgPSB0aGlzLl9jb25maWcuaW5wdXRGb3JtV2hpdGUgPyB0aGlzLl9jbGFzc2VzLm5vdGNoVHJhaWxpbmdXaGl0ZSA6IHRoaXMuX2NsYXNzZXMubm90Y2hUcmFpbGluZ05vcm1hbCwgbiA9IGQuZmluZChrZSwgdGhpcy5fZWxlbWVudCksIG8gPSAkKFwiZGl2XCIpO1xuICAgIGguYWRkQ2xhc3MobywgdGhpcy5fY2xhc3Nlcy5ub3RjaCksIG8uc2V0QXR0cmlidXRlKEZjLCBcIlwiKSwgdGhpcy5fbm90Y2hMZWFkaW5nID0gJChcImRpdlwiKSwgaC5hZGRDbGFzcyhcbiAgICAgIHRoaXMuX25vdGNoTGVhZGluZyxcbiAgICAgIGAke3RoaXMuX2NsYXNzZXMubm90Y2hMZWFkaW5nfSAke3R9YFxuICAgICksIHRoaXMuX25vdGNoTGVhZGluZy5zZXRBdHRyaWJ1dGUoWWMsIFwiXCIpLCB0aGlzLl9ub3RjaE1pZGRsZSA9ICQoXCJkaXZcIiksIGguYWRkQ2xhc3MoXG4gICAgICB0aGlzLl9ub3RjaE1pZGRsZSxcbiAgICAgIGAke3RoaXMuX2NsYXNzZXMubm90Y2hNaWRkbGV9ICR7ZX1gXG4gICAgKSwgdGhpcy5fbm90Y2hNaWRkbGUuc2V0QXR0cmlidXRlKGpjLCBcIlwiKSwgdGhpcy5fbm90Y2hUcmFpbGluZyA9ICQoXCJkaXZcIiksIGguYWRkQ2xhc3MoXG4gICAgICB0aGlzLl9ub3RjaFRyYWlsaW5nLFxuICAgICAgYCR7dGhpcy5fY2xhc3Nlcy5ub3RjaFRyYWlsaW5nfSAke2l9YFxuICAgICksIHRoaXMuX25vdGNoVHJhaWxpbmcuc2V0QXR0cmlidXRlKHpfLCBcIlwiKSwgIShuLmxlbmd0aCA+PSAxKSAmJiAoby5hcHBlbmQodGhpcy5fbm90Y2hMZWFkaW5nKSwgby5hcHBlbmQodGhpcy5fbm90Y2hNaWRkbGUpLCBvLmFwcGVuZCh0aGlzLl9ub3RjaFRyYWlsaW5nKSwgdGhpcy5fZWxlbWVudC5hcHBlbmQobykpO1xuICB9XG4gIF9hcHBseU5vdGNoKCkge1xuICAgIHRoaXMuX25vdGNoTWlkZGxlLnN0eWxlLndpZHRoID0gYCR7dGhpcy5fbGFiZWxXaWR0aH1weGAsIHRoaXMuX25vdGNoTGVhZGluZy5zdHlsZS53aWR0aCA9IGAke3RoaXMuX2xhYmVsTWFyZ2luTGVmdCArIDl9cHhgLCB0aGlzLl9sYWJlbCAhPT0gbnVsbCAmJiAodGhpcy5fbGFiZWwuc3R5bGUubWFyZ2luTGVmdCA9IGAke3RoaXMuX2xhYmVsTWFyZ2luTGVmdH1weGApO1xuICB9XG4gIF9yZW1vdmVCb3JkZXIoKSB7XG4gICAgY29uc3QgdCA9IGQuZmluZE9uZShrZSwgdGhpcy5fZWxlbWVudCk7XG4gICAgdCAmJiB0LnJlbW92ZSgpO1xuICB9XG4gIF9hY3RpdmF0ZSh0KSB7XG4gICAgWmwoKCkgPT4ge1xuICAgICAgdGhpcy5fZ2V0RWxlbWVudHModCk7XG4gICAgICBjb25zdCBlID0gdCA/IHQudGFyZ2V0IDogdGhpcy5pbnB1dCwgaSA9IGQuZmluZE9uZShcbiAgICAgICAga2UsXG4gICAgICAgIHRoaXMuX2VsZW1lbnRcbiAgICAgICk7XG4gICAgICB0ICYmIHQudHlwZSA9PT0gXCJmb2N1c1wiICYmIGkgJiYgaS5zZXRBdHRyaWJ1dGUoQ2EsIFwiXCIpLCBlLnZhbHVlICE9PSBcIlwiICYmIChlLnNldEF0dHJpYnV0ZShGdCwgXCJcIiksIGkgJiYgaS5zZXRBdHRyaWJ1dGUoRnQsIFwiXCIpKSwgdGhpcy5fdG9nZ2xlRGVmYXVsdERhdGVQbGFjZWhvbGRlcihlKTtcbiAgICB9KTtcbiAgfVxuICBfZ2V0RWxlbWVudHModCkge1xuICAgIGlmICh0ICYmICh0aGlzLl9lbGVtZW50ID0gdC50YXJnZXQucGFyZW50Tm9kZSwgdGhpcy5fbGFiZWwgPSBkLmZpbmRPbmUoXCJsYWJlbFwiLCB0aGlzLl9lbGVtZW50KSksIHQgJiYgdGhpcy5fbGFiZWwpIHtcbiAgICAgIGNvbnN0IGUgPSB0aGlzLl9sYWJlbFdpZHRoO1xuICAgICAgdGhpcy5fZ2V0TGFiZWxEYXRhKCksIGUgIT09IHRoaXMuX2xhYmVsV2lkdGggJiYgKHRoaXMuX25vdGNoTWlkZGxlID0gZC5maW5kT25lKFxuICAgICAgICB3YSxcbiAgICAgICAgdC50YXJnZXQucGFyZW50Tm9kZVxuICAgICAgKSwgdGhpcy5fbm90Y2hMZWFkaW5nID0gZC5maW5kT25lKFxuICAgICAgICB5YSxcbiAgICAgICAgdC50YXJnZXQucGFyZW50Tm9kZVxuICAgICAgKSwgdGhpcy5fYXBwbHlOb3RjaCgpKTtcbiAgICB9XG4gIH1cbiAgX2RlYWN0aXZhdGUodCkge1xuICAgIGNvbnN0IGUgPSB0ID8gdC50YXJnZXQgOiB0aGlzLmlucHV0LCBpID0gZC5maW5kT25lKFxuICAgICAga2UsXG4gICAgICBlLnBhcmVudE5vZGVcbiAgICApO1xuICAgIGkucmVtb3ZlQXR0cmlidXRlKENhKSwgZS52YWx1ZSA9PT0gXCJcIiAmJiAoZS5yZW1vdmVBdHRyaWJ1dGUoRnQpLCBpLnJlbW92ZUF0dHJpYnV0ZShGdCkpLCB0aGlzLl90b2dnbGVEZWZhdWx0RGF0ZVBsYWNlaG9sZGVyKGUpO1xuICB9XG4gIHN0YXRpYyBhY3RpdmF0ZSh0KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGUpIHtcbiAgICAgIHQuX2FjdGl2YXRlKGUpO1xuICAgIH07XG4gIH1cbiAgc3RhdGljIGRlYWN0aXZhdGUodCkge1xuICAgIHJldHVybiBmdW5jdGlvbihlKSB7XG4gICAgICB0Ll9kZWFjdGl2YXRlKGUpO1xuICAgIH07XG4gIH1cbiAgc3RhdGljIGpRdWVyeUludGVyZmFjZSh0LCBlKSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgIGxldCBpID0geS5nZXREYXRhKHRoaXMsIG9zKTtcbiAgICAgIGNvbnN0IG4gPSB0eXBlb2YgdCA9PSBcIm9iamVjdFwiICYmIHQ7XG4gICAgICBpZiAoISghaSAmJiAvZGlzcG9zZS8udGVzdCh0KSkgJiYgKGkgfHwgKGkgPSBuZXcgVih0aGlzLCBuKSksIHR5cGVvZiB0ID09IFwic3RyaW5nXCIpKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaVt0XSA+IFwidVwiKVxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcIiR7dH1cImApO1xuICAgICAgICBpW3RdKGUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHN0YXRpYyBnZXRJbnN0YW5jZSh0KSB7XG4gICAgcmV0dXJuIHkuZ2V0RGF0YSh0LCBvcyk7XG4gIH1cbiAgc3RhdGljIGdldE9yQ3JlYXRlSW5zdGFuY2UodCwgZSA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0SW5zdGFuY2UodCkgfHwgbmV3IHRoaXModCwgdHlwZW9mIGUgPT0gXCJvYmplY3RcIiA/IGUgOiBudWxsKTtcbiAgfVxufVxuY29uc3Qga2EgPSBcImFuaW1hdGlvblwiLCBqbiA9IFwidGUuYW5pbWF0aW9uXCIsIEpfID0ge1xuICBhbmltYXRpb246IFwic3RyaW5nXCIsXG4gIGFuaW1hdGlvblN0YXJ0OiBcInN0cmluZ1wiLFxuICBhbmltYXRpb25TaG93T25Mb2FkOiBcImJvb2xlYW5cIixcbiAgb25TdGFydDogXCIobnVsbHxmdW5jdGlvbilcIixcbiAgb25FbmQ6IFwiKG51bGx8ZnVuY3Rpb24pXCIsXG4gIG9uSGlkZTogXCIobnVsbHxmdW5jdGlvbilcIixcbiAgb25TaG93OiBcIihudWxsfGZ1bmN0aW9uKVwiLFxuICBhbmltYXRpb25PblNjcm9sbDogXCIoc3RyaW5nKVwiLFxuICBhbmltYXRpb25XaW5kb3dIZWlnaHQ6IFwibnVtYmVyXCIsXG4gIGFuaW1hdGlvbk9mZnNldDogXCIobnVtYmVyfHN0cmluZylcIixcbiAgYW5pbWF0aW9uRGVsYXk6IFwiKG51bWJlcnxzdHJpbmcpXCIsXG4gIGFuaW1hdGlvblJldmVyc2U6IFwiYm9vbGVhblwiLFxuICBhbmltYXRpb25JbnRlcnZhbDogXCIobnVtYmVyfHN0cmluZylcIixcbiAgYW5pbWF0aW9uUmVwZWF0OiBcIihudW1iZXJ8Ym9vbGVhbilcIixcbiAgYW5pbWF0aW9uUmVzZXQ6IFwiYm9vbGVhblwiXG59LCB0ZiA9IHtcbiAgYW5pbWF0aW9uOiBcImZhZGVcIixcbiAgYW5pbWF0aW9uU3RhcnQ6IFwib25DbGlja1wiLFxuICBhbmltYXRpb25TaG93T25Mb2FkOiAhMCxcbiAgb25TdGFydDogbnVsbCxcbiAgb25FbmQ6IG51bGwsXG4gIG9uSGlkZTogbnVsbCxcbiAgb25TaG93OiBudWxsLFxuICBhbmltYXRpb25PblNjcm9sbDogXCJvbmNlXCIsXG4gIGFuaW1hdGlvbldpbmRvd0hlaWdodDogMCxcbiAgYW5pbWF0aW9uT2Zmc2V0OiAwLFxuICBhbmltYXRpb25EZWxheTogMCxcbiAgYW5pbWF0aW9uUmV2ZXJzZTogITEsXG4gIGFuaW1hdGlvbkludGVydmFsOiAwLFxuICBhbmltYXRpb25SZXBlYXQ6ICExLFxuICBhbmltYXRpb25SZXNldDogITFcbn07XG5jbGFzcyBwciB7XG4gIGNvbnN0cnVjdG9yKHQsIGUpIHtcbiAgICB0aGlzLl9lbGVtZW50ID0gdCwgdGhpcy5fYW5pbWF0ZUVsZW1lbnQgPSB0aGlzLl9nZXRBbmltYXRlRWxlbWVudCgpLCB0aGlzLl9pc0ZpcnN0U2Nyb2xsID0gITAsIHRoaXMuX3JlcGVhdEFuaW1hdGVPblNjcm9sbCA9ICEwLCB0aGlzLl9vcHRpb25zID0gdGhpcy5fZ2V0Q29uZmlnKGUpLCB0aGlzLl9lbGVtZW50ICYmICh5LnNldERhdGEodCwgam4sIHRoaXMpLCB0aGlzLl9pbml0KCkpO1xuICB9XG4gIC8vIEdldHRlcnNcbiAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgIHJldHVybiBrYTtcbiAgfVxuICAvLyBQdWJsaWNcbiAgaW5pdCgpIHtcbiAgICB0aGlzLl9pbml0KCk7XG4gIH1cbiAgc3RhcnRBbmltYXRpb24oKSB7XG4gICAgdGhpcy5fc3RhcnRBbmltYXRpb24oKTtcbiAgfVxuICBzdG9wQW5pbWF0aW9uKCkge1xuICAgIHRoaXMuX2NsZWFyQW5pbWF0aW9uQ2xhc3MoKTtcbiAgfVxuICBjaGFuZ2VBbmltYXRpb25UeXBlKHQpIHtcbiAgICB0aGlzLl9vcHRpb25zLmFuaW1hdGlvbiA9IHQ7XG4gIH1cbiAgZGlzcG9zZSgpIHtcbiAgICBjLm9mZih0aGlzLl9lbGVtZW50LCBcIm1vdXNlZG93blwiKSwgYy5vZmYodGhpcy5fYW5pbWF0ZUVsZW1lbnQsIFwiYW5pbWF0aW9uZW5kXCIpLCBjLm9mZih3aW5kb3csIFwic2Nyb2xsXCIpLCBjLm9mZih0aGlzLl9lbGVtZW50LCBcIm1vdXNlb3ZlclwiKSwgeS5yZW1vdmVEYXRhKHRoaXMuX2VsZW1lbnQsIGpuKSwgdGhpcy5fZWxlbWVudCA9IG51bGwsIHRoaXMuX2FuaW1hdGVFbGVtZW50ID0gbnVsbCwgdGhpcy5faXNGaXJzdFNjcm9sbCA9IG51bGwsIHRoaXMuX3JlcGVhdEFuaW1hdGVPblNjcm9sbCA9IG51bGwsIHRoaXMuX29wdGlvbnMgPSBudWxsO1xuICB9XG4gIC8vIFByaXZhdGVcbiAgX2luaXQoKSB7XG4gICAgc3dpdGNoICh0aGlzLl9vcHRpb25zLmFuaW1hdGlvblN0YXJ0KSB7XG4gICAgICBjYXNlIFwib25Ib3ZlclwiOlxuICAgICAgICB0aGlzLl9iaW5kSG92ZXJFdmVudHMoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwib25Mb2FkXCI6XG4gICAgICAgIHRoaXMuX3N0YXJ0QW5pbWF0aW9uKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIm9uU2Nyb2xsXCI6XG4gICAgICAgIHRoaXMuX2JpbmRTY3JvbGxFdmVudHMoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwib25DbGlja1wiOlxuICAgICAgICB0aGlzLl9iaW5kQ2xpY2tFdmVudHMoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHRoaXMuX2JpbmRUcmlnZ2VyT25FbmRDYWxsYmFjaygpLCB0aGlzLl9vcHRpb25zLmFuaW1hdGlvblJlc2V0ICYmIHRoaXMuX2JpbmRSZXNldEFuaW1hdGlvbkFmdGVyRmluaXNoKCk7XG4gIH1cbiAgX2dldEFuaW1hdGVFbGVtZW50KCkge1xuICAgIGNvbnN0IHQgPSBoLmdldERhdGFBdHRyaWJ1dGUoXG4gICAgICB0aGlzLl9lbGVtZW50LFxuICAgICAgXCJhbmltYXRpb24tdGFyZ2V0XCJcbiAgICApO1xuICAgIHJldHVybiB0ID8gZC5maW5kKHQpWzBdIDogdGhpcy5fZWxlbWVudDtcbiAgfVxuICBfZ2V0Q29uZmlnKHQpIHtcbiAgICBjb25zdCBlID0gaC5nZXREYXRhQXR0cmlidXRlcyh0aGlzLl9hbmltYXRlRWxlbWVudCk7XG4gICAgcmV0dXJuIHQgPSB7XG4gICAgICAuLi50ZixcbiAgICAgIC4uLmUsXG4gICAgICAuLi50XG4gICAgfSwgRChrYSwgdCwgSl8pLCB0O1xuICB9XG4gIF9hbmltYXRlT25TY3JvbGwoKSB7XG4gICAgY29uc3QgdCA9IGgub2Zmc2V0KHRoaXMuX2FuaW1hdGVFbGVtZW50KS50b3AsIGUgPSB0aGlzLl9hbmltYXRlRWxlbWVudC5vZmZzZXRIZWlnaHQsIGkgPSB3aW5kb3cuaW5uZXJIZWlnaHQsIG4gPSB0ICsgdGhpcy5fb3B0aW9ucy5hbmltYXRpb25PZmZzZXQgPD0gaSAmJiB0ICsgdGhpcy5fb3B0aW9ucy5hbmltYXRpb25PZmZzZXQgKyBlID49IDAsIG8gPSB0aGlzLl9hbmltYXRlRWxlbWVudC5zdHlsZS52aXNpYmlsaXR5ID09PSBcInZpc2libGVcIjtcbiAgICBzd2l0Y2ggKCEwKSB7XG4gICAgICBjYXNlIChuICYmIHRoaXMuX2lzRmlyc3RTY3JvbGwpOlxuICAgICAgICB0aGlzLl9pc0ZpcnN0U2Nyb2xsID0gITEsIHRoaXMuX3N0YXJ0QW5pbWF0aW9uKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAoIW4gJiYgdGhpcy5faXNGaXJzdFNjcm9sbCk6XG4gICAgICAgIHRoaXMuX2lzRmlyc3RTY3JvbGwgPSAhMSwgdGhpcy5faGlkZUFuaW1hdGVFbGVtZW50KCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAobiAmJiAhbyAmJiB0aGlzLl9yZXBlYXRBbmltYXRlT25TY3JvbGwpOlxuICAgICAgICB0aGlzLl9vcHRpb25zLmFuaW1hdGlvbk9uU2Nyb2xsICE9PSBcInJlcGVhdFwiICYmICh0aGlzLl9yZXBlYXRBbmltYXRlT25TY3JvbGwgPSAhMSksIHRoaXMuX2NhbGxiYWNrKHRoaXMuX29wdGlvbnMub25TaG93KSwgdGhpcy5fc2hvd0FuaW1hdGVFbGVtZW50KCksIHRoaXMuX3N0YXJ0QW5pbWF0aW9uKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAoIW4gJiYgbyAmJiB0aGlzLl9yZXBlYXRBbmltYXRlT25TY3JvbGwpOlxuICAgICAgICB0aGlzLl9oaWRlQW5pbWF0ZUVsZW1lbnQoKSwgdGhpcy5fY2xlYXJBbmltYXRpb25DbGFzcygpLCB0aGlzLl9jYWxsYmFjayh0aGlzLl9vcHRpb25zLm9uSGlkZSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBfYWRkQW5pbWF0ZWRDbGFzcygpIHtcbiAgICBoLmFkZENsYXNzKFxuICAgICAgdGhpcy5fYW5pbWF0ZUVsZW1lbnQsXG4gICAgICBgYW5pbWF0ZS0ke3RoaXMuX29wdGlvbnMuYW5pbWF0aW9ufWBcbiAgICApO1xuICB9XG4gIF9jbGVhckFuaW1hdGlvbkNsYXNzKCkge1xuICAgIHRoaXMuX2FuaW1hdGVFbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoYGFuaW1hdGUtJHt0aGlzLl9vcHRpb25zLmFuaW1hdGlvbn1gKTtcbiAgfVxuICBfc3RhcnRBbmltYXRpb24oKSB7XG4gICAgdGhpcy5fY2FsbGJhY2sodGhpcy5fb3B0aW9ucy5vblN0YXJ0KSwgdGhpcy5fYWRkQW5pbWF0ZWRDbGFzcygpLCB0aGlzLl9vcHRpb25zLmFuaW1hdGlvblJlcGVhdCAmJiAhdGhpcy5fb3B0aW9ucy5hbmltYXRpb25JbnRlcnZhbCAmJiB0aGlzLl9zZXRBbmltYXRpb25SZXBlYXQoKSwgdGhpcy5fb3B0aW9ucy5hbmltYXRpb25SZXZlcnNlICYmIHRoaXMuX3NldEFuaW1hdGlvblJldmVyc2UoKSwgdGhpcy5fb3B0aW9ucy5hbmltYXRpb25EZWxheSAmJiB0aGlzLl9zZXRBbmltYXRpb25EZWxheSgpLCB0aGlzLl9vcHRpb25zLmFuaW1hdGlvbkR1cmF0aW9uICYmIHRoaXMuX3NldEFuaW1hdGlvbkR1cmF0aW9uKCksIHRoaXMuX29wdGlvbnMuYW5pbWF0aW9uSW50ZXJ2YWwgJiYgdGhpcy5fc2V0QW5pbWF0aW9uSW50ZXJ2YWwoKTtcbiAgfVxuICBfc2V0QW5pbWF0aW9uUmV2ZXJzZSgpIHtcbiAgICBoLnN0eWxlKHRoaXMuX2FuaW1hdGVFbGVtZW50LCB7XG4gICAgICBhbmltYXRpb25JdGVyYXRpb25Db3VudDogdGhpcy5fb3B0aW9ucy5hbmltYXRpb25SZXBlYXQgPT09ICEwID8gXCJpbmZpbml0ZVwiIDogXCIyXCIsXG4gICAgICBhbmltYXRpb25EaXJlY3Rpb246IFwiYWx0ZXJuYXRlXCJcbiAgICB9KTtcbiAgfVxuICBfc2V0QW5pbWF0aW9uRHVyYXRpb24oKSB7XG4gICAgaC5zdHlsZSh0aGlzLl9hbmltYXRlRWxlbWVudCwge1xuICAgICAgYW5pbWF0aW9uRHVyYXRpb246IGAke3RoaXMuX29wdGlvbnMuYW5pbWF0aW9uRHVyYXRpb259bXNgXG4gICAgfSk7XG4gIH1cbiAgX3NldEFuaW1hdGlvbkRlbGF5KCkge1xuICAgIGguc3R5bGUodGhpcy5fYW5pbWF0ZUVsZW1lbnQsIHtcbiAgICAgIGFuaW1hdGlvbkRlbGF5OiBgJHt0aGlzLl9vcHRpb25zLmFuaW1hdGlvbkRlbGF5fW1zYFxuICAgIH0pO1xuICB9XG4gIF9zZXRBbmltYXRpb25SZXBlYXQoKSB7XG4gICAgaC5zdHlsZSh0aGlzLl9hbmltYXRlRWxlbWVudCwge1xuICAgICAgYW5pbWF0aW9uSXRlcmF0aW9uQ291bnQ6IHRoaXMuX29wdGlvbnMuYW5pbWF0aW9uUmVwZWF0ID09PSAhMCA/IFwiaW5maW5pdGVcIiA6IHRoaXMuX29wdGlvbnMuYW5pbWF0aW9uUmVwZWF0XG4gICAgfSk7XG4gIH1cbiAgX3NldEFuaW1hdGlvbkludGVydmFsKCkge1xuICAgIGMub24odGhpcy5fYW5pbWF0ZUVsZW1lbnQsIFwiY2xpY2tcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5fY2xlYXJBbmltYXRpb25DbGFzcygpLCBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy5fYWRkQW5pbWF0ZWRDbGFzcygpO1xuICAgICAgfSwgdGhpcy5fb3B0aW9ucy5hbmltYXRpb25JbnRlcnZhbCk7XG4gICAgfSk7XG4gIH1cbiAgX2hpZGVBbmltYXRlRWxlbWVudCgpIHtcbiAgICBoLnN0eWxlKHRoaXMuX2FuaW1hdGVFbGVtZW50LCB7IHZpc2liaWxpdHk6IFwiaGlkZGVuXCIgfSk7XG4gIH1cbiAgX3Nob3dBbmltYXRlRWxlbWVudCgpIHtcbiAgICBoLnN0eWxlKHRoaXMuX2FuaW1hdGVFbGVtZW50LCB7IHZpc2liaWxpdHk6IFwidmlzaWJsZVwiIH0pO1xuICB9XG4gIF9iaW5kUmVzZXRBbmltYXRpb25BZnRlckZpbmlzaCgpIHtcbiAgICBjLm9uKHRoaXMuX2FuaW1hdGVFbGVtZW50LCBcImFuaW1hdGlvbmVuZFwiLCAoKSA9PiB7XG4gICAgICB0aGlzLl9jbGVhckFuaW1hdGlvbkNsYXNzKCk7XG4gICAgfSk7XG4gIH1cbiAgX2JpbmRUcmlnZ2VyT25FbmRDYWxsYmFjaygpIHtcbiAgICBjLm9uKHRoaXMuX2FuaW1hdGVFbGVtZW50LCBcImFuaW1hdGlvbmVuZFwiLCAoKSA9PiB7XG4gICAgICB0aGlzLl9jYWxsYmFjayh0aGlzLl9vcHRpb25zLm9uRW5kKTtcbiAgICB9KTtcbiAgfVxuICBfYmluZFNjcm9sbEV2ZW50cygpIHtcbiAgICB0aGlzLl9vcHRpb25zLmFuaW1hdGlvblNob3dPbkxvYWQgfHwgdGhpcy5fYW5pbWF0ZU9uU2Nyb2xsKCksIGMub24od2luZG93LCBcInNjcm9sbFwiLCAoKSA9PiB7XG4gICAgICB0aGlzLl9hbmltYXRlT25TY3JvbGwoKTtcbiAgICB9KTtcbiAgfVxuICBfYmluZENsaWNrRXZlbnRzKCkge1xuICAgIGMub24odGhpcy5fZWxlbWVudCwgXCJtb3VzZWRvd25cIiwgKCkgPT4ge1xuICAgICAgdGhpcy5fc3RhcnRBbmltYXRpb24oKTtcbiAgICB9KTtcbiAgfVxuICBfYmluZEhvdmVyRXZlbnRzKCkge1xuICAgIGMub25lKHRoaXMuX2VsZW1lbnQsIFwibW91c2VvdmVyXCIsICgpID0+IHtcbiAgICAgIHRoaXMuX3N0YXJ0QW5pbWF0aW9uKCk7XG4gICAgfSksIGMub25lKHRoaXMuX2FuaW1hdGVFbGVtZW50LCBcImFuaW1hdGlvbmVuZFwiLCAoKSA9PiB7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy5fYmluZEhvdmVyRXZlbnRzKCk7XG4gICAgICB9LCAxMDApO1xuICAgIH0pO1xuICB9XG4gIF9jYWxsYmFjayh0KSB7XG4gICAgdCBpbnN0YW5jZW9mIEZ1bmN0aW9uICYmIHQoKTtcbiAgfVxuICAvLyBTdGF0aWNcbiAgc3RhdGljIGF1dG9Jbml0KHQpIHtcbiAgICB0Ll9pbml0KCk7XG4gIH1cbiAgc3RhdGljIGpRdWVyeUludGVyZmFjZSh0KSB7XG4gICAgbmV3IHByKHRoaXNbMF0sIHQpLmluaXQoKTtcbiAgfVxuICBzdGF0aWMgZ2V0SW5zdGFuY2UodCkge1xuICAgIHJldHVybiB5LmdldERhdGEodCwgam4pO1xuICB9XG4gIHN0YXRpYyBnZXRPckNyZWF0ZUluc3RhbmNlKHQsIGUgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLmdldEluc3RhbmNlKHQpIHx8IG5ldyB0aGlzKHQsIHR5cGVvZiBlID09IFwib2JqZWN0XCIgPyBlIDogbnVsbCk7XG4gIH1cbn1cbmNvbnN0IEtuID0gXCJyaXBwbGVcIiwgcnMgPSBcInRlLnJpcHBsZVwiLCBlZiA9IFwicmdiYSh7e2NvbG9yfX0sIDAuMikgMCwgcmdiYSh7e2NvbG9yfX0sIDAuMykgNDAlLCByZ2JhKHt7Y29sb3J9fSwgMC40KSA1MCUsIHJnYmEoe3tjb2xvcn19LCAwLjUpIDYwJSwgcmdiYSh7e2NvbG9yfX0sIDApIDcwJVwiLCBzZiA9IFtcIltkYXRhLXRlLXJpcHBsZS1pbml0XVwiXSwgYXMgPSBbMCwgMCwgMF0sIG5mID0gW1xuICB7IG5hbWU6IFwicHJpbWFyeVwiLCBncmFkaWVudENvbG9yOiBcIiMzQjcxQ0FcIiB9LFxuICB7IG5hbWU6IFwic2Vjb25kYXJ5XCIsIGdyYWRpZW50Q29sb3I6IFwiIzlGQTZCMlwiIH0sXG4gIHsgbmFtZTogXCJzdWNjZXNzXCIsIGdyYWRpZW50Q29sb3I6IFwiIzE0QTQ0RFwiIH0sXG4gIHsgbmFtZTogXCJkYW5nZXJcIiwgZ3JhZGllbnRDb2xvcjogXCIjREM0QzY0XCIgfSxcbiAgeyBuYW1lOiBcIndhcm5pbmdcIiwgZ3JhZGllbnRDb2xvcjogXCIjRTRBMTFCXCIgfSxcbiAgeyBuYW1lOiBcImluZm9cIiwgZ3JhZGllbnRDb2xvcjogXCIjNTRCNEQzXCIgfSxcbiAgeyBuYW1lOiBcImxpZ2h0XCIsIGdyYWRpZW50Q29sb3I6IFwiI2ZiZmJmYlwiIH0sXG4gIHsgbmFtZTogXCJkYXJrXCIsIGdyYWRpZW50Q29sb3I6IFwiIzI2MjYyNlwiIH1cbl0sIHhhID0gMC41LCBvZiA9IHtcbiAgcmlwcGxlQ2VudGVyZWQ6ICExLFxuICByaXBwbGVDb2xvcjogXCJcIixcbiAgcmlwcGxlQ29sb3JEYXJrOiBcIlwiLFxuICByaXBwbGVEdXJhdGlvbjogXCI1MDBtc1wiLFxuICByaXBwbGVSYWRpdXM6IDAsXG4gIHJpcHBsZVVuYm91bmQ6ICExXG59LCByZiA9IHtcbiAgcmlwcGxlQ2VudGVyZWQ6IFwiYm9vbGVhblwiLFxuICByaXBwbGVDb2xvcjogXCJzdHJpbmdcIixcbiAgcmlwcGxlQ29sb3JEYXJrOiBcInN0cmluZ1wiLFxuICByaXBwbGVEdXJhdGlvbjogXCJzdHJpbmdcIixcbiAgcmlwcGxlUmFkaXVzOiBcIm51bWJlclwiLFxuICByaXBwbGVVbmJvdW5kOiBcImJvb2xlYW5cIlxufSwgYWYgPSB7XG4gIHJpcHBsZTogXCJyZWxhdGl2ZSBvdmVyZmxvdy1oaWRkZW4gaW5saW5lLWJsb2NrIGFsaWduLWJvdHRvbVwiLFxuICByaXBwbGVXYXZlOiBcInJvdW5kZWQtWzUwJV0gb3BhY2l0eS01MCBwb2ludGVyLWV2ZW50cy1ub25lIGFic29sdXRlIHRvdWNoLW5vbmUgc2NhbGUtMCB0cmFuc2l0aW9uLVt0cmFuc2Zvcm0sX29wYWNpdHldIGVhc2UtW2N1YmljLWJlemllcigwLDAsMC4xNSwxKSxfY3ViaWMtYmV6aWVyKDAsMCwwLjE1LDEpXSB6LVs5OTldXCIsXG4gIHVuYm91bmQ6IFwib3ZlcmZsb3ctdmlzaWJsZVwiXG59LCBsZiA9IHtcbiAgcmlwcGxlOiBcInN0cmluZ1wiLFxuICByaXBwbGVXYXZlOiBcInN0cmluZ1wiLFxuICB1bmJvdW5kOiBcInN0cmluZ1wiXG59O1xuY2xhc3MgWmUge1xuICBjb25zdHJ1Y3Rvcih0LCBlLCBpKSB7XG4gICAgdGhpcy5fZWxlbWVudCA9IHQsIHRoaXMuX29wdGlvbnMgPSB0aGlzLl9nZXRDb25maWcoZSksIHRoaXMuX2NsYXNzZXMgPSB0aGlzLl9nZXRDbGFzc2VzKGkpLCB0aGlzLl9lbGVtZW50ICYmICh5LnNldERhdGEodCwgcnMsIHRoaXMpLCBoLmFkZENsYXNzKHRoaXMuX2VsZW1lbnQsIHRoaXMuX2NsYXNzZXMucmlwcGxlKSksIHRoaXMuX2NsaWNrSGFuZGxlciA9IHRoaXMuX2NyZWF0ZVJpcHBsZS5iaW5kKHRoaXMpLCB0aGlzLl9yaXBwbGVUaW1lciA9IG51bGwsIHRoaXMuX2lzTWluV2lkdGhTZXQgPSAhMSwgdGhpcy5faW5pdGlhbENsYXNzZXMgPSBudWxsLCB0aGlzLmluaXQoKTtcbiAgfVxuICAvLyBHZXR0ZXJzXG4gIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICByZXR1cm4gS247XG4gIH1cbiAgLy8gUHVibGljXG4gIGluaXQoKSB7XG4gICAgdGhpcy5fYWRkQ2xpY2tFdmVudCh0aGlzLl9lbGVtZW50KTtcbiAgfVxuICBkaXNwb3NlKCkge1xuICAgIHkucmVtb3ZlRGF0YSh0aGlzLl9lbGVtZW50LCBycyksIGMub2ZmKHRoaXMuX2VsZW1lbnQsIFwiY2xpY2tcIiwgdGhpcy5fY2xpY2tIYW5kbGVyKSwgdGhpcy5fZWxlbWVudCA9IG51bGwsIHRoaXMuX29wdGlvbnMgPSBudWxsO1xuICB9XG4gIC8vIFByaXZhdGVcbiAgX2F1dG9Jbml0KHQpIHtcbiAgICBzZi5mb3JFYWNoKChlKSA9PiB7XG4gICAgICBkLmNsb3Nlc3QodC50YXJnZXQsIGUpICYmICh0aGlzLl9lbGVtZW50ID0gZC5jbG9zZXN0KHQudGFyZ2V0LCBlKSk7XG4gICAgfSksIHRoaXMuX2VsZW1lbnQuc3R5bGUubWluV2lkdGggfHwgKGguc3R5bGUodGhpcy5fZWxlbWVudCwge1xuICAgICAgXCJtaW4td2lkdGhcIjogZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLl9lbGVtZW50KS53aWR0aFxuICAgIH0pLCB0aGlzLl9pc01pbldpZHRoU2V0ID0gITApLCB0aGlzLl9vcHRpb25zID0gdGhpcy5fZ2V0Q29uZmlnKCksIHRoaXMuX2NsYXNzZXMgPSB0aGlzLl9nZXRDbGFzc2VzKCksIHRoaXMuX2luaXRpYWxDbGFzc2VzID0gWy4uLnRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0XSwgaC5hZGRDbGFzcyh0aGlzLl9lbGVtZW50LCB0aGlzLl9jbGFzc2VzLnJpcHBsZSksIHRoaXMuX2NyZWF0ZVJpcHBsZSh0KTtcbiAgfVxuICBfYWRkQ2xpY2tFdmVudCh0KSB7XG4gICAgYy5vbih0LCBcIm1vdXNlZG93blwiLCB0aGlzLl9jbGlja0hhbmRsZXIpO1xuICB9XG4gIF9jcmVhdGVSaXBwbGUodCkge1xuICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NOYW1lLmluZGV4T2YodGhpcy5fY2xhc3Nlcy5yaXBwbGUpIDwgMCAmJiBoLmFkZENsYXNzKHRoaXMuX2VsZW1lbnQsIHRoaXMuX2NsYXNzZXMucmlwcGxlKTtcbiAgICBjb25zdCB7IGxheWVyWDogZSwgbGF5ZXJZOiBpIH0gPSB0LCBuID0gdC5vZmZzZXRYIHx8IGUsIG8gPSB0Lm9mZnNldFkgfHwgaSwgciA9IHRoaXMuX2VsZW1lbnQub2Zmc2V0SGVpZ2h0LCBhID0gdGhpcy5fZWxlbWVudC5vZmZzZXRXaWR0aCwgbCA9IHRoaXMuX2R1cmF0aW9uVG9Nc051bWJlcih0aGlzLl9vcHRpb25zLnJpcHBsZUR1cmF0aW9uKSwgcCA9IHtcbiAgICAgIG9mZnNldFg6IHRoaXMuX29wdGlvbnMucmlwcGxlQ2VudGVyZWQgPyByIC8gMiA6IG4sXG4gICAgICBvZmZzZXRZOiB0aGlzLl9vcHRpb25zLnJpcHBsZUNlbnRlcmVkID8gYSAvIDIgOiBvLFxuICAgICAgaGVpZ2h0OiByLFxuICAgICAgd2lkdGg6IGFcbiAgICB9LCB1ID0gdGhpcy5fZ2V0RGlhbWV0ZXIocCksIF8gPSB0aGlzLl9vcHRpb25zLnJpcHBsZVJhZGl1cyB8fCB1IC8gMiwgZiA9IHtcbiAgICAgIGRlbGF5OiBsICogeGEsXG4gICAgICBkdXJhdGlvbjogbCAtIGwgKiB4YVxuICAgIH0sIGcgPSB7XG4gICAgICBsZWZ0OiB0aGlzLl9vcHRpb25zLnJpcHBsZUNlbnRlcmVkID8gYCR7YSAvIDIgLSBffXB4YCA6IGAke24gLSBffXB4YCxcbiAgICAgIHRvcDogdGhpcy5fb3B0aW9ucy5yaXBwbGVDZW50ZXJlZCA/IGAke3IgLyAyIC0gX31weGAgOiBgJHtvIC0gX31weGAsXG4gICAgICBoZWlnaHQ6IGAke3RoaXMuX29wdGlvbnMucmlwcGxlUmFkaXVzICogMiB8fCB1fXB4YCxcbiAgICAgIHdpZHRoOiBgJHt0aGlzLl9vcHRpb25zLnJpcHBsZVJhZGl1cyAqIDIgfHwgdX1weGAsXG4gICAgICB0cmFuc2l0aW9uRGVsYXk6IGAwcywgJHtmLmRlbGF5fW1zYCxcbiAgICAgIHRyYW5zaXRpb25EdXJhdGlvbjogYCR7bH1tcywgJHtmLmR1cmF0aW9ufW1zYFxuICAgIH0sIG0gPSAkKFwiZGl2XCIpO1xuICAgIHRoaXMuX2NyZWF0ZUhUTUxSaXBwbGUoe1xuICAgICAgd3JhcHBlcjogdGhpcy5fZWxlbWVudCxcbiAgICAgIHJpcHBsZTogbSxcbiAgICAgIHN0eWxlczogZ1xuICAgIH0pLCB0aGlzLl9yZW1vdmVIVE1MUmlwcGxlKHsgcmlwcGxlOiBtLCBkdXJhdGlvbjogbCB9KTtcbiAgfVxuICBfY3JlYXRlSFRNTFJpcHBsZSh7IHdyYXBwZXI6IHQsIHJpcHBsZTogZSwgc3R5bGVzOiBpIH0pIHtcbiAgICBPYmplY3Qua2V5cyhpKS5mb3JFYWNoKFxuICAgICAgKG4pID0+IGUuc3R5bGVbbl0gPSBpW25dXG4gICAgKSwgaC5hZGRDbGFzcyhlLCB0aGlzLl9jbGFzc2VzLnJpcHBsZVdhdmUpLCBlLnNldEF0dHJpYnV0ZShcImRhdGEtdGUtcmlwcGxlLXJlZlwiLCBcIlwiKSwgdGhpcy5fYWRkQ29sb3IoZSwgdCksIHRoaXMuX3RvZ2dsZVVuYm91bmQodCksIHRoaXMuX2FwcGVuZFJpcHBsZShlLCB0KTtcbiAgfVxuICBfcmVtb3ZlSFRNTFJpcHBsZSh7IHJpcHBsZTogdCwgZHVyYXRpb246IGUgfSkge1xuICAgIHRoaXMuX3JpcHBsZVRpbWVyICYmIChjbGVhclRpbWVvdXQodGhpcy5fcmlwcGxlVGltZXIpLCB0aGlzLl9yaXBwbGVUaW1lciA9IG51bGwpLCB0ICYmIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdC5jbGFzc0xpc3QuYWRkKFwiIW9wYWNpdHktMFwiKTtcbiAgICB9LCAxMCksIHRoaXMuX3JpcHBsZVRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBpZiAodCAmJiAodC5yZW1vdmUoKSwgdGhpcy5fZWxlbWVudCkpIHtcbiAgICAgICAgZC5maW5kKFwiW2RhdGEtdGUtcmlwcGxlLXJlZl1cIiwgdGhpcy5fZWxlbWVudCkuZm9yRWFjaChcbiAgICAgICAgICAobikgPT4ge1xuICAgICAgICAgICAgbi5yZW1vdmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgICksIHRoaXMuX2lzTWluV2lkdGhTZXQgJiYgKGguc3R5bGUodGhpcy5fZWxlbWVudCwgeyBcIm1pbi13aWR0aFwiOiBcIlwiIH0pLCB0aGlzLl9pc01pbldpZHRoU2V0ID0gITEpO1xuICAgICAgICBjb25zdCBpID0gdGhpcy5faW5pdGlhbENsYXNzZXMgPyB0aGlzLl9hZGRlZE5ld1JpcHBsZUNsYXNzZXMoXG4gICAgICAgICAgdGhpcy5fY2xhc3Nlcy5yaXBwbGUsXG4gICAgICAgICAgdGhpcy5faW5pdGlhbENsYXNzZXNcbiAgICAgICAgKSA6IHRoaXMuX2NsYXNzZXMucmlwcGxlLnNwbGl0KFwiIFwiKTtcbiAgICAgICAgaC5yZW1vdmVDbGFzcyh0aGlzLl9lbGVtZW50LCBpKTtcbiAgICAgIH1cbiAgICB9LCBlKTtcbiAgfVxuICBfYWRkZWROZXdSaXBwbGVDbGFzc2VzKHQsIGUpIHtcbiAgICByZXR1cm4gdC5zcGxpdChcIiBcIikuZmlsdGVyKFxuICAgICAgKGkpID0+IGUuZmluZEluZGV4KChuKSA9PiBpID09PSBuKSA9PT0gLTFcbiAgICApO1xuICB9XG4gIF9kdXJhdGlvblRvTXNOdW1iZXIodCkge1xuICAgIHJldHVybiBOdW1iZXIodC5yZXBsYWNlKFwibXNcIiwgXCJcIikucmVwbGFjZShcInNcIiwgXCIwMDBcIikpO1xuICB9XG4gIF9nZXRDb25maWcodCA9IHt9KSB7XG4gICAgY29uc3QgZSA9IGguZ2V0RGF0YUF0dHJpYnV0ZXModGhpcy5fZWxlbWVudCk7XG4gICAgcmV0dXJuIHQgPSB7XG4gICAgICAuLi5vZixcbiAgICAgIC4uLmUsXG4gICAgICAuLi50XG4gICAgfSwgRChLbiwgdCwgcmYpLCB0O1xuICB9XG4gIF9nZXRDbGFzc2VzKHQgPSB7fSkge1xuICAgIGNvbnN0IGUgPSBoLmdldERhdGFDbGFzc0F0dHJpYnV0ZXModGhpcy5fZWxlbWVudCk7XG4gICAgcmV0dXJuIHQgPSB7XG4gICAgICAuLi5hZixcbiAgICAgIC4uLmUsXG4gICAgICAuLi50XG4gICAgfSwgRChLbiwgdCwgbGYpLCB0O1xuICB9XG4gIF9nZXREaWFtZXRlcih7IG9mZnNldFg6IHQsIG9mZnNldFk6IGUsIGhlaWdodDogaSwgd2lkdGg6IG4gfSkge1xuICAgIGNvbnN0IG8gPSBlIDw9IGkgLyAyLCByID0gdCA8PSBuIC8gMiwgYSA9IChmLCBnKSA9PiBNYXRoLnNxcnQoZiAqKiAyICsgZyAqKiAyKSwgbCA9IGUgPT09IGkgLyAyICYmIHQgPT09IG4gLyAyLCBwID0ge1xuICAgICAgZmlyc3Q6IG8gPT09ICEwICYmIHIgPT09ICExLFxuICAgICAgc2Vjb25kOiBvID09PSAhMCAmJiByID09PSAhMCxcbiAgICAgIHRoaXJkOiBvID09PSAhMSAmJiByID09PSAhMCxcbiAgICAgIGZvdXJ0aDogbyA9PT0gITEgJiYgciA9PT0gITFcbiAgICB9LCB1ID0ge1xuICAgICAgdG9wTGVmdDogYSh0LCBlKSxcbiAgICAgIHRvcFJpZ2h0OiBhKG4gLSB0LCBlKSxcbiAgICAgIGJvdHRvbUxlZnQ6IGEodCwgaSAtIGUpLFxuICAgICAgYm90dG9tUmlnaHQ6IGEobiAtIHQsIGkgLSBlKVxuICAgIH07XG4gICAgbGV0IF8gPSAwO1xuICAgIHJldHVybiBsIHx8IHAuZm91cnRoID8gXyA9IHUudG9wTGVmdCA6IHAudGhpcmQgPyBfID0gdS50b3BSaWdodCA6IHAuc2Vjb25kID8gXyA9IHUuYm90dG9tUmlnaHQgOiBwLmZpcnN0ICYmIChfID0gdS5ib3R0b21MZWZ0KSwgXyAqIDI7XG4gIH1cbiAgX2FwcGVuZFJpcHBsZSh0LCBlKSB7XG4gICAgZS5hcHBlbmRDaGlsZCh0KSwgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBoLmFkZENsYXNzKHQsIFwib3BhY2l0eS0wIHNjYWxlLTEwMFwiKTtcbiAgICB9LCA1MCk7XG4gIH1cbiAgX3RvZ2dsZVVuYm91bmQodCkge1xuICAgIHRoaXMuX29wdGlvbnMucmlwcGxlVW5ib3VuZCA9PT0gITAgPyBoLmFkZENsYXNzKHQsIHRoaXMuX2NsYXNzZXMudW5ib3VuZCkgOiBoLnJlbW92ZUNsYXNzKHQsIHRoaXMuX2NsYXNzZXMudW5ib3VuZCk7XG4gIH1cbiAgX2FkZENvbG9yKHQpIHtcbiAgICBsZXQgZSA9IHRoaXMuX29wdGlvbnMucmlwcGxlQ29sb3IgfHwgXCJyZ2IoMCwwLDApXCI7XG4gICAgKGxvY2FsU3RvcmFnZS50aGVtZSA9PT0gXCJkYXJrXCIgfHwgIShcInRoZW1lXCIgaW4gbG9jYWxTdG9yYWdlKSAmJiB3aW5kb3cubWF0Y2hNZWRpYShcIihwcmVmZXJzLWNvbG9yLXNjaGVtZTogZGFyaylcIikubWF0Y2hlcykgJiYgKGUgPSB0aGlzLl9vcHRpb25zLnJpcHBsZUNvbG9yRGFyayB8fCB0aGlzLl9vcHRpb25zLnJpcHBsZUNvbG9yKTtcbiAgICBjb25zdCBpID0gbmYuZmluZChcbiAgICAgIChyKSA9PiByLm5hbWUgPT09IGUudG9Mb3dlckNhc2UoKVxuICAgICksIG4gPSBpID8gdGhpcy5fY29sb3JUb1JHQihpLmdyYWRpZW50Q29sb3IpLmpvaW4oXCIsXCIpIDogdGhpcy5fY29sb3JUb1JHQihlKS5qb2luKFwiLFwiKSwgbyA9IGVmLnNwbGl0KFwie3tjb2xvcn19XCIpLmpvaW4oYCR7bn1gKTtcbiAgICB0LnN0eWxlLmJhY2tncm91bmRJbWFnZSA9IGByYWRpYWwtZ3JhZGllbnQoY2lyY2xlLCAke299KWA7XG4gIH1cbiAgX2NvbG9yVG9SR0IodCkge1xuICAgIGZ1bmN0aW9uIGUobykge1xuICAgICAgcmV0dXJuIG8ubGVuZ3RoIDwgNyAmJiAobyA9IGAjJHtvWzFdfSR7b1sxXX0ke29bMl19JHtvWzJdfSR7b1szXX0ke29bM119YCksIFtcbiAgICAgICAgcGFyc2VJbnQoby5zdWJzdHIoMSwgMiksIDE2KSxcbiAgICAgICAgcGFyc2VJbnQoby5zdWJzdHIoMywgMiksIDE2KSxcbiAgICAgICAgcGFyc2VJbnQoby5zdWJzdHIoNSwgMiksIDE2KVxuICAgICAgXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaShvKSB7XG4gICAgICBjb25zdCByID0gZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChcbiAgICAgICAgZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImZpY3R1bVwiKVxuICAgICAgKSwgYSA9IFwicmdiKDEsIDIsIDMpXCI7XG4gICAgICByZXR1cm4gci5zdHlsZS5jb2xvciA9IGEsIHIuc3R5bGUuY29sb3IgIT09IGEgfHwgKHIuc3R5bGUuY29sb3IgPSBvLCByLnN0eWxlLmNvbG9yID09PSBhIHx8IHIuc3R5bGUuY29sb3IgPT09IFwiXCIpID8gYXMgOiAobyA9IGdldENvbXB1dGVkU3R5bGUocikuY29sb3IsIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQociksIG8pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBuKG8pIHtcbiAgICAgIHJldHVybiBvID0gby5tYXRjaCgvWy5cXGRdKy9nKS5tYXAoKHIpID0+ICtOdW1iZXIocikpLCBvLmxlbmd0aCA9IDMsIG87XG4gICAgfVxuICAgIHJldHVybiB0LnRvTG93ZXJDYXNlKCkgPT09IFwidHJhbnNwYXJlbnRcIiA/IGFzIDogdFswXSA9PT0gXCIjXCIgPyBlKHQpIDogKHQuaW5kZXhPZihcInJnYlwiKSA9PT0gLTEgJiYgKHQgPSBpKHQpKSwgdC5pbmRleE9mKFwicmdiXCIpID09PSAwID8gbih0KSA6IGFzKTtcbiAgfVxuICAvLyBTdGF0aWNcbiAgc3RhdGljIGF1dG9Jbml0aWFsKHQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oZSkge1xuICAgICAgdC5fYXV0b0luaXQoZSk7XG4gICAgfTtcbiAgfVxuICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKHQpIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHkuZ2V0RGF0YSh0aGlzLCBycykgPyBudWxsIDogbmV3IFplKHRoaXMsIHQpO1xuICAgIH0pO1xuICB9XG4gIHN0YXRpYyBnZXRJbnN0YW5jZSh0KSB7XG4gICAgcmV0dXJuIHkuZ2V0RGF0YSh0LCBycyk7XG4gIH1cbiAgc3RhdGljIGdldE9yQ3JlYXRlSW5zdGFuY2UodCwgZSA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0SW5zdGFuY2UodCkgfHwgbmV3IHRoaXModCwgdHlwZW9mIGUgPT0gXCJvYmplY3RcIiA/IGUgOiBudWxsKTtcbiAgfVxufVxuZnVuY3Rpb24gWihzKSB7XG4gIHJldHVybiBzLmdldERhdGUoKTtcbn1cbmZ1bmN0aW9uIFZzKHMpIHtcbiAgcmV0dXJuIHMuZ2V0RGF5KCk7XG59XG5mdW5jdGlvbiBZKHMpIHtcbiAgcmV0dXJuIHMuZ2V0TW9udGgoKTtcbn1cbmZ1bmN0aW9uIEIocykge1xuICByZXR1cm4gcy5nZXRGdWxsWWVhcigpO1xufVxuZnVuY3Rpb24gY2YocywgdCwgZSkge1xuICBjb25zdCBpID0gZS5zdGFydERheSwgbiA9IGkgPiAwID8gNyAtIGkgOiAwLCByID0gbmV3IERhdGUocywgdCkuZ2V0RGF5KCkgKyBuO1xuICByZXR1cm4gciA+PSA3ID8gciAtIDcgOiByO1xufVxuZnVuY3Rpb24gUG8ocykge1xuICByZXR1cm4gaGYocykuZ2V0RGF0ZSgpO1xufVxuZnVuY3Rpb24gaGYocykge1xuICByZXR1cm4gRXQocy5nZXRGdWxsWWVhcigpLCBzLmdldE1vbnRoKCkgKyAxLCAwKTtcbn1cbmZ1bmN0aW9uIEJlKCkge1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCk7XG59XG5mdW5jdGlvbiBpdChzLCB0KSB7XG4gIHJldHVybiBudChzLCB0ICogMTIpO1xufVxuZnVuY3Rpb24gbnQocywgdCkge1xuICBjb25zdCBlID0gRXQoXG4gICAgcy5nZXRGdWxsWWVhcigpLFxuICAgIHMuZ2V0TW9udGgoKSArIHQsXG4gICAgcy5nZXREYXRlKClcbiAgKSwgaSA9IFoocyksIG4gPSBaKGUpO1xuICByZXR1cm4gaSAhPT0gbiAmJiBlLnNldERhdGUoMCksIGU7XG59XG5mdW5jdGlvbiB4ZShzLCB0KSB7XG4gIHJldHVybiBFdChzLmdldEZ1bGxZZWFyKCksIHMuZ2V0TW9udGgoKSwgcy5nZXREYXRlKCkgKyB0KTtcbn1cbmZ1bmN0aW9uIEV0KHMsIHQsIGUpIHtcbiAgY29uc3QgaSA9IG5ldyBEYXRlKHMsIHQsIGUpO1xuICByZXR1cm4gcyA+PSAwICYmIHMgPCAxMDAgJiYgaS5zZXRGdWxsWWVhcihpLmdldEZ1bGxZZWFyKCkgLSAxOTAwKSwgaTtcbn1cbmZ1bmN0aW9uIE9hKHMpIHtcbiAgY29uc3QgdCA9IHMuc3BsaXQoXCItXCIpLCBlID0gdFswXSwgaSA9IHRbMV0sIG4gPSB0WzJdO1xuICByZXR1cm4gRXQoZSwgaSwgbik7XG59XG5mdW5jdGlvbiBkZihzKSB7XG4gIHJldHVybiAhTnVtYmVyLmlzTmFOKHMuZ2V0VGltZSgpKTtcbn1cbmZ1bmN0aW9uIFJlKHMsIHQpIHtcbiAgcmV0dXJuIEIocykgLSBCKHQpIHx8IFkocykgLSBZKHQpIHx8IFoocykgLSBaKHQpO1xufVxuZnVuY3Rpb24gZmUocywgdCkge1xuICByZXR1cm4gcy5zZXRIb3VycygwLCAwLCAwLCAwKSwgdC5zZXRIb3VycygwLCAwLCAwLCAwKSwgcy5nZXRUaW1lKCkgPT09IHQuZ2V0VGltZSgpO1xufVxuZnVuY3Rpb24gV3MocywgdCkge1xuICBjb25zdCBpID0gQihzKSAtIHBmKCk7XG4gIHJldHVybiB1ZihpLCB0KTtcbn1cbmZ1bmN0aW9uIHVmKHMsIHQpIHtcbiAgcmV0dXJuIChzICUgdCArIHQpICUgdDtcbn1cbmZ1bmN0aW9uIHBmKHMsIHQsIGUpIHtcbiAgbGV0IGkgPSAwO1xuICByZXR1cm4gZSA/IGkgPSBCKGUpIC0gcyArIDEgOiB0ICYmIChpID0gQih0KSksIGk7XG59XG5mdW5jdGlvbiBubihzLCB0LCBlLCBpLCBuLCBvKSB7XG4gIGNvbnN0IHIgPSAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKTtcbiAgci5zZXRIb3VycygwLCAwLCAwLCAwKTtcbiAgY29uc3QgYSA9IHQgJiYgUmUocywgdCkgPD0gLTEsIGwgPSBlICYmIFJlKHMsIGUpID49IDEsIHAgPSBuICYmIFJlKHMsIHIpIDw9IC0xLCB1ID0gbyAmJiBSZShzLCByKSA+PSAxLCBfID0gaSAmJiBpKHMpID09PSAhMTtcbiAgcmV0dXJuIGEgfHwgbCB8fCBfIHx8IHAgfHwgdTtcbn1cbmZ1bmN0aW9uIHpjKHMsIHQsIGUsIGksIG4sIG8pIHtcbiAgY29uc3QgciA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpLCBhID0gaSAmJiBCKGkpLCBsID0gaSAmJiBZKGkpLCBwID0gZSAmJiBCKGUpLCB1ID0gZSAmJiBZKGUpLCBfID0gQihyKSwgZiA9IFkociksIGcgPSBsICYmIGEgJiYgKHQgPiBhIHx8IHQgPT09IGEgJiYgcyA+IGwpLCBtID0gdSAmJiBwICYmICh0IDwgcCB8fCB0ID09PSBwICYmIHMgPCB1KSwgYiA9IG4gJiYgKHQgPCBfIHx8IHQgPT09IF8gJiYgcyA8IGYpLCB2ID0gbyAmJiAodCA+IF8gfHwgdCA9PT0gXyAmJiBzID4gZik7XG4gIHJldHVybiBnIHx8IG0gfHwgYiB8fCB2O1xufVxuZnVuY3Rpb24gQm8ocywgdCwgZSwgaSwgbikge1xuICBjb25zdCBvID0gdCAmJiBCKHQpLCByID0gZSAmJiBCKGUpLCBhID0gQigvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKSksIGwgPSByICYmIHMgPiByLCBwID0gbyAmJiBzIDwgbywgdSA9IGkgJiYgcyA8IGEsIF8gPSBuICYmIHMgPiBhO1xuICByZXR1cm4gbCB8fCBwIHx8IHUgfHwgXztcbn1cbmZ1bmN0aW9uIF9mKHMsIHQsIGUsIGksIG4sIG8sIHIsIGEpIHtcbiAgY29uc3QgbCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpO1xuICByZXR1cm4gbC5zZXRIb3VycygwLCAwLCAwLCAwKSwgKHMgJiYgbyAmJiBSZShvLCBsKSA8IDAgfHwgcykgJiYgKG8gPSBsKSwgbyAmJiBEaShcbiAgICB0LFxuICAgIG8sXG4gICAgZSxcbiAgICBpLFxuICAgIG4sXG4gICAgbyxcbiAgICByLFxuICAgIGFcbiAgKTtcbn1cbmZ1bmN0aW9uIGZmKHMsIHQsIGUsIGksIG4sIG8sIHIsIGEpIHtcbiAgY29uc3QgbCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpO1xuICByZXR1cm4gbC5zZXRIb3VycygwLCAwLCAwLCAwKSwgKHMgJiYgbiAmJiBSZShuLCBsKSA8IDAgfHwgcykgJiYgKG4gPSBsKSwgbiAmJiBEaShcbiAgICB0LFxuICAgIG4sXG4gICAgZSxcbiAgICBpLFxuICAgIG4sXG4gICAgbyxcbiAgICByLFxuICAgIGFcbiAgKTtcbn1cbmZ1bmN0aW9uIERpKHMsIHQsIGUsIGksIG4sIG8sIHIsIGEpIHtcbiAgcmV0dXJuIGUgPT09IFwiZGF5c1wiID8gQihzKSA9PT0gQih0KSAmJiBZKHMpID09PSBZKHQpIDogZSA9PT0gXCJtb250aHNcIiA/IEIocykgPT09IEIodCkgOiBlID09PSBcInllYXJzXCIgPyBCKHQpID49IGEgJiYgQih0KSA8PSByIDogITE7XG59XG5jb25zdCBtZiA9IFwiZGF0YS10ZS1kYXRlcGlja2VyLW1vZGFsLWNvbnRhaW5lci1yZWZcIiwgZ2YgPSBcImRhdGEtdGUtZGF0ZXBpY2tlci1kcm9wZG93bi1jb250YWluZXItcmVmXCIsIGJmID0gXCJkYXRhLXRlLWRyb3Bkb3duLWJhY2tkcm9wLXJlZlwiLCB2ZiA9IFwiZGF0YS10ZS1kYXRlcGlja2VyLWRhdGUtdGV4dC1yZWZcIiwgU2EgPSBcImRhdGEtdGUtZGF0ZXBpY2tlci12aWV3LXJlZlwiLCBUZiA9IFwiZGF0YS10ZS1kYXRlcGlja2VyLXByZXZpb3VzLWJ1dHRvbi1yZWZcIiwgRWYgPSBcImRhdGEtdGUtZGF0ZXBpY2tlci1uZXh0LWJ1dHRvbi1yZWZcIiwgQ2YgPSBcImRhdGEtdGUtZGF0ZXBpY2tlci1vay1idXR0b24tcmVmXCIsIEFmID0gXCJkYXRhLXRlLWRhdGVwaWNrZXItY2FuY2VsLWJ1dHRvbi1yZWZcIiwgeWYgPSBcImRhdGEtdGUtZGF0ZXBpY2tlci1jbGVhci1idXR0b24tcmVmXCIsIHdmID0gXCJkYXRhLXRlLWRhdGVwaWNrZXItdmlldy1jaGFuZ2UtYnV0dG9uLXJlZlwiO1xuZnVuY3Rpb24ga2YocywgdCwgZSwgaSwgbiwgbywgciwgYSwgbCwgcCkge1xuICBjb25zdCB1ID0gWShzKSwgXyA9IEIocyksIGYgPSBaKHMpLCBnID0gVnMocyksIG0gPSAkKFwiZGl2XCIpLCBiID0gYFxuICAgICAgICAke0lhKFxuICAgIHMsXG4gICAgdSxcbiAgICBfLFxuICAgIHQsXG4gICAgZSxcbiAgICBpLFxuICAgIG4sXG4gICAgbyxcbiAgICByLFxuICAgIGEsXG4gICAgcFxuICApfVxuICAgIGAsIHYgPSBgXG4gICAgICAke09mKGYsIGcsIHUsIG4sIHApfVxuICAgICAgJHtJYShcbiAgICBzLFxuICAgIHUsXG4gICAgXyxcbiAgICB0LFxuICAgIGUsXG4gICAgaSxcbiAgICBuLFxuICAgIG8sXG4gICAgcixcbiAgICBhLFxuICAgIHBcbiAgKX1cbiAgICBgO1xuICByZXR1cm4gbi5pbmxpbmUgPyAoaC5hZGRDbGFzcyhtLCBwLmRhdGVwaWNrZXJEcm9wZG93bkNvbnRhaW5lciksIG0uc2V0QXR0cmlidXRlKGdmLCBsKSwgbS5pbm5lckhUTUwgPSBiKSA6IChoLmFkZENsYXNzKG0sIHAubW9kYWxDb250YWluZXIpLCBtLnNldEF0dHJpYnV0ZShtZiwgbCksIG0uaW5uZXJIVE1MID0gdiksIG07XG59XG5mdW5jdGlvbiB4ZihzKSB7XG4gIGNvbnN0IHQgPSAkKFwiZGl2XCIpO1xuICByZXR1cm4gaC5hZGRDbGFzcyh0LCBzKSwgdC5zZXRBdHRyaWJ1dGUoYmYsIFwiXCIpLCB0O1xufVxuZnVuY3Rpb24gT2YocywgdCwgZSwgaSwgbikge1xuICByZXR1cm4gYFxuICAgICAgPGRpdiBjbGFzcz1cIiR7bi5kYXRlcGlja2VySGVhZGVyfVwiIGRhdGEtdGUtZGF0ZXBpY2tlci1oZWFkZXI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCIke24uZGF0ZXBpY2tlclRpdGxlfVwiPlxuICAgICAgICAgIDxzcGFuIGNsYXNzPVwiJHtuLmRhdGVwaWNrZXJUaXRsZVRleHR9XCI+JHtpLnRpdGxlfTwvc3Bhbj5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxkaXYgY2xhc3M9XCIke24uZGF0ZXBpY2tlckRhdGV9XCI+XG4gICAgICAgICAgPHNwYW4gY2xhc3M9XCIke24uZGF0ZXBpY2tlckRhdGVUZXh0fVwiICR7dmZ9ID4ke2kud2Vla2RheXNTaG9ydFt0XX0sICR7aS5tb250aHNTaG9ydFtlXX0gJHtzfTwvc3Bhbj5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICBgO1xufVxuZnVuY3Rpb24gSWEocywgdCwgZSwgaSwgbiwgbywgciwgYSwgbCwgcCwgdSkge1xuICBsZXQgXztcbiAgcmV0dXJuIHIuaW5saW5lID8gXyA9IGBcbiAgICA8ZGl2IGNsYXNzPVwiJHt1LmRhdGVwaWNrZXJNYWlufVwiPlxuICAgICAgJHskYSh0LCBlLCByLCB1KX1cbiAgICAgIDxkaXYgY2xhc3M9XCIke3UuZGF0ZXBpY2tlclZpZXd9XCIgJHtTYX0gdGFiaW5kZXg9XCIwXCI+XG4gICAgICAgICR7RGEoXG4gICAgcyxcbiAgICBlLFxuICAgIGksXG4gICAgbixcbiAgICBvLFxuICAgIHIsXG4gICAgYSxcbiAgICBsLFxuICAgIHAsXG4gICAgdVxuICApfVxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gIGAgOiBfID0gYFxuICAgIDxkaXYgY2xhc3M9XCIke3UuZGF0ZXBpY2tlck1haW59XCI+XG4gICAgICAkeyRhKHQsIGUsIHIsIHUpfVxuICAgICAgPGRpdiBjbGFzcz1cIiR7dS5kYXRlcGlja2VyVmlld31cIiAke1NhfSB0YWJpbmRleD1cIjBcIj5cbiAgICAgICAgJHtEYShcbiAgICBzLFxuICAgIGUsXG4gICAgaSxcbiAgICBuLFxuICAgIG8sXG4gICAgcixcbiAgICBhLFxuICAgIGwsXG4gICAgcCxcbiAgICB1XG4gICl9XG4gICAgICA8L2Rpdj5cbiAgICAgICR7U2YociwgdSl9XG4gICAgPC9kaXY+XG4gIGAsIF87XG59XG5mdW5jdGlvbiBEYShzLCB0LCBlLCBpLCBuLCBvLCByLCBhLCBsLCBwKSB7XG4gIGxldCB1O1xuICByZXR1cm4gby52aWV3ID09PSBcImRheXNcIiA/IHUgPSBGcyhzLCBlLCBvLCBwKSA6IG8udmlldyA9PT0gXCJtb250aHNcIiA/IHUgPSBZcyhcbiAgICB0LFxuICAgIGksXG4gICAgbixcbiAgICBvLFxuICAgIHIsXG4gICAgcFxuICApIDogdSA9IGpzKFxuICAgIHMsXG4gICAgaSxcbiAgICBvLFxuICAgIGEsXG4gICAgbCxcbiAgICBwXG4gICksIHU7XG59XG5mdW5jdGlvbiAkYShzLCB0LCBlLCBpKSB7XG4gIHJldHVybiBgXG4gICAgPGRpdiBjbGFzcz1cIiR7aS5kYXRlcGlja2VyRGF0ZUNvbnRyb2xzfVwiPlxuICAgICAgPGJ1dHRvbiBjbGFzcz1cIiR7aS5kYXRlcGlja2VyVmlld0NoYW5nZUJ1dHRvbn1cIiBhcmlhLWxhYmVsPVwiJHtlLnN3aXRjaFRvTXVsdGlZZWFyVmlld0xhYmVsfVwiICR7d2Z9PlxuICAgICAgICAke2UubW9udGhzRnVsbFtzXX0gJHt0fSAkeyR0KFxuICAgIGUsXG4gICAgaVxuICApfVxuICAgICAgPC9idXR0b24+XG4gICAgICA8ZGl2IGNsYXNzPVwiJHtpLmRhdGVwaWNrZXJBcnJvd0NvbnRyb2xzfVwiPlxuICAgICAgICA8YnV0dG9uIGNsYXNzPVwiJHtpLmRhdGVwaWNrZXJQcmV2aW91c0J1dHRvbn1cIiBhcmlhLWxhYmVsPVwiJHtlLnByZXZNb250aExhYmVsfVwiICR7VGZ9PiR7ZS5jaGFuZ2VNb250aEljb25UZW1wbGF0ZX08L2J1dHRvbj5cbiAgICAgICAgPGJ1dHRvbiBjbGFzcz1cIiR7aS5kYXRlcGlja2VyTmV4dEJ1dHRvbn1cIiBhcmlhLWxhYmVsPVwiJHtlLm5leHRNb250aExhYmVsfVwiICR7RWZ9PiR7ZS5jaGFuZ2VNb250aEljb25UZW1wbGF0ZX08L2J1dHRvbj5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICAgIGA7XG59XG5mdW5jdGlvbiAkdChzLCB0KSB7XG4gIHJldHVybiBgXG4gIDxzcGFuIGNsYXNzPVwiJHt0LmRhdGVwaWNrZXJWaWV3Q2hhbmdlSWNvbn1cIj5cbiAgJHtzLnZpZXdDaGFuZ2VJY29uVGVtcGxhdGV9XG4gIDwvc3Bhbj5cbiAgYDtcbn1cbmZ1bmN0aW9uIFNmKHMsIHQpIHtcbiAgY29uc3QgZSA9IGA8YnV0dG9uIGNsYXNzPVwiJHt0LmRhdGVwaWNrZXJGb290ZXJCdG59XCIgYXJpYS1sYWJlbD1cIiR7cy5va0J0bkxhYmVsfVwiICR7Q2Z9PiR7cy5va0J0blRleHR9PC9idXR0b24+YCwgaSA9IGA8YnV0dG9uIGNsYXNzPVwiJHt0LmRhdGVwaWNrZXJGb290ZXJCdG59XCIgYXJpYS1sYWJlbD1cIiR7cy5jYW5jZWxCdG5MYWJlbH1cIiAke0FmfT4ke3MuY2FuY2VsQnRuVGV4dH08L2J1dHRvbj5gLCBuID0gYDxidXR0b24gY2xhc3M9XCIke3QuZGF0ZXBpY2tlckZvb3RlckJ0bn0gJHt0LmRhdGVwaWNrZXJDbGVhckJ0bn1cIiBhcmlhLWxhYmVsPVwiJHtzLmNsZWFyQnRuTGFiZWx9XCIgJHt5Zn0+JHtzLmNsZWFyQnRuVGV4dH08L2J1dHRvbj5gO1xuICByZXR1cm4gYFxuICAgICAgICA8ZGl2IGNsYXNzPVwiJHt0LmRhdGVwaWNrZXJGb290ZXJ9XCI+XG4gICAgICAgICAgXG4gICAgICAgICR7cy5yZW1vdmVDbGVhckJ0biA/IFwiXCIgOiBufVxuICAgICAgICAke3MucmVtb3ZlQ2FuY2VsQnRuID8gXCJcIiA6IGl9XG4gICAgICAgICR7cy5yZW1vdmVPa0J0biA/IFwiXCIgOiBlfVxuICAgICAgICA8L2Rpdj5cbiAgICAgIGA7XG59XG5mdW5jdGlvbiBGcyhzLCB0LCBlLCBpKSB7XG4gIGNvbnN0IG4gPSBJZihzLCB0LCBlKSwgciA9IGBcbiAgICAgIDx0cj5cbiAgICAgICAgJHtlLndlZWtkYXlzTmFycm93Lm1hcCgobCwgcCkgPT4gYDx0aCBjbGFzcz1cIiR7aS5kYXRlcGlja2VyRGF5SGVhZGluZ31cIiBzY29wZT1cImNvbFwiIGFyaWEtbGFiZWw9XCIke2Uud2Vla2RheXNGdWxsW3BdfVwiPiR7bH08L3RoPmApLmpvaW4oXCJcIil9XG4gICAgICA8L3RyPlxuICAgIGAsIGEgPSBuLm1hcCgobCkgPT4gYFxuICAgICAgICA8dHI+XG4gICAgICAgICAgJHtsLm1hcCgocCkgPT4gYFxuICAgICAgICAgICAgICA8dGRcbiAgICAgICAgICAgICAgY2xhc3M9XCIke2kuZGF0ZXBpY2tlckNlbGx9ICR7aS5kYXRlcGlja2VyQ2VsbFNtYWxsfVwiXG4gICAgICAgICAgICAgIGRhdGEtdGUtZGF0ZT1cIiR7QihwLmRhdGUpfS0ke1koXG4gICAgcC5kYXRlXG4gICl9LSR7WihwLmRhdGUpfVwiXG4gICAgICAgICAgICAgIGFyaWEtbGFiZWw9XCIke3AuZGF0ZX1cIlxuICAgICAgICAgICAgICBhcmlhLXNlbGVjdGVkPVwiJHtwLmlzU2VsZWN0ZWR9XCJcbiAgICAgICAgICAgICAgJHtwLmlzU2VsZWN0ZWQgPyBcImRhdGEtdGUtZGF0ZXBpY2tlci1jZWxsLXNlbGVjdGVkXCIgOiBcIlwifVxuICAgICAgICAgICAgICAkeyFwLmN1cnJlbnRNb250aCB8fCBwLmRpc2FibGVkID8gXCJkYXRhLXRlLWRhdGVwaWNrZXItY2VsbC1kaXNhYmxlZFwiIDogXCJcIn1cbiAgICAgICAgICAgICAgJHtwLmlzVG9kYXkgPyBcImRhdGEtdGUtZGF0ZXBpY2tlci1jZWxsLWN1cnJlbnRcIiA6IFwiXCJ9XG4gICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICAgICAgICBjbGFzcz1cIiR7aS5kYXRlcGlja2VyQ2VsbENvbnRlbnR9ICR7aS5kYXRlcGlja2VyQ2VsbENvbnRlbnRTbWFsbH1cIlxuICAgICAgICAgICAgICAgICAgc3R5bGU9XCIke3AuY3VycmVudE1vbnRoID8gXCJkaXNwbGF5OiBibG9ja1wiIDogXCJkaXNwbGF5OiBub25lXCJ9XCJcbiAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICR7cC5kYXlOdW1iZXJ9XG4gICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgPC90ZD5cbiAgICAgICAgICAgIGApLmpvaW4oXCJcIil9XG4gICAgICAgIDwvdHI+XG4gICAgICBgKS5qb2luKFwiXCIpO1xuICByZXR1cm4gYFxuICAgICAgPHRhYmxlIGNsYXNzPVwiJHtpLmRhdGVwaWNrZXJUYWJsZX1cIj5cbiAgICAgICAgPHRoZWFkPlxuICAgICAgICAgICR7cn1cbiAgICAgICAgPC90aGVhZD5cbiAgICAgICAgPHRib2R5PlxuICAgICAgICAgJHthfVxuICAgICAgICA8L3Rib2R5PlxuICAgICAgPC90YWJsZT5cbiAgICBgO1xufVxuZnVuY3Rpb24gSWYocywgdCwgZSkge1xuICBjb25zdCBpID0gW10sIG4gPSBZKHMpLCBvID0gWShudChzLCAtMSkpLCByID0gWShudChzLCAxKSksIGEgPSBCKHMpLCBsID0gY2YoYSwgbiwgZSksIHAgPSBQbyhzKSwgdSA9IFBvKG50KHMsIC0xKSksIF8gPSA3O1xuICBsZXQgZiA9IDEsIGcgPSAhMTtcbiAgZm9yIChsZXQgbSA9IDE7IG0gPCBfOyBtKyspIHtcbiAgICBjb25zdCBiID0gW107XG4gICAgaWYgKG0gPT09IDEpIHtcbiAgICAgIGNvbnN0IHYgPSB1IC0gbCArIDE7XG4gICAgICBmb3IgKGxldCB3ID0gdjsgdyA8PSB1OyB3KyspIHtcbiAgICAgICAgY29uc3QgRSA9IEV0KGEsIG8sIHcpO1xuICAgICAgICBiLnB1c2goe1xuICAgICAgICAgIGRhdGU6IEUsXG4gICAgICAgICAgY3VycmVudE1vbnRoOiBnLFxuICAgICAgICAgIGlzU2VsZWN0ZWQ6IHQgJiYgZmUoRSwgdCksXG4gICAgICAgICAgaXNUb2RheTogZmUoRSwgQmUoKSksXG4gICAgICAgICAgZGF5TnVtYmVyOiBaKEUpXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgZyA9ICEwO1xuICAgICAgY29uc3QgQyA9IF8gLSBiLmxlbmd0aDtcbiAgICAgIGZvciAobGV0IHcgPSAwOyB3IDwgQzsgdysrKSB7XG4gICAgICAgIGNvbnN0IEUgPSBFdChhLCBuLCBmKTtcbiAgICAgICAgYi5wdXNoKHtcbiAgICAgICAgICBkYXRlOiBFLFxuICAgICAgICAgIGN1cnJlbnRNb250aDogZyxcbiAgICAgICAgICBpc1NlbGVjdGVkOiB0ICYmIGZlKEUsIHQpLFxuICAgICAgICAgIGlzVG9kYXk6IGZlKEUsIEJlKCkpLFxuICAgICAgICAgIGRheU51bWJlcjogWihFKSxcbiAgICAgICAgICBkaXNhYmxlZDogbm4oXG4gICAgICAgICAgICBFLFxuICAgICAgICAgICAgZS5taW4sXG4gICAgICAgICAgICBlLm1heCxcbiAgICAgICAgICAgIGUuZmlsdGVyLFxuICAgICAgICAgICAgZS5kaXNhYmxlUGFzdCxcbiAgICAgICAgICAgIGUuZGlzYWJsZUZ1dHVyZVxuICAgICAgICAgIClcbiAgICAgICAgfSksIGYrKztcbiAgICAgIH1cbiAgICB9IGVsc2VcbiAgICAgIGZvciAobGV0IHYgPSAxOyB2IDwgODsgdisrKSB7XG4gICAgICAgIGYgPiBwICYmIChmID0gMSwgZyA9ICExKTtcbiAgICAgICAgY29uc3QgQyA9IEV0KFxuICAgICAgICAgIGEsXG4gICAgICAgICAgZyA/IG4gOiByLFxuICAgICAgICAgIGZcbiAgICAgICAgKTtcbiAgICAgICAgYi5wdXNoKHtcbiAgICAgICAgICBkYXRlOiBDLFxuICAgICAgICAgIGN1cnJlbnRNb250aDogZyxcbiAgICAgICAgICBpc1NlbGVjdGVkOiB0ICYmIGZlKEMsIHQpLFxuICAgICAgICAgIGlzVG9kYXk6IGZlKEMsIEJlKCkpLFxuICAgICAgICAgIGRheU51bWJlcjogWihDKSxcbiAgICAgICAgICBkaXNhYmxlZDogbm4oXG4gICAgICAgICAgICBDLFxuICAgICAgICAgICAgZS5taW4sXG4gICAgICAgICAgICBlLm1heCxcbiAgICAgICAgICAgIGUuZmlsdGVyLFxuICAgICAgICAgICAgZS5kaXNhYmxlUGFzdCxcbiAgICAgICAgICAgIGUuZGlzYWJsZUZ1dHVyZVxuICAgICAgICAgIClcbiAgICAgICAgfSksIGYrKztcbiAgICAgIH1cbiAgICBpLnB1c2goYik7XG4gIH1cbiAgcmV0dXJuIGk7XG59XG5mdW5jdGlvbiBZcyhzLCB0LCBlLCBpLCBuLCBvKSB7XG4gIGNvbnN0IHIgPSBEZihpLCBuKSwgYSA9IFkoQmUoKSksIGwgPSBCKEJlKCkpLCBwID0gYFxuICAgICAgJHtyLm1hcCgodSkgPT4gYFxuICAgICAgICAgIDx0cj5cbiAgICAgICAgICAgICR7dS5tYXAoKF8pID0+IHtcbiAgICBjb25zdCBmID0gaS5tb250aHNTaG9ydC5pbmRleE9mKF8pO1xuICAgIHJldHVybiBgXG4gICAgICAgICAgICAgICAgPHRkIGNsYXNzPVwiJHtvLmRhdGVwaWNrZXJDZWxsfSAke28uZGF0ZXBpY2tlckNlbGxMYXJnZX1cIlxuICAgICAgICAgICAgICAgICR7emMoXG4gICAgICBmLFxuICAgICAgcyxcbiAgICAgIGkubWluLFxuICAgICAgaS5tYXgsXG4gICAgICBpLmRpc2FibGVQYXN0LFxuICAgICAgaS5kaXNhYmxlRnV0dXJlXG4gICAgKSA/IFwiZGF0YS10ZS1kYXRlcGlja2VyLWNlbGwtZGlzYWJsZWRcIiA6IFwiXCJ9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgZGF0YS10ZS1tb250aD1cIiR7Zn1cIiBkYXRhLXRlLXllYXI9XCIke3N9XCIgYXJpYS1sYWJlbD1cIiR7X30sICR7c31cIlxuICAgICAgICAgICAgICAgICR7ZiA9PT0gZSAmJiBzID09PSB0ID8gXCJkYXRhLXRlLWRhdGVwaWNrZXItY2VsbC1zZWxlY3RlZFwiIDogXCJcIn1cbiAgICAgICAgICAgICAgICAke2YgPT09IGEgJiYgcyA9PT0gbCA/IFwiZGF0YS10ZS1kYXRlcGlja2VyLWNlbGwtY3VycmVudFwiIDogXCJcIn1cIiBkYXRhLXRlLW1vbnRoPVwiJHtmfVwiIGRhdGEtdGUteWVhcj1cIiR7c31cIiBhcmlhLWxhYmVsPVwiJHtffSwgJHtzfVwiPlxuICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cIiR7by5kYXRlcGlja2VyQ2VsbENvbnRlbnR9ICR7by5kYXRlcGlja2VyQ2VsbENvbnRlbnRMYXJnZX1cIj4ke199PC9kaXY+XG4gICAgICAgICAgICAgICAgPC90ZD5cbiAgICAgICAgICAgICAgYDtcbiAgfSkuam9pbihcIlwiKX1cbiAgICAgICAgICA8L3RyPlxuICAgICAgICBgKS5qb2luKFwiXCIpfVxuICAgIGA7XG4gIHJldHVybiBgXG4gICAgICA8dGFibGUgY2xhc3M9XCIke28uZGF0ZXBpY2tlclRhYmxlfVwiPlxuICAgICAgICA8dGJvZHk+XG4gICAgICAgICAke3B9XG4gICAgICAgIDwvdGJvZHk+XG4gICAgICA8L3RhYmxlPlxuICAgIGA7XG59XG5mdW5jdGlvbiBEZihzLCB0KSB7XG4gIGNvbnN0IGUgPSBbXTtcbiAgbGV0IGkgPSBbXTtcbiAgZm9yIChsZXQgbiA9IDA7IG4gPCBzLm1vbnRoc1Nob3J0Lmxlbmd0aDsgbisrKVxuICAgIGlmIChpLnB1c2gocy5tb250aHNTaG9ydFtuXSksIGkubGVuZ3RoID09PSB0KSB7XG4gICAgICBjb25zdCBvID0gaTtcbiAgICAgIGUucHVzaChvKSwgaSA9IFtdO1xuICAgIH1cbiAgcmV0dXJuIGU7XG59XG5mdW5jdGlvbiBqcyhzLCB0LCBlLCBpLCBuLCBvKSB7XG4gIGNvbnN0IHIgPSAkZihzLCBpLCBuKSwgYSA9IEIoQmUoKSksIGwgPSBgXG4gICAgJHtyLm1hcCgocCkgPT4gYFxuICAgICAgICA8dHI+XG4gICAgICAgICAgJHtwLm1hcCgodSkgPT4gYFxuICAgICAgICAgICAgICA8dGQgY2xhc3M9XCIke28uZGF0ZXBpY2tlckNlbGx9ICR7by5kYXRlcGlja2VyQ2VsbExhcmdlfVwiICBhcmlhLWxhYmVsPVwiJHt1fVwiIGRhdGEtdGUteWVhcj1cIiR7dX1cIlxuICAgICAgICAgICAgICAke0JvKFxuICAgIHUsXG4gICAgZS5taW4sXG4gICAgZS5tYXgsXG4gICAgZS5kaXNhYmxlUGFzdCxcbiAgICBlLmRpc2FibGVGdXR1cmVcbiAgKSA/IFwiZGF0YS10ZS1kYXRlcGlja2VyLWNlbGwtZGlzYWJsZWRcIiA6IFwiXCJ9XG4gICAgICAgICAgICAgICR7dSA9PT0gdCA/IFwiZGF0YS10ZS1kYXRlcGlja2VyLWNlbGwtc2VsZWN0ZWRcIiA6IFwiXCJ9XG4gICAgICAgICAgICAgICR7dSA9PT0gYSA/IFwiZGF0YS10ZS1kYXRlcGlja2VyLWNlbGwtY3VycmVudFwiIDogXCJcIn1cbiAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCIke28uZGF0ZXBpY2tlckNlbGxDb250ZW50fSAke28uZGF0ZXBpY2tlckNlbGxDb250ZW50TGFyZ2V9XCI+JHt1fTwvZGl2PlxuICAgICAgICAgICAgICA8L3RkPlxuICAgICAgICAgICAgYCkuam9pbihcIlwiKX1cbiAgICAgICAgPC90cj5cbiAgICAgIGApLmpvaW4oXCJcIil9XG4gIGA7XG4gIHJldHVybiBgXG4gICAgICA8dGFibGUgY2xhc3M9XCIke28uZGF0ZXBpY2tlclRhYmxlfVwiPlxuICAgICAgICA8dGJvZHk+XG4gICAgICAgICR7bH1cbiAgICAgICAgPC90Ym9keT5cbiAgICAgIDwvdGFibGU+XG4gICAgYDtcbn1cbmZ1bmN0aW9uICRmKHMsIHQsIGUpIHtcbiAgY29uc3QgaSA9IFtdLCBuID0gQihzKSwgbyA9IFdzKHMsIHQpLCByID0gbiAtIG87XG4gIGxldCBhID0gW107XG4gIGZvciAobGV0IGwgPSAwOyBsIDwgdDsgbCsrKVxuICAgIGlmIChhLnB1c2gociArIGwpLCBhLmxlbmd0aCA9PT0gZSkge1xuICAgICAgY29uc3QgcCA9IGE7XG4gICAgICBpLnB1c2gocCksIGEgPSBbXTtcbiAgICB9XG4gIHJldHVybiBpO1xufVxuZnVuY3Rpb24gTGYocywgdCkge1xuICByZXR1cm4gYFxuICAgIDxidXR0b24gaWQ9XCIke3N9XCIgdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiJHt0fVwiIGRhdGEtdGUtZGF0ZXBpY2tlci10b2dnbGUtYnV0dG9uLXJlZiBkYXRhLXRlLWRhdGVwaWNrZXItdG9nZ2xlLXJlZj5cbiAgICAgIDxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBmaWxsPVwiY3VycmVudENvbG9yXCI+XG4gICAgICA8cGF0aCBmaWxsLXJ1bGU9XCJldmVub2RkXCIgZD1cIk02Ljc1IDIuMjVBLjc1Ljc1IDAgMDE3LjUgM3YxLjVoOVYzQS43NS43NSAwIDAxMTggM3YxLjVoLjc1YTMgMyAwIDAxMyAzdjExLjI1YTMgMyAwIDAxLTMgM0g1LjI1YTMgMyAwIDAxLTMtM1Y3LjVhMyAzIDAgMDEzLTNINlYzYS43NS43NSAwIDAxLjc1LS43NXptMTMuNSA5YTEuNSAxLjUgMCAwMC0xLjUtMS41SDUuMjVhMS41IDEuNSAwIDAwLTEuNSAxLjV2Ny41YTEuNSAxLjUgMCAwMDEuNSAxLjVoMTMuNWExLjUgMS41IDAgMDAxLjUtMS41di03LjV6XCIgY2xpcC1ydWxlPVwiZXZlbm9kZFwiIC8+XG4gICAgICA8L3N2Zz4gIFxuICAgIDwvYnV0dG9uPlxuICBgO1xufVxuY29uc3QgSGUgPSAzNywgYXQgPSAzOCwgVmUgPSAzOSwgeiA9IDQwLCBXZSA9IDM2LCBGZSA9IDM1LCB6biA9IDMzLCBVbiA9IDM0LCBjdCA9IDEzLCBLcyA9IDMyLCBGaSA9IDI3LCBQaSA9IDksIE5mID0gOCwgTWYgPSA0NiwgdnQgPSAyNCwgbHMgPSA0LCBjcyA9IDQsIFhuID0gXCJkYXRlcGlja2VyXCIsIHpzID0gXCJ0ZS5kYXRlcGlja2VyXCIsIGRuID0gYC4ke3pzfWAsIFJmID0gXCIuZGF0YS1hcGlcIiwgUGYgPSBgY2xvc2Uke2RufWAsIEJmID0gYG9wZW4ke2RufWAsIEhmID0gYGRhdGVDaGFuZ2Uke2RufWAsIGhzID0gYGNsaWNrJHtkbn0ke1JmfWAsIFVjID0gXCJkYXRhLXRlLWRhdGVwaWNrZXItbW9kYWwtY29udGFpbmVyLXJlZlwiLCBYYyA9IFwiZGF0YS10ZS1kYXRlcGlja2VyLWRyb3Bkb3duLWNvbnRhaW5lci1yZWZcIiwgZHMgPSBcIltkYXRhLXRlLWRhdGVwaWNrZXItdG9nZ2xlLXJlZl1cIiwgVmYgPSBgWyR7VWN9XWAsIFdmID0gYFske1hjfV1gLCBGZiA9IFwiW2RhdGEtdGUtZGF0ZXBpY2tlci12aWV3LWNoYW5nZS1idXR0b24tcmVmXVwiLCBZZiA9IFwiW2RhdGEtdGUtZGF0ZXBpY2tlci1wcmV2aW91cy1idXR0b24tcmVmXVwiLCBqZiA9IFwiW2RhdGEtdGUtZGF0ZXBpY2tlci1uZXh0LWJ1dHRvbi1yZWZdXCIsIEtmID0gXCJbZGF0YS10ZS1kYXRlcGlja2VyLW9rLWJ1dHRvbi1yZWZdXCIsIHpmID0gXCJbZGF0YS10ZS1kYXRlcGlja2VyLWNhbmNlbC1idXR0b24tcmVmXVwiLCBVZiA9IFwiW2RhdGEtdGUtZGF0ZXBpY2tlci1jbGVhci1idXR0b24tcmVmXVwiLCBYZiA9IFwiW2RhdGEtdGUtZGF0ZXBpY2tlci12aWV3LXJlZl1cIiwgR2YgPSBcIltkYXRhLXRlLWRhdGVwaWNrZXItdG9nZ2xlLWJ1dHRvbi1yZWZdXCIsIHFmID0gXCJbZGF0YS10ZS1kYXRlcGlja2VyLWRhdGUtdGV4dC1yZWZdXCIsIFpmID0gXCJbZGF0YS10ZS1kcm9wZG93bi1iYWNrZHJvcC1yZWZdXCIsIFFmID0gXCJhbmltYXRlLVtmYWRlLWluXzAuM3NfYm90aF0gcHgtW2F1dG9dIG1vdGlvbi1yZWR1Y2U6dHJhbnNpdGlvbi1ub25lIG1vdGlvbi1yZWR1Y2U6YW5pbWF0ZS1ub25lXCIsIEpmID0gXCJhbmltYXRlLVtmYWRlLW91dF8wLjNzX2JvdGhdIHB4LVthdXRvXSBtb3Rpb24tcmVkdWNlOnRyYW5zaXRpb24tbm9uZSBtb3Rpb24tcmVkdWNlOmFuaW1hdGUtbm9uZVwiLCB0bSA9IFwiYW5pbWF0ZS1bZmFkZS1pbl8wLjE1c19ib3RoXSBweC1bYXV0b10gbW90aW9uLXJlZHVjZTp0cmFuc2l0aW9uLW5vbmUgbW90aW9uLXJlZHVjZTphbmltYXRlLW5vbmVcIiwgZW0gPSBcImFuaW1hdGUtW2ZhZGUtb3V0XzAuMTVzX2JvdGhdIHB4LVthdXRvXSBtb3Rpb24tcmVkdWNlOnRyYW5zaXRpb24tbm9uZSBtb3Rpb24tcmVkdWNlOmFuaW1hdGUtbm9uZVwiLCBpbSA9IFwiZmxleCBmbGV4LWNvbCBmaXhlZCB0b3AtMS8yIGxlZnQtMS8yIC10cmFuc2xhdGUteC0xLzIgLXRyYW5zbGF0ZS15LTEvMiB3LVszMjhweF0gaC1bNTEycHhdIGJnLXdoaXRlIHJvdW5kZWQtWzAuNnJlbV0gc2hhZG93LWxnIHotWzEwNjZdIHhzOm1heC1tZDpsYW5kc2NhcGU6dy1bNDc1cHhdIHhzOm1heC1tZDpsYW5kc2NhcGU6aC1bMzYwcHhdIHhzOm1heC1tZDpsYW5kc2NhcGU6ZmxleC1yb3cgZGFyazpiZy16aW5jLTcwMFwiLCBzbSA9IFwidy1mdWxsIGgtZnVsbCBmaXhlZCB0b3AtMCByaWdodC0wIGxlZnQtMCBib3R0b20tMCBiZy1ibGFjay80MCB6LVsxMDY1XVwiLCBubSA9IFwicmVsYXRpdmUgaC1mdWxsXCIsIG9tID0gXCJ4czptYXgtbWQ6bGFuZHNjYXBlOmgtZnVsbCBoLVsxMjBweF0gcHgtNiBiZy1wcmltYXJ5IGZsZXggZmxleC1jb2wgcm91bmRlZC10LWxnIGRhcms6YmctemluYy04MDBcIiwgcm0gPSBcImgtOCBmbGV4IGZsZXgtY29sIGp1c3RpZnktZW5kXCIsIGFtID0gXCJ0ZXh0LVsxMHB4XSBmb250LW5vcm1hbCB1cHBlcmNhc2UgdHJhY2tpbmctWzEuN3B4XSB0ZXh0LXdoaXRlXCIsIGxtID0gXCJ4czptYXgtbWQ6bGFuZHNjYXBlOm10LTI0IGgtWzcycHhdIGZsZXggZmxleC1jb2wganVzdGlmeS1lbmRcIiwgY20gPSBcInRleHQtWzM0cHhdIGZvbnQtbm9ybWFsIHRleHQtd2hpdGVcIiwgaG0gPSBcIm91dGxpbmUtbm9uZSBweC0zXCIsIGRtID0gXCJweC0zIHB0LTIuNSBwYi0wIGZsZXgganVzdGlmeS1iZXR3ZWVuIHRleHQtYmxhY2svWzY0XVwiLCB1bSA9IFwiZmxleCBpdGVtcy1jZW50ZXIgb3V0bGluZS1ub25lIHAtMi41IHRleHQtbmV1dHJhbC01MDAgZm9udC1tZWRpdW0gdGV4dC1bMC45cmVtXSByb3VuZGVkLXhsIHNoYWRvdy1ub25lIGJnLXRyYW5zcGFyZW50IG0tMCBib3JkZXItbm9uZSBob3ZlcjpiZy1uZXV0cmFsLTIwMCBmb2N1czpiZy1uZXV0cmFsLTIwMCAgZGFyazp0ZXh0LXdoaXRlIGRhcms6aG92ZXI6Ymctd2hpdGUvMTAgZGFyazpmb2N1czpiZy13aGl0ZS8xMFwiLCBwbSA9IFwibXQtMi41XCIsIF9tID0gXCJwLTAgdy0xMCBoLTEwIGxlYWRpbmctMTAgYm9yZGVyLW5vbmUgb3V0bGluZS1ub25lIG0tMCB0ZXh0LWdyYXktNjAwIGJnLXRyYW5zcGFyZW50IG1yLTYgaG92ZXI6YmctbmV1dHJhbC0yMDAgaG92ZXI6cm91bmRlZC1bNTAlXSBmb2N1czpiZy1uZXV0cmFsLTIwMCBmb2N1czpyb3VuZGVkLVs1MCVdIGRhcms6dGV4dC13aGl0ZSBkYXJrOmhvdmVyOmJnLXdoaXRlLzEwIGRhcms6Zm9jdXM6Ymctd2hpdGUvMTAgWyY+c3ZnXTp3LTQgWyY+c3ZnXTpoLTQgWyY+c3ZnXTpteC1hdXRvXCIsIGZtID0gXCJwLTAgdy0xMCBoLTEwIGxlYWRpbmctMTAgYm9yZGVyLW5vbmUgb3V0bGluZS1ub25lIG0tMCB0ZXh0LWdyYXktNjAwIGJnLXRyYW5zcGFyZW50IGhvdmVyOmJnLW5ldXRyYWwtMjAwIGhvdmVyOnJvdW5kZWQtWzUwJV0gZm9jdXM6YmctbmV1dHJhbC0yMDAgZm9jdXM6cm91bmRlZC1bNTAlXSBkYXJrOnRleHQtd2hpdGUgZGFyazpob3ZlcjpiZy13aGl0ZS8xMCBkYXJrOmZvY3VzOmJnLXdoaXRlLzEwIFsmPnN2Z106dy00IFsmPnN2Z106aC00IFsmPnN2Z106cm90YXRlLTE4MCBbJj5zdmddOm14LWF1dG9cIiwgbW0gPSBcImgtMTQgZmxleCBhYnNvbHV0ZSB3LWZ1bGwgYm90dG9tLTAganVzdGlmeS1lbmQgaXRlbXMtY2VudGVyIHB4LTNcIiwgZ20gPSBcIm91dGxpbmUtbm9uZSBiZy13aGl0ZSB0ZXh0LXByaW1hcnkgYm9yZGVyLW5vbmUgY3Vyc29yLXBvaW50ZXIgcHktMCBweC0yLjUgdXBwZXJjYXNlIHRleHQtWzAuOHJlbV0gbGVhZGluZy0xMCBmb250LW1lZGl1bSBoLTEwIHRyYWNraW5nLVsuMXJlbV0gcm91bmRlZC1bMTBweF0gbWItMi41IGhvdmVyOmJnLW5ldXRyYWwtMjAwIGZvY3VzOmJnLW5ldXRyYWwtMjAwIGRhcms6YmctdHJhbnNwYXJlbnQgZGFyazp0ZXh0LXdoaXRlIGRhcms6aG92ZXI6Ymctd2hpdGUvMTAgZGFyazpmb2N1czpiZy13aGl0ZS8xMFwiLCBibSA9IFwibXItYXV0b1wiLCB2bSA9IFwidy0xMCBoLTEwIHRleHQtY2VudGVyIHRleHQtWzEycHhdIGZvbnQtbm9ybWFsIGRhcms6dGV4dC13aGl0ZVwiLCBUbSA9IFwidGV4dC1jZW50ZXIgZGF0YS1bdGUtZGF0ZXBpY2tlci1jZWxsLWRpc2FibGVkXTp0ZXh0LW5ldXRyYWwtMzAwIGRhdGEtW3RlLWRhdGVwaWNrZXItY2VsbC1kaXNhYmxlZF06Y3Vyc29yLWRlZmF1bHQgZGF0YS1bdGUtZGF0ZXBpY2tlci1jZWxsLWRpc2FibGVkXTpwb2ludGVyLWV2ZW50cy1ub25lIGRhdGEtW3RlLWRhdGVwaWNrZXItY2VsbC1kaXNhYmxlZF06aG92ZXI6Y3Vyc29yLWRlZmF1bHQgaG92ZXI6Y3Vyc29yLXBvaW50ZXIgZ3JvdXBcIiwgRW0gPSBcInctMTAgaC0xMCB4czptYXgtbWQ6bGFuZHNjYXBlOnctOCB4czptYXgtbWQ6bGFuZHNjYXBlOmgtOFwiLCBDbSA9IFwidy1bNzZweF0gaC1bNDJweF1cIiwgQW0gPSBcIm14LWF1dG8gZ3JvdXAtWzpub3QoW2RhdGEtdGUtZGF0ZXBpY2tlci1jZWxsLWRpc2FibGVkXSk6bm90KFtkYXRhLXRlLWRhdGVwaWNrZXItY2VsbC1zZWxlY3RlZF0pOmhvdmVyXTpiZy1uZXV0cmFsLTMwMCBncm91cC1bW2RhdGEtdGUtZGF0ZXBpY2tlci1jZWxsLXNlbGVjdGVkXV06YmctcHJpbWFyeSBncm91cC1bW2RhdGEtdGUtZGF0ZXBpY2tlci1jZWxsLXNlbGVjdGVkXV06dGV4dC13aGl0ZSBncm91cC1bOm5vdChbZGF0YS10ZS1kYXRlcGlja2VyLWNlbGwtc2VsZWN0ZWRdKVtkYXRhLXRlLWRhdGVwaWNrZXItY2VsbC1mb2N1c2VkXV06YmctbmV1dHJhbC0xMDAgZ3JvdXAtW1tkYXRhLXRlLWRhdGVwaWNrZXItY2VsbC1mb2N1c2VkXV06ZGF0YS1bdGUtZGF0ZXBpY2tlci1jZWxsLXNlbGVjdGVkXTpiZy1wcmltYXJ5IGdyb3VwLVtbZGF0YS10ZS1kYXRlcGlja2VyLWNlbGwtY3VycmVudF1dOmJvcmRlci1zb2xpZCBncm91cC1bW2RhdGEtdGUtZGF0ZXBpY2tlci1jZWxsLWN1cnJlbnRdXTpib3JkZXItYmxhY2sgZ3JvdXAtW1tkYXRhLXRlLWRhdGVwaWNrZXItY2VsbC1jdXJyZW50XV06Ym9yZGVyIGRhcms6Z3JvdXAtWzpub3QoW2RhdGEtdGUtZGF0ZXBpY2tlci1jZWxsLWRpc2FibGVkXSk6bm90KFtkYXRhLXRlLWRhdGVwaWNrZXItY2VsbC1zZWxlY3RlZF0pOmhvdmVyXTpiZy13aGl0ZS8xMCBkYXJrOmdyb3VwLVtbZGF0YS10ZS1kYXRlcGlja2VyLWNlbGwtY3VycmVudF1dOmJvcmRlci13aGl0ZSBkYXJrOnRleHQtd2hpdGUgZGFyazpncm91cC1bOm5vdChbZGF0YS10ZS1kYXRlcGlja2VyLWNlbGwtc2VsZWN0ZWRdKVtkYXRhLXRlLWRhdGVwaWNrZXItY2VsbC1mb2N1c2VkXV06Ymctd2hpdGUvMTAgZGFyazpncm91cC1bW2RhdGEtdGUtZGF0ZXBpY2tlci1jZWxsLWRpc2FibGVkXV06dGV4dC1uZXV0cmFsLTUwMFwiLCB5bSA9IFwidy05IGgtOSBsZWFkaW5nLTkgcm91bmRlZC1bNTAlXSB0ZXh0LVsxM3B4XVwiLCB3bSA9IFwidy1bNzJweF0gaC0xMCBsZWFkaW5nLTEwIHB5LVsxcHhdIHB4LTAuNSByb3VuZGVkLVs5OTlweF1cIiwga20gPSBcIm14LWF1dG8gdy1bMzA0cHhdXCIsIHhtID0gXCJmbGV4IGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWNvbnRlbnQtY2VudGVyIFsmPnN2Z106dy01IFsmPnN2Z106aC01IGFic29sdXRlIG91dGxpbmUtbm9uZSBib3JkZXItbm9uZSBiZy10cmFuc3BhcmVudCByaWdodC0wLjUgdG9wLTEvMiAtdHJhbnNsYXRlLXgtMS8yIC10cmFuc2xhdGUteS0xLzIgaG92ZXI6dGV4dC1wcmltYXJ5IGZvY3VzOnRleHQtcHJpbWFyeSBkYXJrOmhvdmVyOnRleHQtcHJpbWFyeS00MDAgZGFyazpmb2N1czp0ZXh0LXByaW1hcnktNDAwIGRhcms6dGV4dC1uZXV0cmFsLTIwMFwiLCBPbSA9IFwiaW5saW5lLWJsb2NrIHBvaW50ZXItZXZlbnRzLW5vbmUgbWwtWzNweF0gWyY+c3ZnXTp3LTQgWyY+c3ZnXTpoLTQgWyY+c3ZnXTpmaWxsLW5ldXRyYWwtNTAwIGRhcms6WyY+c3ZnXTpmaWxsLXdoaXRlXCIsIFNtID0gXCJ3LVszMjhweF0gaC1bMzgwcHhdIGJnLXdoaXRlIHJvdW5kZWQtbGcgc2hhZG93LVswcHhfMnB4XzE1cHhfLTNweF9yZ2JhKDAsMCwwLC4wNyksXzBweF8xMHB4XzIwcHhfLTJweF9yZ2JhKDAsMCwwLC4wNCldIHotWzEwNjZdIGRhcms6YmctemluYy03MDBcIiwgSW0gPSB7XG4gIHRpdGxlOiBcIlNlbGVjdCBkYXRlXCIsXG4gIGNvbnRhaW5lcjogXCJib2R5XCIsXG4gIGRpc2FibGVQYXN0OiAhMSxcbiAgZGlzYWJsZUZ1dHVyZTogITEsXG4gIG1vbnRoc0Z1bGw6IFtcbiAgICBcIkphbnVhcnlcIixcbiAgICBcIkZlYnJ1YXJ5XCIsXG4gICAgXCJNYXJjaFwiLFxuICAgIFwiQXByaWxcIixcbiAgICBcIk1heVwiLFxuICAgIFwiSnVuZVwiLFxuICAgIFwiSnVseVwiLFxuICAgIFwiQXVndXN0XCIsXG4gICAgXCJTZXB0ZW1iZXJcIixcbiAgICBcIk9jdG9iZXJcIixcbiAgICBcIk5vdmVtYmVyXCIsXG4gICAgXCJEZWNlbWJlclwiXG4gIF0sXG4gIG1vbnRoc1Nob3J0OiBbXG4gICAgXCJKYW5cIixcbiAgICBcIkZlYlwiLFxuICAgIFwiTWFyXCIsXG4gICAgXCJBcHJcIixcbiAgICBcIk1heVwiLFxuICAgIFwiSnVuXCIsXG4gICAgXCJKdWxcIixcbiAgICBcIkF1Z1wiLFxuICAgIFwiU2VwXCIsXG4gICAgXCJPY3RcIixcbiAgICBcIk5vdlwiLFxuICAgIFwiRGVjXCJcbiAgXSxcbiAgd2Vla2RheXNGdWxsOiBbXG4gICAgXCJTdW5kYXlcIixcbiAgICBcIk1vbmRheVwiLFxuICAgIFwiVHVlc2RheVwiLFxuICAgIFwiV2VkbmVzZGF5XCIsXG4gICAgXCJUaHVyc2RheVwiLFxuICAgIFwiRnJpZGF5XCIsXG4gICAgXCJTYXR1cmRheVwiXG4gIF0sXG4gIHdlZWtkYXlzU2hvcnQ6IFtcIlN1blwiLCBcIk1vblwiLCBcIlR1ZVwiLCBcIldlZFwiLCBcIlRodVwiLCBcIkZyaVwiLCBcIlNhdFwiXSxcbiAgd2Vla2RheXNOYXJyb3c6IFtcIlNcIiwgXCJNXCIsIFwiVFwiLCBcIldcIiwgXCJUXCIsIFwiRlwiLCBcIlNcIl0sXG4gIG9rQnRuVGV4dDogXCJPa1wiLFxuICBjbGVhckJ0blRleHQ6IFwiQ2xlYXJcIixcbiAgY2FuY2VsQnRuVGV4dDogXCJDYW5jZWxcIixcbiAgb2tCdG5MYWJlbDogXCJDb25maXJtIHNlbGVjdGlvblwiLFxuICBjbGVhckJ0bkxhYmVsOiBcIkNsZWFyIHNlbGVjdGlvblwiLFxuICBjYW5jZWxCdG5MYWJlbDogXCJDYW5jZWwgc2VsZWN0aW9uXCIsXG4gIG5leHRNb250aExhYmVsOiBcIk5leHQgbW9udGhcIixcbiAgcHJldk1vbnRoTGFiZWw6IFwiUHJldmlvdXMgbW9udGhcIixcbiAgbmV4dFllYXJMYWJlbDogXCJOZXh0IHllYXJcIixcbiAgcHJldlllYXJMYWJlbDogXCJQcmV2aW91cyB5ZWFyXCIsXG4gIGNoYW5nZU1vbnRoSWNvblRlbXBsYXRlOiBgPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgZmlsbD1cIm5vbmVcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgc3Ryb2tlLXdpZHRoPVwiM1wiIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIGNsYXNzPVwidy02IGgtNlwiPlxuICA8cGF0aCBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIiBkPVwiTTE1Ljc1IDE5LjVMOC4yNSAxMmw3LjUtNy41XCIgLz5cbiAgPC9zdmc+XG4gIGAsXG4gIG5leHRNdWx0aVllYXJMYWJlbDogXCJOZXh0IDI0IHllYXJzXCIsXG4gIHByZXZNdWx0aVllYXJMYWJlbDogXCJQcmV2aW91cyAyNCB5ZWFyc1wiLFxuICBzd2l0Y2hUb011bHRpWWVhclZpZXdMYWJlbDogXCJDaG9vc2UgeWVhciBhbmQgbW9udGhcIixcbiAgc3dpdGNoVG9Nb250aFZpZXdMYWJlbDogXCJDaG9vc2UgZGF0ZVwiLFxuICBzd2l0Y2hUb0RheVZpZXdMYWJlbDogXCJDaG9vc2UgZGF0ZVwiLFxuICBzdGFydERhdGU6IG51bGwsXG4gIHN0YXJ0RGF5OiAwLFxuICBmb3JtYXQ6IFwiZGQvbW0veXl5eVwiLFxuICB2aWV3OiBcImRheXNcIixcbiAgdmlld0NoYW5nZUljb25UZW1wbGF0ZTogYDxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIGZpbGw9XCJub25lXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIHN0cm9rZS13aWR0aD1cIjBcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBjbGFzcz1cInctNiBoLTZcIj5cbiAgPHBhdGggc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCIgZD1cIk0xOS41IDguMjVsLTcuNSA3LjUtNy41LTcuNVwiIC8+XG4gIDwvc3ZnPlxuICBgLFxuICBtaW46IG51bGwsXG4gIG1heDogbnVsbCxcbiAgZmlsdGVyOiBudWxsLFxuICBpbmxpbmU6ICExLFxuICB0b2dnbGVCdXR0b246ICEwLFxuICBkaXNhYmxlVG9nZ2xlQnV0dG9uOiAhMSxcbiAgZGlzYWJsZUlucHV0OiAhMSxcbiAgYW5pbWF0aW9uczogITAsXG4gIGNvbmZpcm1EYXRlT25TZWxlY3Q6ICExLFxuICByZW1vdmVPa0J0bjogITEsXG4gIHJlbW92ZUNhbmNlbEJ0bjogITEsXG4gIHJlbW92ZUNsZWFyQnRuOiAhMVxufSwgRG0gPSB7XG4gIHRpdGxlOiBcInN0cmluZ1wiLFxuICBjb250YWluZXI6IFwic3RyaW5nXCIsXG4gIGRpc2FibGVQYXN0OiBcImJvb2xlYW5cIixcbiAgZGlzYWJsZUZ1dHVyZTogXCJib29sZWFuXCIsXG4gIG1vbnRoc0Z1bGw6IFwiYXJyYXlcIixcbiAgbW9udGhzU2hvcnQ6IFwiYXJyYXlcIixcbiAgd2Vla2RheXNGdWxsOiBcImFycmF5XCIsXG4gIHdlZWtkYXlzU2hvcnQ6IFwiYXJyYXlcIixcbiAgd2Vla2RheXNOYXJyb3c6IFwiYXJyYXlcIixcbiAgb2tCdG5UZXh0OiBcInN0cmluZ1wiLFxuICBjbGVhckJ0blRleHQ6IFwic3RyaW5nXCIsXG4gIGNhbmNlbEJ0blRleHQ6IFwic3RyaW5nXCIsXG4gIG9rQnRuTGFiZWw6IFwic3RyaW5nXCIsXG4gIGNsZWFyQnRuTGFiZWw6IFwic3RyaW5nXCIsXG4gIGNhbmNlbEJ0bkxhYmVsOiBcInN0cmluZ1wiLFxuICBuZXh0TW9udGhMYWJlbDogXCJzdHJpbmdcIixcbiAgcHJldk1vbnRoTGFiZWw6IFwic3RyaW5nXCIsXG4gIG5leHRZZWFyTGFiZWw6IFwic3RyaW5nXCIsXG4gIHByZXZZZWFyTGFiZWw6IFwic3RyaW5nXCIsXG4gIG5leHRNdWx0aVllYXJMYWJlbDogXCJzdHJpbmdcIixcbiAgcHJldk11bHRpWWVhckxhYmVsOiBcInN0cmluZ1wiLFxuICBjaGFuZ2VNb250aEljb25UZW1wbGF0ZTogXCJzdHJpbmdcIixcbiAgc3dpdGNoVG9NdWx0aVllYXJWaWV3TGFiZWw6IFwic3RyaW5nXCIsXG4gIHN3aXRjaFRvTW9udGhWaWV3TGFiZWw6IFwic3RyaW5nXCIsXG4gIHN3aXRjaFRvRGF5Vmlld0xhYmVsOiBcInN0cmluZ1wiLFxuICBzdGFydERhdGU6IFwiKG51bGx8c3RyaW5nfGRhdGUpXCIsXG4gIHN0YXJ0RGF5OiBcIm51bWJlclwiLFxuICBmb3JtYXQ6IFwic3RyaW5nXCIsXG4gIHZpZXc6IFwic3RyaW5nXCIsXG4gIHZpZXdDaGFuZ2VJY29uVGVtcGxhdGU6IFwic3RyaW5nXCIsXG4gIG1pbjogXCIobnVsbHxzdHJpbmd8ZGF0ZSlcIixcbiAgbWF4OiBcIihudWxsfHN0cmluZ3xkYXRlKVwiLFxuICBmaWx0ZXI6IFwiKG51bGx8ZnVuY3Rpb24pXCIsXG4gIGlubGluZTogXCJib29sZWFuXCIsXG4gIHRvZ2dsZUJ1dHRvbjogXCJib29sZWFuXCIsXG4gIGRpc2FibGVUb2dnbGVCdXR0b246IFwiYm9vbGVhblwiLFxuICBkaXNhYmxlSW5wdXQ6IFwiYm9vbGVhblwiLFxuICBhbmltYXRpb25zOiBcImJvb2xlYW5cIixcbiAgY29uZmlybURhdGVPblNlbGVjdDogXCJib29sZWFuXCIsXG4gIHJlbW92ZU9rQnRuOiBcImJvb2xlYW5cIixcbiAgcmVtb3ZlQ2FuY2VsQnRuOiBcImJvb2xlYW5cIixcbiAgcmVtb3ZlQ2xlYXJCdG46IFwiYm9vbGVhblwiXG59LCAkbSA9IHtcbiAgZmFkZUluOiBRZixcbiAgZmFkZU91dDogSmYsXG4gIGZhZGVJblNob3J0OiB0bSxcbiAgZmFkZU91dFNob3J0OiBlbSxcbiAgbW9kYWxDb250YWluZXI6IGltLFxuICBkYXRlcGlja2VyQmFja2Ryb3A6IHNtLFxuICBkYXRlcGlja2VyTWFpbjogbm0sXG4gIGRhdGVwaWNrZXJIZWFkZXI6IG9tLFxuICBkYXRlcGlja2VyVGl0bGU6IHJtLFxuICBkYXRlcGlja2VyVGl0bGVUZXh0OiBhbSxcbiAgZGF0ZXBpY2tlckRhdGU6IGxtLFxuICBkYXRlcGlja2VyRGF0ZVRleHQ6IGNtLFxuICBkYXRlcGlja2VyVmlldzogaG0sXG4gIGRhdGVwaWNrZXJEYXRlQ29udHJvbHM6IGRtLFxuICBkYXRlcGlja2VyVmlld0NoYW5nZUJ1dHRvbjogdW0sXG4gIGRhdGVwaWNrZXJWaWV3Q2hhbmdlSWNvbjogT20sXG4gIGRhdGVwaWNrZXJBcnJvd0NvbnRyb2xzOiBwbSxcbiAgZGF0ZXBpY2tlclByZXZpb3VzQnV0dG9uOiBfbSxcbiAgZGF0ZXBpY2tlck5leHRCdXR0b246IGZtLFxuICBkYXRlcGlja2VyRm9vdGVyOiBtbSxcbiAgZGF0ZXBpY2tlckZvb3RlckJ0bjogZ20sXG4gIGRhdGVwaWNrZXJDbGVhckJ0bjogYm0sXG4gIGRhdGVwaWNrZXJEYXlIZWFkaW5nOiB2bSxcbiAgZGF0ZXBpY2tlckNlbGw6IFRtLFxuICBkYXRlcGlja2VyQ2VsbFNtYWxsOiBFbSxcbiAgZGF0ZXBpY2tlckNlbGxMYXJnZTogQ20sXG4gIGRhdGVwaWNrZXJDZWxsQ29udGVudDogQW0sXG4gIGRhdGVwaWNrZXJDZWxsQ29udGVudFNtYWxsOiB5bSxcbiAgZGF0ZXBpY2tlckNlbGxDb250ZW50TGFyZ2U6IHdtLFxuICBkYXRlcGlja2VyVGFibGU6IGttLFxuICBkYXRlcGlja2VyVG9nZ2xlQnV0dG9uOiB4bSxcbiAgZGF0ZXBpY2tlckRyb3Bkb3duQ29udGFpbmVyOiBTbVxufSwgTG0gPSB7XG4gIGZhZGVJbjogXCJzdHJpbmdcIixcbiAgZmFkZU91dDogXCJzdHJpbmdcIixcbiAgZmFkZUluU2hvcnQ6IFwic3RyaW5nXCIsXG4gIGZhZGVPdXRTaG9ydDogXCJzdHJpbmdcIixcbiAgbW9kYWxDb250YWluZXI6IFwic3RyaW5nXCIsXG4gIGRhdGVwaWNrZXJCYWNrZHJvcDogXCJzdHJpbmdcIixcbiAgZGF0ZXBpY2tlck1haW46IFwic3RyaW5nXCIsXG4gIGRhdGVwaWNrZXJIZWFkZXI6IFwic3RyaW5nXCIsXG4gIGRhdGVwaWNrZXJUaXRsZTogXCJzdHJpbmdcIixcbiAgZGF0ZXBpY2tlclRpdGxlVGV4dDogXCJzdHJpbmdcIixcbiAgZGF0ZXBpY2tlckRhdGU6IFwic3RyaW5nXCIsXG4gIGRhdGVwaWNrZXJEYXRlVGV4dDogXCJzdHJpbmdcIixcbiAgZGF0ZXBpY2tlclZpZXc6IFwic3RyaW5nXCIsXG4gIGRhdGVwaWNrZXJEYXRlQ29udHJvbHM6IFwic3RyaW5nXCIsXG4gIGRhdGVwaWNrZXJWaWV3Q2hhbmdlQnV0dG9uOiBcInN0cmluZ1wiLFxuICBkYXRlcGlja2VyQXJyb3dDb250cm9sczogXCJzdHJpbmdcIixcbiAgZGF0ZXBpY2tlclByZXZpb3VzQnV0dG9uOiBcInN0cmluZ1wiLFxuICBkYXRlcGlja2VyTmV4dEJ1dHRvbjogXCJzdHJpbmdcIixcbiAgZGF0ZXBpY2tlckZvb3RlcjogXCJzdHJpbmdcIixcbiAgZGF0ZXBpY2tlckZvb3RlckJ0bjogXCJzdHJpbmdcIixcbiAgZGF0ZXBpY2tlckNsZWFyQnRuOiBcInN0cmluZ1wiLFxuICBkYXRlcGlja2VyRGF5SGVhZGluZzogXCJzdHJpbmdcIixcbiAgZGF0ZXBpY2tlckNlbGw6IFwic3RyaW5nXCIsXG4gIGRhdGVwaWNrZXJDZWxsU21hbGw6IFwic3RyaW5nXCIsXG4gIGRhdGVwaWNrZXJDZWxsTGFyZ2U6IFwic3RyaW5nXCIsXG4gIGRhdGVwaWNrZXJDZWxsQ29udGVudDogXCJzdHJpbmdcIixcbiAgZGF0ZXBpY2tlckNlbGxDb250ZW50U21hbGw6IFwic3RyaW5nXCIsXG4gIGRhdGVwaWNrZXJDZWxsQ29udGVudExhcmdlOiBcInN0cmluZ1wiLFxuICBkYXRlcGlja2VyVGFibGU6IFwic3RyaW5nXCIsXG4gIGRhdGVwaWNrZXJUb2dnbGVCdXR0b246IFwic3RyaW5nXCIsXG4gIGRhdGVwaWNrZXJEcm9wZG93bkNvbnRhaW5lcjogXCJzdHJpbmdcIlxufTtcbmNsYXNzIE5tIHtcbiAgY29uc3RydWN0b3IodCwgZSwgaSkge1xuICAgIHRoaXMuX2VsZW1lbnQgPSB0LCB0aGlzLl9pbnB1dCA9IGQuZmluZE9uZShcImlucHV0XCIsIHRoaXMuX2VsZW1lbnQpLCB0aGlzLl9vcHRpb25zID0gdGhpcy5fZ2V0Q29uZmlnKGUpLCB0aGlzLl9jbGFzc2VzID0gdGhpcy5fZ2V0Q2xhc3NlcyhpKSwgdGhpcy5fYWN0aXZlRGF0ZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpLCB0aGlzLl9zZWxlY3RlZERhdGUgPSBudWxsLCB0aGlzLl9zZWxlY3RlZFllYXIgPSBudWxsLCB0aGlzLl9zZWxlY3RlZE1vbnRoID0gbnVsbCwgdGhpcy5faGVhZGVyRGF0ZSA9IG51bGwsIHRoaXMuX2hlYWRlclllYXIgPSBudWxsLCB0aGlzLl9oZWFkZXJNb250aCA9IG51bGwsIHRoaXMuX3ZpZXcgPSB0aGlzLl9vcHRpb25zLnZpZXcsIHRoaXMuX3BvcHBlciA9IG51bGwsIHRoaXMuX2ZvY3VzVHJhcCA9IG51bGwsIHRoaXMuX2lzT3BlbiA9ICExLCB0aGlzLl90b2dnbGVCdXR0b25JZCA9IHJ0KFwiZGF0ZXBpY2tlci10b2dnbGUtXCIpLCB0aGlzLl9hbmltYXRpb25zID0gIXdpbmRvdy5tYXRjaE1lZGlhKFwiKHByZWZlcnMtcmVkdWNlZC1tb3Rpb246IHJlZHVjZSlcIikubWF0Y2hlcyAmJiB0aGlzLl9vcHRpb25zLmFuaW1hdGlvbnMsIHRoaXMuX3Njcm9sbEJhciA9IG5ldyBxZSgpLCB0aGlzLl9lbGVtZW50ICYmIHkuc2V0RGF0YSh0LCB6cywgdGhpcyksIHRoaXMuX2luaXQoKSwgdGhpcy50b2dnbGVCdXR0b24gJiYgdGhpcy5fb3B0aW9ucy5kaXNhYmxlVG9nZ2xlICYmICh0aGlzLnRvZ2dsZUJ1dHRvbi5kaXNhYmxlZCA9IFwidHJ1ZVwiKSwgdGhpcy5fb3B0aW9ucy5kaXNhYmxlSW5wdXQgJiYgKHRoaXMuX2lucHV0LmRpc2FibGVkID0gXCJ0cnVlXCIpO1xuICB9XG4gIC8vIEdldHRlcnNcbiAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgIHJldHVybiBYbjtcbiAgfVxuICBnZXQgY29udGFpbmVyKCkge1xuICAgIHJldHVybiBkLmZpbmRPbmUoXG4gICAgICBgWyR7VWN9PScke3RoaXMuX3RvZ2dsZUJ1dHRvbklkfSddYFxuICAgICkgfHwgZC5maW5kT25lKFxuICAgICAgYFske1hjfT0nJHt0aGlzLl90b2dnbGVCdXR0b25JZH0nXWBcbiAgICApO1xuICB9XG4gIGdldCBvcHRpb25zKCkge1xuICAgIHJldHVybiB0aGlzLl9vcHRpb25zO1xuICB9XG4gIGdldCBhY3RpdmVDZWxsKCkge1xuICAgIGxldCB0O1xuICAgIHJldHVybiB0aGlzLl92aWV3ID09PSBcImRheXNcIiAmJiAodCA9IHRoaXMuX2dldEFjdGl2ZURheUNlbGwoKSksIHRoaXMuX3ZpZXcgPT09IFwibW9udGhzXCIgJiYgKHQgPSB0aGlzLl9nZXRBY3RpdmVNb250aENlbGwoKSksIHRoaXMuX3ZpZXcgPT09IFwieWVhcnNcIiAmJiAodCA9IHRoaXMuX2dldEFjdGl2ZVllYXJDZWxsKCkpLCB0O1xuICB9XG4gIGdldCBhY3RpdmVEYXkoKSB7XG4gICAgcmV0dXJuIFoodGhpcy5fYWN0aXZlRGF0ZSk7XG4gIH1cbiAgZ2V0IGFjdGl2ZU1vbnRoKCkge1xuICAgIHJldHVybiBZKHRoaXMuX2FjdGl2ZURhdGUpO1xuICB9XG4gIGdldCBhY3RpdmVZZWFyKCkge1xuICAgIHJldHVybiBCKHRoaXMuX2FjdGl2ZURhdGUpO1xuICB9XG4gIGdldCBmaXJzdFllYXJJblZpZXcoKSB7XG4gICAgcmV0dXJuIHRoaXMuYWN0aXZlWWVhciAtIFdzKHRoaXMuX2FjdGl2ZURhdGUsIHZ0KTtcbiAgfVxuICBnZXQgbGFzdFllYXJJblZpZXcoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmlyc3RZZWFySW5WaWV3ICsgdnQgLSAxO1xuICB9XG4gIGdldCB2aWV3Q2hhbmdlQnV0dG9uKCkge1xuICAgIHJldHVybiBkLmZpbmRPbmUoRmYsIHRoaXMuY29udGFpbmVyKTtcbiAgfVxuICBnZXQgcHJldmlvdXNCdXR0b24oKSB7XG4gICAgcmV0dXJuIGQuZmluZE9uZShZZiwgdGhpcy5jb250YWluZXIpO1xuICB9XG4gIGdldCBuZXh0QnV0dG9uKCkge1xuICAgIHJldHVybiBkLmZpbmRPbmUoamYsIHRoaXMuY29udGFpbmVyKTtcbiAgfVxuICBnZXQgb2tCdXR0b24oKSB7XG4gICAgcmV0dXJuIGQuZmluZE9uZShLZiwgdGhpcy5jb250YWluZXIpO1xuICB9XG4gIGdldCBjYW5jZWxCdXR0b24oKSB7XG4gICAgcmV0dXJuIGQuZmluZE9uZSh6ZiwgdGhpcy5jb250YWluZXIpO1xuICB9XG4gIGdldCBjbGVhckJ1dHRvbigpIHtcbiAgICByZXR1cm4gZC5maW5kT25lKFVmLCB0aGlzLmNvbnRhaW5lcik7XG4gIH1cbiAgZ2V0IGRhdGVzQ29udGFpbmVyKCkge1xuICAgIHJldHVybiBkLmZpbmRPbmUoWGYsIHRoaXMuY29udGFpbmVyKTtcbiAgfVxuICBnZXQgdG9nZ2xlQnV0dG9uKCkge1xuICAgIHJldHVybiBkLmZpbmRPbmUoR2YsIHRoaXMuX2VsZW1lbnQpO1xuICB9XG4gIHVwZGF0ZSh0ID0ge30pIHtcbiAgICB0aGlzLl9vcHRpb25zID0gdGhpcy5fZ2V0Q29uZmlnKHsgLi4udGhpcy5fb3B0aW9ucywgLi4udCB9KTtcbiAgfVxuICBfZ2V0Q29uZmlnKHQpIHtcbiAgICBjb25zdCBlID0gaC5nZXREYXRhQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KTtcbiAgICBpZiAodCA9IHtcbiAgICAgIC4uLkltLFxuICAgICAgLi4uZSxcbiAgICAgIC4uLnRcbiAgICB9LCBEKFhuLCB0LCBEbSksIHQubWF4ICYmIHR5cGVvZiB0Lm1heCA9PSBcInN0cmluZ1wiICYmICh0Lm1heCA9IG5ldyBEYXRlKHQubWF4KSksIHQubWluICYmIHR5cGVvZiB0Lm1pbiA9PSBcInN0cmluZ1wiICYmICh0Lm1pbiA9IG5ldyBEYXRlKHQubWluKSksIHQuc3RhcnREYXkgJiYgdC5zdGFydERheSAhPT0gMCkge1xuICAgICAgY29uc3QgaSA9IHRoaXMuX2dldE5ld0RheXNPcmRlckFycmF5KHQpO1xuICAgICAgdC53ZWVrZGF5c05hcnJvdyA9IGk7XG4gICAgfVxuICAgIHJldHVybiB0O1xuICB9XG4gIF9nZXRDbGFzc2VzKHQpIHtcbiAgICBjb25zdCBlID0gaC5nZXREYXRhQ2xhc3NBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpO1xuICAgIHJldHVybiB0ID0ge1xuICAgICAgLi4uJG0sXG4gICAgICAuLi5lLFxuICAgICAgLi4udFxuICAgIH0sIEQoWG4sIHQsIExtKSwgdDtcbiAgfVxuICBfZ2V0Q29udGFpbmVyKCkge1xuICAgIHJldHVybiBkLmZpbmRPbmUodGhpcy5fb3B0aW9ucy5jb250YWluZXIpO1xuICB9XG4gIF9nZXROZXdEYXlzT3JkZXJBcnJheSh0KSB7XG4gICAgY29uc3QgZSA9IHQuc3RhcnREYXksIGkgPSB0LndlZWtkYXlzTmFycm93O1xuICAgIHJldHVybiBpLnNsaWNlKGUpLmNvbmNhdChpLnNsaWNlKDAsIGUpKTtcbiAgfVxuICBfaW5pdCgpIHtcbiAgICAhdGhpcy50b2dnbGVCdXR0b24gJiYgdGhpcy5fb3B0aW9ucy50b2dnbGVCdXR0b24gJiYgKHRoaXMuX2FwcGVuZFRvZ2dsZUJ1dHRvbigpLCAodGhpcy5faW5wdXQucmVhZE9ubHkgfHwgdGhpcy5faW5wdXQuZGlzYWJsZWQpICYmICh0aGlzLnRvZ2dsZUJ1dHRvbi5zdHlsZS5wb2ludGVyRXZlbnRzID0gXCJub25lXCIpKSwgdGhpcy5fbGlzdGVuVG9Vc2VySW5wdXQoKSwgdGhpcy5fbGlzdGVuVG9Ub2dnbGVDbGljaygpLCB0aGlzLl9saXN0ZW5Ub1RvZ2dsZUtleWRvd24oKTtcbiAgfVxuICBfYXBwZW5kVG9nZ2xlQnV0dG9uKCkge1xuICAgIGNvbnN0IHQgPSBMZihcbiAgICAgIHRoaXMuX3RvZ2dsZUJ1dHRvbklkLFxuICAgICAgdGhpcy5fY2xhc3Nlcy5kYXRlcGlja2VyVG9nZ2xlQnV0dG9uXG4gICAgKTtcbiAgICB0aGlzLl9lbGVtZW50Lmluc2VydEFkamFjZW50SFRNTChcImJlZm9yZWVuZFwiLCB0KTtcbiAgfVxuICBvcGVuKCkge1xuICAgIGlmICh0aGlzLl9pbnB1dC5yZWFkT25seSB8fCB0aGlzLl9pbnB1dC5kaXNhYmxlZClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB0ID0gYy50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEJmKTtcbiAgICBpZiAodGhpcy5faXNPcGVuIHx8IHQuZGVmYXVsdFByZXZlbnRlZClcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLl9zZXRJbml0aWFsRGF0ZSgpO1xuICAgIGNvbnN0IGUgPSB4Zih0aGlzLl9jbGFzc2VzLmRhdGVwaWNrZXJCYWNrZHJvcCksIGkgPSBrZihcbiAgICAgIHRoaXMuX2FjdGl2ZURhdGUsXG4gICAgICB0aGlzLl9zZWxlY3RlZERhdGUsXG4gICAgICB0aGlzLl9zZWxlY3RlZFllYXIsXG4gICAgICB0aGlzLl9zZWxlY3RlZE1vbnRoLFxuICAgICAgdGhpcy5fb3B0aW9ucyxcbiAgICAgIGNzLFxuICAgICAgdnQsXG4gICAgICBscyxcbiAgICAgIHRoaXMuX3RvZ2dsZUJ1dHRvbklkLFxuICAgICAgdGhpcy5fY2xhc3Nlc1xuICAgICk7XG4gICAgdGhpcy5fb3B0aW9ucy5pbmxpbmUgPyB0aGlzLl9vcGVuRHJvcGRvd24oaSkgOiAodGhpcy5fb3Blbk1vZGFsKGUsIGkpLCB0aGlzLl9zY3JvbGxCYXIuaGlkZSgpKSwgdGhpcy5fYW5pbWF0aW9ucyAmJiAoaC5hZGRDbGFzcyh0aGlzLmNvbnRhaW5lciwgdGhpcy5fY2xhc3Nlcy5mYWRlSW4pLCBoLmFkZENsYXNzKGUsIHRoaXMuX2NsYXNzZXMuZmFkZUluU2hvcnQpKSwgdGhpcy5fc2V0Rm9jdXNUcmFwKHRoaXMuY29udGFpbmVyKSwgdGhpcy5fbGlzdGVuVG9EYXRlU2VsZWN0aW9uKCksIHRoaXMuX2FkZENvbnRyb2xzTGlzdGVuZXJzKCksIHRoaXMuX3VwZGF0ZUNvbnRyb2xzRGlzYWJsZWRTdGF0ZSgpLCB0aGlzLl9saXN0ZW5Ub0VzY2FwZUNsaWNrKCksIHRoaXMuX2xpc3RlblRvS2V5Ym9hcmROYXZpZ2F0aW9uKCksIHRoaXMuX2xpc3RlblRvRGF0ZXNDb250YWluZXJGb2N1cygpLCB0aGlzLl9saXN0ZW5Ub0RhdGVzQ29udGFpbmVyQmx1cigpLCB0aGlzLl9hc3luY0ZvY3VzRGF0ZXNDb250YWluZXIoKSwgdGhpcy5fdXBkYXRlVmlld0NvbnRyb2xzQW5kQXR0cmlidXRlcyh0aGlzLl92aWV3KSwgdGhpcy5faXNPcGVuID0gITAsIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5fbGlzdGVuVG9PdXRzaWRlQ2xpY2soKTtcbiAgICB9LCAwKTtcbiAgfVxuICBfb3BlbkRyb3Bkb3duKHQpIHtcbiAgICB0aGlzLl9wb3BwZXIgPSBDZSh0aGlzLl9pbnB1dCwgdCwge1xuICAgICAgcGxhY2VtZW50OiBcImJvdHRvbS1zdGFydFwiXG4gICAgfSksIHRoaXMuX2dldENvbnRhaW5lcigpLmFwcGVuZENoaWxkKHQpO1xuICB9XG4gIF9vcGVuTW9kYWwodCwgZSkge1xuICAgIGNvbnN0IGkgPSB0aGlzLl9nZXRDb250YWluZXIoKTtcbiAgICBpLmFwcGVuZENoaWxkKHQpLCBpLmFwcGVuZENoaWxkKGUpO1xuICB9XG4gIF9zZXRGb2N1c1RyYXAodCkge1xuICAgIHRoaXMuX2ZvY3VzVHJhcCA9IG5ldyBXaSh0LCB7XG4gICAgICBldmVudDogXCJrZXlkb3duXCIsXG4gICAgICBjb25kaXRpb246IChlKSA9PiBlLmtleSA9PT0gXCJUYWJcIlxuICAgIH0pLCB0aGlzLl9mb2N1c1RyYXAudHJhcCgpO1xuICB9XG4gIF9saXN0ZW5Ub1VzZXJJbnB1dCgpIHtcbiAgICBjLm9uKHRoaXMuX2lucHV0LCBcImlucHV0XCIsICh0KSA9PiB7XG4gICAgICB0aGlzLl9oYW5kbGVVc2VySW5wdXQodC50YXJnZXQudmFsdWUpO1xuICAgIH0pO1xuICB9XG4gIF9saXN0ZW5Ub1RvZ2dsZUNsaWNrKCkge1xuICAgIGMub24oXG4gICAgICB0aGlzLl9lbGVtZW50LFxuICAgICAgaHMsXG4gICAgICBkcyxcbiAgICAgICh0KSA9PiB7XG4gICAgICAgIHQucHJldmVudERlZmF1bHQoKSwgdGhpcy5vcGVuKCk7XG4gICAgICB9XG4gICAgKTtcbiAgfVxuICBfbGlzdGVuVG9Ub2dnbGVLZXlkb3duKCkge1xuICAgIGMub24oXG4gICAgICB0aGlzLl9lbGVtZW50LFxuICAgICAgXCJrZXlkb3duXCIsXG4gICAgICBkcyxcbiAgICAgICh0KSA9PiB7XG4gICAgICAgIHQua2V5Q29kZSA9PT0gY3QgJiYgIXRoaXMuX2lzT3BlbiAmJiB0aGlzLm9wZW4oKTtcbiAgICAgIH1cbiAgICApO1xuICB9XG4gIF9saXN0ZW5Ub0RhdGVTZWxlY3Rpb24oKSB7XG4gICAgYy5vbih0aGlzLmRhdGVzQ29udGFpbmVyLCBcImNsaWNrXCIsICh0KSA9PiB7XG4gICAgICB0aGlzLl9oYW5kbGVEYXRlU2VsZWN0aW9uKHQpO1xuICAgIH0pO1xuICB9XG4gIF9oYW5kbGVEYXRlU2VsZWN0aW9uKHQpIHtcbiAgICBjb25zdCBlID0gdC50YXJnZXQubm9kZU5hbWUgPT09IFwiRElWXCIgPyB0LnRhcmdldC5wYXJlbnROb2RlLmRhdGFzZXQgOiB0LnRhcmdldC5kYXRhc2V0LCBpID0gdC50YXJnZXQubm9kZU5hbWUgPT09IFwiRElWXCIgPyB0LnRhcmdldC5wYXJlbnROb2RlIDogdC50YXJnZXQ7XG4gICAgaWYgKGUudGVEYXRlICYmIHRoaXMuX3BpY2tEYXkoZS50ZURhdGUsIGkpLCBlLnRlTW9udGggJiYgZS50ZVllYXIpIHtcbiAgICAgIGNvbnN0IG4gPSBwYXJzZUludChlLnRlTW9udGgsIDEwKSwgbyA9IHBhcnNlSW50KGUudGVZZWFyLCAxMCk7XG4gICAgICB0aGlzLl9waWNrTW9udGgobiwgbyk7XG4gICAgfVxuICAgIGlmIChlLnRlWWVhciAmJiAhZS50ZU1vbnRoKSB7XG4gICAgICBjb25zdCBuID0gcGFyc2VJbnQoZS50ZVllYXIsIDEwKTtcbiAgICAgIHRoaXMuX3BpY2tZZWFyKG4pO1xuICAgIH1cbiAgICB0aGlzLl9vcHRpb25zLmlubGluZSB8fCB0aGlzLl91cGRhdGVIZWFkZXJEYXRlKFxuICAgICAgdGhpcy5fYWN0aXZlRGF0ZSxcbiAgICAgIHRoaXMuX29wdGlvbnMubW9udGhzU2hvcnQsXG4gICAgICB0aGlzLl9vcHRpb25zLndlZWtkYXlzU2hvcnRcbiAgICApO1xuICB9XG4gIF91cGRhdGVIZWFkZXJEYXRlKHQsIGUsIGkpIHtcbiAgICBjb25zdCBuID0gZC5maW5kT25lKFxuICAgICAgcWYsXG4gICAgICB0aGlzLmNvbnRhaW5lclxuICAgICksIG8gPSBZKHQpLCByID0gWih0KSwgYSA9IFZzKHQpO1xuICAgIG4uaW5uZXJIVE1MID0gYCR7aVthXX0sICR7ZVtvXX0gJHtyfWA7XG4gIH1cbiAgX2FkZENvbnRyb2xzTGlzdGVuZXJzKCkge1xuICAgIGMub24odGhpcy5uZXh0QnV0dG9uLCBcImNsaWNrXCIsICgpID0+IHtcbiAgICAgIHRoaXMuX3ZpZXcgPT09IFwiZGF5c1wiID8gdGhpcy5uZXh0TW9udGgoKSA6IHRoaXMuX3ZpZXcgPT09IFwieWVhcnNcIiA/IHRoaXMubmV4dFllYXJzKCkgOiB0aGlzLm5leHRZZWFyKCksIHRoaXMuX3VwZGF0ZUNvbnRyb2xzRGlzYWJsZWRTdGF0ZSgpO1xuICAgIH0pLCBjLm9uKHRoaXMucHJldmlvdXNCdXR0b24sIFwiY2xpY2tcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5fdmlldyA9PT0gXCJkYXlzXCIgPyB0aGlzLnByZXZpb3VzTW9udGgoKSA6IHRoaXMuX3ZpZXcgPT09IFwieWVhcnNcIiA/IHRoaXMucHJldmlvdXNZZWFycygpIDogdGhpcy5wcmV2aW91c1llYXIoKSwgdGhpcy5fdXBkYXRlQ29udHJvbHNEaXNhYmxlZFN0YXRlKCk7XG4gICAgfSksIGMub24odGhpcy52aWV3Q2hhbmdlQnV0dG9uLCBcImNsaWNrXCIsICgpID0+IHtcbiAgICAgIHRoaXMuX3ZpZXcgPT09IFwiZGF5c1wiID8gdGhpcy5fY2hhbmdlVmlldyhcInllYXJzXCIpIDogKHRoaXMuX3ZpZXcgPT09IFwieWVhcnNcIiB8fCB0aGlzLl92aWV3ID09PSBcIm1vbnRoc1wiKSAmJiB0aGlzLl9jaGFuZ2VWaWV3KFwiZGF5c1wiKTtcbiAgICB9KSwgdGhpcy5fb3B0aW9ucy5pbmxpbmUgfHwgdGhpcy5fbGlzdGVuVG9Gb290ZXJCdXR0b25zQ2xpY2soKTtcbiAgfVxuICBfbGlzdGVuVG9Gb290ZXJCdXR0b25zQ2xpY2soKSB7XG4gICAgYy5vbih0aGlzLm9rQnV0dG9uLCBcImNsaWNrXCIsICgpID0+IHRoaXMuaGFuZGxlT2soKSksIGMub24odGhpcy5jYW5jZWxCdXR0b24sIFwiY2xpY2tcIiwgKCkgPT4gdGhpcy5oYW5kbGVDYW5jZWwoKSksIGMub24odGhpcy5jbGVhckJ1dHRvbiwgXCJjbGlja1wiLCAoKSA9PiB0aGlzLmhhbmRsZUNsZWFyKCkpO1xuICB9XG4gIF9saXN0ZW5Ub091dHNpZGVDbGljaygpIHtcbiAgICBjLm9uKGRvY3VtZW50LCBocywgKHQpID0+IHtcbiAgICAgIGNvbnN0IGUgPSB0LnRhcmdldCA9PT0gdGhpcy5jb250YWluZXIsIGkgPSB0aGlzLmNvbnRhaW5lciAmJiB0aGlzLmNvbnRhaW5lci5jb250YWlucyh0LnRhcmdldCk7XG4gICAgICAhZSAmJiAhaSAmJiB0aGlzLmNsb3NlKCk7XG4gICAgfSk7XG4gIH1cbiAgX2xpc3RlblRvRXNjYXBlQ2xpY2soKSB7XG4gICAgYy5vbihkb2N1bWVudCwgXCJrZXlkb3duXCIsICh0KSA9PiB7XG4gICAgICB0LmtleUNvZGUgPT09IEZpICYmIHRoaXMuX2lzT3BlbiAmJiB0aGlzLmNsb3NlKCk7XG4gICAgfSk7XG4gIH1cbiAgX2xpc3RlblRvS2V5Ym9hcmROYXZpZ2F0aW9uKCkge1xuICAgIGMub24odGhpcy5kYXRlc0NvbnRhaW5lciwgXCJrZXlkb3duXCIsICh0KSA9PiB7XG4gICAgICB0aGlzLl9oYW5kbGVLZXlkb3duKHQpO1xuICAgIH0pO1xuICB9XG4gIF9saXN0ZW5Ub0RhdGVzQ29udGFpbmVyRm9jdXMoKSB7XG4gICAgYy5vbih0aGlzLmRhdGVzQ29udGFpbmVyLCBcImZvY3VzXCIsICgpID0+IHtcbiAgICAgIHRoaXMuX2ZvY3VzQWN0aXZlQ2VsbCh0aGlzLmFjdGl2ZUNlbGwpO1xuICAgIH0pO1xuICB9XG4gIF9saXN0ZW5Ub0RhdGVzQ29udGFpbmVyQmx1cigpIHtcbiAgICBjLm9uKHRoaXMuZGF0ZXNDb250YWluZXIsIFwiYmx1clwiLCAoKSA9PiB7XG4gICAgICB0aGlzLl9yZW1vdmVDdXJyZW50Rm9jdXNTdHlsZXMoKTtcbiAgICB9KTtcbiAgfVxuICBfaGFuZGxlS2V5ZG93bih0KSB7XG4gICAgdGhpcy5fdmlldyA9PT0gXCJkYXlzXCIgJiYgdGhpcy5faGFuZGxlRGF5c1ZpZXdLZXlkb3duKHQpLCB0aGlzLl92aWV3ID09PSBcIm1vbnRoc1wiICYmIHRoaXMuX2hhbmRsZU1vbnRoc1ZpZXdLZXlkb3duKHQpLCB0aGlzLl92aWV3ID09PSBcInllYXJzXCIgJiYgdGhpcy5faGFuZGxlWWVhcnNWaWV3S2V5ZG93bih0KTtcbiAgfVxuICBfaGFuZGxlRGF5c1ZpZXdLZXlkb3duKHQpIHtcbiAgICBjb25zdCBlID0gdGhpcy5fYWN0aXZlRGF0ZSwgaSA9IHRoaXMuYWN0aXZlQ2VsbDtcbiAgICBzd2l0Y2ggKHQua2V5Q29kZSkge1xuICAgICAgY2FzZSBIZTpcbiAgICAgICAgdGhpcy5fYWN0aXZlRGF0ZSA9IHhlKHRoaXMuX2FjdGl2ZURhdGUsIEYoKSA/IDEgOiAtMSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBWZTpcbiAgICAgICAgdGhpcy5fYWN0aXZlRGF0ZSA9IHhlKHRoaXMuX2FjdGl2ZURhdGUsIEYoKSA/IC0xIDogMSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBhdDpcbiAgICAgICAgdGhpcy5fYWN0aXZlRGF0ZSA9IHhlKHRoaXMuX2FjdGl2ZURhdGUsIC03KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHo6XG4gICAgICAgIHRoaXMuX2FjdGl2ZURhdGUgPSB4ZSh0aGlzLl9hY3RpdmVEYXRlLCA3KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFdlOlxuICAgICAgICB0aGlzLl9hY3RpdmVEYXRlID0geGUoXG4gICAgICAgICAgdGhpcy5fYWN0aXZlRGF0ZSxcbiAgICAgICAgICAxIC0gWih0aGlzLl9hY3RpdmVEYXRlKVxuICAgICAgICApO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRmU6XG4gICAgICAgIHRoaXMuX2FjdGl2ZURhdGUgPSB4ZShcbiAgICAgICAgICB0aGlzLl9hY3RpdmVEYXRlLFxuICAgICAgICAgIFBvKHRoaXMuX2FjdGl2ZURhdGUpIC0gWih0aGlzLl9hY3RpdmVEYXRlKVxuICAgICAgICApO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugem46XG4gICAgICAgIHRoaXMuX2FjdGl2ZURhdGUgPSBudCh0aGlzLl9hY3RpdmVEYXRlLCAtMSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBVbjpcbiAgICAgICAgdGhpcy5fYWN0aXZlRGF0ZSA9IG50KHRoaXMuX2FjdGl2ZURhdGUsIDEpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgY3Q6XG4gICAgICBjYXNlIEtzOlxuICAgICAgICB0aGlzLl9zZWxlY3REYXRlKHRoaXMuX2FjdGl2ZURhdGUpLCB0aGlzLl9oYW5kbGVEYXRlU2VsZWN0aW9uKHQpLCB0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgRGkoXG4gICAgICBlLFxuICAgICAgdGhpcy5fYWN0aXZlRGF0ZSxcbiAgICAgIHRoaXMuX3ZpZXcsXG4gICAgICB2dCxcbiAgICAgIHRoaXMuX29wdGlvbnMubWluLFxuICAgICAgdGhpcy5fb3B0aW9ucy5tYXhcbiAgICApIHx8IHRoaXMuX2NoYW5nZVZpZXcoXCJkYXlzXCIpLCB0aGlzLl9yZW1vdmVIaWdobGlnaHRGcm9tQ2VsbChpKSwgdGhpcy5fZm9jdXNBY3RpdmVDZWxsKHRoaXMuYWN0aXZlQ2VsbCksIHQucHJldmVudERlZmF1bHQoKTtcbiAgfVxuICBfYXN5bmNGb2N1c0RhdGVzQ29udGFpbmVyKCkge1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5kYXRlc0NvbnRhaW5lci5mb2N1cygpO1xuICAgIH0sIDApO1xuICB9XG4gIF9mb2N1c0FjdGl2ZUNlbGwodCkge1xuICAgIHQgJiYgdC5zZXRBdHRyaWJ1dGUoXCJkYXRhLXRlLWRhdGVwaWNrZXItY2VsbC1mb2N1c2VkXCIsIFwiXCIpO1xuICB9XG4gIF9yZW1vdmVIaWdobGlnaHRGcm9tQ2VsbCh0KSB7XG4gICAgdCAmJiB0LnJlbW92ZUF0dHJpYnV0ZShcImRhdGEtdGUtZGF0ZXBpY2tlci1jZWxsLWZvY3VzZWRcIik7XG4gIH1cbiAgX2dldEFjdGl2ZURheUNlbGwoKSB7XG4gICAgY29uc3QgdCA9IGQuZmluZChcInRkXCIsIHRoaXMuZGF0ZXNDb250YWluZXIpO1xuICAgIHJldHVybiBBcnJheS5mcm9tKHQpLmZpbmQoKGkpID0+IHtcbiAgICAgIGNvbnN0IG4gPSBPYShpLmRhdGFzZXQudGVEYXRlKTtcbiAgICAgIHJldHVybiBmZShuLCB0aGlzLl9hY3RpdmVEYXRlKTtcbiAgICB9KTtcbiAgfVxuICBfaGFuZGxlTW9udGhzVmlld0tleWRvd24odCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLl9hY3RpdmVEYXRlLCBpID0gdGhpcy5hY3RpdmVDZWxsO1xuICAgIHN3aXRjaCAodC5rZXlDb2RlKSB7XG4gICAgICBjYXNlIEhlOlxuICAgICAgICB0aGlzLl9hY3RpdmVEYXRlID0gbnQodGhpcy5fYWN0aXZlRGF0ZSwgRigpID8gMSA6IC0xKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFZlOlxuICAgICAgICB0aGlzLl9hY3RpdmVEYXRlID0gbnQodGhpcy5fYWN0aXZlRGF0ZSwgRigpID8gLTEgOiAxKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGF0OlxuICAgICAgICB0aGlzLl9hY3RpdmVEYXRlID0gbnQodGhpcy5fYWN0aXZlRGF0ZSwgLTQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgejpcbiAgICAgICAgdGhpcy5fYWN0aXZlRGF0ZSA9IG50KHRoaXMuX2FjdGl2ZURhdGUsIDQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgV2U6XG4gICAgICAgIHRoaXMuX2FjdGl2ZURhdGUgPSBudCh0aGlzLl9hY3RpdmVEYXRlLCAtdGhpcy5hY3RpdmVNb250aCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBGZTpcbiAgICAgICAgdGhpcy5fYWN0aXZlRGF0ZSA9IG50KHRoaXMuX2FjdGl2ZURhdGUsIDExIC0gdGhpcy5hY3RpdmVNb250aCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSB6bjpcbiAgICAgICAgdGhpcy5fYWN0aXZlRGF0ZSA9IGl0KHRoaXMuX2FjdGl2ZURhdGUsIC0xKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFVuOlxuICAgICAgICB0aGlzLl9hY3RpdmVEYXRlID0gaXQodGhpcy5fYWN0aXZlRGF0ZSwgMSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBjdDpcbiAgICAgIGNhc2UgS3M6XG4gICAgICAgIHRoaXMuX3NlbGVjdE1vbnRoKHRoaXMuYWN0aXZlTW9udGgpO1xuICAgICAgICByZXR1cm47XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIERpKFxuICAgICAgZSxcbiAgICAgIHRoaXMuX2FjdGl2ZURhdGUsXG4gICAgICB0aGlzLl92aWV3LFxuICAgICAgdnQsXG4gICAgICB0aGlzLl9vcHRpb25zLm1pbixcbiAgICAgIHRoaXMuX29wdGlvbnMubWF4XG4gICAgKSB8fCB0aGlzLl9jaGFuZ2VWaWV3KFwibW9udGhzXCIpLCB0aGlzLl9yZW1vdmVIaWdobGlnaHRGcm9tQ2VsbChpKSwgdGhpcy5fZm9jdXNBY3RpdmVDZWxsKHRoaXMuYWN0aXZlQ2VsbCksIHQucHJldmVudERlZmF1bHQoKTtcbiAgfVxuICBfZ2V0QWN0aXZlTW9udGhDZWxsKCkge1xuICAgIGNvbnN0IHQgPSBkLmZpbmQoXCJ0ZFwiLCB0aGlzLmRhdGVzQ29udGFpbmVyKTtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0KS5maW5kKChpKSA9PiB7XG4gICAgICBjb25zdCBuID0gcGFyc2VJbnQoaS5kYXRhc2V0LnRlWWVhciwgMTApLCBvID0gcGFyc2VJbnQoaS5kYXRhc2V0LnRlTW9udGgsIDEwKTtcbiAgICAgIHJldHVybiBuID09PSB0aGlzLmFjdGl2ZVllYXIgJiYgbyA9PT0gdGhpcy5hY3RpdmVNb250aDtcbiAgICB9KTtcbiAgfVxuICBfaGFuZGxlWWVhcnNWaWV3S2V5ZG93bih0KSB7XG4gICAgY29uc3QgZSA9IHRoaXMuX2FjdGl2ZURhdGUsIGkgPSB0aGlzLmFjdGl2ZUNlbGwsIG4gPSA0LCBvID0gMjQ7XG4gICAgc3dpdGNoICh0LmtleUNvZGUpIHtcbiAgICAgIGNhc2UgSGU6XG4gICAgICAgIHRoaXMuX2FjdGl2ZURhdGUgPSBpdCh0aGlzLl9hY3RpdmVEYXRlLCBGKCkgPyAxIDogLTEpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgVmU6XG4gICAgICAgIHRoaXMuX2FjdGl2ZURhdGUgPSBpdCh0aGlzLl9hY3RpdmVEYXRlLCBGKCkgPyAtMSA6IDEpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgYXQ6XG4gICAgICAgIHRoaXMuX2FjdGl2ZURhdGUgPSBpdCh0aGlzLl9hY3RpdmVEYXRlLCAtbik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSB6OlxuICAgICAgICB0aGlzLl9hY3RpdmVEYXRlID0gaXQodGhpcy5fYWN0aXZlRGF0ZSwgbik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBXZTpcbiAgICAgICAgdGhpcy5fYWN0aXZlRGF0ZSA9IGl0KFxuICAgICAgICAgIHRoaXMuX2FjdGl2ZURhdGUsXG4gICAgICAgICAgLVdzKHRoaXMuX2FjdGl2ZURhdGUsIG8pXG4gICAgICAgICk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBGZTpcbiAgICAgICAgdGhpcy5fYWN0aXZlRGF0ZSA9IGl0KFxuICAgICAgICAgIHRoaXMuX2FjdGl2ZURhdGUsXG4gICAgICAgICAgbyAtIFdzKHRoaXMuX2FjdGl2ZURhdGUsIG8pIC0gMVxuICAgICAgICApO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugem46XG4gICAgICAgIHRoaXMuX2FjdGl2ZURhdGUgPSBpdCh0aGlzLl9hY3RpdmVEYXRlLCAtbyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBVbjpcbiAgICAgICAgdGhpcy5fYWN0aXZlRGF0ZSA9IGl0KHRoaXMuX2FjdGl2ZURhdGUsIG8pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgY3Q6XG4gICAgICBjYXNlIEtzOlxuICAgICAgICB0aGlzLl9zZWxlY3RZZWFyKHRoaXMuYWN0aXZlWWVhcik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgRGkoXG4gICAgICBlLFxuICAgICAgdGhpcy5fYWN0aXZlRGF0ZSxcbiAgICAgIHRoaXMuX3ZpZXcsXG4gICAgICB2dCxcbiAgICAgIHRoaXMuX29wdGlvbnMubWluLFxuICAgICAgdGhpcy5fb3B0aW9ucy5tYXhcbiAgICApIHx8IHRoaXMuX2NoYW5nZVZpZXcoXCJ5ZWFyc1wiKSwgdGhpcy5fcmVtb3ZlSGlnaGxpZ2h0RnJvbUNlbGwoaSksIHRoaXMuX2ZvY3VzQWN0aXZlQ2VsbCh0aGlzLmFjdGl2ZUNlbGwpLCB0LnByZXZlbnREZWZhdWx0KCk7XG4gIH1cbiAgX2dldEFjdGl2ZVllYXJDZWxsKCkge1xuICAgIGNvbnN0IHQgPSBkLmZpbmQoXCJ0ZFwiLCB0aGlzLmRhdGVzQ29udGFpbmVyKTtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0KS5maW5kKChpKSA9PiBwYXJzZUludChpLmRhdGFzZXQudGVZZWFyLCAxMCkgPT09IHRoaXMuYWN0aXZlWWVhcik7XG4gIH1cbiAgX3NldEluaXRpYWxEYXRlKCkge1xuICAgIHRoaXMuX2lucHV0LnZhbHVlID8gdGhpcy5faGFuZGxlVXNlcklucHV0KHRoaXMuX2lucHV0LnZhbHVlKSA6IHRoaXMuX29wdGlvbnMuc3RhcnREYXRlID8gdGhpcy5fYWN0aXZlRGF0ZSA9IG5ldyBEYXRlKHRoaXMuX29wdGlvbnMuc3RhcnREYXRlKSA6IHRoaXMuX2FjdGl2ZURhdGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKTtcbiAgfVxuICBjbG9zZSgpIHtcbiAgICBjb25zdCB0ID0gYy50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIFBmKTtcbiAgICAhdGhpcy5faXNPcGVuIHx8IHQuZGVmYXVsdFByZXZlbnRlZCB8fCAodGhpcy5fcmVtb3ZlRGF0ZXBpY2tlckxpc3RlbmVycygpLCB0aGlzLl9hbmltYXRpb25zICYmIGguYWRkQ2xhc3ModGhpcy5jb250YWluZXIsIHRoaXMuX2NsYXNzZXMuZmFkZU91dCksIHRoaXMuX29wdGlvbnMuaW5saW5lID8gdGhpcy5fY2xvc2VEcm9wZG93bigpIDogdGhpcy5fY2xvc2VNb2RhbCgpLCB0aGlzLl9pc09wZW4gPSAhMSwgdGhpcy5fdmlldyA9IHRoaXMuX29wdGlvbnMudmlldywgdGhpcy50b2dnbGVCdXR0b24gPyB0aGlzLnRvZ2dsZUJ1dHRvbi5mb2N1cygpIDogdGhpcy5faW5wdXQuZm9jdXMoKSk7XG4gIH1cbiAgX2Nsb3NlRHJvcGRvd24oKSB7XG4gICAgY29uc3QgdCA9IGQuZmluZE9uZShXZiksIGUgPSB0aGlzLl9nZXRDb250YWluZXIoKTtcbiAgICB3aW5kb3cubWF0Y2hNZWRpYShcIihwcmVmZXJzLXJlZHVjZWQtbW90aW9uOiByZWR1Y2UpXCIpLm1hdGNoZXMgJiYgKHQgJiYgZS5yZW1vdmVDaGlsZCh0KSwgdGhpcy5fcG9wcGVyICYmIHRoaXMuX3BvcHBlci5kZXN0cm95KCkpLCB0LmFkZEV2ZW50TGlzdGVuZXIoXCJhbmltYXRpb25lbmRcIiwgKCkgPT4ge1xuICAgICAgdCAmJiBlLnJlbW92ZUNoaWxkKHQpLCB0aGlzLl9wb3BwZXIgJiYgdGhpcy5fcG9wcGVyLmRlc3Ryb3koKTtcbiAgICB9KSwgdGhpcy5fcmVtb3ZlRm9jdXNUcmFwKCk7XG4gIH1cbiAgX2Nsb3NlTW9kYWwoKSB7XG4gICAgY29uc3QgdCA9IGQuZmluZE9uZShaZiksIGUgPSBkLmZpbmRPbmUoVmYpO1xuICAgICFlIHx8ICF0IHx8ICh0aGlzLl9hbmltYXRpb25zID8gKGguYWRkQ2xhc3ModCwgdGhpcy5fY2xhc3Nlcy5mYWRlT3V0U2hvcnQpLCB0LmFkZEV2ZW50TGlzdGVuZXIoXCJhbmltYXRpb25lbmRcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5fcmVtb3ZlUGlja2VyKHQsIGUpLCB0aGlzLl9zY3JvbGxCYXIucmVzZXQoKTtcbiAgICB9KSkgOiAodGhpcy5fcmVtb3ZlUGlja2VyKHQsIGUpLCB0aGlzLl9zY3JvbGxCYXIucmVzZXQoKSkpO1xuICB9XG4gIF9yZW1vdmVQaWNrZXIodCwgZSkge1xuICAgIGNvbnN0IGkgPSB0aGlzLl9nZXRDb250YWluZXIoKTtcbiAgICBpLnJlbW92ZUNoaWxkKHQpLCBpLnJlbW92ZUNoaWxkKGUpO1xuICB9XG4gIF9yZW1vdmVGb2N1c1RyYXAoKSB7XG4gICAgdGhpcy5fZm9jdXNUcmFwICYmICh0aGlzLl9mb2N1c1RyYXAuZGlzYWJsZSgpLCB0aGlzLl9mb2N1c1RyYXAgPSBudWxsKTtcbiAgfVxuICBfcmVtb3ZlRGF0ZXBpY2tlckxpc3RlbmVycygpIHtcbiAgICBjLm9mZih0aGlzLm5leHRCdXR0b24sIFwiY2xpY2tcIiksIGMub2ZmKHRoaXMucHJldmlvdXNCdXR0b24sIFwiY2xpY2tcIiksIGMub2ZmKHRoaXMudmlld0NoYW5nZUJ1dHRvbiwgXCJjbGlja1wiKSwgYy5vZmYodGhpcy5va0J1dHRvbiwgXCJjbGlja1wiKSwgYy5vZmYodGhpcy5jYW5jZWxCdXR0b24sIFwiY2xpY2tcIiksIGMub2ZmKHRoaXMuY2xlYXJCdXR0b24sIFwiY2xpY2tcIiksIGMub2ZmKHRoaXMuZGF0ZXNDb250YWluZXIsIFwiY2xpY2tcIiksIGMub2ZmKHRoaXMuZGF0ZXNDb250YWluZXIsIFwia2V5ZG93blwiKSwgYy5vZmYodGhpcy5kYXRlc0NvbnRhaW5lciwgXCJmb2N1c1wiKSwgYy5vZmYodGhpcy5kYXRlc0NvbnRhaW5lciwgXCJibHVyXCIpLCBjLm9mZihkb2N1bWVudCwgaHMpO1xuICB9XG4gIGRpc3Bvc2UoKSB7XG4gICAgdGhpcy5faXNPcGVuICYmIHRoaXMuY2xvc2UoKSwgdGhpcy5fcmVtb3ZlSW5wdXRBbmRUb2dnbGVMaXN0ZW5lcnMoKTtcbiAgICBjb25zdCB0ID0gZC5maW5kT25lKFxuICAgICAgYCMke3RoaXMuX3RvZ2dsZUJ1dHRvbklkfWBcbiAgICApO1xuICAgIHQgJiYgdGhpcy5fZWxlbWVudC5yZW1vdmVDaGlsZCh0KSwgeS5yZW1vdmVEYXRhKHRoaXMuX2VsZW1lbnQsIHpzKSwgdGhpcy5fZWxlbWVudCA9IG51bGwsIHRoaXMuX2lucHV0ID0gbnVsbCwgdGhpcy5fb3B0aW9ucyA9IG51bGwsIHRoaXMuX2FjdGl2ZURhdGUgPSBudWxsLCB0aGlzLl9zZWxlY3RlZERhdGUgPSBudWxsLCB0aGlzLl9zZWxlY3RlZFllYXIgPSBudWxsLCB0aGlzLl9zZWxlY3RlZE1vbnRoID0gbnVsbCwgdGhpcy5faGVhZGVyRGF0ZSA9IG51bGwsIHRoaXMuX2hlYWRlclllYXIgPSBudWxsLCB0aGlzLl9oZWFkZXJNb250aCA9IG51bGwsIHRoaXMuX3ZpZXcgPSBudWxsLCB0aGlzLl9wb3BwZXIgPSBudWxsLCB0aGlzLl9mb2N1c1RyYXAgPSBudWxsO1xuICB9XG4gIF9yZW1vdmVJbnB1dEFuZFRvZ2dsZUxpc3RlbmVycygpIHtcbiAgICBjLm9mZih0aGlzLl9pbnB1dCwgXCJpbnB1dFwiKSwgYy5vZmYoXG4gICAgICB0aGlzLl9lbGVtZW50LFxuICAgICAgaHMsXG4gICAgICBkc1xuICAgICksIGMub2ZmKHRoaXMuX2VsZW1lbnQsIFwia2V5ZG93blwiLCBkcyk7XG4gIH1cbiAgaGFuZGxlT2soKSB7XG4gICAgdGhpcy5fY29uZmlybVNlbGVjdGlvbih0aGlzLl9oZWFkZXJEYXRlKSwgdGhpcy5jbG9zZSgpO1xuICB9XG4gIF9zZWxlY3REYXRlKHQsIGUgPSB0aGlzLmFjdGl2ZUNlbGwpIHtcbiAgICBjb25zdCB7IG1pbjogaSwgbWF4OiBuLCBmaWx0ZXI6IG8sIGRpc2FibGVQYXN0OiByLCBkaXNhYmxlRnV0dXJlOiBhIH0gPSB0aGlzLl9vcHRpb25zO1xuICAgIG5uKHQsIGksIG4sIG8sIHIsIGEpIHx8ICh0aGlzLl9yZW1vdmVDdXJyZW50U2VsZWN0aW9uU3R5bGVzKCksIHRoaXMuX3JlbW92ZUN1cnJlbnRGb2N1c1N0eWxlcygpLCB0aGlzLl9hZGRTZWxlY3RlZFN0eWxlcyhlKSwgdGhpcy5fc2VsZWN0ZWREYXRlID0gdCwgdGhpcy5fc2VsZWN0ZWRZZWFyID0gQih0KSwgdGhpcy5fc2VsZWN0ZWRNb250aCA9IFkodCksIHRoaXMuX2hlYWRlckRhdGUgPSB0LCAodGhpcy5fb3B0aW9ucy5pbmxpbmUgfHwgdGhpcy5vcHRpb25zLmNvbmZpcm1EYXRlT25TZWxlY3QpICYmICh0aGlzLl9jb25maXJtU2VsZWN0aW9uKHQpLCB0aGlzLmNsb3NlKCkpKTtcbiAgfVxuICBfc2VsZWN0WWVhcih0LCBlID0gdGhpcy5hY3RpdmVDZWxsKSB7XG4gICAgdGhpcy5fcmVtb3ZlQ3VycmVudFNlbGVjdGlvblN0eWxlcygpLCB0aGlzLl9yZW1vdmVDdXJyZW50Rm9jdXNTdHlsZXMoKSwgdGhpcy5fYWRkU2VsZWN0ZWRTdHlsZXMoZSksIHRoaXMuX2hlYWRlclllYXIgPSB0LCB0aGlzLl9hc3luY0NoYW5nZVZpZXcoXCJtb250aHNcIik7XG4gIH1cbiAgX3NlbGVjdE1vbnRoKHQsIGUgPSB0aGlzLmFjdGl2ZUNlbGwpIHtcbiAgICB0aGlzLl9yZW1vdmVDdXJyZW50U2VsZWN0aW9uU3R5bGVzKCksIHRoaXMuX3JlbW92ZUN1cnJlbnRGb2N1c1N0eWxlcygpLCB0aGlzLl9hZGRTZWxlY3RlZFN0eWxlcyhlKSwgdGhpcy5faGVhZGVyTW9udGggPSB0LCB0aGlzLl9hc3luY0NoYW5nZVZpZXcoXCJkYXlzXCIpO1xuICB9XG4gIF9yZW1vdmVTZWxlY3RlZFN0eWxlcyh0KSB7XG4gICAgdCAmJiB0LnJlbW92ZUF0dHJpYnV0ZShcImRhdGEtdGUtZGF0ZXBpY2tlci1jZWxsLXNlbGVjdGVkXCIpO1xuICB9XG4gIF9hZGRTZWxlY3RlZFN0eWxlcyh0KSB7XG4gICAgdCAmJiB0LnNldEF0dHJpYnV0ZShcImRhdGEtdGUtZGF0ZXBpY2tlci1jZWxsLXNlbGVjdGVkXCIsIFwiXCIpO1xuICB9XG4gIF9jb25maXJtU2VsZWN0aW9uKHQpIHtcbiAgICBpZiAodCkge1xuICAgICAgY29uc3QgZSA9IHRoaXMuZm9ybWF0RGF0ZSh0KTtcbiAgICAgIHRoaXMuX2lucHV0LnZhbHVlID0gZSwgYy50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEhmLCB7IGRhdGU6IHQgfSksIGMudHJpZ2dlcih0aGlzLl9pbnB1dCwgXCJpbnB1dFwiKTtcbiAgICB9XG4gIH1cbiAgaGFuZGxlQ2FuY2VsKCkge1xuICAgIHRoaXMuX3NlbGVjdGVkRGF0ZSA9IG51bGwsIHRoaXMuX3NlbGVjdGVkWWVhciA9IG51bGwsIHRoaXMuX3NlbGVjdGVkTW9udGggPSBudWxsLCB0aGlzLmNsb3NlKCk7XG4gIH1cbiAgaGFuZGxlQ2xlYXIoKSB7XG4gICAgdGhpcy5fc2VsZWN0ZWREYXRlID0gbnVsbCwgdGhpcy5fc2VsZWN0ZWRNb250aCA9IG51bGwsIHRoaXMuX3NlbGVjdGVkWWVhciA9IG51bGwsIHRoaXMuX2hlYWRlckRhdGUgPSBudWxsLCB0aGlzLl9oZWFkZXJNb250aCA9IG51bGwsIHRoaXMuX2hlYWRlclllYXIgPSBudWxsLCB0aGlzLl9yZW1vdmVDdXJyZW50U2VsZWN0aW9uU3R5bGVzKCksIHRoaXMuX2lucHV0LnZhbHVlID0gXCJcIiwgdGhpcy5fc2V0SW5pdGlhbERhdGUoKSwgdGhpcy5fY2hhbmdlVmlldyhcImRheXNcIiksIHRoaXMuX3VwZGF0ZUhlYWRlckRhdGUoXG4gICAgICB0aGlzLl9hY3RpdmVEYXRlLFxuICAgICAgdGhpcy5fb3B0aW9ucy5tb250aHNTaG9ydCxcbiAgICAgIHRoaXMuX29wdGlvbnMud2Vla2RheXNTaG9ydFxuICAgICk7XG4gIH1cbiAgX3JlbW92ZUN1cnJlbnRTZWxlY3Rpb25TdHlsZXMoKSB7XG4gICAgY29uc3QgdCA9IGQuZmluZE9uZShcbiAgICAgIFwiW2RhdGEtdGUtZGF0ZXBpY2tlci1jZWxsLXNlbGVjdGVkXVwiLFxuICAgICAgdGhpcy5jb250YWluZXJcbiAgICApO1xuICAgIHQgJiYgdC5yZW1vdmVBdHRyaWJ1dGUoXCJkYXRhLXRlLWRhdGVwaWNrZXItY2VsbC1zZWxlY3RlZFwiKTtcbiAgfVxuICBfcmVtb3ZlQ3VycmVudEZvY3VzU3R5bGVzKCkge1xuICAgIGNvbnN0IHQgPSBkLmZpbmRPbmUoXG4gICAgICBcIltkYXRhLXRlLWRhdGVwaWNrZXItY2VsbC1mb2N1c2VkXVwiLFxuICAgICAgdGhpcy5jb250YWluZXJcbiAgICApO1xuICAgIHQgJiYgdC5yZW1vdmVBdHRyaWJ1dGUoXCJkYXRhLXRlLWRhdGVwaWNrZXItY2VsbC1mb2N1c2VkXCIpO1xuICB9XG4gIGZvcm1hdERhdGUodCkge1xuICAgIGNvbnN0IGUgPSBaKHQpLCBpID0gdGhpcy5fYWRkTGVhZGluZ1plcm8oWih0KSksIG4gPSB0aGlzLl9vcHRpb25zLndlZWtkYXlzU2hvcnRbVnModCldLCBvID0gdGhpcy5fb3B0aW9ucy53ZWVrZGF5c0Z1bGxbVnModCldLCByID0gWSh0KSArIDEsIGEgPSB0aGlzLl9hZGRMZWFkaW5nWmVybyhZKHQpICsgMSksIGwgPSB0aGlzLl9vcHRpb25zLm1vbnRoc1Nob3J0W1kodCldLCBwID0gdGhpcy5fb3B0aW9ucy5tb250aHNGdWxsW1kodCldLCB1ID0gQih0KS50b1N0cmluZygpLmxlbmd0aCA9PT0gMiA/IEIodCkgOiBCKHQpLnRvU3RyaW5nKCkuc2xpY2UoMiwgNCksIF8gPSBCKHQpLCBmID0gdGhpcy5fb3B0aW9ucy5mb3JtYXQuc3BsaXQoXG4gICAgICAvKGR7MSw0fXxtezEsNH18eXs0fXx5eXwhLikvZ1xuICAgICk7XG4gICAgbGV0IGcgPSBcIlwiO1xuICAgIHJldHVybiBmLmZvckVhY2goKG0pID0+IHtcbiAgICAgIHN3aXRjaCAobSkge1xuICAgICAgICBjYXNlIFwiZGRkZFwiOlxuICAgICAgICAgIG0gPSBtLnJlcGxhY2UobSwgbyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJkZGRcIjpcbiAgICAgICAgICBtID0gbS5yZXBsYWNlKG0sIG4pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiZGRcIjpcbiAgICAgICAgICBtID0gbS5yZXBsYWNlKG0sIGkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiZFwiOlxuICAgICAgICAgIG0gPSBtLnJlcGxhY2UobSwgZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJtbW1tXCI6XG4gICAgICAgICAgbSA9IG0ucmVwbGFjZShtLCBwKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIm1tbVwiOlxuICAgICAgICAgIG0gPSBtLnJlcGxhY2UobSwgbCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJtbVwiOlxuICAgICAgICAgIG0gPSBtLnJlcGxhY2UobSwgYSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJtXCI6XG4gICAgICAgICAgbSA9IG0ucmVwbGFjZShtLCByKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInl5eXlcIjpcbiAgICAgICAgICBtID0gbS5yZXBsYWNlKG0sIF8pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwieXlcIjpcbiAgICAgICAgICBtID0gbS5yZXBsYWNlKG0sIHUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgZyArPSBtO1xuICAgIH0pLCBnO1xuICB9XG4gIF9hZGRMZWFkaW5nWmVybyh0KSB7XG4gICAgcmV0dXJuIHBhcnNlSW50KHQsIDEwKSA8IDEwID8gYDAke3R9YCA6IHQ7XG4gIH1cbiAgX3BpY2tEYXkodCwgZSkge1xuICAgIGNvbnN0IGkgPSBPYSh0KSwgeyBtaW46IG4sIG1heDogbywgZmlsdGVyOiByLCBkaXNhYmxlUGFzdDogYSwgZGlzYWJsZUZ1dHVyZTogbCB9ID0gdGhpcy5fb3B0aW9ucztcbiAgICBubihpLCBuLCBvLCByLCBhLCBsKSB8fCAodGhpcy5fYWN0aXZlRGF0ZSA9IGksIHRoaXMuX3NlbGVjdERhdGUoaSwgZSkpO1xuICB9XG4gIF9waWNrWWVhcih0KSB7XG4gICAgY29uc3QgeyBtaW46IGUsIG1heDogaSwgZGlzYWJsZVBhc3Q6IG4sIGRpc2FibGVGdXR1cmU6IG8gfSA9IHRoaXMuX29wdGlvbnM7XG4gICAgaWYgKEJvKHQsIGUsIGksIG4sIG8pKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHIgPSBFdCh0LCB0aGlzLmFjdGl2ZU1vbnRoLCB0aGlzLmFjdGl2ZURheSk7XG4gICAgdGhpcy5fYWN0aXZlRGF0ZSA9IHIsIHRoaXMuX3NlbGVjdGVkRGF0ZSA9IHIsIHRoaXMuX3NlbGVjdFllYXIodCk7XG4gIH1cbiAgX3BpY2tNb250aCh0LCBlKSB7XG4gICAgY29uc3QgeyBtaW46IGksIG1heDogbiwgZGlzYWJsZVBhc3Q6IG8sIGRpc2FibGVGdXR1cmU6IHIgfSA9IHRoaXMuX29wdGlvbnM7XG4gICAgaWYgKHpjKHQsIGUsIGksIG4sIG8sIHIpIHx8IEJvKGUsIGksIG4sIG8sIHIpKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGEgPSBFdChlLCB0LCB0aGlzLmFjdGl2ZURheSk7XG4gICAgdGhpcy5fYWN0aXZlRGF0ZSA9IGEsIHRoaXMuX3NlbGVjdE1vbnRoKHQpO1xuICB9XG4gIG5leHRNb250aCgpIHtcbiAgICBjb25zdCB0ID0gbnQodGhpcy5fYWN0aXZlRGF0ZSwgMSksIGUgPSBGcyhcbiAgICAgIHQsXG4gICAgICB0aGlzLl9oZWFkZXJEYXRlLFxuICAgICAgdGhpcy5fb3B0aW9ucyxcbiAgICAgIHRoaXMuX2NsYXNzZXNcbiAgICApO1xuICAgIHRoaXMuX2FjdGl2ZURhdGUgPSB0LCB0aGlzLnZpZXdDaGFuZ2VCdXR0b24udGV4dENvbnRlbnQgPSBgJHt0aGlzLl9vcHRpb25zLm1vbnRoc0Z1bGxbdGhpcy5hY3RpdmVNb250aF19ICR7dGhpcy5hY3RpdmVZZWFyfWAsIHRoaXMudmlld0NoYW5nZUJ1dHRvbi5pbm5lckhUTUwgKz0gJHQoXG4gICAgICB0aGlzLl9vcHRpb25zLFxuICAgICAgdGhpcy5fY2xhc3Nlc1xuICAgICksIHRoaXMuZGF0ZXNDb250YWluZXIuaW5uZXJIVE1MID0gZTtcbiAgfVxuICBwcmV2aW91c01vbnRoKCkge1xuICAgIGNvbnN0IHQgPSBudCh0aGlzLl9hY3RpdmVEYXRlLCAtMSk7XG4gICAgdGhpcy5fYWN0aXZlRGF0ZSA9IHQ7XG4gICAgY29uc3QgZSA9IEZzKFxuICAgICAgdCxcbiAgICAgIHRoaXMuX2hlYWRlckRhdGUsXG4gICAgICB0aGlzLl9vcHRpb25zLFxuICAgICAgdGhpcy5fY2xhc3Nlc1xuICAgICk7XG4gICAgdGhpcy52aWV3Q2hhbmdlQnV0dG9uLnRleHRDb250ZW50ID0gYCR7dGhpcy5fb3B0aW9ucy5tb250aHNGdWxsW3RoaXMuYWN0aXZlTW9udGhdfSAke3RoaXMuYWN0aXZlWWVhcn1gLCB0aGlzLnZpZXdDaGFuZ2VCdXR0b24uaW5uZXJIVE1MICs9ICR0KFxuICAgICAgdGhpcy5fb3B0aW9ucyxcbiAgICAgIHRoaXMuX2NsYXNzZXNcbiAgICApLCB0aGlzLmRhdGVzQ29udGFpbmVyLmlubmVySFRNTCA9IGU7XG4gIH1cbiAgbmV4dFllYXIoKSB7XG4gICAgY29uc3QgdCA9IGl0KHRoaXMuX2FjdGl2ZURhdGUsIDEpO1xuICAgIHRoaXMuX2FjdGl2ZURhdGUgPSB0LCB0aGlzLnZpZXdDaGFuZ2VCdXR0b24udGV4dENvbnRlbnQgPSBgJHt0aGlzLmFjdGl2ZVllYXJ9YCwgdGhpcy52aWV3Q2hhbmdlQnV0dG9uLmlubmVySFRNTCArPSAkdChcbiAgICAgIHRoaXMuX29wdGlvbnMsXG4gICAgICB0aGlzLl9jbGFzc2VzXG4gICAgKTtcbiAgICBjb25zdCBlID0gWXMoXG4gICAgICB0aGlzLmFjdGl2ZVllYXIsXG4gICAgICB0aGlzLl9zZWxlY3RlZFllYXIsXG4gICAgICB0aGlzLl9zZWxlY3RlZE1vbnRoLFxuICAgICAgdGhpcy5fb3B0aW9ucyxcbiAgICAgIGNzLFxuICAgICAgdGhpcy5fY2xhc3Nlc1xuICAgICk7XG4gICAgdGhpcy5kYXRlc0NvbnRhaW5lci5pbm5lckhUTUwgPSBlO1xuICB9XG4gIHByZXZpb3VzWWVhcigpIHtcbiAgICBjb25zdCB0ID0gaXQodGhpcy5fYWN0aXZlRGF0ZSwgLTEpO1xuICAgIHRoaXMuX2FjdGl2ZURhdGUgPSB0LCB0aGlzLnZpZXdDaGFuZ2VCdXR0b24udGV4dENvbnRlbnQgPSBgJHt0aGlzLmFjdGl2ZVllYXJ9YCwgdGhpcy52aWV3Q2hhbmdlQnV0dG9uLmlubmVySFRNTCArPSAkdChcbiAgICAgIHRoaXMuX29wdGlvbnMsXG4gICAgICB0aGlzLl9jbGFzc2VzXG4gICAgKTtcbiAgICBjb25zdCBlID0gWXMoXG4gICAgICB0aGlzLmFjdGl2ZVllYXIsXG4gICAgICB0aGlzLl9zZWxlY3RlZFllYXIsXG4gICAgICB0aGlzLl9zZWxlY3RlZE1vbnRoLFxuICAgICAgdGhpcy5fb3B0aW9ucyxcbiAgICAgIGNzLFxuICAgICAgdGhpcy5fY2xhc3Nlc1xuICAgICk7XG4gICAgdGhpcy5kYXRlc0NvbnRhaW5lci5pbm5lckhUTUwgPSBlO1xuICB9XG4gIG5leHRZZWFycygpIHtcbiAgICBjb25zdCB0ID0gaXQodGhpcy5fYWN0aXZlRGF0ZSwgMjQpO1xuICAgIHRoaXMuX2FjdGl2ZURhdGUgPSB0O1xuICAgIGNvbnN0IGUgPSBqcyhcbiAgICAgIHQsXG4gICAgICB0aGlzLl9zZWxlY3RlZFllYXIsXG4gICAgICB0aGlzLl9vcHRpb25zLFxuICAgICAgdnQsXG4gICAgICBscyxcbiAgICAgIHRoaXMuX2NsYXNzZXNcbiAgICApO1xuICAgIHRoaXMudmlld0NoYW5nZUJ1dHRvbi50ZXh0Q29udGVudCA9IGAke3RoaXMuZmlyc3RZZWFySW5WaWV3fSAtICR7dGhpcy5sYXN0WWVhckluVmlld31gLCB0aGlzLnZpZXdDaGFuZ2VCdXR0b24uaW5uZXJIVE1MICs9ICR0KFxuICAgICAgdGhpcy5fb3B0aW9ucyxcbiAgICAgIHRoaXMuX2NsYXNzZXNcbiAgICApLCB0aGlzLmRhdGVzQ29udGFpbmVyLmlubmVySFRNTCA9IGU7XG4gIH1cbiAgcHJldmlvdXNZZWFycygpIHtcbiAgICBjb25zdCB0ID0gaXQodGhpcy5fYWN0aXZlRGF0ZSwgLTI0KTtcbiAgICB0aGlzLl9hY3RpdmVEYXRlID0gdDtcbiAgICBjb25zdCBlID0ganMoXG4gICAgICB0LFxuICAgICAgdGhpcy5fc2VsZWN0ZWRZZWFyLFxuICAgICAgdGhpcy5fb3B0aW9ucyxcbiAgICAgIHZ0LFxuICAgICAgbHMsXG4gICAgICB0aGlzLl9jbGFzc2VzXG4gICAgKTtcbiAgICB0aGlzLnZpZXdDaGFuZ2VCdXR0b24udGV4dENvbnRlbnQgPSBgJHt0aGlzLmZpcnN0WWVhckluVmlld30gLSAke3RoaXMubGFzdFllYXJJblZpZXd9YCwgdGhpcy52aWV3Q2hhbmdlQnV0dG9uLmlubmVySFRNTCArPSAkdChcbiAgICAgIHRoaXMuX29wdGlvbnMsXG4gICAgICB0aGlzLl9jbGFzc2VzXG4gICAgKSwgdGhpcy5kYXRlc0NvbnRhaW5lci5pbm5lckhUTUwgPSBlO1xuICB9XG4gIF9hc3luY0NoYW5nZVZpZXcodCkge1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5fY2hhbmdlVmlldyh0KTtcbiAgICB9LCAwKTtcbiAgfVxuICBfY2hhbmdlVmlldyh0KSB7XG4gICAgdGhpcy5fdmlldyA9IHQsIHRoaXMuZGF0ZXNDb250YWluZXIuYmx1cigpLCB0ID09PSBcImRheXNcIiAmJiAodGhpcy5kYXRlc0NvbnRhaW5lci5pbm5lckhUTUwgPSBGcyhcbiAgICAgIHRoaXMuX2FjdGl2ZURhdGUsXG4gICAgICB0aGlzLl9oZWFkZXJEYXRlLFxuICAgICAgdGhpcy5fb3B0aW9ucyxcbiAgICAgIHRoaXMuX2NsYXNzZXNcbiAgICApKSwgdCA9PT0gXCJtb250aHNcIiAmJiAodGhpcy5kYXRlc0NvbnRhaW5lci5pbm5lckhUTUwgPSBZcyhcbiAgICAgIHRoaXMuYWN0aXZlWWVhcixcbiAgICAgIHRoaXMuX3NlbGVjdGVkWWVhcixcbiAgICAgIHRoaXMuX3NlbGVjdGVkTW9udGgsXG4gICAgICB0aGlzLl9vcHRpb25zLFxuICAgICAgY3MsXG4gICAgICB0aGlzLl9jbGFzc2VzXG4gICAgKSksIHQgPT09IFwieWVhcnNcIiAmJiAodGhpcy5kYXRlc0NvbnRhaW5lci5pbm5lckhUTUwgPSBqcyhcbiAgICAgIHRoaXMuX2FjdGl2ZURhdGUsXG4gICAgICB0aGlzLl9zZWxlY3RlZFllYXIsXG4gICAgICB0aGlzLl9vcHRpb25zLFxuICAgICAgdnQsXG4gICAgICBscyxcbiAgICAgIHRoaXMuX2NsYXNzZXNcbiAgICApKSwgdGhpcy5kYXRlc0NvbnRhaW5lci5mb2N1cygpLCB0aGlzLl91cGRhdGVWaWV3Q29udHJvbHNBbmRBdHRyaWJ1dGVzKHQpLCB0aGlzLl91cGRhdGVDb250cm9sc0Rpc2FibGVkU3RhdGUoKTtcbiAgfVxuICBfdXBkYXRlVmlld0NvbnRyb2xzQW5kQXR0cmlidXRlcyh0KSB7XG4gICAgdCA9PT0gXCJkYXlzXCIgJiYgKHRoaXMudmlld0NoYW5nZUJ1dHRvbi50ZXh0Q29udGVudCA9IGAke3RoaXMuX29wdGlvbnMubW9udGhzRnVsbFt0aGlzLmFjdGl2ZU1vbnRoXX0gJHt0aGlzLmFjdGl2ZVllYXJ9YCwgdGhpcy52aWV3Q2hhbmdlQnV0dG9uLmlubmVySFRNTCArPSAkdChcbiAgICAgIHRoaXMuX29wdGlvbnMsXG4gICAgICB0aGlzLl9jbGFzc2VzXG4gICAgKSwgdGhpcy52aWV3Q2hhbmdlQnV0dG9uLnNldEF0dHJpYnV0ZShcbiAgICAgIFwiYXJpYS1sYWJlbFwiLFxuICAgICAgdGhpcy5fb3B0aW9ucy5zd2l0Y2hUb011bHRpWWVhclZpZXdMYWJlbFxuICAgICksIHRoaXMucHJldmlvdXNCdXR0b24uc2V0QXR0cmlidXRlKFxuICAgICAgXCJhcmlhLWxhYmVsXCIsXG4gICAgICB0aGlzLl9vcHRpb25zLnByZXZNb250aExhYmVsXG4gICAgKSwgdGhpcy5uZXh0QnV0dG9uLnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIiwgdGhpcy5fb3B0aW9ucy5uZXh0TW9udGhMYWJlbCkpLCB0ID09PSBcIm1vbnRoc1wiICYmICh0aGlzLnZpZXdDaGFuZ2VCdXR0b24udGV4dENvbnRlbnQgPSBgJHt0aGlzLmFjdGl2ZVllYXJ9YCwgdGhpcy52aWV3Q2hhbmdlQnV0dG9uLmlubmVySFRNTCArPSAkdChcbiAgICAgIHRoaXMuX29wdGlvbnMsXG4gICAgICB0aGlzLl9jbGFzc2VzXG4gICAgKSwgdGhpcy52aWV3Q2hhbmdlQnV0dG9uLnNldEF0dHJpYnV0ZShcbiAgICAgIFwiYXJpYS1sYWJlbFwiLFxuICAgICAgdGhpcy5fb3B0aW9ucy5zd2l0Y2hUb0RheVZpZXdMYWJlbFxuICAgICksIHRoaXMucHJldmlvdXNCdXR0b24uc2V0QXR0cmlidXRlKFxuICAgICAgXCJhcmlhLWxhYmVsXCIsXG4gICAgICB0aGlzLl9vcHRpb25zLnByZXZZZWFyTGFiZWxcbiAgICApLCB0aGlzLm5leHRCdXR0b24uc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiLCB0aGlzLl9vcHRpb25zLm5leHRZZWFyTGFiZWwpKSwgdCA9PT0gXCJ5ZWFyc1wiICYmICh0aGlzLnZpZXdDaGFuZ2VCdXR0b24udGV4dENvbnRlbnQgPSBgJHt0aGlzLmZpcnN0WWVhckluVmlld30gLSAke3RoaXMubGFzdFllYXJJblZpZXd9YCwgdGhpcy52aWV3Q2hhbmdlQnV0dG9uLmlubmVySFRNTCArPSAkdChcbiAgICAgIHRoaXMuX29wdGlvbnMsXG4gICAgICB0aGlzLl9jbGFzc2VzXG4gICAgKSwgdGhpcy52aWV3Q2hhbmdlQnV0dG9uLnNldEF0dHJpYnV0ZShcbiAgICAgIFwiYXJpYS1sYWJlbFwiLFxuICAgICAgdGhpcy5fb3B0aW9ucy5zd2l0Y2hUb01vbnRoVmlld0xhYmVsXG4gICAgKSwgdGhpcy5wcmV2aW91c0J1dHRvbi5zZXRBdHRyaWJ1dGUoXG4gICAgICBcImFyaWEtbGFiZWxcIixcbiAgICAgIHRoaXMuX29wdGlvbnMucHJldk11bHRpWWVhckxhYmVsXG4gICAgKSwgdGhpcy5uZXh0QnV0dG9uLnNldEF0dHJpYnV0ZShcbiAgICAgIFwiYXJpYS1sYWJlbFwiLFxuICAgICAgdGhpcy5fb3B0aW9ucy5uZXh0TXVsdGlZZWFyTGFiZWxcbiAgICApKTtcbiAgfVxuICBfdXBkYXRlQ29udHJvbHNEaXNhYmxlZFN0YXRlKCkge1xuICAgIF9mKFxuICAgICAgdGhpcy5fb3B0aW9ucy5kaXNhYmxlRnV0dXJlLFxuICAgICAgdGhpcy5fYWN0aXZlRGF0ZSxcbiAgICAgIHRoaXMuX3ZpZXcsXG4gICAgICB2dCxcbiAgICAgIHRoaXMuX29wdGlvbnMubWluLFxuICAgICAgdGhpcy5fb3B0aW9ucy5tYXgsXG4gICAgICB0aGlzLmxhc3RZZWFySW5WaWV3LFxuICAgICAgdGhpcy5maXJzdFllYXJJblZpZXdcbiAgICApID8gdGhpcy5uZXh0QnV0dG9uLmRpc2FibGVkID0gITAgOiB0aGlzLm5leHRCdXR0b24uZGlzYWJsZWQgPSAhMSwgZmYoXG4gICAgICB0aGlzLl9vcHRpb25zLmRpc2FibGVQYXN0LFxuICAgICAgdGhpcy5fYWN0aXZlRGF0ZSxcbiAgICAgIHRoaXMuX3ZpZXcsXG4gICAgICB2dCxcbiAgICAgIHRoaXMuX29wdGlvbnMubWluLFxuICAgICAgdGhpcy5fb3B0aW9ucy5tYXgsXG4gICAgICB0aGlzLmxhc3RZZWFySW5WaWV3LFxuICAgICAgdGhpcy5maXJzdFllYXJJblZpZXdcbiAgICApID8gdGhpcy5wcmV2aW91c0J1dHRvbi5kaXNhYmxlZCA9ICEwIDogdGhpcy5wcmV2aW91c0J1dHRvbi5kaXNhYmxlZCA9ICExO1xuICB9XG4gIF9oYW5kbGVVc2VySW5wdXQodCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLl9nZXREZWxpbWV0ZXJzKHRoaXMuX29wdGlvbnMuZm9ybWF0KSwgaSA9IHRoaXMuX3BhcnNlRGF0ZSh0LCB0aGlzLl9vcHRpb25zLmZvcm1hdCwgZSk7XG4gICAgZGYoaSkgPyAodGhpcy5fYWN0aXZlRGF0ZSA9IGksIHRoaXMuX3NlbGVjdGVkRGF0ZSA9IGksIHRoaXMuX3NlbGVjdGVkWWVhciA9IEIoaSksIHRoaXMuX3NlbGVjdGVkTW9udGggPSBZKGkpLCB0aGlzLl9oZWFkZXJEYXRlID0gaSkgOiAodGhpcy5fYWN0aXZlRGF0ZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpLCB0aGlzLl9zZWxlY3RlZERhdGUgPSBudWxsLCB0aGlzLl9zZWxlY3RlZE1vbnRoID0gbnVsbCwgdGhpcy5fc2VsZWN0ZWRZZWFyID0gbnVsbCwgdGhpcy5faGVhZGVyRGF0ZSA9IG51bGwsIHRoaXMuX2hlYWRlck1vbnRoID0gbnVsbCwgdGhpcy5faGVhZGVyWWVhciA9IG51bGwpO1xuICB9XG4gIF9nZXREZWxpbWV0ZXJzKHQpIHtcbiAgICByZXR1cm4gdC5tYXRjaCgvW14oZG15KV17MSx9L2cpO1xuICB9XG4gIF9wYXJzZURhdGUodCwgZSwgaSkge1xuICAgIGxldCBuO1xuICAgIGlbMF0gIT09IGlbMV0gPyBuID0gaVswXSArIGlbMV0gOiBuID0gaVswXTtcbiAgICBjb25zdCBvID0gbmV3IFJlZ0V4cChgWyR7bn1dYCksIHIgPSB0LnNwbGl0KG8pLCBhID0gZS5zcGxpdChvKSwgbCA9IGUuaW5kZXhPZihcIm1tbVwiKSAhPT0gLTEsIHAgPSBbXTtcbiAgICBmb3IgKGxldCBiID0gMDsgYiA8IGEubGVuZ3RoOyBiKyspXG4gICAgICBhW2JdLmluZGV4T2YoXCJ5eVwiKSAhPT0gLTEgJiYgKHBbMF0gPSB7IHZhbHVlOiByW2JdLCBmb3JtYXQ6IGFbYl0gfSksIGFbYl0uaW5kZXhPZihcIm1cIikgIT09IC0xICYmIChwWzFdID0geyB2YWx1ZTogcltiXSwgZm9ybWF0OiBhW2JdIH0pLCBhW2JdLmluZGV4T2YoXCJkXCIpICE9PSAtMSAmJiBhW2JdLmxlbmd0aCA8PSAyICYmIChwWzJdID0geyB2YWx1ZTogcltiXSwgZm9ybWF0OiBhW2JdIH0pO1xuICAgIGxldCB1O1xuICAgIGUuaW5kZXhPZihcIm1tbW1cIikgIT09IC0xID8gdSA9IHRoaXMuX29wdGlvbnMubW9udGhzRnVsbCA6IHUgPSB0aGlzLl9vcHRpb25zLm1vbnRoc1Nob3J0O1xuICAgIGNvbnN0IF8gPSBOdW1iZXIocFswXS52YWx1ZSksIGYgPSBsID8gdGhpcy5nZXRNb250aE51bWJlckJ5TW9udGhOYW1lKHBbMV0udmFsdWUsIHUpIDogTnVtYmVyKHBbMV0udmFsdWUpIC0gMSwgZyA9IE51bWJlcihwWzJdLnZhbHVlKTtcbiAgICByZXR1cm4gRXQoXywgZiwgZyk7XG4gIH1cbiAgZ2V0TW9udGhOdW1iZXJCeU1vbnRoTmFtZSh0LCBlKSB7XG4gICAgcmV0dXJuIGUuZmluZEluZGV4KChpKSA9PiBpID09PSB0KTtcbiAgfVxuICBzdGF0aWMgZ2V0SW5zdGFuY2UodCkge1xuICAgIHJldHVybiB5LmdldERhdGEodCwgenMpO1xuICB9XG4gIHN0YXRpYyBnZXRPckNyZWF0ZUluc3RhbmNlKHQsIGUgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLmdldEluc3RhbmNlKHQpIHx8IG5ldyB0aGlzKHQsIHR5cGVvZiBlID09IFwib2JqZWN0XCIgPyBlIDogbnVsbCk7XG4gIH1cbn1cbmNvbnN0IE1tID0gKHtcbiAgZm9ybWF0MjQ6IHMsXG4gIG9rTGFiZWw6IHQsXG4gIGNhbmNlbExhYmVsOiBlLFxuICBoZWFkSUQ6IGksXG4gIGZvb3RlcklEOiBuLFxuICBib2R5SUQ6IG8sXG4gIHBpY2tlcklEOiByLFxuICBjbGVhckxhYmVsOiBhLFxuICBpbmxpbmU6IGwsXG4gIHNob3dDbGVhckJ0bjogcCxcbiAgYW1MYWJlbDogdSxcbiAgcG1MYWJlbDogX1xufSwgZikgPT4ge1xuICBjb25zdCBnID0gYDxkaXYgaWQ9JyR7cn0nIGNsYXNzPScke2YudGltZXBpY2tlcldyYXBwZXJ9JyBkYXRhLXRlLXRpbWVwaWNrZXItd3JhcHBlcj5cbiAgICAgIDxkaXYgY2xhc3M9XCIke2YudGltZXBpY2tlckNvbnRhaW5lcn1cIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cIiR7Zi50aW1lcGlja2VyRWxlbWVudHN9XCIgZGF0YS10ZS10aW1lcGlja2VyLWVsZW1lbnRzLXdyYXBwZXI+XG4gICAgICAgIDxkaXYgaWQ9JyR7aX0nIGNsYXNzPScke2YudGltZXBpY2tlckhlYWR9JyBzdHlsZT0ncGFkZGluZy1yaWdodDoke3MgPyA1MCA6IDEwfXB4Jz5cbiAgICAgICAgPGRpdiBjbGFzcz0nJHtmLnRpbWVwaWNrZXJIZWFkQ29udGVudH0nPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cIiR7Zi50aW1lcGlja2VyQ3VycmVudFdyYXBwZXJ9XCI+XG4gICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiJHtmLnRpbWVwaWNrZXJDdXJyZW50QnV0dG9uV3JhcHBlcn1cIj5cbiAgICAgICAgICAgICAgICA8YnV0dG9uIHR5cGU9J2J1dHRvbicgY2xhc3M9JyR7Zi50aW1lcGlja2VyQ3VycmVudEJ1dHRvbn0nIHRhYmluZGV4PVwiMFwiIGRhdGEtdGUtdGltZXBpY2tlci1hY3RpdmUgZGF0YS10ZS10aW1lcGlja2VyLWN1cnJlbnQgZGF0YS10ZS10aW1lcGlja2VyLWhvdXIgZGF0YS10ZS1yaXBwbGUtaW5pdD4yMTwvYnV0dG9uPlxuICAgICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICAgIDxidXR0b24gdHlwZT0nYnV0dG9uJyBjbGFzcz0nJHtmLnRpbWVwaWNrZXJEb3R9JyBkaXNhYmxlZD46PC9idXR0b24+XG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cIiR7Zi50aW1lcGlja2VyQ3VycmVudEJ1dHRvbldyYXBwZXJ9XCI+XG4gICAgICAgICAgICAgIDxidXR0b24gdHlwZT0nYnV0dG9uJyBjbGFzcz0nJHtmLnRpbWVwaWNrZXJDdXJyZW50QnV0dG9ufScgdGFiaW5kZXg9XCIwXCIgZGF0YS10ZS10aW1lcGlja2VyLWN1cnJlbnQgZGF0YS10ZS10aW1lcGlja2VyLW1pbnV0ZSBkYXRhLXRlLXJpcHBsZS1pbml0PjIxPC9idXR0b24+XG4gICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICR7cyA/IFwiXCIgOiBgPGRpdiBjbGFzcz1cIiR7Zi50aW1lcGlja2VyTW9kZVdyYXBwZXJ9XCI+XG4gICAgICAgICAgICAgICAgICA8YnV0dG9uIHR5cGU9J2J1dHRvbicgY2xhc3M9XCIke2YudGltZXBpY2tlck1vZGVBbX1cIiB0YWJpbmRleD1cIjBcIiBkYXRhLXRlLXRpbWVwaWNrZXItYW0gZGF0YS10ZS10aW1lcGlja2VyLWhvdXItbW9kZSBkYXRhLXRlLXJpcHBsZS1pbml0PiR7dX08L2J1dHRvbj5cbiAgICAgICAgICAgICAgICAgIDxidXR0b24gY2xhc3M9XCIke2YudGltZXBpY2tlck1vZGVQbX1cIiB0YWJpbmRleD1cIjBcIiBkYXRhLXRlLXRpbWVwaWNrZXItcG0gZGF0YS10ZS10aW1lcGlja2VyLWhvdXItbW9kZSBkYXRhLXRlLXJpcHBsZS1pbml0PiR7X308L2J1dHRvbj5cbiAgICAgICAgICAgICAgICA8L2Rpdj5gfVxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgICAgJHtsID8gXCJcIiA6IGA8ZGl2IGlkPScke299JyBjbGFzcz0nJHtmLnRpbWVwaWNrZXJDbG9ja1dyYXBwZXJ9JyBkYXRhLXRlLXRpbWVwaWNrZXItY2xvY2std3JhcHBlcj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9JyR7Zi50aW1lcGlja2VyQ2xvY2t9JyBkYXRhLXRlLXRpbWVwaWNrZXItY2xvY2s+XG4gICAgICAgICAgICAgIDxzcGFuIGNsYXNzPScke2YudGltZXBpY2tlck1pZGRsZURvdH0nIGRhdGEtdGUtdGltZXBpY2tlci1taWRkbGUtZG90Pjwvc3Bhbj5cbiAgICAgICAgICAgICAgPGRpdiBjbGFzcz0nJHtmLnRpbWVwaWNrZXJIYW5kUG9pbnRlcn0nIGRhdGEtdGUtdGltZXBpY2tlci1oYW5kLXBvaW50ZXI+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0nJHtmLnRpbWVwaWNrZXJQb2ludGVyQ2lyY2xlfScgZGF0YS10ZS10aW1lcGlja2VyLWNpcmNsZT48L2Rpdj5cbiAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICR7cyA/ICc8ZGl2IGNsYXNzPVwiJyArIGYudGltZXBpY2tlckNsb2NrSW5uZXIgKyAnXCIgZGF0YS10ZS10aW1lcGlja2VyLWNsb2NrLWlubmVyPjwvZGl2PicgOiBcIlwifVxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPC9kaXY+YH1cbiAgICA8L2Rpdj5cbiAgICA8ZGl2IGlkPScke259JyBjbGFzcz0nJHtmLnRpbWVwaWNrZXJGb290ZXJXcmFwcGVyfSc+XG4gICAgICA8ZGl2IGNsYXNzPVwiJHtmLnRpbWVwaWNrZXJGb290ZXJ9XCI+XG4gICAgICAgICR7cCA/IGA8YnV0dG9uIHR5cGU9J2J1dHRvbicgY2xhc3M9JyR7Zi50aW1lcGlja2VyRm9vdGVyQnV0dG9ufScgZGF0YS10ZS10aW1lcGlja2VyLWNsZWFyIHRhYmluZGV4PVwiMFwiIGRhdGEtdGUtcmlwcGxlLWluaXQ+JHthfTwvYnV0dG9uPmAgOiBcIlwifVxuICAgICAgICA8YnV0dG9uIHR5cGU9J2J1dHRvbicgY2xhc3M9JyR7Zi50aW1lcGlja2VyRm9vdGVyQnV0dG9ufScgZGF0YS10ZS10aW1lcGlja2VyLWNhbmNlbCB0YWJpbmRleD1cIjBcIiBkYXRhLXRlLXJpcHBsZS1pbml0PiR7ZX08L2J1dHRvbj5cbiAgICAgICAgPGJ1dHRvbiB0eXBlPSdidXR0b24nIGNsYXNzPScke2YudGltZXBpY2tlckZvb3RlckJ1dHRvbn0nIGRhdGEtdGUtdGltZXBpY2tlci1zdWJtaXQgdGFiaW5kZXg9XCIwXCIgZGF0YS10ZS1yaXBwbGUtaW5pdD4ke3R9PC9idXR0b24+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgPC9kaXY+XG48L2Rpdj5gLCBtID0gYDxkaXYgaWQ9JyR7cn0nIGNsYXNzPScke2YudGltZXBpY2tlcklubGluZVdyYXBwZXJ9JyBkYXRhLXRlLXRpbWVwaWNrZXItd3JhcHBlcj5cbiAgICAgICAgPGRpdiBjbGFzcz1cIiR7Zi50aW1lcGlja2VySW5saW5lQ29udGFpbmVyfVwiPlxuICAgICAgICAgIDxkaXYgY2xhc3M9XCIke2YudGltZXBpY2tlcklubGluZUVsZW1lbnRzfVwiIGRhdGEtdGUtdGltZXBpY2tlci1lbGVtZW50cy13cmFwcGVyPlxuICAgICAgICAgIDxkaXYgaWQ9JyR7aX0nIGNsYXNzPScke2YudGltZXBpY2tlcklubGluZUhlYWR9J1xuICAgICAgICAgIHN0eWxlPSdwYWRkaW5nLXJpZ2h0OjEwcHgnPlxuICAgICAgICAgIDxkaXYgY2xhc3M9JyR7Zi50aW1lcGlja2VySW5saW5lSGVhZENvbnRlbnR9Jz5cbiAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cIiR7Zi50aW1lcGlja2VyQ3VycmVudFdyYXBwZXJ9XCI+XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCIke2YudGltZXBpY2tlcklubGluZUhvdXJXcmFwcGVyfVwiIGRhdGEtdGUtdGltZXBpY2tlci1pbmxpbmUtaG91ci1pY29ucz5cbiAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiJHtmLnRpbWVwaWNrZXJJbmxpbmVJY29uVXB9XCIgZGF0YS10ZS10aW1lcGlja2VyLWljb24tdXAgZGF0YS10ZS10aW1lcGlja2VyLWljb24taW5saW5lLWhvdXI+XG4gICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiJHtmLnRpbWVwaWNrZXJJbmxpbmVJY29uU3ZnfVwiPlxuICAgICAgICAgICAgICAgICAgICAgIDxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIGZpbGw9XCJub25lXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIHN0cm9rZS13aWR0aD1cIjEuNVwiIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIGNsYXNzPVwidy01IGgtNVwiPlxuICAgICAgICAgICAgICAgICAgICAgIDxwYXRoIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiIGQ9XCJNNC41IDE1Ljc1bDcuNS03LjUgNy41IDcuNVwiIC8+XG4gICAgICAgICAgICAgICAgICAgICAgPC9zdmc+ICAgXG4gICAgICAgICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgIDxidXR0b24gdHlwZT0nYnV0dG9uJyBjbGFzcz0nJHtmLnRpbWVwaWNrZXJJbmxpbmVDdXJyZW50QnV0dG9ufScgZGF0YS10ZS10aW1lcGlja2VyLWhvdXIgZGF0YS10ZS10aW1lcGlja2VyLWN1cnJlbnQgZGF0YS10ZS10aW1lcGlja2VyLWN1cnJlbnQtaW5saW5lIHRhYmluZGV4PVwiMFwiIGRhdGEtdGUtcmlwcGxlLWluaXQ+MjE8L2J1dHRvbj5cbiAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiJHtmLnRpbWVwaWNrZXJJbmxpbmVJY29uRG93bn1cIiBkYXRhLXRlLXRpbWVwaWNrZXItaWNvbi1pbmxpbmUtaG91ciBkYXRhLXRlLXRpbWVwaWNrZXItaWNvbi1kb3duPlxuICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cIiR7Zi50aW1lcGlja2VySW5saW5lSWNvblN2Z31cIj5cbiAgICAgICAgICAgICAgICAgICAgICA8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiBmaWxsPVwibm9uZVwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBzdHJva2Utd2lkdGg9XCIxLjVcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBjbGFzcz1cInctNSBoLTVcIj5cbiAgICAgICAgICAgICAgICAgICAgICA8cGF0aCBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIiBkPVwiTTE5LjUgOC4yNWwtNy41IDcuNS03LjUtNy41XCIgLz5cbiAgICAgICAgICAgICAgICAgICAgICA8L3N2Zz4gIFxuICAgICAgICAgICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgICAgIDxidXR0b24gdHlwZT0nYnV0dG9uJyBjbGFzcz0nJHtmLnRpbWVwaWNrZXJJbmxpbmVEb3R9JyBkYXRhLXRlLXRpbWVwaWNrZXItY3VycmVudC1pbmxpbmUgZGlzYWJsZWQ+OjwvYnV0dG9uPlxuICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cIiR7Zi50aW1lcGlja2VyQ3VycmVudE1pbnV0ZVdyYXBwZXJ9XCI+XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCIke2YudGltZXBpY2tlcklubGluZUljb25VcH1cIiBkYXRhLXRlLXRpbWVwaWNrZXItaWNvbi11cCBkYXRhLXRlLXRpbWVwaWNrZXItaWNvbi1pbmxpbmUtbWludXRlPlxuICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCIke2YudGltZXBpY2tlcklubGluZUljb25Tdmd9XCI+XG4gICAgICAgICAgICAgICAgICAgIDxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIGZpbGw9XCJub25lXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIHN0cm9rZS13aWR0aD1cIjEuNVwiIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIGNsYXNzPVwidy01IGgtNVwiPlxuICAgICAgICAgICAgICAgICAgICA8cGF0aCBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIiBkPVwiTTQuNSAxNS43NWw3LjUtNy41IDcuNSA3LjVcIiAvPlxuICAgICAgICAgICAgICAgICAgICA8L3N2Zz5cbiAgICAgICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPSdidXR0b24nIGNsYXNzPScke2YudGltZXBpY2tlcklubGluZUN1cnJlbnRCdXR0b259JyBkYXRhLXRlLXRpbWVwaWNrZXItbWludXRlIGRhdGEtdGUtdGltZXBpY2tlci1jdXJyZW50IGRhdGEtdGUtdGltZXBpY2tlci1jdXJyZW50LWlubGluZSB0YWJpbmRleD1cIjBcIiBkYXRhLXRlLXJpcHBsZS1pbml0PjIxPC9idXR0b24+XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCIke2YudGltZXBpY2tlcklubGluZUljb25Eb3dufVwiIGRhdGEtdGUtdGltZXBpY2tlci1pY29uLWlubGluZS1taW51dGUgZGF0YS10ZS10aW1lcGlja2VyLWljb24tZG93bj5cbiAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiJHtmLnRpbWVwaWNrZXJJbmxpbmVJY29uU3ZnfVwiPlxuICAgICAgICAgICAgICAgICAgICA8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiBmaWxsPVwibm9uZVwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBzdHJva2Utd2lkdGg9XCIxLjVcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBjbGFzcz1cInctNSBoLTVcIj5cbiAgICAgICAgICAgICAgICAgICAgPHBhdGggc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCIgZD1cIk0xOS41IDguMjVsLTcuNSA3LjUtNy41LTcuNVwiIC8+XG4gICAgICAgICAgICAgICAgICAgIDwvc3ZnPiBcbiAgICAgICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICR7cyA/IFwiXCIgOiBgPGRpdiBjbGFzcz1cIiR7Zi50aW1lcGlja2VySW5saW5lTW9kZVdyYXBwZXJ9XCI+XG4gICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPSdidXR0b24nIGNsYXNzPVwiJHtmLnRpbWVwaWNrZXJJbmxpbmVNb2RlQW19XCIgZGF0YS10ZS10aW1lcGlja2VyLWFtIGRhdGEtdGUtdGltZXBpY2tlci1ob3VyLW1vZGUgdGFiaW5kZXg9XCIwXCIgZGF0YS10ZS1yaXBwbGUtaW5pdD4ke3V9PC9idXR0b24+XG4gICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBjbGFzcz1cIiR7Zi50aW1lcGlja2VySW5saW5lTW9kZVBtfVwiIGRhdGEtdGUtdGltZXBpY2tlci1ob3VyLW1vZGUgZGF0YS10ZS10aW1lcGlja2VyLXBtIHRhYmluZGV4PVwiMFwiIGRhdGEtdGUtcmlwcGxlLWluaXQ+JHtffTwvYnV0dG9uPlxuICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24gdHlwZT0nYnV0dG9uJyBjbGFzcz0nJHtmLnRpbWVwaWNrZXJJbmxpbmVTdWJtaXRCdXR0b259JyBkYXRhLXRlLXRpbWVwaWNrZXItc3VibWl0IHRhYmluZGV4PVwiMFwiIGRhdGEtdGUtcmlwcGxlLWluaXQ+JHt0fTwvYnV0dG9uPlxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5gfVxuICAgICAgICAgICAgICAke3MgPyBgPGJ1dHRvbiBjbGFzcz0nJHtmLnRpbWVwaWNrZXJJbmxpbmVTdWJtaXRCdXR0b259JyBkYXRhLXRlLXRpbWVwaWNrZXItc3VibWl0IHRhYmluZGV4PVwiMFwiIGRhdGEtdGUtcmlwcGxlLWluaXQ+JHt0fTwvYnV0dG9uPmAgOiBcIlwifVxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuPC9kaXY+YDtcbiAgcmV0dXJuIGwgPyBtIDogZztcbn0sIFJtID0gKHMsIHQsIGUpID0+IHtcbiAgY29uc3QgeyBpY29uU1ZHOiBpIH0gPSBzO1xuICByZXR1cm4gYFxuICA8YnV0dG9uIGlkPVwiJHt0fVwiIHRhYmluZGV4PVwiMFwiIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cIiR7ZS50aW1lcGlja2VyVG9nZ2xlQnV0dG9ufVwiIGRhdGEtdGUtdG9nZ2xlPVwidGltZXBpY2tlclwiIGRhdGEtdGUtdGltZXBpY2tlci10b2dnbGUtYnV0dG9uIGRhdGEtdGUtdGltZXBpY2tlci1pY29uPlxuICAgICR7aX1cbiAgPC9idXR0b24+XG5gO1xufSwgdW4gPSBcImRhdGEtdGUtdGltZXBpY2tlci1kaXNhYmxlZFwiLCB1cyA9IFwiZGF0YS10ZS10aW1lcGlja2VyLWFjdGl2ZVwiLCB2ZSA9IChzKSA9PiB7XG4gIGlmIChzID09PSBcIlwiKVxuICAgIHJldHVybjtcbiAgbGV0IHQsIGUsIGksIG47XG4gIHJldHVybiBHYyhzKSA/ICh0ID0gcy5nZXRIb3VycygpLCBuID0gdCwgZSA9IHMuZ2V0TWludXRlcygpLCB0ICU9IDEyLCBuID09PSAwICYmIHQgPT09IDAgJiYgKGkgPSBcIkFNXCIpLCB0ID0gdCB8fCAxMiwgaSA9PT0gdm9pZCAwICYmIChpID0gTnVtYmVyKG4pID49IDEyID8gXCJQTVwiIDogXCJBTVwiKSwgZSA9IGUgPCAxMCA/IGAwJHtlfWAgOiBlKSA6IChbdCwgZSwgaV0gPSBSKHMsICExKSwgbiA9IHQsIHQgJT0gMTIsIG4gPT09IDAgJiYgdCA9PT0gMCAmJiAoaSA9IFwiQU1cIiksIHQgPSB0IHx8IDEyLCBpID09PSB2b2lkIDAgJiYgKGkgPSBOdW1iZXIobikgPj0gMTIgPyBcIlBNXCIgOiBcIkFNXCIpKSwge1xuICAgIGhvdXJzOiB0LFxuICAgIG1pbnV0ZXM6IGUsXG4gICAgYW1PclBtOiBpXG4gIH07XG59LCBHYyA9IChzKSA9PiBzICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChzKSA9PT0gXCJbb2JqZWN0IERhdGVdXCIgJiYgIU51bWJlci5pc05hTihzKSwgTGEgPSAocykgPT4ge1xuICBpZiAocyA9PT0gXCJcIilcbiAgICByZXR1cm47XG4gIGxldCB0LCBlO1xuICByZXR1cm4gR2MocykgPyAodCA9IHMuZ2V0SG91cnMoKSwgZSA9IHMuZ2V0TWludXRlcygpKSA6IFt0LCBlXSA9IFIocywgITEpLCBlID0gTnVtYmVyKGUpIDwgMTAgPyBgMCR7TnVtYmVyKGUpfWAgOiBlLCB7XG4gICAgaG91cnM6IHQsXG4gICAgbWludXRlczogZVxuICB9O1xufSwgUG0gPSAocywgdCwgZSkgPT4gYy5vbihkb2N1bWVudCwgcywgdCwgKHsgdGFyZ2V0OiBpIH0pID0+IHtcbiAgaWYgKGkuaGFzQXR0cmlidXRlKHVzKSlcbiAgICByZXR1cm47XG4gIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwodCkuZm9yRWFjaCgobykgPT4ge1xuICAgIG8uaGFzQXR0cmlidXRlKHVzKSAmJiAoaC5yZW1vdmVDbGFzcyhvLCBlLm9wYWNpdHkpLCBvLnJlbW92ZUF0dHJpYnV0ZSh1cykpO1xuICB9KSwgaC5hZGRDbGFzcyhpLCBlLm9wYWNpdHkpLCBpLnNldEF0dHJpYnV0ZSh1cywgXCJcIik7XG59KSwgTmEgPSAoeyBjbGllbnRYOiBzLCBjbGllbnRZOiB0LCB0b3VjaGVzOiBlIH0sIGksIG4gPSAhMSkgPT4ge1xuICBjb25zdCB7IGxlZnQ6IG8sIHRvcDogciB9ID0gaS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgbGV0IGEgPSB7fTtcbiAgcmV0dXJuICFuIHx8ICFlID8gYSA9IHtcbiAgICB4OiBzIC0gbyxcbiAgICB5OiB0IC0gclxuICB9IDogbiAmJiBPYmplY3Qua2V5cyhlKS5sZW5ndGggPiAwICYmIChhID0ge1xuICAgIHg6IGVbMF0uY2xpZW50WCAtIG8sXG4gICAgeTogZVswXS5jbGllbnRZIC0gclxuICB9KSwgYTtcbn0sIHBzID0gKCkgPT4gbmF2aWdhdG9yLm1heFRvdWNoUG9pbnRzICYmIG5hdmlnYXRvci5tYXhUb3VjaFBvaW50cyA+IDIgJiYgL01hY0ludGVsLy50ZXN0KG5hdmlnYXRvci5wbGF0Zm9ybSkgfHwgL0FuZHJvaWR8d2ViT1N8aVBob25lfGlQYWR8aVBvZHxCbGFja0JlcnJ5fElFTW9iaWxlfE9wZXJhIE1pbmkvaS50ZXN0KFxuICBuYXZpZ2F0b3IudXNlckFnZW50XG4pLCBSID0gKHMsIHQgPSAhMCkgPT4gdCA/IHMudmFsdWUucmVwbGFjZSgvOi9naSwgXCIgXCIpLnNwbGl0KFwiIFwiKSA6IHMucmVwbGFjZSgvOi9naSwgXCIgXCIpLnNwbGl0KFwiIFwiKSwgcWMgPSAocywgdCkgPT4ge1xuICBjb25zdCBbZSwgaSwgbl0gPSBSKHMsICExKSwgW28sIHIsIGFdID0gUih0LCAhMSk7XG4gIHJldHVybiBuID09PSBcIlBNXCIgJiYgYSA9PT0gXCJBTVwiIHx8IG4gPT09IGEgJiYgZSA+IG8gfHwgaSA+IHI7XG59LCBaYyA9ICgpID0+IHtcbiAgY29uc3QgcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpLCB0ID0gcy5nZXRIb3VycygpLCBlID0gcy5nZXRNaW51dGVzKCk7XG4gIHJldHVybiBgJHt0fToke2UgPCAxMCA/IGAwJHtlfWAgOiBlfWA7XG59LCBYdCA9IChzLCB0LCBlKSA9PiB7XG4gIGlmICghdClcbiAgICByZXR1cm4gcztcbiAgbGV0IGkgPSBaYygpO1xuICByZXR1cm4gZSAmJiAoaSA9IGAke3ZlKGkpLmhvdXJzfToke3ZlKGkpLm1pbnV0ZXN9ICR7dmUoaSkuYW1PclBtfWApLCAocyAhPT0gXCJcIiAmJiBxYyhpLCBzKSB8fCBzID09PSBcIlwiKSAmJiAocyA9IGkpLCBzO1xufSwgR3QgPSAocywgdCwgZSkgPT4ge1xuICBpZiAoIXQpXG4gICAgcmV0dXJuIHM7XG4gIGxldCBpID0gWmMoKTtcbiAgcmV0dXJuIGUgJiYgKGkgPSBgJHt2ZShpKS5ob3Vyc306JHt2ZShpKS5taW51dGVzfSAke3ZlKGkpLmFtT3JQbX1gKSwgKHMgIT09IFwiXCIgJiYgIXFjKGksIHMpIHx8IHMgPT09IFwiXCIpICYmIChzID0gaSksIHM7XG59LCBCbSA9ICh7IGZvcm1hdDEyOiBzLCBtYXhUaW1lOiB0LCBtaW5UaW1lOiBlLCBkaXNhYmxlUGFzdDogaSwgZGlzYWJsZUZ1dHVyZTogbiB9LCBvLCByKSA9PiB7XG4gIGNvbnN0IGEgPSBSKG8pWzFdO1xuICBlID0gWHQoZSwgaSwgcyksIHQgPSBHdCh0LCBuLCBzKTtcbiAgY29uc3QgW2wsIHAsIHVdID0gUih0LCAhMSksIFtfLCBmLCBnXSA9IFIoZSwgITEpO1xuICBpZiAodSAhPT0gdm9pZCAwIHx8IGcgIT09IHZvaWQgMClcbiAgICByZXR1cm4gW3IsIGFdO1xuICBpZiAoIShsICE9PSBcIlwiICYmIF8gPT09IFwiXCIgJiYgTnVtYmVyKHIpID4gTnVtYmVyKGwpKSAmJiAhKGwgPT09IFwiXCIgJiYgXyAhPT0gXCJcIiAmJiBwID09PSB2b2lkIDAgJiYgZiAhPT0gXCJcIiAmJiBOdW1iZXIocikgPCBOdW1iZXIoXykpKVxuICAgIHJldHVybiBbciwgYV07XG59LCBNYSA9IChzLCB0LCBlLCBpKSA9PiB7XG4gIHMuZm9yRWFjaCgobikgPT4ge1xuICAgIHQgPSB0ID09PSBcIjEyXCIgJiYgaSA/IFwiMFwiIDogdCwgKG4udGV4dENvbnRlbnQgPT09IFwiMDBcIiB8fCBOdW1iZXIobi50ZXh0Q29udGVudCA9PT0gXCIxMlwiICYmIGkgPyBcIjBcIiA6IG4udGV4dENvbnRlbnQpID4gdCkgJiYgKGguYWRkQ2xhc3MobiwgZS50aXBzRGlzYWJsZWQpLCBuLnNldEF0dHJpYnV0ZSh1biwgXCJcIikpO1xuICB9KTtcbn0sIFJhID0gKHMsIHQsIGUsIGkpID0+IHtcbiAgcy5mb3JFYWNoKChuKSA9PiB7XG4gICAgdCA9IHQgPT09IFwiMTJcIiAmJiBpID8gXCIwXCIgOiB0LCBuLnRleHRDb250ZW50ICE9PSBcIjAwXCIgJiYgTnVtYmVyKG4udGV4dENvbnRlbnQgPT09IFwiMTJcIiAmJiBpID8gXCIwXCIgOiBuLnRleHRDb250ZW50KSA8IE51bWJlcih0KSAmJiAoaC5hZGRDbGFzcyhuLCBlLnRpcHNEaXNhYmxlZCksIG4uc2V0QXR0cmlidXRlKHVuLCBcIlwiKSk7XG4gIH0pO1xufSwgUWMgPSAocywgdCwgZSwgaSkgPT4ge1xuICBpZiAodCA9PT0gXCIxMlwiIHx8IHQgPT09IFwiMjRcIilcbiAgICByZXR1cm47XG4gIGNvbnN0IG4gPSBlID8gMTIgOiAyNDtcbiAgcmV0dXJuIGkgPT09IFwibWF4XCIgPyAoTnVtYmVyKHMpID09PSBuID8gMCA6IE51bWJlcihzKSkgPiBOdW1iZXIodCkgOiAoTnVtYmVyKHMpID09PSBuID8gMCA6IE51bWJlcihzKSkgPCBOdW1iZXIodCk7XG59LCBIbSA9IChzLCB0LCBlLCBpLCBuLCBvKSA9PiB7XG4gIHMuZm9yRWFjaCgocikgPT4ge1xuICAgIChRYyhpLCBlLCBvLCBcIm1heFwiKSB8fCBOdW1iZXIoci50ZXh0Q29udGVudCkgPiB0ICYmIE51bWJlcihpKSA9PT0gTnVtYmVyKGUpKSAmJiAoaC5hZGRDbGFzcyhyLCBuLnRpcHNEaXNhYmxlZCksIHIuc2V0QXR0cmlidXRlKHVuLCBcIlwiKSk7XG4gIH0pO1xufSwgVm0gPSAocywgdCwgZSwgaSwgbiwgbykgPT4ge1xuICBzLmZvckVhY2goKHIpID0+IHtcbiAgICAoUWMoaSwgZSwgbywgXCJtaW5cIikgfHwgTnVtYmVyKHIudGV4dENvbnRlbnQpIDwgdCAmJiBOdW1iZXIoaSkgPT09IE51bWJlcihlKSkgJiYgKGguYWRkQ2xhc3Mociwgbi50aXBzRGlzYWJsZWQpLCByLnNldEF0dHJpYnV0ZSh1biwgXCJcIikpO1xuICB9KTtcbn0sIFdtID0gKHMpID0+IHMuc3RhcnRzV2l0aChcIjBcIikgPyBOdW1iZXIocy5zbGljZSgxKSkgOiBOdW1iZXIocyksICRpID0gXCJ0aW1lcGlja2VyXCIsIE0gPSBgZGF0YS10ZS0keyRpfWAsIFBhID0gXCJbZGF0YS10ZS10b2dnbGVdXCIsIFVzID0gYHRlLiR7JGl9YCwgUnQgPSBgLiR7VXN9YCwgUHQgPSBcIi5kYXRhLWFwaVwiLCBCYSA9IGBjbGljayR7UnR9JHtQdH1gLCBfcyA9IGBrZXlkb3duJHtSdH0ke1B0fWAsIEhhID0gYG1vdXNlZG93biR7UnR9JHtQdH1gLCBWYSA9IGBtb3VzZXVwJHtSdH0ke1B0fWAsIFdhID0gYG1vdXNlbW92ZSR7UnR9JHtQdH1gLCBGYSA9IGBtb3VzZWxlYXZlJHtSdH0ke1B0fWAsIFlhID0gYG1vdXNlb3ZlciR7UnR9JHtQdH1gLCBqYSA9IGB0b3VjaG1vdmUke1J0fSR7UHR9YCwgS2EgPSBgdG91Y2hlbmQke1J0fSR7UHR9YCwgemEgPSBgdG91Y2hzdGFydCR7UnR9JHtQdH1gLCBGbSA9IGBbJHtNfS1hbV1gLCBZbSA9IGBbJHtNfS1wbV1gLCBqbSA9IGBbJHtNfS1mb3JtYXQyNF1gLCBmcyA9IGBbJHtNfS1jdXJyZW50XWAsIG1zID0gYFske019LWhvdXItbW9kZV1gLCBLbSA9IGBbJHtNfS10b2dnbGUtYnV0dG9uXWAsIEduID0gYCR7TX0tY2FuY2VsYCwgVWEgPSBgJHtNfS1jbGVhcmAsIHFuID0gYCR7TX0tc3VibWl0YCwgem0gPSBgJHtNfS1pY29uYCwgWm4gPSBgJHtNfS1pY29uLXVwYCwgUW4gPSBgJHtNfS1pY29uLWRvd25gLCBVbSA9IGAke019LWljb24taW5saW5lLWhvdXJgLCBYbSA9IGAke019LWljb24taW5saW5lLW1pbnV0ZWAsIFhhID0gYCR7TX0taW5saW5lLWhvdXItaWNvbnNgLCBHbSA9IGAke019LWN1cnJlbnQtaW5saW5lYCwgcW0gPSBcInJlYWRvbmx5XCIsIFptID0gYCR7TX0taW52YWxpZC1mZWVkYmFja2AsIEpuID0gYCR7TX0taXMtaW52YWxpZGAsIFl0ID0gYCR7TX0tZGlzYWJsZWRgLCBIID0gYCR7TX0tYWN0aXZlYCwgUW0gPSBgJHtNfS1pbnB1dGAsIHBlID0gYCR7TX0tY2xvY2tgLCBkaSA9IGAke019LWNsb2NrLWlubmVyYCwgdG8gPSBgJHtNfS13cmFwcGVyYCwgR2EgPSBgJHtNfS1jbG9jay13cmFwcGVyYCwgZ3MgPSBgJHtNfS1ob3VyYCwgZW8gPSBgJHtNfS1taW51dGVgLCBicyA9IGAke019LXRpcHMtZWxlbWVudGAsIEsgPSBgJHtNfS10aXBzLWhvdXJzYCwgWCA9IGAke019LXRpcHMtbWludXRlc2AsIGx0ID0gYCR7TX0tdGlwcy1pbm5lcmAsIHZzID0gYCR7TX0tdGlwcy1pbm5lci1lbGVtZW50YCwgcWEgPSBgJHtNfS1taWRkbGUtZG90YCwgaW8gPSBgJHtNfS1oYW5kLXBvaW50ZXJgLCBzbyA9IGAke019LWNpcmNsZWAsIFphID0gYCR7TX0tbW9kYWxgLCBKbSA9IGA8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiBmaWxsPVwibm9uZVwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBzdHJva2Utd2lkdGg9XCIxLjVcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIj5cbiAgPHBhdGggc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCIgZD1cIk0xMiA2djZoNC41bTQuNSAwYTkgOSAwIDExLTE4IDAgOSA5IDAgMDExOCAwelwiIC8+XG48L3N2Zz5gLCB0ZyA9IHtcbiAgYXBwZW5kVmFsaWRhdGlvbkluZm86ICEwLFxuICBib2R5SUQ6IFwiXCIsXG4gIGNhbmNlbExhYmVsOiBcIkNhbmNlbFwiLFxuICBjbGVhckxhYmVsOiBcIkNsZWFyXCIsXG4gIGNsb3NlTW9kYWxPbkJhY2tkcm9wQ2xpY2s6ICEwLFxuICBjbG9zZU1vZGFsT25NaW51dGVzQ2xpY2s6ICExLFxuICBjb250YWluZXI6IFwiYm9keVwiLFxuICBkZWZhdWx0VGltZTogXCJcIixcbiAgZGlzYWJsZWQ6ICExLFxuICBkaXNhYmxlUGFzdDogITEsXG4gIGRpc2FibGVGdXR1cmU6ICExLFxuICBlbmFibGVWYWxpZGF0aW9uOiAhMCxcbiAgZm9jdXNJbnB1dEFmdGVyQXBwcm92ZTogITEsXG4gIGZvb3RlcklEOiBcIlwiLFxuICBmb3JtYXQxMjogITAsXG4gIGZvcm1hdDI0OiAhMSxcbiAgaGVhZElEOiBcIlwiLFxuICBpbmNyZW1lbnQ6ICExLFxuICBpbmxpbmU6ICExLFxuICBpbnZhbGlkTGFiZWw6IFwiSW52YWxpZCBUaW1lIEZvcm1hdFwiLFxuICBtYXhUaW1lOiBcIlwiLFxuICBtaW5UaW1lOiBcIlwiLFxuICBtb2RhbElEOiBcIlwiLFxuICBva0xhYmVsOiBcIk9rXCIsXG4gIG92ZXJmbG93SGlkZGVuOiAhMCxcbiAgcGlja2VySUQ6IFwiXCIsXG4gIHJlYWRPbmx5OiAhMSxcbiAgc2hvd0NsZWFyQnRuOiAhMCxcbiAgc3dpdGNoSG91cnNUb01pbnV0ZXNPbkNsaWNrOiAhMCxcbiAgaWNvblNWRzogSm0sXG4gIHdpdGhJY29uOiAhMCxcbiAgcG1MYWJlbDogXCJQTVwiLFxuICBhbUxhYmVsOiBcIkFNXCIsXG4gIGFuaW1hdGlvbnM6ICEwXG59LCBlZyA9IHtcbiAgYXBwZW5kVmFsaWRhdGlvbkluZm86IFwiYm9vbGVhblwiLFxuICBib2R5SUQ6IFwic3RyaW5nXCIsXG4gIGNhbmNlbExhYmVsOiBcInN0cmluZ1wiLFxuICBjbGVhckxhYmVsOiBcInN0cmluZ1wiLFxuICBjbG9zZU1vZGFsT25CYWNrZHJvcENsaWNrOiBcImJvb2xlYW5cIixcbiAgY2xvc2VNb2RhbE9uTWludXRlc0NsaWNrOiBcImJvb2xlYW5cIixcbiAgY29udGFpbmVyOiBcInN0cmluZ1wiLFxuICBkaXNhYmxlZDogXCJib29sZWFuXCIsXG4gIGRpc2FibGVQYXN0OiBcImJvb2xlYW5cIixcbiAgZGlzYWJsZUZ1dHVyZTogXCJib29sZWFuXCIsXG4gIGVuYWJsZVZhbGlkYXRpb246IFwiYm9vbGVhblwiLFxuICBmb290ZXJJRDogXCJzdHJpbmdcIixcbiAgZm9ybWF0MTI6IFwiYm9vbGVhblwiLFxuICBmb3JtYXQyNDogXCJib29sZWFuXCIsXG4gIGhlYWRJRDogXCJzdHJpbmdcIixcbiAgaW5jcmVtZW50OiBcImJvb2xlYW5cIixcbiAgaW5saW5lOiBcImJvb2xlYW5cIixcbiAgaW52YWxpZExhYmVsOiBcInN0cmluZ1wiLFxuICBtb2RhbElEOiBcInN0cmluZ1wiLFxuICBva0xhYmVsOiBcInN0cmluZ1wiLFxuICBvdmVyZmxvd0hpZGRlbjogXCJib29sZWFuXCIsXG4gIHBpY2tlcklEOiBcInN0cmluZ1wiLFxuICByZWFkT25seTogXCJib29sZWFuXCIsXG4gIHNob3dDbGVhckJ0bjogXCJib29sZWFuXCIsXG4gIHN3aXRjaEhvdXJzVG9NaW51dGVzT25DbGljazogXCJib29sZWFuXCIsXG4gIGRlZmF1bHRUaW1lOiBcIihzdHJpbmd8ZGF0ZXxudW1iZXIpXCIsXG4gIGljb25TVkc6IFwic3RyaW5nXCIsXG4gIHdpdGhJY29uOiBcImJvb2xlYW5cIixcbiAgcG1MYWJlbDogXCJzdHJpbmdcIixcbiAgYW1MYWJlbDogXCJzdHJpbmdcIixcbiAgYW5pbWF0aW9uczogXCJib29sZWFuXCJcbn0sIGlnID0ge1xuICB0aXBzOiBcImFic29sdXRlIHJvdW5kZWQtWzEwMCVdIHctWzMycHhdIGgtWzMycHhdIHRleHQtY2VudGVyIGN1cnNvci1wb2ludGVyIHRleHQtWzEuMXJlbV0gcm91bmRlZC1bMTAwJV0gYmctdHJhbnNwYXJlbnQgZmxleCBqdXN0aWZ5LWNlbnRlciBpdGVtcy1jZW50ZXIgZm9udC1saWdodCBmb2N1czpvdXRsaW5lLW5vbmUgc2VsZWN0aW9uOmJnLXRyYW5zcGFyZW50XCIsXG4gIHRpcHNBY3RpdmU6IFwidGV4dC13aGl0ZSBiZy1bIzNiNzFjYV0gZm9udC1ub3JtYWxcIixcbiAgdGlwc0Rpc2FibGVkOiBcInRleHQtWyNiM2FmYWZdIHBvaW50ZXItZXZlbnRzLW5vbmUgYmctdHJhbnNwYXJlbnRcIixcbiAgdHJhbnNmb3JtOiBcInRyYW5zaXRpb24tW3RyYW5zZm9ybSxoZWlnaHRdIGVhc2UtaW4tb3V0IGR1cmF0aW9uLVs0MDBtc11cIixcbiAgbW9kYWw6IFwiei1bMTA2NV1cIixcbiAgY2xvY2tBbmltYXRpb246IFwiYW5pbWF0ZS1bc2hvdy11cC1jbG9ja18zNTBtc19saW5lYXJdXCIsXG4gIG9wYWNpdHk6IFwiIW9wYWNpdHktMTAwXCIsXG4gIHRpbWVwaWNrZXJXcmFwcGVyOiBcInRvdWNoLW5vbmUgb3BhY2l0eS0xMDAgei1bMTA2NV0gaW5zZXQtMCBiZy1bIzAwMDAwMDY2XSBoLWZ1bGwgZmxleCBpdGVtcy1jZW50ZXIganVzdGlmeS1jZW50ZXIgZmxleC1jb2wgZml4ZWRcIixcbiAgdGltZXBpY2tlckNvbnRhaW5lcjogXCJmbGV4IGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWNlbnRlciBmbGV4LWNvbCBtYXgtaC1bY2FsYygxMDAlLTY0cHgpXSBvdmVyZmxvdy15LWF1dG8gc2hhZG93LVswXzEwcHhfMTVweF8tM3B4X3JnYmEoMCwwLDAsMC4wNyksMF80cHhfNnB4Xy0ycHhfcmdiYSgwLDAsMCwwLjA1KV0gbWluLVszMjBweF06bWF4LVs4MjVweF06bGFuZHNjYXBlOnJvdW5kZWQtbGdcIixcbiAgdGltZXBpY2tlckVsZW1lbnRzOiBcImZsZXggZmxleC1jb2wgbWluLXctWzMxMHB4XSBtaW4taC1bMzI1cHhdIGJnLXdoaXRlIHJvdW5kZWQtdC1bMC42cmVtXSBtaW4tWzMyMHB4XTptYXgtWzgyNXB4XTpsYW5kc2NhcGU6IWZsZXgtcm93IG1pbi1bMzIwcHhdOm1heC1bODI1cHhdOmxhbmRzY2FwZTptaW4tdy1bYXV0b10gbWluLVszMjBweF06bWF4LVs4MjVweF06bGFuZHNjYXBlOm1pbi1oLVthdXRvXSBtaW4tWzMyMHB4XTptYXgtWzgyNXB4XTpsYW5kc2NhcGU6b3ZlcmZsb3cteS1hdXRvIGp1c3RpZnktYXJvdW5kXCIsXG4gIHRpbWVwaWNrZXJIZWFkOiBcImJnLVsjM2I3MWNhXSBkYXJrOmJnLXppbmMtNzAwIGgtWzEwMHB4XSByb3VuZGVkLXQtbGcgcHItWzI0cHhdIHBsLVs1MHB4XSBweS1bMTBweF0gbWluLVszMjBweF06bWF4LVs4MjVweF06bGFuZHNjYXBlOnJvdW5kZWQtdHItbm9uZSBtaW4tWzMyMHB4XTptYXgtWzgyNXB4XTpsYW5kc2NhcGU6cm91bmRlZC1ibC1ub25lIG1pbi1bMzIwcHhdOm1heC1bODI1cHhdOmxhbmRzY2FwZTpwLVsxMHB4XSBtaW4tWzMyMHB4XTptYXgtWzgyNXB4XTpsYW5kc2NhcGU6cHItWzEwcHhdIG1pbi1bMzIwcHhdOm1heC1bODI1cHhdOmxhbmRzY2FwZTpoLWF1dG8gbWluLVszMjBweF06bWF4LVs4MjVweF06bGFuZHNjYXBlOm1pbi1oLVszMDVweF0gZmxleCBmbGV4LXJvdyBpdGVtcy1jZW50ZXIganVzdGlmeS1jZW50ZXJcIixcbiAgdGltZXBpY2tlckhlYWRDb250ZW50OiBcIm1pbi1bMzIwcHhdOm1heC1bODI1cHhdOmxhbmRzY2FwZTpmbGV4LWNvbCBmbGV4IHctZnVsbCBqdXN0aWZ5LWV2ZW5seVwiLFxuICB0aW1lcGlja2VyQ3VycmVudFdyYXBwZXI6IFwiW2RpcmVjdGlvbjpsdHJdIHJ0bDpbZGlyZWN0aW9uOnJ0bF1cIixcbiAgdGltZXBpY2tlckN1cnJlbnRCdXR0b25XcmFwcGVyOiBcInJlbGF0aXZlIGgtZnVsbFwiLFxuICB0aW1lcGlja2VyQ3VycmVudEJ1dHRvbjogXCJ0ZXh0LVszLjc1cmVtXSBmb250LWxpZ2h0IGxlYWRpbmctWzEuMl0gdHJhY2tpbmctWy0wLjAwODMzZW1dIHRleHQtd2hpdGUgb3BhY2l0eS1bLjU0XSBib3JkZXItbm9uZSBiZy10cmFuc3BhcmVudCBwLTAgbWluLVszMjBweF06bWF4LVs4MjVweF06bGFuZHNjYXBlOnRleHQtNXhsIG1pbi1bMzIwcHhdOm1heC1bODI1cHhdOmxhbmRzY2FwZTpmb250LW5vcm1hbCBjdXJzb3ItcG9pbnRlciBob3ZlcjpiZy1bIzAwMDAwMDI2XSBob3ZlcjpvdXRsaW5lLW5vbmUgZm9jdXM6YmctWyMwMDAwMDAyNl0gZm9jdXM6b3V0bGluZS1ub25lIFwiLFxuICB0aW1lcGlja2VyRG90OiBcImZvbnQtbGlnaHQgbGVhZGluZy1bMS4yXSB0cmFja2luZy1bLTAuMDA4MzNlbV0gdGV4dC1bMy43NXJlbV0gb3BhY2l0eS1bLjU0XSBib3JkZXItbm9uZSBiZy10cmFuc3BhcmVudCBwLTAgdGV4dC13aGl0ZSBtaW4tWzMyMHB4XTptYXgtWzgyNXB4XTpsYW5kc2NhcGU6dGV4dC1bM3JlbV0gbWluLVszMjBweF06bWF4LVs4MjVweF06bGFuZHNjYXBlOmZvbnQtbm9ybWFsXCIsXG4gIHRpbWVwaWNrZXJNb2RlV3JhcHBlcjogXCJmbGV4IGZsZXgtY29sIGp1c3RpZnktY2VudGVyIHRleHQtWzE4cHhdIHRleHQtWyNmZmZmZmY4YV0gbWluLVszMjBweF06bWF4LVs4MjVweF06bGFuZHNjYXBlOiFqdXN0aWZ5LWFyb3VuZCBtaW4tWzMyMHB4XTptYXgtWzgyNXB4XTpsYW5kc2NhcGU6IWZsZXgtcm93XCIsXG4gIHRpbWVwaWNrZXJNb2RlQW06IFwicC0wIGJnLXRyYW5zcGFyZW50IGJvcmRlci1ub25lIHRleHQtd2hpdGUgb3BhY2l0eS1bLjU0XSBjdXJzb3ItcG9pbnRlciBob3ZlcjpiZy1bIzAwMDAwMDI2XSBob3ZlcjpvdXRsaW5lLW5vbmUgZm9jdXM6YmctWyMwMDAwMDAyNl0gZm9jdXM6b3V0bGluZS1ub25lXCIsXG4gIHRpbWVwaWNrZXJNb2RlUG06IFwicC0wIGJnLXRyYW5zcGFyZW50IGJvcmRlci1ub25lIHRleHQtd2hpdGUgb3BhY2l0eS1bLjU0XSBjdXJzb3ItcG9pbnRlciBob3ZlcjpiZy1bIzAwMDAwMDI2XSBob3ZlcjpvdXRsaW5lLW5vbmUgZm9jdXM6YmctWyMwMDAwMDAyNl0gZm9jdXM6b3V0bGluZS1ub25lXCIsXG4gIHRpbWVwaWNrZXJDbG9ja1dyYXBwZXI6IFwibWluLXctWzMxMHB4XSBtYXgtdy1bMzI1cHhdIG1pbi1oLVszMDVweF0gb3ZlcmZsb3cteC1oaWRkZW4gaC1mdWxsIGZsZXgganVzdGlmeS1jZW50ZXIgZmxleC1jb2wgaXRlbXMtY2VudGVyIGRhcms6YmctemluYy01MDBcIixcbiAgdGltZXBpY2tlckNsb2NrOiBcInJlbGF0aXZlIHJvdW5kZWQtWzEwMCVdIHctWzI2MHB4XSBoLVsyNjBweF0gY3Vyc29yLWRlZmF1bHQgbXktMCBteC1hdXRvIGJnLVsjMDAwMDAwMTJdIGRhcms6YmctemluYy02MDAvNTBcIixcbiAgdGltZXBpY2tlck1pZGRsZURvdDogXCJ0b3AtMS8yIGxlZnQtMS8yIHctWzZweF0gaC1bNnB4XSAtdHJhbnNsYXRlLXktMS8yIC10cmFuc2xhdGUteC0xLzIgcm91bmRlZC1bNTAlXSBiZy1bIzNiNzFjYV0gYWJzb2x1dGVcIixcbiAgdGltZXBpY2tlckhhbmRQb2ludGVyOiBcImJnLVsjM2I3MWNhXSBib3R0b20tMS8yIGgtMi81IGxlZnQtW2NhbGMoNTAlLTFweCldIHJ0bDohbGVmdC1hdXRvIG9yaWdpbi1bY2VudGVyX2JvdHRvbV8wXSBydGw6IW9yaWdpbi1bNTAlXzUwJV8wXSB3LVsycHhdIGFic29sdXRlXCIsXG4gIHRpbWVwaWNrZXJQb2ludGVyQ2lyY2xlOiBcIi10b3AtWzIxcHhdIC1sZWZ0LVsxNXB4XSB3LVs0cHhdIGJvcmRlci1bMTRweF0gYm9yZGVyLXNvbGlkIGJvcmRlci1bIzNiNzFjYV0gaC1bNHB4XSBib3gtY29udGVudCByb3VuZGVkLVsxMDAlXSBhYnNvbHV0ZVwiLFxuICB0aW1lcGlja2VyQ2xvY2tJbm5lcjogXCJhYnNvbHV0ZSB0b3AtMS8yIGxlZnQtMS8yIC10cmFuc2xhdGUteS0xLzIgLXRyYW5zbGF0ZS14LTEvMiB3LVsxNjBweF0gaC1bMTYwcHhdIHJvdW5kZWQtWzEwMCVdXCIsXG4gIHRpbWVwaWNrZXJGb290ZXJXcmFwcGVyOiBcInJvdW5kZWQtYi1sZyBmbGV4IGp1c3RpZnktYmV0d2VlbiBpdGVtcy1jZW50ZXIgdy1mdWxsIGgtWzU2cHhdIHB4LVsxMnB4XSBiZy13aGl0ZSBkYXJrOmJnLXppbmMtNTAwXCIsXG4gIHRpbWVwaWNrZXJGb290ZXI6IFwidy1mdWxsIGZsZXgganVzdGlmeS1iZXR3ZWVuXCIsXG4gIHRpbWVwaWNrZXJGb290ZXJCdXR0b246IFwidGV4dC1bMC44cmVtXSBtaW4tdy1bNjRweF0gYm94LWJvcmRlciBmb250LW1lZGl1bSBsZWFkaW5nLVs0MHB4XSByb3VuZGVkLVsxMHB4XSB0cmFja2luZy1bMC4xcmVtXSB1cHBlcmNhc2UgdGV4dC1bIzNiNzFjYV0gZGFyazp0ZXh0LXdoaXRlIGJvcmRlci1ub25lIGJnLXRyYW5zcGFyZW50IHRyYW5zaXRpb24tW2JhY2tncm91bmQtY29sb3IsYm94LXNoYWRvdyxib3JkZXJdIGR1cmF0aW9uLVsyNTBtc10gZWFzZS1bY3ViaWMtYmV6aWVyKDAuNCwwLDAuMiwxKV0gZGVsYXktWzBtc10gb3V0bGluZS1ub25lIHB5LTAgcHgtWzEwcHhdIGgtWzQwcHhdIG1iLVsxMHB4XSBob3ZlcjpiZy1bIzAwMDAwMDE0XSBmb2N1czpiZy1bIzAwMDAwMDE0XSBmb2N1czpvdXRsaW5lLW5vbmVcIixcbiAgdGltZXBpY2tlcklubGluZVdyYXBwZXI6IFwidG91Y2gtbm9uZSBvcGFjaXR5LTEwMCB6LVsxMDY1XSBpbnNldC0wIGJnLVsjMDAwMDAwNjZdIGgtZnVsbCBmbGV4IGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWNlbnRlciBmbGV4LWNvbCByb3VuZGVkLWxnXCIsXG4gIHRpbWVwaWNrZXJJbmxpbmVDb250YWluZXI6IFwiZmxleCBpdGVtcy1jZW50ZXIganVzdGlmeS1jZW50ZXIgZmxleC1jb2wgbWF4LWgtW2NhbGMoMTAwJS02NHB4KV0gb3ZlcmZsb3cteS1hdXRvIHNoYWRvdy1bMF8xMHB4XzE1cHhfLTNweF9yZ2JhKDAsMCwwLDAuMDcpLDBfNHB4XzZweF8tMnB4X3JnYmEoMCwwLDAsMC4wNSldXCIsXG4gIHRpbWVwaWNrZXJJbmxpbmVFbGVtZW50czogXCJmbGV4IGZsZXgtY29sIG1pbi1oLVthdXRvXSBtaW4tdy1bMzEwcHhdIGJnLXdoaXRlIHJvdW5kZWQtWzAuNnJlbV0gbWluLVszMjBweF06bWF4LVs4MjVweF06bGFuZHNjYXBlOiFmbGV4LXJvdyBtaW4tWzMyMHB4XTptYXgtWzgyNXB4XTpsYW5kc2NhcGU6cm91bmRlZC1ibC1sZyBtaW4tWzMyMHB4XTptYXgtWzgyNXB4XTpsYW5kc2NhcGU6bWluLXctW2F1dG9dIG1pbi1bMzIwcHhdOm1heC1bODI1cHhdOmxhbmRzY2FwZTo6bWluLWgtW2F1dG9dIG1pbi1bMzIwcHhdOm1heC1bODI1cHhdOmxhbmRzY2FwZTpvdmVyZmxvdy15LWF1dG8ganVzdGlmeS1hcm91bmRcIixcbiAgdGltZXBpY2tlcklubGluZUhlYWQ6IFwiYmctWyMzYjcxY2FdIGRhcms6YmctemluYy03MDAgaC1bMTAwcHhdIHJvdW5kZWQtdC1sZyBtaW4tWzMyMHB4XTptYXgtWzgyNXB4XTpsYW5kc2NhcGU6cm91bmRlZC10ci1ub25lIG1pbi1bMzIwcHhdOm1heC1bODI1cHhdOmxhbmRzY2FwZTpyb3VuZGVkLWJsLW5vbmUgbWluLVszMjBweF06bWF4LVs4MjVweF06bGFuZHNjYXBlOnAtWzEwcHhdIG1pbi1bMzIwcHhdOm1heC1bODI1cHhdOmxhbmRzY2FwZTpwci1bMTBweF0gbWluLVszMjBweF06bWF4LVs4MjVweF06bGFuZHNjYXBlOmgtYXV0byBtaW4tWzMyMHB4XTptYXgtWzgyNXB4XTpsYW5kc2NhcGU6bWluLWgtWzMwNXB4XSBmbGV4IGZsZXgtcm93IGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWNlbnRlciBwLTAgcm91bmRlZC1iLWxnXCIsXG4gIHRpbWVwaWNrZXJJbmxpbmVIZWFkQ29udGVudDogXCJtaW4tWzMyMHB4XTptYXgtWzgyNXB4XTpsYW5kc2NhcGU6ZmxleC1jb2wgZmxleCB3LWZ1bGwganVzdGlmeS1ldmVubHkgaXRlbXMtY2VudGVyXCIsXG4gIHRpbWVwaWNrZXJJbmxpbmVIb3VyV3JhcHBlcjogXCJyZWxhdGl2ZSBoLWZ1bGwgIW9wYWNpdHktMTAwXCIsXG4gIHRpbWVwaWNrZXJDdXJyZW50TWludXRlV3JhcHBlcjogXCJyZWxhdGl2ZSBoLWZ1bGxcIixcbiAgdGltZXBpY2tlcklubGluZUljb25VcDogXCJhYnNvbHV0ZSB0ZXh0LXdoaXRlIC10b3AtWzM1cHhdIG9wYWNpdHktMCBob3ZlcjpvcGFjaXR5LTEwMCB0cmFuc2l0aW9uLWFsbCBkdXJhdGlvbi0yMDAgZWFzZS1bZWFzZV0gY3Vyc29yLXBvaW50ZXIgLXRyYW5zbGF0ZS14LTEvMiAtdHJhbnNsYXRlLXktMS8yIGxlZnQtMS8yIHctWzMwcHhdIGgtWzMwcHhdIGZsZXgganVzdGlmeS1jZW50ZXIgaXRlbXMtY2VudGVyXCIsXG4gIHRpbWVwaWNrZXJJbmxpbmVJY29uU3ZnOiBcImgtNCB3LTRcIixcbiAgdGltZXBpY2tlcklubGluZUN1cnJlbnRCdXR0b246IFwiZm9udC1saWdodCBsZWFkaW5nLVsxLjJdIHRyYWNraW5nLVstMC4wMDgzM2VtXSB0ZXh0LXdoaXRlIGJvcmRlci1ub25lIGJnLXRyYW5zcGFyZW50IHAtMCBtaW4tWzMyMHB4XTptYXgtWzgyNXB4XTpsYW5kc2NhcGU6dGV4dC01eGwgbWluLVszMjBweF06bWF4LVs4MjVweF06bGFuZHNjYXBlOmZvbnQtbm9ybWFsICFvcGFjaXR5LTEwMCBjdXJzb3ItcG9pbnRlciBmb2N1czpiZy1bIzAwMDAwMDI2XSBob3ZlcjpvdXRsaW5lLW5vbmUgZm9jdXM6b3V0bGluZS1ub25lIHRleHQtWzIuNXJlbV0gaG92ZXI6YmctW3Vuc2V0XVwiLFxuICB0aW1lcGlja2VySW5saW5lSWNvbkRvd246IFwiYWJzb2x1dGUgdGV4dC13aGl0ZSAtYm90dG9tLVs0N3B4XSBvcGFjaXR5LTAgaG92ZXI6b3BhY2l0eS0xMDAgdHJhbnNpdGlvbi1hbGwgZHVyYXRpb24tMjAwIGVhc2UtW2Vhc2VdIGN1cnNvci1wb2ludGVyIC10cmFuc2xhdGUteC0xLzIgLXRyYW5zbGF0ZS15LTEvMiBsZWZ0LTEvMiB3LVszMHB4XSBoLVszMHB4XSBmbGV4IGp1c3RpZnktY2VudGVyIGl0ZW1zLWNlbnRlclwiLFxuICB0aW1lcGlja2VySW5saW5lRG90OiBcImZvbnQtbGlnaHQgbGVhZGluZy1bMS4yXSB0cmFja2luZy1bLTAuMDA4MzNlbV0gb3BhY2l0eS1bLjU0XSBib3JkZXItbm9uZSBiZy10cmFuc3BhcmVudCBwLTAgdGV4dC13aGl0ZSBtaW4tWzMyMHB4XTptYXgtWzgyNXB4XTpsYW5kc2NhcGU6dGV4dC1bM3JlbV0gbWluLVszMjBweF06bWF4LVs4MjVweF06bGFuZHNjYXBlOmZvbnQtbm9ybWFsIHRleHQtWzIuNXJlbV1cIixcbiAgdGltZXBpY2tlcklubGluZU1vZGVXcmFwcGVyOiBcImZsZXgganVzdGlmeS1jZW50ZXIgdGV4dC1bMThweF0gdGV4dC1bI2ZmZmZmZjhhXSBtaW4tWzMyMHB4XTptYXgtWzgyNXB4XTpsYW5kc2NhcGU6IWp1c3RpZnktYXJvdW5kIG1pbi1bMzIwcHhdOm1heC1bODI1cHhdOmxhbmRzY2FwZTohZmxleC1yb3dcIixcbiAgdGltZXBpY2tlcklubGluZU1vZGVBbTogXCJob3ZlcjpiZy1bIzAwMDAwMDI2XSBob3ZlcjpvdXRsaW5lLW5vbmUgZm9jdXM6YmctWyMwMDAwMDAyNl0gZm9jdXM6b3V0bGluZS1ub25lIHAtMCBiZy10cmFuc3BhcmVudCBib3JkZXItbm9uZSB0ZXh0LXdoaXRlIG9wYWNpdHktWy41NF0gY3Vyc29yLXBvaW50ZXIgbXItMiBtbC02XCIsXG4gIHRpbWVwaWNrZXJJbmxpbmVNb2RlUG06IFwiaG92ZXI6YmctWyMwMDAwMDAyNl0gaG92ZXI6b3V0bGluZS1ub25lIGZvY3VzOmJnLVsjMDAwMDAwMjZdIGZvY3VzOm91dGxpbmUtbm9uZSBwLTAgYmctdHJhbnNwYXJlbnQgYm9yZGVyLW5vbmUgdGV4dC13aGl0ZSBvcGFjaXR5LVsuNTRdIGN1cnNvci1wb2ludGVyXCIsXG4gIHRpbWVwaWNrZXJJbmxpbmVTdWJtaXRCdXR0b246IFwiaG92ZXI6YmctWyMwMDAwMDAxNF0gZm9jdXM6YmctWyMwMDAwMDAxNF0gZm9jdXM6b3V0bGluZS1ub25lIHRleHQtWzAuOHJlbV0gYm94LWJvcmRlciBmb250LW1lZGl1bSBsZWFkaW5nLVs0MHB4XSB0cmFja2luZy1bLjFyZW1dIHVwcGVyY2FzZSBib3JkZXItbm9uZSBiZy10cmFuc3BhcmVudCBbdHJhbnNpdGlvbjpiYWNrZ3JvdW5kLWNvbG9yXzI1MG1zX2N1YmljLWJlemllcigwLjQsMCwwLjIsMSlfMG1zLGJveC1zaGFkb3dfMjUwbXNfY3ViaWMtYmV6aWVyKDAuNCwwLDAuMiwxKV8wbXMsYm9yZGVyXzI1MG1zX2N1YmljLWJlemllcigwLjQsMCwwLjIsMSlfMG1zXSBvdXRsaW5lLW5vbmUgcm91bmRlZC1bMTAwJV0gaC1bNDhweF0gbWluLXctWzQ4cHhdIGlubGluZS1ibG9jayBtbC1bMzBweF0gdGV4dC13aGl0ZSBweS0xIHB4LTIgbWItMFwiLFxuICB0aW1lcGlja2VyVG9nZ2xlQnV0dG9uOiBcImgtNCB3LTQgbWwtYXV0byBhYnNvbHV0ZSBvdXRsaW5lLW5vbmUgYm9yZGVyLW5vbmUgYmctdHJhbnNwYXJlbnQgcmlnaHQtMS41IHRvcC0xLzIgLXRyYW5zbGF0ZS14LTEvMiAtdHJhbnNsYXRlLXktMS8yIHRyYW5zaXRpb24tYWxsIGR1cmF0aW9uLTMwMCBlYXNlLVtjdWJpYy1iZXppZXIoMC4yNSwwLjEsMC4yNSwxKV0gY3Vyc29yLXBvaW50ZXIgaG92ZXI6dGV4dC1bIzNiNzFjYV0gZm9jdXM6dGV4dC1bIzNiNzFjYV0gZGFyazpob3Zlcjp0ZXh0LVsjM2I3MWNhXSBkYXJrOmZvY3VzOnRleHQtWyMzYjcxY2FdIGRhcms6dGV4dC13aGl0ZVwiXG59LCBzZyA9IHtcbiAgdGlwczogXCJzdHJpbmdcIixcbiAgdGlwc0FjdGl2ZTogXCJzdHJpbmdcIixcbiAgdGlwc0Rpc2FibGVkOiBcInN0cmluZ1wiLFxuICB0cmFuc2Zvcm06IFwic3RyaW5nXCIsXG4gIG1vZGFsOiBcInN0cmluZ1wiLFxuICBjbG9ja0FuaW1hdGlvbjogXCJzdHJpbmdcIixcbiAgb3BhY2l0eTogXCJzdHJpbmdcIixcbiAgdGltZXBpY2tlcldyYXBwZXI6IFwic3RyaW5nXCIsXG4gIHRpbWVwaWNrZXJDb250YWluZXI6IFwic3RyaW5nXCIsXG4gIHRpbWVwaWNrZXJFbGVtZW50czogXCJzdHJpbmdcIixcbiAgdGltZXBpY2tlckhlYWQ6IFwic3RyaW5nXCIsXG4gIHRpbWVwaWNrZXJIZWFkQ29udGVudDogXCJzdHJpbmdcIixcbiAgdGltZXBpY2tlckN1cnJlbnRXcmFwcGVyOiBcInN0cmluZ1wiLFxuICB0aW1lcGlja2VyQ3VycmVudEJ1dHRvbldyYXBwZXI6IFwic3RyaW5nXCIsXG4gIHRpbWVwaWNrZXJDdXJyZW50QnV0dG9uOiBcInN0cmluZ1wiLFxuICB0aW1lcGlja2VyRG90OiBcInN0cmluZ1wiLFxuICB0aW1lcGlja2VyTW9kZVdyYXBwZXI6IFwic3RyaW5nXCIsXG4gIHRpbWVwaWNrZXJNb2RlQW06IFwic3RyaW5nXCIsXG4gIHRpbWVwaWNrZXJNb2RlUG06IFwic3RyaW5nXCIsXG4gIHRpbWVwaWNrZXJDbG9ja1dyYXBwZXI6IFwic3RyaW5nXCIsXG4gIHRpbWVwaWNrZXJDbG9jazogXCJzdHJpbmdcIixcbiAgdGltZXBpY2tlck1pZGRsZURvdDogXCJzdHJpbmdcIixcbiAgdGltZXBpY2tlckhhbmRQb2ludGVyOiBcInN0cmluZ1wiLFxuICB0aW1lcGlja2VyUG9pbnRlckNpcmNsZTogXCJzdHJpbmdcIixcbiAgdGltZXBpY2tlckNsb2NrSW5uZXI6IFwic3RyaW5nXCIsXG4gIHRpbWVwaWNrZXJGb290ZXJXcmFwcGVyOiBcInN0cmluZ1wiLFxuICB0aW1lcGlja2VyRm9vdGVyQnV0dG9uOiBcInN0cmluZ1wiLFxuICB0aW1lcGlja2VySW5saW5lV3JhcHBlcjogXCJzdHJpbmdcIixcbiAgdGltZXBpY2tlcklubGluZUNvbnRhaW5lcjogXCJzdHJpbmdcIixcbiAgdGltZXBpY2tlcklubGluZUVsZW1lbnRzOiBcInN0cmluZ1wiLFxuICB0aW1lcGlja2VySW5saW5lSGVhZDogXCJzdHJpbmdcIixcbiAgdGltZXBpY2tlcklubGluZUhlYWRDb250ZW50OiBcInN0cmluZ1wiLFxuICB0aW1lcGlja2VySW5saW5lSG91cldyYXBwZXI6IFwic3RyaW5nXCIsXG4gIHRpbWVwaWNrZXJDdXJyZW50TWludXRlV3JhcHBlcjogXCJzdHJpbmdcIixcbiAgdGltZXBpY2tlcklubGluZUljb25VcDogXCJzdHJpbmdcIixcbiAgdGltZXBpY2tlcklubGluZUljb25Tdmc6IFwic3RyaW5nXCIsXG4gIHRpbWVwaWNrZXJJbmxpbmVDdXJyZW50QnV0dG9uOiBcInN0cmluZ1wiLFxuICB0aW1lcGlja2VySW5saW5lSWNvbkRvd246IFwic3RyaW5nXCIsXG4gIHRpbWVwaWNrZXJJbmxpbmVEb3Q6IFwic3RyaW5nXCIsXG4gIHRpbWVwaWNrZXJJbmxpbmVNb2RlV3JhcHBlcjogXCJzdHJpbmdcIixcbiAgdGltZXBpY2tlcklubGluZU1vZGVBbTogXCJzdHJpbmdcIixcbiAgdGltZXBpY2tlcklubGluZU1vZGVQbTogXCJzdHJpbmdcIixcbiAgdGltZXBpY2tlcklubGluZVN1Ym1pdEJ1dHRvbjogXCJzdHJpbmdcIixcbiAgdGltZXBpY2tlclRvZ2dsZUJ1dHRvbjogXCJzdHJpbmdcIlxufTtcbmNsYXNzIG5nIHtcbiAgY29uc3RydWN0b3IodCwgZSA9IHt9LCBpKSB7XG4gICAgeXQodGhpcywgXCJfdG9nZ2xlQW1QbVwiLCAodCkgPT4ge1xuICAgICAgdCA9PT0gXCJQTVwiID8gKHRoaXMuX2lzUG1FbmFibGVkID0gITAsIHRoaXMuX2lzQW1FbmFibGVkID0gITEpIDogdCA9PT0gXCJBTVwiICYmICh0aGlzLl9pc1BtRW5hYmxlZCA9ICExLCB0aGlzLl9pc0FtRW5hYmxlZCA9ICEwKTtcbiAgICB9KTtcbiAgICB5dCh0aGlzLCBcIl90b2dnbGVCYWNrZ3JvdW5kQ29sb3JDaXJjbGVcIiwgKHQpID0+IHtcbiAgICAgIGlmICh0aGlzLl9tb2RhbC5xdWVyeVNlbGVjdG9yKGAke3R9WyR7SH1dYCkgIT09IG51bGwpIHtcbiAgICAgICAgaC5hZGRTdHlsZSh0aGlzLl9jaXJjbGUsIHtcbiAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiIzE5NzZkMlwiXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBoLmFkZFN0eWxlKHRoaXMuX2NpcmNsZSwge1xuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwidHJhbnNwYXJlbnRcIlxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgeXQodGhpcywgXCJfdG9nZ2xlQ2xhc3NBY3RpdmVcIiwgKHQsIHsgdGV4dENvbnRlbnQ6IGUgfSwgaSkgPT4ge1xuICAgICAgY29uc3QgbiA9IFsuLi50XS5maW5kKFxuICAgICAgICAobykgPT4gTnVtYmVyKG8pID09PSBOdW1iZXIoZSlcbiAgICAgICk7XG4gICAgICByZXR1cm4gaS5mb3JFYWNoKChvKSA9PiB7XG4gICAgICAgIGlmICghby5oYXNBdHRyaWJ1dGUoWXQpKSB7XG4gICAgICAgICAgaWYgKG8udGV4dENvbnRlbnQgPT09IG4pIHtcbiAgICAgICAgICAgIGguYWRkQ2xhc3MobywgdGhpcy5fY2xhc3Nlcy50aXBzQWN0aXZlKSwgby5zZXRBdHRyaWJ1dGUoSCwgXCJcIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGgucmVtb3ZlQ2xhc3MobywgdGhpcy5fY2xhc3Nlcy50aXBzQWN0aXZlKSwgby5yZW1vdmVBdHRyaWJ1dGUoSCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHl0KHRoaXMsIFwiX21ha2VNaW51dGVzRGVncmVlc1wiLCAodCwgZSkgPT4ge1xuICAgICAgY29uc3QgeyBpbmNyZW1lbnQ6IGkgfSA9IHRoaXMuX29wdGlvbnM7XG4gICAgICByZXR1cm4gdCA8IDAgPyAoZSA9IE1hdGgucm91bmQoMzYwICsgdCAvIDYpICUgNjAsIHQgPSAzNjAgKyBNYXRoLnJvdW5kKHQgLyA2KSAqIDYpIDogKGUgPSBNYXRoLnJvdW5kKHQgLyA2KSAlIDYwLCB0ID0gTWF0aC5yb3VuZCh0IC8gNikgKiA2KSwgaSAmJiAodCA9IE1hdGgucm91bmQodCAvIDMwKSAqIDMwLCBlID0gTWF0aC5yb3VuZCh0IC8gNikgKiA2IC8gNiwgZSA9PT0gNjAgJiYgKGUgPSBcIjAwXCIpKSwgdCA+PSAzNjAgJiYgKHQgPSAwKSwge1xuICAgICAgICBkZWdyZWVzOiB0LFxuICAgICAgICBtaW51dGU6IGUsXG4gICAgICAgIGFkZERlZ3JlZXM6IGkgPyAzMCA6IDZcbiAgICAgIH07XG4gICAgfSk7XG4gICAgeXQodGhpcywgXCJfbWFrZUhvdXJEZWdyZWVzXCIsICh0LCBlLCBpKSA9PiB7XG4gICAgICBpZiAodClcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hhc1RhcmdldElubmVyQ2xhc3ModCkgPyBlIDwgMCA/IChpID0gTWF0aC5yb3VuZCgzNjAgKyBlIC8gMzApICUgMjQsIGUgPSAzNjAgKyBlKSA6IChpID0gTWF0aC5yb3VuZChlIC8gMzApICsgMTIsIGkgPT09IDEyICYmIChpID0gXCIwMFwiKSkgOiBlIDwgMCA/IChpID0gTWF0aC5yb3VuZCgzNjAgKyBlIC8gMzApICUgMTIsIGUgPSAzNjAgKyBlKSA6IChpID0gTWF0aC5yb3VuZChlIC8gMzApICUgMTIsIChpID09PSAwIHx8IGkgPiAxMikgJiYgKGkgPSAxMikpLCBlID49IDM2MCAmJiAoZSA9IDApLCB7XG4gICAgICAgICAgZGVncmVlczogZSxcbiAgICAgICAgICBob3VyOiBpLFxuICAgICAgICAgIGFkZERlZ3JlZXM6IDMwXG4gICAgICAgIH07XG4gICAgfSk7XG4gICAgeXQodGhpcywgXCJfbWFrZUlubmVySG91cnNEZWdyZWVzXCIsICh0LCBlKSA9PiAodCA8IDAgPyAoZSA9IE1hdGgucm91bmQoMzYwICsgdCAvIDMwKSAlIDI0LCB0ID0gMzYwICsgdCkgOiAoZSA9IE1hdGgucm91bmQodCAvIDMwKSArIDEyLCBlID09PSAxMiAmJiAoZSA9IFwiMDBcIikpLCB7XG4gICAgICBkZWdyZWVzOiB0LFxuICAgICAgaG91cjogZSxcbiAgICAgIGFkZERlZ3JlZXM6IDMwXG4gICAgfSkpO1xuICAgIHl0KHRoaXMsIFwiX2dldEFwcGVuZENsb2NrXCIsICh0ID0gW10sIGUgPSBgWyR7cGV9XWAsIGkpID0+IHtcbiAgICAgIGxldCB7IG1pblRpbWU6IG4sIG1heFRpbWU6IG8gfSA9IHRoaXMuX29wdGlvbnM7XG4gICAgICBjb25zdCB7IGlubGluZTogciwgZm9ybWF0MTI6IGEsIGRpc2FibGVQYXN0OiBsLCBkaXNhYmxlRnV0dXJlOiBwIH0gPSB0aGlzLl9vcHRpb25zO1xuICAgICAgbiA9IFh0KG4sIGwsIGEpLCBvID0gR3QobywgcCwgYSk7XG4gICAgICBjb25zdCBbdSwgXywgZl0gPSBSKFxuICAgICAgICBvLFxuICAgICAgICAhMVxuICAgICAgKSwgW2csIG0sIGJdID0gUihcbiAgICAgICAgbixcbiAgICAgICAgITFcbiAgICAgICk7XG4gICAgICAhciAmJiBhICYmIHRoaXMuX2lzSW52YWxpZFRpbWVGb3JtYXQgJiYgIXRoaXMuX0FNLmhhc0F0dHJpYnV0ZShIKSAmJiAoaC5hZGRDbGFzcyh0aGlzLl9QTSwgdGhpcy5fY2xhc3Nlcy5vcGFjaXR5KSwgdGhpcy5fUE0uc2V0QXR0cmlidXRlKEgsIFwiXCIpKTtcbiAgICAgIGNvbnN0IHYgPSBkLmZpbmRPbmUoZSksIEMgPSAzNjAgLyB0Lmxlbmd0aDtcbiAgICAgIGZ1bmN0aW9uIHcoaykge1xuICAgICAgICByZXR1cm4gayAqIChNYXRoLlBJIC8gMTgwKTtcbiAgICAgIH1cbiAgICAgIGlmICh2ID09PSBudWxsKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCBFID0gKHYub2Zmc2V0V2lkdGggLSAzMikgLyAyLCBUID0gKHYub2Zmc2V0SGVpZ2h0IC0gMzIpIC8gMiwgQSA9IEUgLSA0O1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGxldCBrO1xuICAgICAgICBhICYmIChrID0gZC5maW5kT25lKFxuICAgICAgICAgIGAke21zfVske0h9XWBcbiAgICAgICAgKS50ZXh0Q29udGVudCksIHRoaXMuX2hhbmRsZURpc2FibGluZ1RpcHNNaW5UaW1lKFxuICAgICAgICAgIGssXG4gICAgICAgICAgYixcbiAgICAgICAgICBtLFxuICAgICAgICAgIGdcbiAgICAgICAgKSwgdGhpcy5faGFuZGxlRGlzYWJsaW5nVGlwc01heFRpbWUoXG4gICAgICAgICAgayxcbiAgICAgICAgICBmLFxuICAgICAgICAgIF8sXG4gICAgICAgICAgdVxuICAgICAgICApO1xuICAgICAgfSwgMCksIFsuLi50XS5mb3JFYWNoKChrLCBJKSA9PiB7XG4gICAgICAgIGNvbnN0IE8gPSB3KEkgKiBDKSwgeCA9ICQoXCJzcGFuXCIpLCBMID0gJChcInNwYW5cIik7XG4gICAgICAgIEwuaW5uZXJIVE1MID0gaywgaC5hZGRDbGFzcyh4LCB0aGlzLl9jbGFzc2VzLnRpcHMpLCB4LnNldEF0dHJpYnV0ZShpLCBcIlwiKTtcbiAgICAgICAgY29uc3QgUyA9IHgub2Zmc2V0V2lkdGgsIE4gPSB4Lm9mZnNldEhlaWdodDtcbiAgICAgICAgcmV0dXJuIGguYWRkU3R5bGUoeCwge1xuICAgICAgICAgIGxlZnQ6IGAke0UgKyBNYXRoLnNpbihPKSAqIEEgLSBTfXB4YCxcbiAgICAgICAgICBib3R0b206IGAke1QgKyBNYXRoLmNvcyhPKSAqIEEgLSBOfXB4YFxuICAgICAgICB9KSwgdC5pbmNsdWRlcyhcIjA1XCIpICYmIHguc2V0QXR0cmlidXRlKFgsIFwiXCIpLCB0LmluY2x1ZGVzKFwiMTNcIikgPyBMLnNldEF0dHJpYnV0ZSh2cywgXCJcIikgOiBMLnNldEF0dHJpYnV0ZShicywgXCJcIiksIHguYXBwZW5kQ2hpbGQoTCksIHYuYXBwZW5kQ2hpbGQoeCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICB0aGlzLl9lbGVtZW50ID0gdCwgdGhpcy5fZWxlbWVudCAmJiB5LnNldERhdGEodCwgVXMsIHRoaXMpLCB0aGlzLl9kb2N1bWVudCA9IGRvY3VtZW50LCB0aGlzLl9vcHRpb25zID0gdGhpcy5fZ2V0Q29uZmlnKGUpLCB0aGlzLl9jbGFzc2VzID0gdGhpcy5fZ2V0Q2xhc3NlcyhpKSwgdGhpcy5fY3VycmVudFRpbWUgPSBudWxsLCB0aGlzLl90b2dnbGVCdXR0b25JZCA9IHJ0KFwidGltZXBpY2tlci10b2dnbGUtXCIpLCB0aGlzLmhvdXJzQXJyYXkgPSBbXG4gICAgICBcIjEyXCIsXG4gICAgICBcIjFcIixcbiAgICAgIFwiMlwiLFxuICAgICAgXCIzXCIsXG4gICAgICBcIjRcIixcbiAgICAgIFwiNVwiLFxuICAgICAgXCI2XCIsXG4gICAgICBcIjdcIixcbiAgICAgIFwiOFwiLFxuICAgICAgXCI5XCIsXG4gICAgICBcIjEwXCIsXG4gICAgICBcIjExXCJcbiAgICBdLCB0aGlzLmlubmVySG91cnMgPSBbXG4gICAgICBcIjAwXCIsXG4gICAgICBcIjEzXCIsXG4gICAgICBcIjE0XCIsXG4gICAgICBcIjE1XCIsXG4gICAgICBcIjE2XCIsXG4gICAgICBcIjE3XCIsXG4gICAgICBcIjE4XCIsXG4gICAgICBcIjE5XCIsXG4gICAgICBcIjIwXCIsXG4gICAgICBcIjIxXCIsXG4gICAgICBcIjIyXCIsXG4gICAgICBcIjIzXCJcbiAgICBdLCB0aGlzLm1pbnV0ZXNBcnJheSA9IFtcbiAgICAgIFwiMDBcIixcbiAgICAgIFwiMDVcIixcbiAgICAgIFwiMTBcIixcbiAgICAgIFwiMTVcIixcbiAgICAgIFwiMjBcIixcbiAgICAgIFwiMjVcIixcbiAgICAgIFwiMzBcIixcbiAgICAgIFwiMzVcIixcbiAgICAgIFwiNDBcIixcbiAgICAgIFwiNDVcIixcbiAgICAgIFwiNTBcIixcbiAgICAgIFwiNTVcIlxuICAgIF0sIHRoaXMuaW5wdXQgPSBkLmZpbmRPbmUoXCJpbnB1dFwiLCB0aGlzLl9lbGVtZW50KSwgdGhpcy5kYXRhV2l0aEljb24gPSB0LmRhdGFzZXQud2l0aEljb24sIHRoaXMuZGF0YVRvZ2dsZSA9IHQuZGF0YXNldC50b2dnbGUsIHRoaXMuY3VzdG9tSWNvbiA9IGQuZmluZE9uZShcbiAgICAgIEttLFxuICAgICAgdGhpcy5fZWxlbWVudFxuICAgICksIHRoaXMuX2NoZWNrVG9nZ2xlQnV0dG9uKCksIHRoaXMuaW5wdXRGb3JtYXRTaG93ID0gZC5maW5kT25lKFxuICAgICAgam0sXG4gICAgICB0aGlzLl9lbGVtZW50XG4gICAgKSwgdGhpcy5pbnB1dEZvcm1hdCA9IHRoaXMuaW5wdXRGb3JtYXRTaG93ID09PSBudWxsID8gXCJcIiA6IE9iamVjdC52YWx1ZXModGhpcy5pbnB1dEZvcm1hdFNob3cuZGF0YXNldClbMF0sIHRoaXMuZWxlbWVudFRvZ2dsZSA9IGQuZmluZE9uZShcbiAgICAgIFBhLFxuICAgICAgdGhpcy5fZWxlbWVudFxuICAgICksIHRoaXMudG9nZ2xlRWxlbWVudCA9IE9iamVjdC52YWx1ZXMoXG4gICAgICB0LnF1ZXJ5U2VsZWN0b3IoUGEpLmRhdGFzZXRcbiAgICApWzBdLCB0aGlzLl9ob3VyID0gbnVsbCwgdGhpcy5fbWludXRlcyA9IG51bGwsIHRoaXMuX0FNID0gbnVsbCwgdGhpcy5fUE0gPSBudWxsLCB0aGlzLl93cmFwcGVyID0gbnVsbCwgdGhpcy5fbW9kYWwgPSBudWxsLCB0aGlzLl9oYW5kID0gbnVsbCwgdGhpcy5fY2lyY2xlID0gbnVsbCwgdGhpcy5fZm9jdXNUcmFwID0gbnVsbCwgdGhpcy5fcG9wcGVyID0gbnVsbCwgdGhpcy5faW50ZXJ2YWwgPSBudWxsLCB0aGlzLl90aW1lb3V0SW50ZXJ2YWwgPSBudWxsLCB0aGlzLl9pbnB1dFZhbHVlID0gdGhpcy5fb3B0aW9ucy5kZWZhdWx0VGltZSAhPT0gXCJcIiA/IHRoaXMuX29wdGlvbnMuZGVmYXVsdFRpbWUgOiB0aGlzLmlucHV0LnZhbHVlLCB0aGlzLl9vcHRpb25zLmZvcm1hdDI0ICYmICh0aGlzLl9vcHRpb25zLmZvcm1hdDEyID0gITEsIHRoaXMuX2N1cnJlbnRUaW1lID0gTGEodGhpcy5faW5wdXRWYWx1ZSkpLCB0aGlzLl9vcHRpb25zLmZvcm1hdDEyICYmICh0aGlzLl9vcHRpb25zLmZvcm1hdDI0ID0gITEsIHRoaXMuX2N1cnJlbnRUaW1lID0gdmUodGhpcy5faW5wdXRWYWx1ZSkpLCB0aGlzLl9vcHRpb25zLnJlYWRPbmx5ICYmIHRoaXMuaW5wdXQuc2V0QXR0cmlidXRlKHFtLCAhMCksIHRoaXMuaW5wdXRGb3JtYXQgPT09IFwidHJ1ZVwiICYmIHRoaXMuaW5wdXRGb3JtYXQgIT09IFwiXCIgJiYgKHRoaXMuX29wdGlvbnMuZm9ybWF0MTIgPSAhMSwgdGhpcy5fb3B0aW9ucy5mb3JtYXQyNCA9ICEwLCB0aGlzLl9jdXJyZW50VGltZSA9IExhKHRoaXMuX2lucHV0VmFsdWUpKSwgdGhpcy5fYW5pbWF0aW9ucyA9ICF3aW5kb3cubWF0Y2hNZWRpYShcIihwcmVmZXJzLXJlZHVjZWQtbW90aW9uOiByZWR1Y2UpXCIpLm1hdGNoZXMgJiYgdGhpcy5fb3B0aW9ucy5hbmltYXRpb25zLCB0aGlzLmluaXQoKSwgdGhpcy5faXNIb3VycyA9ICEwLCB0aGlzLl9pc01pbnV0ZXMgPSAhMSwgdGhpcy5faXNJbnZhbGlkVGltZUZvcm1hdCA9ICExLCB0aGlzLl9pc01vdXNlTW92ZSA9ICExLCB0aGlzLl9pc0lubmVyID0gITEsIHRoaXMuX2lzQW1FbmFibGVkID0gITEsIHRoaXMuX2lzUG1FbmFibGVkID0gITEsIHRoaXMuX29wdGlvbnMuZm9ybWF0MTIgJiYgIXRoaXMuX29wdGlvbnMuZGVmYXVsdFRpbWUgJiYgKHRoaXMuX2lzUG1FbmFibGVkID0gITApLCB0aGlzLl9vYmpXaXRoRGF0YU9uQ2hhbmdlID0geyBkZWdyZWVzOiBudWxsIH0sIHRoaXMuX3Njcm9sbEJhciA9IG5ldyBxZSgpO1xuICB9XG4gIC8vIEdldHRlcnNcbiAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgIHJldHVybiAkaTtcbiAgfVxuICAvLyBQdWJsaWNcbiAgaW5pdCgpIHtcbiAgICBjb25zdCB7IGZvcm1hdDEyOiB0LCBmb3JtYXQyNDogZSwgZW5hYmxlVmFsaWRhdGlvbjogaSB9ID0gdGhpcy5fb3B0aW9ucztcbiAgICBsZXQgbiwgbywgcjtcbiAgICBpZiAodGhpcy5pbnB1dC5zZXRBdHRyaWJ1dGUoUW0sIFwiXCIpLCB0aGlzLl9jdXJyZW50VGltZSAhPT0gdm9pZCAwKSB7XG4gICAgICBjb25zdCB7IGhvdXJzOiBhLCBtaW51dGVzOiBsLCBhbU9yUG06IHAgfSA9IHRoaXMuX2N1cnJlbnRUaW1lO1xuICAgICAgbiA9IE51bWJlcihhKSA8IDEwID8gMCA6IFwiXCIsIG8gPSBgJHtufSR7TnVtYmVyKGEpfToke2x9YCwgciA9IHAsIHQgPyB0aGlzLmlucHV0LnZhbHVlID0gYCR7b30gJHtyfWAgOiBlICYmICh0aGlzLmlucHV0LnZhbHVlID0gYCR7b31gKTtcbiAgICB9IGVsc2VcbiAgICAgIG4gPSBcIlwiLCBvID0gXCJcIiwgciA9IFwiXCIsIHRoaXMuaW5wdXQudmFsdWUgPSBcIlwiO1xuICAgIHRoaXMuaW5wdXQudmFsdWUubGVuZ3RoID4gMCAmJiB0aGlzLmlucHV0LnZhbHVlICE9PSBcIlwiICYmICh0aGlzLmlucHV0LnNldEF0dHJpYnV0ZShILCBcIlwiKSwgYy50cmlnZ2VyKHRoaXMuaW5wdXQsIFwiaW5wdXRcIikpLCAhKHRoaXMuX29wdGlvbnMgPT09IG51bGwgJiYgdGhpcy5fZWxlbWVudCA9PT0gbnVsbCkgJiYgKGkgJiYgdGhpcy5fZ2V0VmFsaWRhdGUoXCJrZXlkb3duIGNoYW5nZSBibHVyIGZvY3VzXCIpLCB0aGlzLl9oYW5kbGVPcGVuKCksIHRoaXMuX2xpc3RlblRvVG9nZ2xlS2V5ZG93bigpKTtcbiAgfVxuICBkaXNwb3NlKCkge1xuICAgIHRoaXMuX3JlbW92ZU1vZGFsKCksIHRoaXMuX2VsZW1lbnQgIT09IG51bGwgJiYgeS5yZW1vdmVEYXRhKHRoaXMuX2VsZW1lbnQsIFVzKSwgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLl9lbGVtZW50ID0gbnVsbCwgdGhpcy5fb3B0aW9ucyA9IG51bGwsIHRoaXMuaW5wdXQgPSBudWxsLCB0aGlzLl9mb2N1c1RyYXAgPSBudWxsO1xuICAgIH0sIDM1MCksIGMub2ZmKFxuICAgICAgdGhpcy5fZG9jdW1lbnQsXG4gICAgICBcImNsaWNrXCIsXG4gICAgICBgW2RhdGEtdGUtdG9nZ2xlPScke3RoaXMudG9nZ2xlRWxlbWVudH0nXWBcbiAgICApLCBjLm9mZihcbiAgICAgIHRoaXMuX2VsZW1lbnQsXG4gICAgICBcImtleWRvd25cIixcbiAgICAgIGBbZGF0YS10ZS10b2dnbGU9JyR7dGhpcy50b2dnbGVFbGVtZW50fSddYFxuICAgICk7XG4gIH1cbiAgdXBkYXRlKHQgPSB7fSkge1xuICAgIHRoaXMuX29wdGlvbnMgPSB0aGlzLl9nZXRDb25maWcoeyAuLi50aGlzLl9vcHRpb25zLCAuLi50IH0pO1xuICB9XG4gIC8vIHByaXZhdGVcbiAgX2NoZWNrVG9nZ2xlQnV0dG9uKCkge1xuICAgIHRoaXMuY3VzdG9tSWNvbiA9PT0gbnVsbCAmJiAodGhpcy5kYXRhV2l0aEljb24gIT09IHZvaWQgMCAmJiAodGhpcy5fb3B0aW9ucy53aXRoSWNvbiA9IG51bGwsIHRoaXMuZGF0YVdpdGhJY29uID09PSBcInRydWVcIiAmJiB0aGlzLl9hcHBlbmRUb2dnbGVCdXR0b24odGhpcy5fb3B0aW9ucykpLCB0aGlzLl9vcHRpb25zLndpdGhJY29uICYmIHRoaXMuX2FwcGVuZFRvZ2dsZUJ1dHRvbih0aGlzLl9vcHRpb25zKSk7XG4gIH1cbiAgX2FwcGVuZFRvZ2dsZUJ1dHRvbigpIHtcbiAgICBjb25zdCB0ID0gUm0oXG4gICAgICB0aGlzLl9vcHRpb25zLFxuICAgICAgdGhpcy5fdG9nZ2xlQnV0dG9uSWQsXG4gICAgICB0aGlzLl9jbGFzc2VzXG4gICAgKTtcbiAgICB0aGlzLmlucHV0Lmluc2VydEFkamFjZW50SFRNTChcImFmdGVyZW5kXCIsIHQpO1xuICB9XG4gIF9nZXREb21FbGVtZW50cygpIHtcbiAgICB0aGlzLl9ob3VyID0gZC5maW5kT25lKGBbJHtnc31dYCksIHRoaXMuX21pbnV0ZXMgPSBkLmZpbmRPbmUoYFske2VvfV1gKSwgdGhpcy5fQU0gPSBkLmZpbmRPbmUoRm0pLCB0aGlzLl9QTSA9IGQuZmluZE9uZShZbSksIHRoaXMuX3dyYXBwZXIgPSBkLmZpbmRPbmUoYFske3RvfV1gKSwgdGhpcy5fbW9kYWwgPSBkLmZpbmRPbmUoYFske1phfV1gKSwgdGhpcy5faGFuZCA9IGQuZmluZE9uZShgWyR7aW99XWApLCB0aGlzLl9jaXJjbGUgPSBkLmZpbmRPbmUoYFske3NvfV1gKSwgdGhpcy5fY2xvY2sgPSBkLmZpbmRPbmUoYFske3BlfV1gKSwgdGhpcy5fY2xvY2tJbm5lciA9IGQuZmluZE9uZShcbiAgICAgIGBbJHtkaX1dYFxuICAgICk7XG4gIH1cbiAgX2hhbmRsZXJNYXhNaW5Ib3Vyc09wdGlvbnModCwgZSwgaSwgbiwgbywgcikge1xuICAgIGlmICghZSAmJiAhaSlcbiAgICAgIHJldHVybiAhMDtcbiAgICBjb25zdCB7IGZvcm1hdDI0OiBhLCBmb3JtYXQxMjogbCwgZGlzYWJsZVBhc3Q6IHAsIGRpc2FibGVGdXR1cmU6IHUgfSA9IHRoaXMuX29wdGlvbnMsIHsgX2lzQW1FbmFibGVkOiBfLCBfaXNQbUVuYWJsZWQ6IGYgfSA9IHRoaXMsIGcgPSByLmtleUNvZGUsIG0gPSByLnRhcmdldC5oYXNBdHRyaWJ1dGUoZGkpIHx8IHIudGFyZ2V0Lmhhc0F0dHJpYnV0ZShsdCkgfHwgci50YXJnZXQuaGFzQXR0cmlidXRlKHZzKTtcbiAgICBpID0gWHQoaSwgcCwgbCksIGUgPSBHdChlLCB1LCBsKSwgdHlwZW9mIGUgIT0gXCJudW1iZXJcIiAmJiAoZSA9IFIoZSwgITEpWzBdKTtcbiAgICBjb25zdCBiID0gZSAhPT0gXCJcIiA/IGUgKiAzMCA6IFwiXCIsIHYgPSBpICE9PSBcIlwiID8gaSAqIDMwIDogXCJcIjtcbiAgICB0IDwgMCAmJiAodCA9IDM2MCArIHQpLCB0ID0gdCA9PT0gMzYwID8gMCA6IHQ7XG4gICAgY29uc3QgQyA9ICgpID0+IHtcbiAgICAgIGNvbnN0IEkgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFxuICAgICAgICBgWyR7YnN9XWBcbiAgICAgICksIE8gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFxuICAgICAgICBgWyR7dnN9XWBcbiAgICAgICksIHggPSBXbSh0aGlzLl9ob3VyLmlubmVyVGV4dCk7XG4gICAgICBsZXQgTCwgUywgTjtcbiAgICAgIHJldHVybiBnID09PSBhdCA/IFMgPSAxIDogZyA9PT0geiAmJiAoUyA9IC0xKSwgeCA9PT0gMTIgJiYgZyA9PT0gYXQgPyBOID0gMSA6IHggPT09IDAgJiYgZyA9PT0gYXQgPyBOID0gMTMgOiB4ID09PSAwICYmIGcgPT09IHogPyBOID0gMjMgOiB4ID09PSAxMyAmJiBnID09PSB6ID8gTiA9IDAgOiB4ID09PSAxICYmIGcgPT09IHogPyBOID0gMTIgOiBOID0geCArIFMsIEkuZm9yRWFjaCgoUCkgPT4ge1xuICAgICAgICBOdW1iZXIoUC50ZXh0Q29udGVudCkgPT09IE4gJiYgKEwgPSBQKTtcbiAgICAgIH0pLCBPLmZvckVhY2goKFApID0+IHtcbiAgICAgICAgTnVtYmVyKFAudGV4dENvbnRlbnQpID09PSBOICYmIChMID0gUCk7XG4gICAgICB9KSwgIUwucGFyZW50RWxlbWVudC5oYXNBdHRyaWJ1dGUoWXQpO1xuICAgIH0sIHcgPSAoKSA9PiB7XG4gICAgICBjb25zdCBJID0gaSAhPT0gXCJcIiAmJiBpID4gMTIgPyAoaSAtIDEyKSAqIDMwIDogXCJcIiwgTyA9IGUgIT09IFwiXCIgJiYgZSA+IDEyID8gKGUgLSAxMikgKiAzMCA6IFwiXCI7XG4gICAgICBpZiAoIShJICYmIHQgPCBJIHx8IE8gJiYgdCA+IE8gfHwgZSAmJiBlIDwgMTIpKVxuICAgICAgICByZXR1cm4gITA7XG4gICAgfTtcbiAgICBpZiAoYSAmJiByLnR5cGUgIT09IFwia2V5ZG93blwiICYmIG0pXG4gICAgICByZXR1cm4gdygpO1xuICAgIGlmIChyLnR5cGUgPT09IFwia2V5ZG93blwiKVxuICAgICAgcmV0dXJuIEMoKTtcbiAgICBjb25zdCBFID0gIW8gfHwgbyA9PT0gXCJQTVwiICYmIGYgfHwgaSAhPT0gXCJcIiAmJiBvID09PSBcIkFNXCIgJiYgXywgVCA9ICFuIHx8IG4gPT09IFwiUE1cIiAmJiBmIHx8IGUgIT09IFwiXCIgJiYgbiA9PT0gXCJBTVwiICYmIF8sIEEgPSAoKSA9PiB7XG4gICAgICBjb25zdCBJID0gdiA9PT0gMzYwICYmIGwgPyAwIDogdjtcbiAgICAgIGlmIChpKSB7XG4gICAgICAgIGlmIChvID09PSBcIlBNXCIgJiYgXyB8fCBFICYmIHQgPCBJKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZVxuICAgICAgICByZXR1cm4gITA7XG4gICAgICByZXR1cm4gITA7XG4gICAgfSwgayA9ICgpID0+IHtcbiAgICAgIGNvbnN0IEkgPSBiID09PSAzNjAgJiYgbCA/IDAgOiBiO1xuICAgICAgaWYgKGUpIHtcbiAgICAgICAgaWYgKG4gPT09IFwiQU1cIiAmJiBmIHx8IFQgJiYgdCA+IEkpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlXG4gICAgICAgIHJldHVybiAhMDtcbiAgICAgIHJldHVybiAhMDtcbiAgICB9O1xuICAgIHJldHVybiBBKCkgJiYgaygpO1xuICB9XG4gIF9oYW5kbGVLZXlib2FyZCgpIHtcbiAgICBjLm9uKHRoaXMuX2RvY3VtZW50LCBfcywgXCJcIiwgKHQpID0+IHtcbiAgICAgIGxldCBlLCBpLCBuO1xuICAgICAgY29uc3Qge1xuICAgICAgICBpbmNyZW1lbnQ6IG8sXG4gICAgICAgIG1heFRpbWU6IHIsXG4gICAgICAgIG1pblRpbWU6IGEsXG4gICAgICAgIGZvcm1hdDEyOiBsLFxuICAgICAgICBkaXNhYmxlUGFzdDogcCxcbiAgICAgICAgZGlzYWJsZUZ1dHVyZTogdVxuICAgICAgfSA9IHRoaXMuX29wdGlvbnM7XG4gICAgICBsZXQgXyA9IFIoYSwgITEpWzBdLCBmID0gUihyLCAhMSlbMF07XG4gICAgICBjb25zdCBnID0gUihhLCAhMSlbMl0sIG0gPSBSKHIsICExKVsyXTtcbiAgICAgIF8gPSBYdChfLCBwLCBsKSwgZiA9IEd0KGYsIHUsIGwpLCB0eXBlb2YgZiAhPSBcIm51bWJlclwiICYmIChmID0gUihmLCAhMSlbMF0pO1xuICAgICAgY29uc3QgYiA9IGQuZmluZE9uZShgWyR7WH1dYCkgPT09IG51bGwsIHYgPSBkLmZpbmRPbmUoYFske2x0fV1gKSAhPT0gbnVsbCwgQyA9IE51bWJlcih0aGlzLl9oYW5kLnN0eWxlLnRyYW5zZm9ybS5yZXBsYWNlKC9bXlxcZC1dL2csIFwiXCIpKSwgdyA9IGQuZmluZChcbiAgICAgICAgYFske1h9XWAsXG4gICAgICAgIHRoaXMuX21vZGFsXG4gICAgICApLCBFID0gZC5maW5kKFxuICAgICAgICBgWyR7S31dYCxcbiAgICAgICAgdGhpcy5fbW9kYWxcbiAgICAgICksIFQgPSBkLmZpbmQoXG4gICAgICAgIGBbJHtsdH1dYCxcbiAgICAgICAgdGhpcy5fbW9kYWxcbiAgICAgICk7XG4gICAgICBsZXQgQSA9IHRoaXMuX21ha2VIb3VyRGVncmVlcyh0LnRhcmdldCwgQywgZSkuaG91cjtcbiAgICAgIGNvbnN0IHsgZGVncmVlczogaywgYWRkRGVncmVlczogSSB9ID0gdGhpcy5fbWFrZUhvdXJEZWdyZWVzKFxuICAgICAgICB0LnRhcmdldCxcbiAgICAgICAgQyxcbiAgICAgICAgZVxuICAgICAgKTtcbiAgICAgIGxldCB7IG1pbnV0ZTogTywgZGVncmVlczogeCB9ID0gdGhpcy5fbWFrZU1pbnV0ZXNEZWdyZWVzKEMsIGkpO1xuICAgICAgY29uc3QgTCA9IHRoaXMuX21ha2VNaW51dGVzRGVncmVlcyhcbiAgICAgICAgQyxcbiAgICAgICAgaVxuICAgICAgKS5hZGREZWdyZWVzO1xuICAgICAgbGV0IHsgaG91cjogUyB9ID0gdGhpcy5fbWFrZUlubmVySG91cnNEZWdyZWVzKFxuICAgICAgICBDLFxuICAgICAgICBuXG4gICAgICApO1xuICAgICAgaWYgKHQua2V5Q29kZSA9PT0gRmkpIHtcbiAgICAgICAgY29uc3QgTiA9IGQuZmluZE9uZShcbiAgICAgICAgICBgWyR7R259XWAsXG4gICAgICAgICAgdGhpcy5fbW9kYWxcbiAgICAgICAgKTtcbiAgICAgICAgYy50cmlnZ2VyKE4sIFwiY2xpY2tcIik7XG4gICAgICB9IGVsc2UgaWYgKGIpIHtcbiAgICAgICAgaWYgKHYgJiYgKHQua2V5Q29kZSA9PT0gVmUgJiYgKHRoaXMuX2lzSW5uZXIgPSAhMSwgaC5hZGRTdHlsZSh0aGlzLl9oYW5kLCB7XG4gICAgICAgICAgaGVpZ2h0OiBcImNhbGMoNDAlICsgMXB4KVwiXG4gICAgICAgIH0pLCB0aGlzLl9ob3VyLnRleHRDb250ZW50ID0gdGhpcy5fc2V0SG91ck9yTWludXRlKFxuICAgICAgICAgIEEgPiAxMiA/IDEgOiBBXG4gICAgICAgICksIHRoaXMuX3RvZ2dsZUNsYXNzQWN0aXZlKHRoaXMuaG91cnNBcnJheSwgdGhpcy5faG91ciwgRSksIHRoaXMuX3RvZ2dsZUNsYXNzQWN0aXZlKHRoaXMuaW5uZXJIb3VycywgdGhpcy5faG91ciwgVCkpLCB0LmtleUNvZGUgPT09IEhlICYmICh0aGlzLl9pc0lubmVyID0gITAsIGguYWRkU3R5bGUodGhpcy5faGFuZCwge1xuICAgICAgICAgIGhlaWdodDogXCIyMS41JVwiXG4gICAgICAgIH0pLCB0aGlzLl9ob3VyLnRleHRDb250ZW50ID0gdGhpcy5fc2V0SG91ck9yTWludXRlKFxuICAgICAgICAgIFMgPj0gMjQgfHwgUyA9PT0gXCIwMFwiID8gMCA6IFNcbiAgICAgICAgKSwgdGhpcy5fdG9nZ2xlQ2xhc3NBY3RpdmUodGhpcy5pbm5lckhvdXJzLCB0aGlzLl9ob3VyLCBUKSwgdGhpcy5fdG9nZ2xlQ2xhc3NBY3RpdmUoXG4gICAgICAgICAgdGhpcy5ob3Vyc0FycmF5LFxuICAgICAgICAgIHRoaXMuX2hvdXIgLSAxLFxuICAgICAgICAgIEVcbiAgICAgICAgKSkpLCB0LmtleUNvZGUgPT09IGF0KSB7XG4gICAgICAgICAgaWYgKCF0aGlzLl9oYW5kbGVyTWF4TWluSG91cnNPcHRpb25zKFxuICAgICAgICAgICAgayArIDMwLFxuICAgICAgICAgICAgZixcbiAgICAgICAgICAgIF8sXG4gICAgICAgICAgICBtLFxuICAgICAgICAgICAgZyxcbiAgICAgICAgICAgIHRcbiAgICAgICAgICApKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIGguYWRkU3R5bGUodGhpcy5faGFuZCwge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiBgcm90YXRlWigke2sgKyBJfWRlZylgXG4gICAgICAgICAgfSksIHRoaXMuX2lzSW5uZXIgPyAoUyArPSAxLCBTID09PSAyNCA/IFMgPSAwIDogKFMgPT09IDI1IHx8IFMgPT09IFwiMDAxXCIpICYmIChTID0gMTMpLCB0aGlzLl9ob3VyLnRleHRDb250ZW50ID0gdGhpcy5fc2V0SG91ck9yTWludXRlKFMpLCB0aGlzLl90b2dnbGVDbGFzc0FjdGl2ZSh0aGlzLmlubmVySG91cnMsIHRoaXMuX2hvdXIsIFQpKSA6IChBICs9IDEsIHRoaXMuX2hvdXIudGV4dENvbnRlbnQgPSB0aGlzLl9zZXRIb3VyT3JNaW51dGUoXG4gICAgICAgICAgICBBID4gMTIgPyAxIDogQVxuICAgICAgICAgICksIHRoaXMuX3RvZ2dsZUNsYXNzQWN0aXZlKHRoaXMuaG91cnNBcnJheSwgdGhpcy5faG91ciwgRSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0LmtleUNvZGUgPT09IHopIHtcbiAgICAgICAgICBpZiAoIXRoaXMuX2hhbmRsZXJNYXhNaW5Ib3Vyc09wdGlvbnMoXG4gICAgICAgICAgICBrIC0gMzAsXG4gICAgICAgICAgICBmLFxuICAgICAgICAgICAgXyxcbiAgICAgICAgICAgIG0sXG4gICAgICAgICAgICBnLFxuICAgICAgICAgICAgdFxuICAgICAgICAgICkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgaC5hZGRTdHlsZSh0aGlzLl9oYW5kLCB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06IGByb3RhdGVaKCR7ayAtIEl9ZGVnKWBcbiAgICAgICAgICB9KSwgdGhpcy5faXNJbm5lciA/IChTIC09IDEsIFMgPT09IDEyID8gUyA9IDAgOiBTID09PSAtMSAmJiAoUyA9IDIzKSwgdGhpcy5faG91ci50ZXh0Q29udGVudCA9IHRoaXMuX3NldEhvdXJPck1pbnV0ZShTKSwgdGhpcy5fdG9nZ2xlQ2xhc3NBY3RpdmUodGhpcy5pbm5lckhvdXJzLCB0aGlzLl9ob3VyLCBUKSkgOiAoQSAtPSAxLCB0aGlzLl9ob3VyLnRleHRDb250ZW50ID0gdGhpcy5fc2V0SG91ck9yTWludXRlKFxuICAgICAgICAgICAgQSA9PT0gMCA/IDEyIDogQVxuICAgICAgICAgICksIHRoaXMuX3RvZ2dsZUNsYXNzQWN0aXZlKHRoaXMuaG91cnNBcnJheSwgdGhpcy5faG91ciwgRSkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2VcbiAgICAgICAgdC5rZXlDb2RlID09PSBhdCAmJiAoeCArPSBMLCBoLmFkZFN0eWxlKHRoaXMuX2hhbmQsIHtcbiAgICAgICAgICB0cmFuc2Zvcm06IGByb3RhdGVaKCR7eH1kZWcpYFxuICAgICAgICB9KSwgTyArPSAxLCBvICYmIChPICs9IDQsIE8gPT09IFwiMDAxNFwiICYmIChPID0gNSkpLCB0aGlzLl9taW51dGVzLnRleHRDb250ZW50ID0gdGhpcy5fc2V0SG91ck9yTWludXRlKFxuICAgICAgICAgIE8gPiA1OSA/IDAgOiBPXG4gICAgICAgICksIHRoaXMuX3RvZ2dsZUNsYXNzQWN0aXZlKFxuICAgICAgICAgIHRoaXMubWludXRlc0FycmF5LFxuICAgICAgICAgIHRoaXMuX21pbnV0ZXMsXG4gICAgICAgICAgd1xuICAgICAgICApLCB0aGlzLl90b2dnbGVCYWNrZ3JvdW5kQ29sb3JDaXJjbGUoXG4gICAgICAgICAgYFske1h9XWBcbiAgICAgICAgKSksIHQua2V5Q29kZSA9PT0geiAmJiAoeCAtPSBMLCBoLmFkZFN0eWxlKHRoaXMuX2hhbmQsIHtcbiAgICAgICAgICB0cmFuc2Zvcm06IGByb3RhdGVaKCR7eH1kZWcpYFxuICAgICAgICB9KSwgbyA/IE8gLT0gNSA6IE8gLT0gMSwgTyA9PT0gLTEgPyBPID0gNTkgOiBPID09PSAtNSAmJiAoTyA9IDU1KSwgdGhpcy5fbWludXRlcy50ZXh0Q29udGVudCA9IHRoaXMuX3NldEhvdXJPck1pbnV0ZShPKSwgdGhpcy5fdG9nZ2xlQ2xhc3NBY3RpdmUoXG4gICAgICAgICAgdGhpcy5taW51dGVzQXJyYXksXG4gICAgICAgICAgdGhpcy5fbWludXRlcyxcbiAgICAgICAgICB3XG4gICAgICAgICksIHRoaXMuX3RvZ2dsZUJhY2tncm91bmRDb2xvckNpcmNsZShcbiAgICAgICAgICBgWyR7WH1dYFxuICAgICAgICApKTtcbiAgICB9KTtcbiAgfVxuICBfc2V0QWN0aXZlQ2xhc3NUb1RpcHNPbk9wZW4odCwgLi4uZSkge1xuICAgIGlmICghdGhpcy5faXNJbnZhbGlkVGltZUZvcm1hdClcbiAgICAgIGlmICh0aGlzLl9vcHRpb25zLmZvcm1hdDI0KSB7XG4gICAgICAgIGNvbnN0IGkgPSBkLmZpbmQoXG4gICAgICAgICAgYFske0t9XWAsXG4gICAgICAgICAgdGhpcy5fbW9kYWxcbiAgICAgICAgKSwgbiA9IGQuZmluZChcbiAgICAgICAgICBgWyR7bHR9XWAsXG4gICAgICAgICAgdGhpcy5fbW9kYWxcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5fYWRkQWN0aXZlQ2xhc3NUb1RpcChpLCB0KSwgdGhpcy5fYWRkQWN0aXZlQ2xhc3NUb1RpcChuLCB0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIFsuLi5lXS5maWx0ZXIoKG4pID0+IChuID09PSBcIlBNXCIgPyAoaC5hZGRDbGFzcyh0aGlzLl9QTSwgdGhpcy5fY2xhc3Nlcy5vcGFjaXR5KSwgdGhpcy5fUE0uc2V0QXR0cmlidXRlKEgsIFwiXCIpKSA6IG4gPT09IFwiQU1cIiA/IChoLmFkZENsYXNzKHRoaXMuX0FNLCB0aGlzLl9jbGFzc2VzLm9wYWNpdHkpLCB0aGlzLl9BTS5zZXRBdHRyaWJ1dGUoSCwgXCJcIikpIDogKGgucmVtb3ZlQ2xhc3ModGhpcy5fQU0sIHRoaXMuX2NsYXNzZXMub3BhY2l0eSksIGgucmVtb3ZlQ2xhc3ModGhpcy5fUE0sIHRoaXMuX2NsYXNzZXMub3BhY2l0eSksIHRoaXMuX0FNLnJlbW92ZUF0dHJpYnV0ZShIKSwgdGhpcy5fUE0ucmVtb3ZlQXR0cmlidXRlKEgpKSwgbikpO1xuICAgICAgICBjb25zdCBpID0gZC5maW5kKFxuICAgICAgICAgIGBbJHtLfV1gLFxuICAgICAgICAgIHRoaXMuX21vZGFsXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuX2FkZEFjdGl2ZUNsYXNzVG9UaXAoaSwgdCk7XG4gICAgICB9XG4gIH1cbiAgX3NldFRpcHNBbmRUaW1lc0RlcGVuZE9uSW5wdXRWYWx1ZSh0LCBlKSB7XG4gICAgY29uc3QgeyBpbmxpbmU6IGksIGZvcm1hdDEyOiBuIH0gPSB0aGlzLl9vcHRpb25zO1xuICAgIGlmICh0aGlzLl9pc0ludmFsaWRUaW1lRm9ybWF0KVxuICAgICAgdGhpcy5faG91ci50ZXh0Q29udGVudCA9IFwiMTJcIiwgdGhpcy5fbWludXRlcy50ZXh0Q29udGVudCA9IFwiMDBcIiwgaSB8fCBoLmFkZFN0eWxlKHRoaXMuX2hhbmQsIHtcbiAgICAgICAgdHJhbnNmb3JtOiBcInJvdGF0ZVooMGRlZylcIlxuICAgICAgfSksIG4gJiYgKGguYWRkQ2xhc3ModGhpcy5fUE0sIHRoaXMuX2NsYXNzZXMub3BhY2l0eSksIHRoaXMuX1BNLnNldEF0dHJpYnV0ZShILCBcIlwiKSk7XG4gICAgZWxzZSB7XG4gICAgICBjb25zdCBvID0gdCA+IDEyID8gdCAqIDMwIC0gMzYwIDogdCAqIDMwO1xuICAgICAgdGhpcy5faG91ci50ZXh0Q29udGVudCA9IHQsIHRoaXMuX21pbnV0ZXMudGV4dENvbnRlbnQgPSBlLCBpIHx8IChoLmFkZFN0eWxlKHRoaXMuX2hhbmQsIHtcbiAgICAgICAgdHJhbnNmb3JtOiBgcm90YXRlWigke299ZGVnKWBcbiAgICAgIH0pLCBoLmFkZFN0eWxlKHRoaXMuX2NpcmNsZSwge1xuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiIzE5NzZkMlwiXG4gICAgICB9KSwgKE51bWJlcih0KSA+IDEyIHx8IHQgPT09IFwiMDBcIikgJiYgaC5hZGRTdHlsZSh0aGlzLl9oYW5kLCB7XG4gICAgICAgIGhlaWdodDogXCIyMS41JVwiXG4gICAgICB9KSk7XG4gICAgfVxuICB9XG4gIF9saXN0ZW5Ub1RvZ2dsZUtleWRvd24oKSB7XG4gICAgYy5vbihcbiAgICAgIHRoaXMuX2VsZW1lbnQsXG4gICAgICBcImtleWRvd25cIixcbiAgICAgIGBbZGF0YS10ZS10b2dnbGU9JyR7dGhpcy50b2dnbGVFbGVtZW50fSddYCxcbiAgICAgICh0KSA9PiB7XG4gICAgICAgIHQua2V5Q29kZSA9PT0gY3QgJiYgKHQucHJldmVudERlZmF1bHQoKSwgYy50cmlnZ2VyKHRoaXMuZWxlbWVudFRvZ2dsZSwgXCJjbGlja1wiKSk7XG4gICAgICB9XG4gICAgKTtcbiAgfVxuICBfaGFuZGxlT3BlbigpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5fZ2V0Q29udGFpbmVyKCk7XG4gICAgcmUub24oXG4gICAgICB0aGlzLl9lbGVtZW50LFxuICAgICAgXCJjbGlja1wiLFxuICAgICAgYFtkYXRhLXRlLXRvZ2dsZT0nJHt0aGlzLnRvZ2dsZUVsZW1lbnR9J11gLFxuICAgICAgKGUpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuX29wdGlvbnMgPT09IG51bGwpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBpID0gaC5nZXREYXRhQXR0cmlidXRlKHRoaXMuaW5wdXQsIFwidG9nZ2xlXCIpICE9PSBudWxsID8gMjAwIDogMDtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgaC5hZGRTdHlsZSh0aGlzLmVsZW1lbnRUb2dnbGUsIHtcbiAgICAgICAgICAgIHBvaW50ZXJFdmVudHM6IFwibm9uZVwiXG4gICAgICAgICAgfSksIHRoaXMuZWxlbWVudFRvZ2dsZS5ibHVyKCk7XG4gICAgICAgICAgbGV0IG47XG4gICAgICAgICAgUih0aGlzLmlucHV0KVswXSA9PT0gXCJcIiA/IG4gPSBbXCIxMlwiLCBcIjAwXCIsIFwiUE1cIl0gOiBuID0gUih0aGlzLmlucHV0KTtcbiAgICAgICAgICBjb25zdCB7IG1vZGFsSUQ6IG8sIGlubGluZTogciwgZm9ybWF0MTI6IGEgfSA9IHRoaXMuX29wdGlvbnMsIFtsLCBwLCB1XSA9IG4sIF8gPSAkKFwiZGl2XCIpO1xuICAgICAgICAgIGlmICgoTnVtYmVyKGwpID4gMTIgfHwgbCA9PT0gXCIwMFwiKSAmJiAodGhpcy5faXNJbm5lciA9ICEwKSwgdGhpcy5pbnB1dC5ibHVyKCksIGUudGFyZ2V0LmJsdXIoKSwgXy5pbm5lckhUTUwgPSBNbSh0aGlzLl9vcHRpb25zLCB0aGlzLl9jbGFzc2VzKSwgaC5hZGRDbGFzcyhfLCB0aGlzLl9jbGFzc2VzLm1vZGFsKSwgXy5zZXRBdHRyaWJ1dGUoWmEsIFwiXCIpLCBfLnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJkaWFsb2dcIiksIF8uc2V0QXR0cmlidXRlKFwidGFiSW5kZXhcIiwgXCItMVwiKSwgXy5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBvKSwgciA/ICh0aGlzLl9wb3BwZXIgPSBDZSh0aGlzLmlucHV0LCBfLCB7XG4gICAgICAgICAgICBwbGFjZW1lbnQ6IFwiYm90dG9tLXN0YXJ0XCJcbiAgICAgICAgICB9KSwgdC5hcHBlbmRDaGlsZChfKSkgOiAodC5hcHBlbmRDaGlsZChfKSwgdGhpcy5fc2Nyb2xsQmFyLmhpZGUoKSksIHRoaXMuX2dldERvbUVsZW1lbnRzKCksIHRoaXMuX2FuaW1hdGlvbnMgPyB0aGlzLl90b2dnbGVCYWNrZHJvcEFuaW1hdGlvbigpIDogaC5hZGRDbGFzcyh0aGlzLl93cmFwcGVyLCB0aGlzLl9jbGFzc2VzLm9wYWNpdHkpLCB0aGlzLl9zZXRBY3RpdmVDbGFzc1RvVGlwc09uT3BlbihsLCBwLCB1KSwgdGhpcy5fYXBwZW5kVGltZXMoKSwgdGhpcy5fc2V0QWN0aXZlQ2xhc3NUb1RpcHNPbk9wZW4obCwgcCwgdSksIHRoaXMuX3NldFRpcHNBbmRUaW1lc0RlcGVuZE9uSW5wdXRWYWx1ZShsLCBwKSwgdGhpcy5pbnB1dC52YWx1ZSA9PT0gXCJcIikge1xuICAgICAgICAgICAgY29uc3QgZiA9IGQuZmluZChcbiAgICAgICAgICAgICAgYFske0t9XWAsXG4gICAgICAgICAgICAgIHRoaXMuX21vZGFsXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgYSAmJiAoaC5hZGRDbGFzcyh0aGlzLl9QTSwgdGhpcy5fY2xhc3Nlcy5vcGFjaXR5KSwgdGhpcy5fUE0uc2V0QXR0cmlidXRlKEgsIFwiXCIpKSwgdGhpcy5faG91ci50ZXh0Q29udGVudCA9IFwiMTJcIiwgdGhpcy5fbWludXRlcy50ZXh0Q29udGVudCA9IFwiMDBcIiwgdGhpcy5fYWRkQWN0aXZlQ2xhc3NUb1RpcChcbiAgICAgICAgICAgICAgZixcbiAgICAgICAgICAgICAgTnVtYmVyKHRoaXMuX2hvdXIudGV4dENvbnRlbnQpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGhpcy5faGFuZGxlU3dpdGNoVGltZU1vZGUoKSwgdGhpcy5faGFuZGxlT2tCdXR0b24oKSwgdGhpcy5faGFuZGxlQ2xvc2UoKSwgcilcbiAgICAgICAgICAgIHRoaXMuX2hhbmRsZUhvdmVySW5saW5lQnRuKCksIHRoaXMuX2hhbmRsZURvY3VtZW50Q2xpY2tJbmxpbmUoKSwgdGhpcy5faGFuZGxlSW5saW5lQ2xpY2tzKCk7XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9oYW5kbGVTd2l0Y2hIb3VyTWludXRlKCksIHRoaXMuX2hhbmRsZUNsb2NrQ2xpY2soKSwgdGhpcy5faGFuZGxlS2V5Ym9hcmQoKTtcbiAgICAgICAgICAgIGNvbnN0IGYgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFxuICAgICAgICAgICAgICBgJHtmc31bJHtIfV1gXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaC5hZGRDbGFzcyhmLCB0aGlzLl9jbGFzc2VzLm9wYWNpdHkpLCBoLmFkZFN0eWxlKHRoaXMuX2hvdXIsIHtcbiAgICAgICAgICAgICAgcG9pbnRlckV2ZW50czogXCJub25lXCJcbiAgICAgICAgICAgIH0pLCBoLmFkZFN0eWxlKHRoaXMuX21pbnV0ZXMsIHtcbiAgICAgICAgICAgICAgcG9pbnRlckV2ZW50czogXCJcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX2ZvY3VzVHJhcCA9IG5ldyBXaSh0aGlzLl93cmFwcGVyLCB7XG4gICAgICAgICAgICBldmVudDogXCJrZXlkb3duXCIsXG4gICAgICAgICAgICBjb25kaXRpb246ICh7IGtleTogZiB9KSA9PiBmID09PSBcIlRhYlwiXG4gICAgICAgICAgfSksIHRoaXMuX2ZvY3VzVHJhcC50cmFwKCk7XG4gICAgICAgIH0sIGkpO1xuICAgICAgfVxuICAgICk7XG4gIH1cbiAgX2hhbmRsZUlubGluZUNsaWNrcygpIHtcbiAgICBsZXQgdCwgZTtcbiAgICBjb25zdCBpID0gKGcpID0+IHtcbiAgICAgIGxldCBtID0gZztcbiAgICAgIHJldHVybiBtID4gNTkgPyBtID0gMCA6IG0gPCAwICYmIChtID0gNTkpLCBtO1xuICAgIH0sIG4gPSAoZykgPT4ge1xuICAgICAgbGV0IG0gPSBnO1xuICAgICAgcmV0dXJuIHRoaXMuX29wdGlvbnMuZm9ybWF0MjQgPyAobSA+IDI0ID8gbSA9IDEgOiBtIDwgMCAmJiAobSA9IDIzKSwgbSA+IDIzICYmIChtID0gMCkpIDogKG0gPiAxMiA/IG0gPSAxIDogbSA8IDEgJiYgKG0gPSAxMiksIG0gPiAxMiAmJiAobSA9IDEpKSwgbTtcbiAgICB9LCBvID0gKGcpID0+IHtcbiAgICAgIGNvbnN0IG0gPSBuKGcpO1xuICAgICAgdGhpcy5faG91ci50ZXh0Q29udGVudCA9IHRoaXMuX3NldEhvdXJPck1pbnV0ZShtKTtcbiAgICB9LCByID0gKGcpID0+IHtcbiAgICAgIGNvbnN0IG0gPSBpKGcpO1xuICAgICAgdGhpcy5fbWludXRlcy50ZXh0Q29udGVudCA9IHRoaXMuX3NldEhvdXJPck1pbnV0ZShtKTtcbiAgICB9LCBhID0gKCkgPT4ge1xuICAgICAgdCA9IG4odCkgKyAxLCBvKHQpO1xuICAgIH0sIGwgPSAoKSA9PiB7XG4gICAgICBlID0gaShlKSArIDEsIHIoZSk7XG4gICAgfSwgcCA9ICgpID0+IHtcbiAgICAgIHQgPSBuKHQpIC0gMSwgbyh0KTtcbiAgICB9LCB1ID0gKCkgPT4ge1xuICAgICAgZSA9IGkoZSkgLSAxLCByKGUpO1xuICAgIH0sIF8gPSAoKSA9PiB7XG4gICAgICBjbGVhckludGVydmFsKHRoaXMuX2ludGVydmFsKSwgY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVvdXRJbnRlcnZhbCk7XG4gICAgfSwgZiA9IChnKSA9PiB7XG4gICAgICBfKCksIHRoaXMuX3RpbWVvdXRJbnRlcnZhbCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aGlzLl9pbnRlcnZhbCA9IHNldEludGVydmFsKGcsIDEwMCk7XG4gICAgICB9LCA1MDApO1xuICAgIH07XG4gICAgcmUub24oXG4gICAgICB0aGlzLl9tb2RhbCxcbiAgICAgIFwiY2xpY2sgbW91c2Vkb3duIG1vdXNldXAgdG91Y2hzdGFydCB0b3VjaGVuZCBjb250ZXh0bWVudVwiLFxuICAgICAgYFske1pufV0sIFske1FufV1gLFxuICAgICAgKGcpID0+IHtcbiAgICAgICAgdCA9IE51bWJlcih0aGlzLl9ob3VyLnRleHRDb250ZW50KSwgZSA9IE51bWJlcih0aGlzLl9taW51dGVzLnRleHRDb250ZW50KTtcbiAgICAgICAgY29uc3QgeyB0YXJnZXQ6IG0sIHR5cGU6IGIgfSA9IGcsIHYgPSBiID09PSBcIm1vdXNlZG93blwiIHx8IGIgPT09IFwidG91Y2hzdGFydFwiO1xuICAgICAgICBtLmNsb3Nlc3QoYFske1pufV1gKSA/IG0uY2xvc2VzdChgWyR7Wm59XWApLnBhcmVudE5vZGUuaGFzQXR0cmlidXRlKFhhKSA/IHYgPyBmKGEpIDogYiA9PT0gXCJtb3VzZXVwXCIgfHwgYiA9PT0gXCJ0b3VjaGVuZFwiIHx8IGIgPT09IFwiY29udGV4dG1lbnVcIiA/IF8oKSA6IGEoKSA6IHYgPyBmKGwpIDogYiA9PT0gXCJtb3VzZXVwXCIgfHwgYiA9PT0gXCJ0b3VjaGVuZFwiIHx8IGIgPT09IFwiY29udGV4dG1lbnVcIiA/IF8oKSA6IGwoKSA6IG0uY2xvc2VzdChgWyR7UW59XWApICYmIChtLmNsb3Nlc3QoYFske1FufV1gKS5wYXJlbnROb2RlLmhhc0F0dHJpYnV0ZShYYSkgPyB2ID8gZihwKSA6IGIgPT09IFwibW91c2V1cFwiIHx8IGIgPT09IFwidG91Y2hlbmRcIiA/IF8oKSA6IHAoKSA6IHYgPyBmKHUpIDogYiA9PT0gXCJtb3VzZXVwXCIgfHwgYiA9PT0gXCJ0b3VjaGVuZFwiID8gXygpIDogdSgpKTtcbiAgICAgIH1cbiAgICApLCBjLm9uKHdpbmRvdywgX3MsIChnKSA9PiB7XG4gICAgICBjb25zdCBtID0gZy5jb2RlLCBiID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudC5oYXNBdHRyaWJ1dGUoZ3MpLCB2ID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudC5oYXNBdHRyaWJ1dGUoXG4gICAgICAgIGVvXG4gICAgICApLCBDID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA9PT0gZG9jdW1lbnQuYm9keTtcbiAgICAgIHN3aXRjaCAodCA9IE51bWJlcih0aGlzLl9ob3VyLnRleHRDb250ZW50KSwgZSA9IE51bWJlcih0aGlzLl9taW51dGVzLnRleHRDb250ZW50KSwgbSkge1xuICAgICAgICBjYXNlIFwiQXJyb3dVcFwiOlxuICAgICAgICAgIGcucHJldmVudERlZmF1bHQoKSwgQyB8fCBiID8gKHRoaXMuX2hvdXIuZm9jdXMoKSwgYSgpKSA6IHYgJiYgbCgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiQXJyb3dEb3duXCI6XG4gICAgICAgICAgZy5wcmV2ZW50RGVmYXVsdCgpLCBDIHx8IGIgPyAodGhpcy5faG91ci5mb2N1cygpLCBwKCkpIDogdiAmJiB1KCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgX2hhbmRsZUNsb3NlKCkge1xuICAgIGMub24oXG4gICAgICB0aGlzLl9tb2RhbCxcbiAgICAgIFwiY2xpY2tcIixcbiAgICAgIGBbJHt0b31dLCBbJHtHbn1dLCBbJHtVYX1dYCxcbiAgICAgICh7IHRhcmdldDogdCB9KSA9PiB7XG4gICAgICAgIGNvbnN0IHsgY2xvc2VNb2RhbE9uQmFja2Ryb3BDbGljazogZSB9ID0gdGhpcy5fb3B0aW9ucywgaSA9ICgpID0+IHtcbiAgICAgICAgICB2YXIgbjtcbiAgICAgICAgICBoLmFkZFN0eWxlKHRoaXMuZWxlbWVudFRvZ2dsZSwge1xuICAgICAgICAgICAgcG9pbnRlckV2ZW50czogXCJhdXRvXCJcbiAgICAgICAgICB9KSwgdGhpcy5fYW5pbWF0aW9ucyAmJiB0aGlzLl90b2dnbGVCYWNrZHJvcEFuaW1hdGlvbighMCksIHRoaXMuX3JlbW92ZU1vZGFsKCksIChuID0gdGhpcy5fZm9jdXNUcmFwKSA9PSBudWxsIHx8IG4uZGlzYWJsZSgpLCB0aGlzLl9mb2N1c1RyYXAgPSBudWxsLCB0aGlzLmVsZW1lbnRUb2dnbGUgPyB0aGlzLmVsZW1lbnRUb2dnbGUuZm9jdXMoKSA6IHRoaXMuaW5wdXQgJiYgdGhpcy5pbnB1dC5mb2N1cygpO1xuICAgICAgICB9O1xuICAgICAgICBpZiAodC5oYXNBdHRyaWJ1dGUoVWEpKSB7XG4gICAgICAgICAgdGhpcy5fdG9nZ2xlQW1QbShcIlBNXCIpLCB0aGlzLmlucHV0LnZhbHVlID0gXCJcIiwgdGhpcy5pbnB1dC5yZW1vdmVBdHRyaWJ1dGUoSCk7XG4gICAgICAgICAgbGV0IG47XG4gICAgICAgICAgUih0aGlzLmlucHV0KVswXSA9PT0gXCJcIiA/IG4gPSBbXCIxMlwiLCBcIjAwXCIsIFwiUE1cIl0gOiBuID0gUih0aGlzLmlucHV0KTtcbiAgICAgICAgICBjb25zdCBbbywgciwgYV0gPSBuO1xuICAgICAgICAgIHRoaXMuX3NldFRpcHNBbmRUaW1lc0RlcGVuZE9uSW5wdXRWYWx1ZShcIjEyXCIsIFwiMDBcIiksIHRoaXMuX3NldEFjdGl2ZUNsYXNzVG9UaXBzT25PcGVuKG8sIHIsIGEpLCB0aGlzLl9ob3VyLmNsaWNrKCk7XG4gICAgICAgIH0gZWxzZVxuICAgICAgICAgICh0Lmhhc0F0dHJpYnV0ZShHbikgfHwgdC5oYXNBdHRyaWJ1dGUocW4pIHx8IHQuaGFzQXR0cmlidXRlKHRvKSAmJiBlKSAmJiBpKCk7XG4gICAgICB9XG4gICAgKTtcbiAgfVxuICBzaG93VmFsdWVJbnB1dCgpIHtcbiAgICByZXR1cm4gdGhpcy5pbnB1dC52YWx1ZTtcbiAgfVxuICBfaGFuZGxlT2tCdXR0b24oKSB7XG4gICAgcmUub24oXG4gICAgICB0aGlzLl9tb2RhbCxcbiAgICAgIFwiY2xpY2tcIixcbiAgICAgIGBbJHtxbn1dYCxcbiAgICAgICgpID0+IHtcbiAgICAgICAgbGV0IHsgbWF4VGltZTogdCwgbWluVGltZTogZSB9ID0gdGhpcy5fb3B0aW9ucztcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGZvcm1hdDEyOiBpLFxuICAgICAgICAgIGZvcm1hdDI0OiBuLFxuICAgICAgICAgIHJlYWRPbmx5OiBvLFxuICAgICAgICAgIGZvY3VzSW5wdXRBZnRlckFwcHJvdmU6IHIsXG4gICAgICAgICAgZGlzYWJsZVBhc3Q6IGEsXG4gICAgICAgICAgZGlzYWJsZUZ1dHVyZTogbFxuICAgICAgICB9ID0gdGhpcy5fb3B0aW9ucywgcCA9IHRoaXMuX2RvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXG4gICAgICAgICAgYCR7bXN9WyR7SH1dYFxuICAgICAgICApLCB1ID0gYCR7dGhpcy5faG91ci50ZXh0Q29udGVudH06JHt0aGlzLl9taW51dGVzLnRleHRDb250ZW50fWAsIF8gPSBOdW1iZXIodGhpcy5faG91ci50ZXh0Q29udGVudCksIGYgPSBfID09PSAxMiAmJiBpID8gMCA6IF8sIGcgPSBOdW1iZXIodGhpcy5fbWludXRlcy50ZXh0Q29udGVudCk7XG4gICAgICAgIGUgPSBYdChlLCBhLCBpKSwgdCA9IEd0KHQsIGwsIGkpO1xuICAgICAgICBsZXQgW20sIGIsIHZdID0gUihcbiAgICAgICAgICB0LFxuICAgICAgICAgICExXG4gICAgICAgICksIFtDLCB3LCBFXSA9IFIoXG4gICAgICAgICAgZSxcbiAgICAgICAgICAhMVxuICAgICAgICApO1xuICAgICAgICBDID0gQyA9PT0gXCIxMlwiICYmIGkgPyBcIjAwXCIgOiBDLCBtID0gbSA9PT0gXCIxMlwiICYmIGkgPyBcIjAwXCIgOiBtO1xuICAgICAgICBjb25zdCBUID0gZiA8IE51bWJlcihDKSwgQSA9IGYgPiBOdW1iZXIobSk7XG4gICAgICAgIGxldCBrID0gITA7XG4gICAgICAgIHAgJiYgKGsgPSB2ID09PSBwLnRleHRDb250ZW50KTtcbiAgICAgICAgbGV0IEkgPSAhMDtcbiAgICAgICAgcCAmJiAoSSA9IEUgPT09IHAudGV4dENvbnRlbnQpO1xuICAgICAgICBjb25zdCBPID0gZyA+IGIgJiYgZiA9PT0gTnVtYmVyKG0pLCB4ID0gZyA8IHcgJiYgZiA9PT0gTnVtYmVyKEMpO1xuICAgICAgICBpZiAodGhpcy5pbnB1dC5zZXRBdHRyaWJ1dGUoSCwgXCJcIiksIGguYWRkU3R5bGUodGhpcy5lbGVtZW50VG9nZ2xlLCB7XG4gICAgICAgICAgcG9pbnRlckV2ZW50czogXCJhdXRvXCJcbiAgICAgICAgfSksIHQgIT09IFwiXCIpIHtcbiAgICAgICAgICBpZiAoayAmJiAoQSB8fCBPKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICBpZiAodiA9PT0gXCJBTVwiICYmIHAudGV4dENvbnRlbnQgPT09IFwiUE1cIilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBlICE9PSBcIlwiICYmIChJICYmIChUIHx8IHgpIHx8IEUgPT09IFwiUE1cIiAmJiBwLnRleHRDb250ZW50ID09PSBcIkFNXCIpIHx8IEJtKFxuICAgICAgICAgIHRoaXMuX29wdGlvbnMsXG4gICAgICAgICAgdGhpcy5pbnB1dCxcbiAgICAgICAgICB0aGlzLl9ob3VyLnRleHRDb250ZW50XG4gICAgICAgICkgIT09IHZvaWQgMCAmJiAodGhpcy5faXNJbnZhbGlkVGltZUZvcm1hdCAmJiB0aGlzLmlucHV0LnJlbW92ZUF0dHJpYnV0ZShKbiksICFvICYmIHIgJiYgdGhpcy5pbnB1dC5mb2N1cygpLCBoLmFkZFN0eWxlKHRoaXMuZWxlbWVudFRvZ2dsZSwge1xuICAgICAgICAgIHBvaW50ZXJFdmVudHM6IFwiYXV0b1wiXG4gICAgICAgIH0pLCBuID8gdGhpcy5pbnB1dC52YWx1ZSA9IHUgOiBwID09PSBudWxsID8gdGhpcy5pbnB1dC52YWx1ZSA9IGAke3V9IFBNYCA6IHRoaXMuaW5wdXQudmFsdWUgPSBgJHt1fSAke3AudGV4dENvbnRlbnR9YCwgdGhpcy5fYW5pbWF0aW9ucyAmJiB0aGlzLl90b2dnbGVCYWNrZHJvcEFuaW1hdGlvbighMCksIHRoaXMuX3JlbW92ZU1vZGFsKCksIGMudHJpZ2dlcih0aGlzLmlucHV0LCBcImlucHV0LnRlLnRpbWVwaWNrZXJcIiksIGMudHJpZ2dlcih0aGlzLmlucHV0LCBcImlucHV0XCIpKTtcbiAgICAgIH1cbiAgICApO1xuICB9XG4gIF9oYW5kbGVIb3ZlcklubGluZUJ0bigpIHtcbiAgICByZS5vbihcbiAgICAgIHRoaXMuX21vZGFsLFxuICAgICAgXCJtb3VzZW92ZXIgbW91c2VsZWF2ZVwiLFxuICAgICAgYFske0dtfV1gLFxuICAgICAgKHsgdHlwZTogdCwgdGFyZ2V0OiBlIH0pID0+IHtcbiAgICAgICAgY29uc3QgaSA9IGQuZmluZChcbiAgICAgICAgICBgWyR7VW19XWAsXG4gICAgICAgICAgdGhpcy5fbW9kYWxcbiAgICAgICAgKSwgbiA9IGQuZmluZChcbiAgICAgICAgICBgWyR7WG19XWAsXG4gICAgICAgICAgdGhpcy5fbW9kYWxcbiAgICAgICAgKSwgbyA9IChsLCBwKSA9PiBsLmZvckVhY2goKHUpID0+IHtcbiAgICAgICAgICBpZiAocCkge1xuICAgICAgICAgICAgaC5hZGRDbGFzcyh1LCB0aGlzLl9jbGFzc2VzLm9wYWNpdHkpLCB1LnNldEF0dHJpYnV0ZShILCBcIlwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaC5yZW1vdmVDbGFzcyh1LCB0aGlzLl9jbGFzc2VzLm9wYWNpdHkpLCB1LnJlbW92ZUF0dHJpYnV0ZShIKTtcbiAgICAgICAgfSksIGEgPSBlLmhhc0F0dHJpYnV0ZShncykgPyBpIDogbjtcbiAgICAgICAgbyhhLCB0ID09PSBcIm1vdXNlb3ZlclwiKTtcbiAgICAgIH1cbiAgICApO1xuICB9XG4gIF9oYW5kbGVEb2N1bWVudENsaWNrSW5saW5lKCkge1xuICAgIGMub24oZG9jdW1lbnQsIEJhLCAoeyB0YXJnZXQ6IHQgfSkgPT4ge1xuICAgICAgaWYgKHRoaXMuX21vZGFsICYmICF0aGlzLl9tb2RhbC5jb250YWlucyh0KSAmJiAhdC5oYXNBdHRyaWJ1dGUoem0pKSB7XG4gICAgICAgIGlmIChjbGVhckludGVydmFsKHRoaXMuX2ludGVydmFsKSwgaC5hZGRTdHlsZSh0aGlzLmVsZW1lbnRUb2dnbGUsIHtcbiAgICAgICAgICBwb2ludGVyRXZlbnRzOiBcImF1dG9cIlxuICAgICAgICB9KSwgdGhpcy5fcmVtb3ZlTW9kYWwoKSwgIXRoaXMuX2FuaW1hdGlvbnMpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLl90b2dnbGVCYWNrZHJvcEFuaW1hdGlvbighMCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgX2hhbmRsZVN3aXRjaEhvdXJNaW51dGUoKSB7XG4gICAgUG0oXG4gICAgICBcImNsaWNrXCIsXG4gICAgICBmcyxcbiAgICAgIHRoaXMuX2NsYXNzZXNcbiAgICApLCBjLm9uKFxuICAgICAgdGhpcy5fbW9kYWwsXG4gICAgICBcImNsaWNrXCIsXG4gICAgICBmcyxcbiAgICAgICgpID0+IHtcbiAgICAgICAgY29uc3QgeyBmb3JtYXQyNDogdCB9ID0gdGhpcy5fb3B0aW9ucywgZSA9IGQuZmluZChcbiAgICAgICAgICBmcyxcbiAgICAgICAgICB0aGlzLl9tb2RhbFxuICAgICAgICApLCBpID0gZC5maW5kKFxuICAgICAgICAgIGBbJHtYfV1gLFxuICAgICAgICAgIHRoaXMuX21vZGFsXG4gICAgICAgICksIG4gPSBkLmZpbmQoXG4gICAgICAgICAgYFske0t9XWAsXG4gICAgICAgICAgdGhpcy5fbW9kYWxcbiAgICAgICAgKSwgbyA9IGQuZmluZChcbiAgICAgICAgICBgWyR7bHR9XWAsXG4gICAgICAgICAgdGhpcy5fbW9kYWxcbiAgICAgICAgKSwgciA9IE51bWJlcih0aGlzLl9ob3VyLnRleHRDb250ZW50KSwgYSA9IE51bWJlcih0aGlzLl9taW51dGVzLnRleHRDb250ZW50KSwgbCA9IChwLCB1KSA9PiB7XG4gICAgICAgICAgbi5mb3JFYWNoKChmKSA9PiBmLnJlbW92ZSgpKSwgaS5mb3JFYWNoKChmKSA9PiBmLnJlbW92ZSgpKSwgaC5hZGRDbGFzcyh0aGlzLl9oYW5kLCB0aGlzLl9jbGFzc2VzLnRyYW5zZm9ybSksIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgaC5yZW1vdmVDbGFzcyh0aGlzLl9oYW5kLCB0aGlzLl9jbGFzc2VzLnRyYW5zZm9ybSk7XG4gICAgICAgICAgfSwgNDAxKSwgdGhpcy5fZ2V0QXBwZW5kQ2xvY2socCwgYFske3BlfV1gLCB1KTtcbiAgICAgICAgICBjb25zdCBfID0gKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZiA9IGQuZmluZChcbiAgICAgICAgICAgICAgYFske0t9XWAsXG4gICAgICAgICAgICAgIHRoaXMuX21vZGFsXG4gICAgICAgICAgICApLCBnID0gZC5maW5kKFxuICAgICAgICAgICAgICBgWyR7WH1dYCxcbiAgICAgICAgICAgICAgdGhpcy5fbW9kYWxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB0aGlzLl9hZGRBY3RpdmVDbGFzc1RvVGlwKGYsIHIpLCB0aGlzLl9hZGRBY3RpdmVDbGFzc1RvVGlwKGcsIGEpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgaWYgKCF0KVxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgIF8oKTtcbiAgICAgICAgICAgIH0sIDQwMSk7XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBmID0gZC5maW5kKFxuICAgICAgICAgICAgICBgWyR7bHR9XWAsXG4gICAgICAgICAgICAgIHRoaXMuX21vZGFsXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgIHRoaXMuX2FkZEFjdGl2ZUNsYXNzVG9UaXAoZiwgciksIF8oKTtcbiAgICAgICAgICAgIH0sIDQwMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBlLmZvckVhY2goKHApID0+IHtcbiAgICAgICAgICBwLmhhc0F0dHJpYnV0ZShIKSAmJiAocC5oYXNBdHRyaWJ1dGUoZW8pID8gKGguYWRkQ2xhc3ModGhpcy5faGFuZCwgdGhpcy5fY2xhc3Nlcy50cmFuc2Zvcm0pLCBoLmFkZFN0eWxlKHRoaXMuX2hhbmQsIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogYHJvdGF0ZVooJHt0aGlzLl9taW51dGVzLnRleHRDb250ZW50ICogNn1kZWcpYCxcbiAgICAgICAgICAgIGhlaWdodDogXCJjYWxjKDQwJSArIDFweClcIlxuICAgICAgICAgIH0pLCB0ICYmIG8ubGVuZ3RoID4gMCAmJiBvLmZvckVhY2goKHUpID0+IHUucmVtb3ZlKCkpLCBsKFxuICAgICAgICAgICAgdGhpcy5taW51dGVzQXJyYXksXG4gICAgICAgICAgICBYXG4gICAgICAgICAgKSwgdGhpcy5faG91ci5zdHlsZS5wb2ludGVyRXZlbnRzID0gXCJcIiwgdGhpcy5fbWludXRlcy5zdHlsZS5wb2ludGVyRXZlbnRzID0gXCJub25lXCIpIDogcC5oYXNBdHRyaWJ1dGUoZ3MpICYmIChoLmFkZFN0eWxlKHRoaXMuX2hhbmQsIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogYHJvdGF0ZVooJHt0aGlzLl9ob3VyLnRleHRDb250ZW50ICogMzB9ZGVnKWBcbiAgICAgICAgICB9KSwgTnVtYmVyKHRoaXMuX2hvdXIudGV4dENvbnRlbnQpID4gMTIgPyAoaC5hZGRTdHlsZSh0aGlzLl9oYW5kLCB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06IGByb3RhdGVaKCR7dGhpcy5faG91ci50ZXh0Q29udGVudCAqIDMwIC0gMzYwfWRlZylgLFxuICAgICAgICAgICAgaGVpZ2h0OiBcIjIxLjUlXCJcbiAgICAgICAgICB9KSwgTnVtYmVyKHRoaXMuX2hvdXIudGV4dENvbnRlbnQpID4gMTIgJiYgaC5hZGRTdHlsZSh0aGlzLl9oYW5kLCB7XG4gICAgICAgICAgICBoZWlnaHQ6IFwiMjEuNSVcIlxuICAgICAgICAgIH0pKSA6IGguYWRkU3R5bGUodGhpcy5faGFuZCwge1xuICAgICAgICAgICAgaGVpZ2h0OiBcImNhbGMoNDAlICsgMXB4KVwiXG4gICAgICAgICAgfSksIHQgJiYgdGhpcy5fZ2V0QXBwZW5kQ2xvY2soXG4gICAgICAgICAgICB0aGlzLmlubmVySG91cnMsXG4gICAgICAgICAgICBgWyR7ZGl9XWAsXG4gICAgICAgICAgICBsdFxuICAgICAgICAgICksIG8ubGVuZ3RoID4gMCAmJiBvLmZvckVhY2goKHUpID0+IHUucmVtb3ZlKCkpLCBsKFxuICAgICAgICAgICAgdGhpcy5ob3Vyc0FycmF5LFxuICAgICAgICAgICAgS1xuICAgICAgICAgICksIGguYWRkU3R5bGUodGhpcy5faG91ciwge1xuICAgICAgICAgICAgcG9pbnRlckV2ZW50czogXCJub25lXCJcbiAgICAgICAgICB9KSwgaC5hZGRTdHlsZSh0aGlzLl9taW51dGVzLCB7XG4gICAgICAgICAgICBwb2ludGVyRXZlbnRzOiBcIlwiXG4gICAgICAgICAgfSkpKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgKTtcbiAgfVxuICBfaGFuZGxlRGlzYWJsaW5nVGlwc01heFRpbWUodCwgZSwgaSwgbikge1xuICAgIGlmICghdGhpcy5fb3B0aW9ucy5tYXhUaW1lICYmICF0aGlzLl9vcHRpb25zLmRpc2FibGVGdXR1cmUpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgbyA9IGQuZmluZChcbiAgICAgIGBbJHtLfV1gXG4gICAgKSwgciA9IGQuZmluZChcbiAgICAgIGBbJHtsdH1dYFxuICAgICksIGEgPSBkLmZpbmQoXG4gICAgICBgWyR7WH1dYFxuICAgICk7XG4gICAgaWYgKCFlIHx8IGUgPT09IHQpIHtcbiAgICAgIE1hKFxuICAgICAgICByLFxuICAgICAgICBuLFxuICAgICAgICB0aGlzLl9jbGFzc2VzLFxuICAgICAgICB0aGlzLl9vcHRpb25zLmZvcm1hdDEyXG4gICAgICApLCBNYShcbiAgICAgICAgbyxcbiAgICAgICAgbixcbiAgICAgICAgdGhpcy5fY2xhc3NlcyxcbiAgICAgICAgdGhpcy5fb3B0aW9ucy5mb3JtYXQxMlxuICAgICAgKSwgSG0oXG4gICAgICAgIGEsXG4gICAgICAgIGksXG4gICAgICAgIG4sXG4gICAgICAgIHRoaXMuX2hvdXIudGV4dENvbnRlbnQsXG4gICAgICAgIHRoaXMuX2NsYXNzZXMsXG4gICAgICAgIHRoaXMuX29wdGlvbnMuZm9ybWF0MTJcbiAgICAgICk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGUgPT09IFwiQU1cIiAmJiB0ID09PSBcIlBNXCIgJiYgKG8uZm9yRWFjaCgobCkgPT4ge1xuICAgICAgaC5hZGRDbGFzcyhsLCB0aGlzLl9jbGFzc2VzLnRpcHNEaXNhYmxlZCksIGwuc2V0QXR0cmlidXRlKFl0LCBcIlwiKTtcbiAgICB9KSwgYS5mb3JFYWNoKChsKSA9PiB7XG4gICAgICBoLmFkZENsYXNzKGwsIHRoaXMuX2NsYXNzZXMudGlwc0Rpc2FibGVkKSwgbC5zZXRBdHRyaWJ1dGUoWXQsIFwiXCIpO1xuICAgIH0pKTtcbiAgfVxuICBfaGFuZGxlRGlzYWJsaW5nVGlwc01pblRpbWUodCwgZSwgaSwgbikge1xuICAgIGlmICghdGhpcy5fb3B0aW9ucy5taW5UaW1lICYmICF0aGlzLl9vcHRpb25zLmRpc2FibGVQYXN0KVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IG8gPSBkLmZpbmQoXG4gICAgICBgWyR7S31dYFxuICAgICksIHIgPSBkLmZpbmQoXG4gICAgICBgWyR7bHR9XWBcbiAgICApLCBhID0gZC5maW5kKFxuICAgICAgYFske1h9XWBcbiAgICApO1xuICAgICFlIHx8IGUgPT09IHQgPyAoUmEoXG4gICAgICBvLFxuICAgICAgbixcbiAgICAgIHRoaXMuX2NsYXNzZXMsXG4gICAgICB0aGlzLl9vcHRpb25zLmZvcm1hdDEyXG4gICAgKSwgUmEoXG4gICAgICByLFxuICAgICAgbixcbiAgICAgIHRoaXMuX2NsYXNzZXMsXG4gICAgICB0aGlzLl9vcHRpb25zLmZvcm1hdDEyXG4gICAgKSwgVm0oXG4gICAgICBhLFxuICAgICAgaSxcbiAgICAgIG4sXG4gICAgICB0aGlzLl9ob3VyLnRleHRDb250ZW50LFxuICAgICAgdGhpcy5fY2xhc3NlcyxcbiAgICAgIHRoaXMuX29wdGlvbnMuZm9ybWF0MTJcbiAgICApKSA6IGUgPT09IFwiUE1cIiAmJiB0ID09PSBcIkFNXCIgJiYgKG8uZm9yRWFjaCgobCkgPT4ge1xuICAgICAgaC5hZGRDbGFzcyhsLCB0aGlzLl9jbGFzc2VzLnRpcHNEaXNhYmxlZCksIGwuc2V0QXR0cmlidXRlKFl0LCBcIlwiKTtcbiAgICB9KSwgYS5mb3JFYWNoKChsKSA9PiB7XG4gICAgICBoLmFkZENsYXNzKGwsIHRoaXMuX2NsYXNzZXMudGlwc0Rpc2FibGVkKSwgbC5zZXRBdHRyaWJ1dGUoWXQsIFwiXCIpO1xuICAgIH0pKTtcbiAgfVxuICBfaGFuZGxlU3dpdGNoVGltZU1vZGUoKSB7XG4gICAgYy5vbihcbiAgICAgIGRvY3VtZW50LFxuICAgICAgXCJjbGlja1wiLFxuICAgICAgbXMsXG4gICAgICAoeyB0YXJnZXQ6IHQgfSkgPT4ge1xuICAgICAgICBsZXQgeyBtYXhUaW1lOiBlLCBtaW5UaW1lOiBpIH0gPSB0aGlzLl9vcHRpb25zO1xuICAgICAgICBjb25zdCB7IGRpc2FibGVQYXN0OiBuLCBkaXNhYmxlRnV0dXJlOiBvLCBmb3JtYXQxMjogciB9ID0gdGhpcy5fb3B0aW9ucztcbiAgICAgICAgaSA9IFh0KGksIG4sIHIpLCBlID0gR3QoZSwgbywgcik7XG4gICAgICAgIGNvbnN0IFthLCBsLCBwXSA9IFIoXG4gICAgICAgICAgZSxcbiAgICAgICAgICAhMVxuICAgICAgICApLCBbdSwgXywgZl0gPSBSKFxuICAgICAgICAgIGksXG4gICAgICAgICAgITFcbiAgICAgICAgKSwgZyA9IGQuZmluZChcbiAgICAgICAgICBgWyR7S31dYFxuICAgICAgICApLCBtID0gZC5maW5kKFxuICAgICAgICAgIGBbJHtYfV1gXG4gICAgICAgICk7XG4gICAgICAgICgoKSA9PiB7XG4gICAgICAgICAgZy5mb3JFYWNoKCh2KSA9PiB7XG4gICAgICAgICAgICBoLnJlbW92ZUNsYXNzKHYsIHRoaXMuX2NsYXNzZXMudGlwc0Rpc2FibGVkKSwgdi5yZW1vdmVBdHRyaWJ1dGUoWXQpO1xuICAgICAgICAgIH0pLCBtLmZvckVhY2goKHYpID0+IHtcbiAgICAgICAgICAgIGgucmVtb3ZlQ2xhc3ModiwgdGhpcy5fY2xhc3Nlcy50aXBzRGlzYWJsZWQpLCB2LnJlbW92ZUF0dHJpYnV0ZShZdCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pKCksIHRoaXMuX2hhbmRsZURpc2FibGluZ1RpcHNNaW5UaW1lKFxuICAgICAgICAgIHQudGV4dENvbnRlbnQsXG4gICAgICAgICAgZixcbiAgICAgICAgICBfLFxuICAgICAgICAgIHVcbiAgICAgICAgKSwgdGhpcy5faGFuZGxlRGlzYWJsaW5nVGlwc01heFRpbWUoXG4gICAgICAgICAgdC50ZXh0Q29udGVudCxcbiAgICAgICAgICBwLFxuICAgICAgICAgIGwsXG4gICAgICAgICAgYVxuICAgICAgICApLCB0aGlzLl90b2dnbGVBbVBtKHQudGV4dENvbnRlbnQpLCB0Lmhhc0F0dHJpYnV0ZShIKSB8fCAoZC5maW5kKFxuICAgICAgICAgIG1zXG4gICAgICAgICkuZm9yRWFjaCgoQykgPT4ge1xuICAgICAgICAgIEMuaGFzQXR0cmlidXRlKEgpICYmIChoLnJlbW92ZUNsYXNzKEMsIHRoaXMuX2NsYXNzZXMub3BhY2l0eSksIEMucmVtb3ZlQXR0cmlidXRlKEgpKTtcbiAgICAgICAgfSksIGguYWRkQ2xhc3ModCwgdGhpcy5fY2xhc3Nlcy5vcGFjaXR5KSwgdC5zZXRBdHRyaWJ1dGUoSCwgXCJcIikpO1xuICAgICAgfVxuICAgICk7XG4gIH1cbiAgX2hhbmRsZUNsb2NrQ2xpY2soKSB7XG4gICAgbGV0IHsgbWF4VGltZTogdCwgbWluVGltZTogZSB9ID0gdGhpcy5fb3B0aW9ucztcbiAgICBjb25zdCB7IGRpc2FibGVQYXN0OiBpLCBkaXNhYmxlRnV0dXJlOiBuLCBmb3JtYXQxMjogbyB9ID0gdGhpcy5fb3B0aW9ucztcbiAgICBlID0gWHQoZSwgaSwgbyksIHQgPSBHdCh0LCBuLCBvKTtcbiAgICBjb25zdCByID0gUih0LCAhMSlbMl0sIGEgPSBSKGUsICExKVsyXSwgbCA9IFIodCwgITEpWzBdLCBwID0gUihlLCAhMSlbMF0sIHUgPSBkLmZpbmRPbmUoXG4gICAgICBgWyR7R2F9XWBcbiAgICApO1xuICAgIHJlLm9uKFxuICAgICAgZG9jdW1lbnQsXG4gICAgICBgJHtIYX0gJHtWYX0gJHtXYX0gJHtGYX0gJHtZYX0gJHt6YX0gJHtqYX0gJHtLYX1gLFxuICAgICAgXCJcIixcbiAgICAgIChfKSA9PiB7XG4gICAgICAgIHBzKCkgfHwgXy5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBjb25zdCB7IHR5cGU6IGYsIHRhcmdldDogZyB9ID0gXywgeyBjbG9zZU1vZGFsT25NaW51dGVzQ2xpY2s6IG0sIHN3aXRjaEhvdXJzVG9NaW51dGVzT25DbGljazogYiB9ID0gdGhpcy5fb3B0aW9ucywgdiA9IGQuZmluZE9uZShcbiAgICAgICAgICBgWyR7WH1dYCxcbiAgICAgICAgICB0aGlzLl9tb2RhbFxuICAgICAgICApICE9PSBudWxsLCBDID0gZC5maW5kT25lKFxuICAgICAgICAgIGBbJHtLfV1gLFxuICAgICAgICAgIHRoaXMuX21vZGFsXG4gICAgICAgICkgIT09IG51bGwsIHcgPSBkLmZpbmRPbmUoXG4gICAgICAgICAgYFske2x0fV1gLFxuICAgICAgICAgIHRoaXMuX21vZGFsXG4gICAgICAgICkgIT09IG51bGwsIEUgPSBkLmZpbmQoXG4gICAgICAgICAgYFske1h9XWAsXG4gICAgICAgICAgdGhpcy5fbW9kYWxcbiAgICAgICAgKSwgVCA9IE5hKF8sIHUpLCBBID0gdS5vZmZzZXRXaWR0aCAvIDI7XG4gICAgICAgIGxldCBrID0gTWF0aC5hdGFuMihULnkgLSBBLCBULnggLSBBKTtcbiAgICAgICAgaWYgKHBzKCkpIHtcbiAgICAgICAgICBjb25zdCBMID0gTmEoXywgdSwgITApO1xuICAgICAgICAgIGsgPSBNYXRoLmF0YW4yKEwueSAtIEEsIEwueCAtIEEpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBJID0gbnVsbCwgTyA9IG51bGwsIHggPSBudWxsO1xuICAgICAgICBpZiAoZiA9PT0gXCJtb3VzZWRvd25cIiB8fCBmID09PSBcIm1vdXNlbW92ZVwiIHx8IGYgPT09IFwidG91Y2htb3ZlXCIgfHwgZiA9PT0gXCJ0b3VjaHN0YXJ0XCIpXG4gICAgICAgICAgKGYgPT09IFwibW91c2Vkb3duXCIgfHwgZiA9PT0gXCJ0b3VjaHN0YXJ0XCIgfHwgZiA9PT0gXCJ0b3VjaG1vdmVcIikgJiYgKHRoaXMuX2hhc1RhcmdldElubmVyQ2xhc3MoZykgfHwgZy5oYXNBdHRyaWJ1dGUoR2EpIHx8IGcuaGFzQXR0cmlidXRlKHBlKSB8fCBnLmhhc0F0dHJpYnV0ZShYKSB8fCBnLmhhc0F0dHJpYnV0ZShLKSB8fCBnLmhhc0F0dHJpYnV0ZShzbykgfHwgZy5oYXNBdHRyaWJ1dGUoaW8pIHx8IGcuaGFzQXR0cmlidXRlKHFhKSB8fCBnLmhhc0F0dHJpYnV0ZShicykpICYmICh0aGlzLl9pc01vdXNlTW92ZSA9ICEwLCBwcygpICYmIF8udG91Y2hlcyAmJiAoSSA9IF8udG91Y2hlc1swXS5jbGllbnRYLCBPID0gXy50b3VjaGVzWzBdLmNsaWVudFksIHggPSBkb2N1bWVudC5lbGVtZW50RnJvbVBvaW50KEksIE8pKSk7XG4gICAgICAgIGVsc2UgaWYgKGYgPT09IFwibW91c2V1cFwiIHx8IGYgPT09IFwidG91Y2hlbmRcIikge1xuICAgICAgICAgIGlmICh0aGlzLl9pc01vdXNlTW92ZSA9ICExLCB0aGlzLl9oYXNUYXJnZXRJbm5lckNsYXNzKGcpIHx8IGcuaGFzQXR0cmlidXRlKHBlKSB8fCBnLmhhc0F0dHJpYnV0ZShLKSB8fCBnLmhhc0F0dHJpYnV0ZShzbykgfHwgZy5oYXNBdHRyaWJ1dGUoaW8pIHx8IGcuaGFzQXR0cmlidXRlKHFhKSB8fCBnLmhhc0F0dHJpYnV0ZShicykpIHtcbiAgICAgICAgICAgIGlmICgoQyB8fCB3KSAmJiBiKSB7XG4gICAgICAgICAgICAgIGNvbnN0IEwgPSBOdW1iZXIodGhpcy5faG91ci50ZXh0Q29udGVudCkgPiBsIHx8IE51bWJlcih0aGlzLl9ob3VyLnRleHRDb250ZW50KSA8IHA7XG4gICAgICAgICAgICAgIGlmICh0aGlzLl9vcHRpb25zLmZvcm1hdDI0ICYmIGwgIT09IFwiXCIgJiYgcCAhPT0gXCJcIiAmJiBMKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgaWYgKHRoaXMuX29wdGlvbnMuZm9ybWF0MjQgJiYgcCAhPT0gXCJcIiAmJiBOdW1iZXIodGhpcy5faG91ci50ZXh0Q29udGVudCkgPCBwKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGMudHJpZ2dlcih0aGlzLl9taW51dGVzLCBcImNsaWNrXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodiAmJiBtKSB7XG4gICAgICAgICAgICBjb25zdCBMID0gZC5maW5kT25lKFxuICAgICAgICAgICAgICBgWyR7cW59XWAsXG4gICAgICAgICAgICAgIHRoaXMuX21vZGFsXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgYy50cmlnZ2VyKEwsIFwiY2xpY2tcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh2KSB7XG4gICAgICAgICAgbGV0IEw7XG4gICAgICAgICAgY29uc3QgUyA9IE1hdGgudHJ1bmMoayAqIDE4MCAvIE1hdGguUEkpICsgOTAsIHsgZGVncmVlczogTiwgbWludXRlOiBQIH0gPSB0aGlzLl9tYWtlTWludXRlc0RlZ3JlZXMoUywgTCk7XG4gICAgICAgICAgaWYgKHRoaXMuX2hhbmRsZXJNYXhNaW5NaW51dGVzT3B0aW9ucyhOLCBQKSA9PT0gdm9pZCAwKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIGNvbnN0IHsgZGVncmVlczogdHQsIG1pbnV0ZTogZXQgfSA9IHRoaXMuX2hhbmRsZXJNYXhNaW5NaW51dGVzT3B0aW9ucyhOLCBQKTtcbiAgICAgICAgICBpZiAodGhpcy5faXNNb3VzZU1vdmUpIHtcbiAgICAgICAgICAgIGlmIChoLmFkZFN0eWxlKHRoaXMuX2hhbmQsIHtcbiAgICAgICAgICAgICAgdHJhbnNmb3JtOiBgcm90YXRlWigke3R0fWRlZylgXG4gICAgICAgICAgICB9KSwgZXQgPT09IHZvaWQgMClcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY29uc3QgVSA9ICgpID0+IGV0ID49IDEwIHx8IGV0ID09PSBcIjAwXCIgPyBldCA6IGAwJHtldH1gO1xuICAgICAgICAgICAgdGhpcy5fbWludXRlcy50ZXh0Q29udGVudCA9IFUoKSwgdGhpcy5fdG9nZ2xlQ2xhc3NBY3RpdmUoXG4gICAgICAgICAgICAgIHRoaXMubWludXRlc0FycmF5LFxuICAgICAgICAgICAgICB0aGlzLl9taW51dGVzLFxuICAgICAgICAgICAgICBFXG4gICAgICAgICAgICApLCB0aGlzLl90b2dnbGVCYWNrZ3JvdW5kQ29sb3JDaXJjbGUoXG4gICAgICAgICAgICAgIGBbJHtYfV1gXG4gICAgICAgICAgICApLCB0aGlzLl9vYmpXaXRoRGF0YU9uQ2hhbmdlLmRlZ3JlZXNNaW51dGVzID0gdHQsIHRoaXMuX29ialdpdGhEYXRhT25DaGFuZ2UubWludXRlcyA9IGV0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoQyB8fCB3KSB7XG4gICAgICAgICAgbGV0IEwsIFMgPSBNYXRoLnRydW5jKGsgKiAxODAgLyBNYXRoLlBJKSArIDkwO1xuICAgICAgICAgIGlmIChTID0gTWF0aC5yb3VuZChTIC8gMzApICogMzAsIGguYWRkU3R5bGUodGhpcy5fY2lyY2xlLCB7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiIzE5NzZkMlwiXG4gICAgICAgICAgfSksIHRoaXMuX21ha2VIb3VyRGVncmVlcyhnLCBTLCBMKSA9PT0gdm9pZCAwKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIGNvbnN0IE4gPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAocHMoKSAmJiBTICYmIHgpIHtcbiAgICAgICAgICAgICAgY29uc3QgeyBkZWdyZWVzOiBQLCBob3VyOiB0dCB9ID0gdGhpcy5fbWFrZUhvdXJEZWdyZWVzKHgsIFMsIEwpO1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5faGFuZGxlTW92ZUhhbmQoXG4gICAgICAgICAgICAgICAgeCxcbiAgICAgICAgICAgICAgICB0dCxcbiAgICAgICAgICAgICAgICBQXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjb25zdCB7IGRlZ3JlZXM6IFAsIGhvdXI6IHR0IH0gPSB0aGlzLl9tYWtlSG91ckRlZ3JlZXMoZywgUywgTCk7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLl9oYW5kbGVNb3ZlSGFuZChnLCB0dCwgUCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgICB0aGlzLl9vYmpXaXRoRGF0YU9uQ2hhbmdlLmRlZ3JlZXNIb3VycyA9IFMsIHRoaXMuX2hhbmRsZXJNYXhNaW5Ib3Vyc09wdGlvbnMoXG4gICAgICAgICAgICBTLFxuICAgICAgICAgICAgbCxcbiAgICAgICAgICAgIHAsXG4gICAgICAgICAgICByLFxuICAgICAgICAgICAgYSxcbiAgICAgICAgICAgIF9cbiAgICAgICAgICApICYmIE4oKTtcbiAgICAgICAgfVxuICAgICAgICBfLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgfVxuICAgICk7XG4gIH1cbiAgX2hhc1RhcmdldElubmVyQ2xhc3ModCkge1xuICAgIHJldHVybiB0Lmhhc0F0dHJpYnV0ZShkaSkgfHwgdC5oYXNBdHRyaWJ1dGUobHQpIHx8IHQuaGFzQXR0cmlidXRlKHZzKTtcbiAgfVxuICBfaGFuZGxlTW92ZUhhbmQodCwgZSwgaSkge1xuICAgIGNvbnN0IG4gPSBkLmZpbmQoXG4gICAgICBgWyR7S31dYCxcbiAgICAgIHRoaXMuX21vZGFsXG4gICAgKSwgbyA9IGQuZmluZChcbiAgICAgIGBbJHtsdH1dYCxcbiAgICAgIHRoaXMuX21vZGFsXG4gICAgKTtcbiAgICB0aGlzLl9pc01vdXNlTW92ZSAmJiAodGhpcy5faGFzVGFyZ2V0SW5uZXJDbGFzcyh0KSA/IGguYWRkU3R5bGUodGhpcy5faGFuZCwge1xuICAgICAgaGVpZ2h0OiBcIjIxLjUlXCJcbiAgICB9KSA6IGguYWRkU3R5bGUodGhpcy5faGFuZCwge1xuICAgICAgaGVpZ2h0OiBcImNhbGMoNDAlICsgMXB4KVwiXG4gICAgfSksIGguYWRkU3R5bGUodGhpcy5faGFuZCwge1xuICAgICAgdHJhbnNmb3JtOiBgcm90YXRlWigke2l9ZGVnKWBcbiAgICB9KSwgdGhpcy5faG91ci50ZXh0Q29udGVudCA9IGUgPj0gMTAgfHwgZSA9PT0gXCIwMFwiID8gZSA6IGAwJHtlfWAsIHRoaXMuX3RvZ2dsZUNsYXNzQWN0aXZlKHRoaXMuaG91cnNBcnJheSwgdGhpcy5faG91ciwgbiksIHRoaXMuX3RvZ2dsZUNsYXNzQWN0aXZlKHRoaXMuaW5uZXJIb3VycywgdGhpcy5faG91ciwgbyksIHRoaXMuX29ialdpdGhEYXRhT25DaGFuZ2UuaG91ciA9IGUgPj0gMTAgfHwgZSA9PT0gXCIwMFwiID8gZSA6IGAwJHtlfWApO1xuICB9XG4gIF9oYW5kbGVyTWF4TWluTWludXRlc09wdGlvbnModCwgZSkge1xuICAgIGxldCB7IG1heFRpbWU6IGksIG1pblRpbWU6IG4gfSA9IHRoaXMuX29wdGlvbnM7XG4gICAgY29uc3QgeyBmb3JtYXQxMjogbywgaW5jcmVtZW50OiByLCBkaXNhYmxlUGFzdDogYSwgZGlzYWJsZUZ1dHVyZTogbCB9ID0gdGhpcy5fb3B0aW9ucztcbiAgICBuID0gWHQobiwgYSwgbyksIGkgPSBHdChpLCBsLCBvKTtcbiAgICBjb25zdCBwID0gUihpLCAhMSlbMV0sIHUgPSBSKG4sICExKVsxXSwgXyA9IFIoaSwgITEpWzBdLCBmID0gUihuLCAhMSlbMF0sIGcgPSBmID09PSBcIjEyXCIgJiYgbyA/IFwiMFwiIDogZiwgbSA9IF8gPT09IFwiMTJcIiAmJiBvID8gXCIwXCIgOiBfLCBiID0gUihpLCAhMSlbMl0sIHYgPSBSKG4sICExKVsyXSwgQyA9IHAgIT09IFwiXCIgPyBwICogNiA6IFwiXCIsIHcgPSB1ICE9PSBcIlwiID8gdSAqIDYgOiBcIlwiLCBFID0gTnVtYmVyKHRoaXMuX2hvdXIudGV4dENvbnRlbnQpLCBUID0gRSA9PT0gMTIgJiYgbyA/IDAgOiBFO1xuICAgIGlmICghYiAmJiAhdikge1xuICAgICAgaWYgKGkgIT09IFwiXCIgJiYgbiAhPT0gXCJcIikge1xuICAgICAgICBpZiAoTnVtYmVyKG0pID09PSBUICYmIHQgPiBDIHx8IE51bWJlcihnKSA9PT0gVCAmJiB0IDwgdylcbiAgICAgICAgICByZXR1cm4gdDtcbiAgICAgIH0gZWxzZSBpZiAobiAhPT0gXCJcIiAmJiBUIDw9IE51bWJlcihnKSkge1xuICAgICAgICBpZiAodCA8PSB3IC0gNilcbiAgICAgICAgICByZXR1cm4gdDtcbiAgICAgIH0gZWxzZSBpZiAoaSAhPT0gXCJcIiAmJiBUID49IE51bWJlcihtKSAmJiB0ID49IEMgKyA2KVxuICAgICAgICByZXR1cm4gdDtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKG4gIT09IFwiXCIpIHtcbiAgICAgICAgaWYgKHYgPT09IFwiUE1cIiAmJiB0aGlzLl9pc0FtRW5hYmxlZClcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICh2ID09PSBcIlBNXCIgJiYgdGhpcy5faXNQbUVuYWJsZWQpIHtcbiAgICAgICAgICBpZiAoVCA8IE51bWJlcihnKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICBpZiAoVCA8PSBOdW1iZXIoZykgJiYgdCA8PSB3IC0gNilcbiAgICAgICAgICAgIHJldHVybiB0O1xuICAgICAgICB9IGVsc2UgaWYgKHYgPT09IFwiQU1cIiAmJiB0aGlzLl9pc0FtRW5hYmxlZCkge1xuICAgICAgICAgIGlmIChUIDwgTnVtYmVyKGcpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIGlmIChUIDw9IE51bWJlcihnKSAmJiB0IDw9IHcgLSA2KVxuICAgICAgICAgICAgcmV0dXJuIHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpICE9PSBcIlwiKSB7XG4gICAgICAgIGlmIChiID09PSBcIkFNXCIgJiYgdGhpcy5faXNQbUVuYWJsZWQpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoYiA9PT0gXCJQTVwiICYmIHRoaXMuX2lzUG1FbmFibGVkKSB7XG4gICAgICAgICAgaWYgKFQgPj0gTnVtYmVyKG0pICYmIHQgPj0gQyArIDYpXG4gICAgICAgICAgICByZXR1cm4gdDtcbiAgICAgICAgfSBlbHNlIGlmIChiID09PSBcIkFNXCIgJiYgdGhpcy5faXNBbUVuYWJsZWQgJiYgVCA+PSBOdW1iZXIobSkgJiYgdCA+PSBDICsgNilcbiAgICAgICAgICByZXR1cm4gdDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHIgJiYgKHQgPSBNYXRoLnJvdW5kKHQgLyAzMCkgKiAzMCksIHQgPCAwID8gdCA9IDM2MCArIHQgOiB0ID49IDM2MCAmJiAodCA9IDApLCB7XG4gICAgICBkZWdyZWVzOiB0LFxuICAgICAgbWludXRlOiBlXG4gICAgfTtcbiAgfVxuICBfcmVtb3ZlTW9kYWwoKSB7XG4gICAgdGhpcy5fYW5pbWF0aW9ucyA/IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5fcmVtb3ZlTW9kYWxFbGVtZW50cygpLCB0aGlzLl9zY3JvbGxCYXIucmVzZXQoKTtcbiAgICB9LCAzMDApIDogKHRoaXMuX3JlbW92ZU1vZGFsRWxlbWVudHMoKSwgdGhpcy5fc2Nyb2xsQmFyLnJlc2V0KCkpLCByZS5vZmYoXG4gICAgICB0aGlzLl9kb2N1bWVudCxcbiAgICAgIGAke0JhfSAke19zfSAke0hhfSAke1ZhfSAke1dhfSAke0ZhfSAke1lhfSAke3phfSAke2phfSAke0thfWBcbiAgICApLCBjLm9mZih3aW5kb3csIF9zKTtcbiAgfVxuICBfcmVtb3ZlTW9kYWxFbGVtZW50cygpIHtcbiAgICB0aGlzLl9tb2RhbCAmJiB0aGlzLl9tb2RhbC5yZW1vdmUoKTtcbiAgfVxuICBfdG9nZ2xlQmFja2Ryb3BBbmltYXRpb24odCA9ICExKSB7XG4gICAgdCA/IHRoaXMuX3dyYXBwZXIuY2xhc3NMaXN0LmFkZChcImFuaW1hdGUtW2ZhZGUtb3V0XzM1MG1zX2Vhc2UtaW4tb3V0XVwiKSA6ICh0aGlzLl93cmFwcGVyLmNsYXNzTGlzdC5hZGQoXCJhbmltYXRlLVtmYWRlLWluXzM1MG1zX2Vhc2UtaW4tb3V0XVwiKSwgdGhpcy5fb3B0aW9ucy5pbmxpbmUgfHwgaC5hZGRDbGFzcyh0aGlzLl9jbG9jaywgdGhpcy5fY2xhc3Nlcy5jbG9ja0FuaW1hdGlvbikpLCBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuX3dyYXBwZXIuY2xhc3NMaXN0LnJlbW92ZShcbiAgICAgICAgXCJhbmltYXRlLVtmYWRlLW91dF8zNTBtc19lYXNlLWluLW91dF1cIixcbiAgICAgICAgXCJhbmltYXRlLVtmYWRlLWluXzM1MG1zX2Vhc2UtaW4tb3V0XVwiXG4gICAgICApO1xuICAgIH0sIDM1MSk7XG4gIH1cbiAgX2FkZEFjdGl2ZUNsYXNzVG9UaXAodCwgZSkge1xuICAgIHQuZm9yRWFjaCgoaSkgPT4ge1xuICAgICAgTnVtYmVyKGkudGV4dENvbnRlbnQpID09PSBOdW1iZXIoZSkgJiYgKGguYWRkQ2xhc3MoaSwgdGhpcy5fY2xhc3Nlcy50aXBzQWN0aXZlKSwgaS5zZXRBdHRyaWJ1dGUoSCwgXCJcIikpO1xuICAgIH0pO1xuICB9XG4gIF9zZXRIb3VyT3JNaW51dGUodCkge1xuICAgIHJldHVybiB0IDwgMTAgPyBgMCR7dH1gIDogdDtcbiAgfVxuICBfYXBwZW5kVGltZXMoKSB7XG4gICAgY29uc3QgeyBmb3JtYXQyNDogdCB9ID0gdGhpcy5fb3B0aW9ucztcbiAgICBpZiAodCkge1xuICAgICAgdGhpcy5fZ2V0QXBwZW5kQ2xvY2soXG4gICAgICAgIHRoaXMuaG91cnNBcnJheSxcbiAgICAgICAgYFske3BlfV1gLFxuICAgICAgICBLXG4gICAgICApLCB0aGlzLl9nZXRBcHBlbmRDbG9jayhcbiAgICAgICAgdGhpcy5pbm5lckhvdXJzLFxuICAgICAgICBgWyR7ZGl9XWAsXG4gICAgICAgIGx0XG4gICAgICApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9nZXRBcHBlbmRDbG9jayhcbiAgICAgIHRoaXMuaG91cnNBcnJheSxcbiAgICAgIGBbJHtwZX1dYCxcbiAgICAgIEtcbiAgICApO1xuICB9XG4gIF9nZXRDb25maWcodCkge1xuICAgIGNvbnN0IGUgPSBoLmdldERhdGFBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpO1xuICAgIHJldHVybiB0ID0ge1xuICAgICAgLi4udGcsXG4gICAgICAuLi5lLFxuICAgICAgLi4udFxuICAgIH0sIEQoJGksIHQsIGVnKSwgdDtcbiAgfVxuICBfZ2V0Q2xhc3Nlcyh0KSB7XG4gICAgY29uc3QgZSA9IGguZ2V0RGF0YUNsYXNzQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KTtcbiAgICByZXR1cm4gdCA9IHtcbiAgICAgIC4uLmlnLFxuICAgICAgLi4uZSxcbiAgICAgIC4uLnRcbiAgICB9LCBEKCRpLCB0LCBzZyksIHQ7XG4gIH1cbiAgX2dldENvbnRhaW5lcigpIHtcbiAgICByZXR1cm4gZC5maW5kT25lKHRoaXMuX29wdGlvbnMuY29udGFpbmVyKTtcbiAgfVxuICBfZ2V0VmFsaWRhdGUodCkge1xuICAgIGNvbnN0IHsgZm9ybWF0MjQ6IGUsIGZvcm1hdDEyOiBpLCBhcHBlbmRWYWxpZGF0aW9uSW5mbzogbiB9ID0gdGhpcy5fb3B0aW9ucztcbiAgICByZS5vbih0aGlzLmlucHV0LCB0LCAoeyB0YXJnZXQ6IG8gfSkgPT4ge1xuICAgICAgaWYgKHRoaXMuX29wdGlvbnMgPT09IG51bGwgfHwgdGhpcy5pbnB1dC52YWx1ZSA9PT0gXCJcIilcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY29uc3QgciA9IC9eKDA/WzEtOV18MVswMTJdKSg6WzAtNV1cXGQpIFtBUGFwXVttTV0kLywgYSA9IC9eKFswMV1cXGR8MlswLTNdKSg6WzAtNV1cXGQpJC8sIGwgPSByLnRlc3Qoby52YWx1ZSk7XG4gICAgICBpZiAoYS50ZXN0KG8udmFsdWUpICE9PSAhMCAmJiBlIHx8IGwgIT09ICEwICYmIGkpIHtcbiAgICAgICAgbiAmJiB0aGlzLmlucHV0LnNldEF0dHJpYnV0ZShKbiwgXCJcIiksIGguYWRkU3R5bGUobywgeyBtYXJnaW5Cb3R0b206IDAgfSksIHRoaXMuX2lzSW52YWxpZFRpbWVGb3JtYXQgPSAhMDtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5pbnB1dC5yZW1vdmVBdHRyaWJ1dGUoSm4pLCB0aGlzLl9pc0ludmFsaWRUaW1lRm9ybWF0ID0gITE7XG4gICAgICBjb25zdCB1ID0gZC5maW5kT25lKFxuICAgICAgICBgWyR7Wm19XWBcbiAgICAgICk7XG4gICAgICB1ICE9PSBudWxsICYmIHUucmVtb3ZlKCk7XG4gICAgfSk7XG4gIH1cbiAgLy8gU3RhdGljXG4gIHN0YXRpYyBnZXRJbnN0YW5jZSh0KSB7XG4gICAgcmV0dXJuIHkuZ2V0RGF0YSh0LCBVcyk7XG4gIH1cbiAgc3RhdGljIGdldE9yQ3JlYXRlSW5zdGFuY2UodCwgZSA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0SW5zdGFuY2UodCkgfHwgbmV3IHRoaXModCwgdHlwZW9mIGUgPT0gXCJvYmplY3RcIiA/IGUgOiBudWxsKTtcbiAgfVxufVxuY29uc3Qgb2cgPSB7XG4gIHRocmVzaG9sZDogMTAsXG4gIGRpcmVjdGlvbjogXCJhbGxcIlxufTtcbmxldCByZyA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IodCwgZSkge1xuICAgIHRoaXMuX2VsZW1lbnQgPSB0LCB0aGlzLl9zdGFydFBvc2l0aW9uID0gbnVsbCwgdGhpcy5fb3B0aW9ucyA9IHtcbiAgICAgIC4uLm9nLFxuICAgICAgLi4uZVxuICAgIH07XG4gIH1cbiAgaGFuZGxlVG91Y2hTdGFydCh0KSB7XG4gICAgdGhpcy5fc3RhcnRQb3NpdGlvbiA9IHRoaXMuX2dldENvb3JkaW5hdGVzKHQpO1xuICB9XG4gIGhhbmRsZVRvdWNoTW92ZSh0KSB7XG4gICAgaWYgKCF0aGlzLl9zdGFydFBvc2l0aW9uKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGUgPSB0aGlzLl9nZXRDb29yZGluYXRlcyh0KSwgaSA9IHtcbiAgICAgIHg6IGUueCAtIHRoaXMuX3N0YXJ0UG9zaXRpb24ueCxcbiAgICAgIHk6IGUueSAtIHRoaXMuX3N0YXJ0UG9zaXRpb24ueVxuICAgIH0sIG4gPSB0aGlzLl9nZXREaXJlY3Rpb24oaSk7XG4gICAgaWYgKHRoaXMuX29wdGlvbnMuZGlyZWN0aW9uID09PSBcImFsbFwiKSB7XG4gICAgICBpZiAobi55LnZhbHVlIDwgdGhpcy5fb3B0aW9ucy50aHJlc2hvbGQgJiYgbi54LnZhbHVlIDwgdGhpcy5fb3B0aW9ucy50aHJlc2hvbGQpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNvbnN0IHIgPSBuLnkudmFsdWUgPiBuLngudmFsdWUgPyBuLnkuZGlyZWN0aW9uIDogbi54LmRpcmVjdGlvbjtcbiAgICAgIGMudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBgc3dpcGUke3J9YCksIGMudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBcInN3aXBlXCIsIHsgZGlyZWN0aW9uOiByIH0pLCB0aGlzLl9zdGFydFBvc2l0aW9uID0gbnVsbDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbyA9IHRoaXMuX29wdGlvbnMuZGlyZWN0aW9uID09PSBcImxlZnRcIiB8fCB0aGlzLl9vcHRpb25zID09PSBcInJpZ2h0XCIgPyBcInhcIiA6IFwieVwiO1xuICAgIG5bb10uZGlyZWN0aW9uID09PSB0aGlzLl9vcHRpb25zLmRpcmVjdGlvbiAmJiBuW29dLnZhbHVlID4gdGhpcy5fb3B0aW9ucy50aHJlc2hvbGQgJiYgKGMudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBgc3dpcGUke25bb10uZGlyZWN0aW9ufWApLCB0aGlzLl9zdGFydFBvc2l0aW9uID0gbnVsbCk7XG4gIH1cbiAgaGFuZGxlVG91Y2hFbmQoKSB7XG4gICAgdGhpcy5fc3RhcnRQb3NpdGlvbiA9IG51bGw7XG4gIH1cbiAgX2dldENvb3JkaW5hdGVzKHQpIHtcbiAgICBjb25zdCBbZV0gPSB0LnRvdWNoZXM7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IGUuY2xpZW50WCxcbiAgICAgIHk6IGUuY2xpZW50WVxuICAgIH07XG4gIH1cbiAgX2dldERpcmVjdGlvbih0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHtcbiAgICAgICAgZGlyZWN0aW9uOiB0LnggPCAwID8gXCJsZWZ0XCIgOiBcInJpZ2h0XCIsXG4gICAgICAgIHZhbHVlOiBNYXRoLmFicyh0LngpXG4gICAgICB9LFxuICAgICAgeToge1xuICAgICAgICBkaXJlY3Rpb246IHQueSA8IDAgPyBcInVwXCIgOiBcImRvd25cIixcbiAgICAgICAgdmFsdWU6IE1hdGguYWJzKHQueSlcbiAgICAgIH1cbiAgICB9O1xuICB9XG59LCBhZyA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IodCwgZSA9IFwic3dpcGVcIiwgaSA9IHt9KSB7XG4gICAgdGhpcy5fZWxlbWVudCA9IHQsIHRoaXMuX2V2ZW50ID0gZSwgdGhpcy5zd2lwZSA9IG5ldyByZyh0LCBpKSwgdGhpcy5fdG91Y2hTdGFydEhhbmRsZXIgPSB0aGlzLl9oYW5kbGVUb3VjaFN0YXJ0LmJpbmQodGhpcyksIHRoaXMuX3RvdWNoTW92ZUhhbmRsZXIgPSB0aGlzLl9oYW5kbGVUb3VjaE1vdmUuYmluZCh0aGlzKSwgdGhpcy5fdG91Y2hFbmRIYW5kbGVyID0gdGhpcy5faGFuZGxlVG91Y2hFbmQuYmluZCh0aGlzKTtcbiAgfVxuICBkaXNwb3NlKCkge1xuICAgIHRoaXMuX2VsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNoc3RhcnRcIiwgdGhpcy5fdG91Y2hTdGFydEhhbmRsZXIpLCB0aGlzLl9lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaG1vdmVcIiwgdGhpcy5fdG91Y2hNb3ZlSGFuZGxlciksIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2hlbmRcIiwgdGhpcy5fdG91Y2hFbmRIYW5kbGVyKTtcbiAgfVxuICBpbml0KCkge1xuICAgIHRoaXMuX2VsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgIFwidG91Y2hzdGFydFwiLFxuICAgICAgKHQpID0+IHRoaXMuX2hhbmRsZVRvdWNoU3RhcnQodClcbiAgICApLCB0aGlzLl9lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICBcInRvdWNobW92ZVwiLFxuICAgICAgKHQpID0+IHRoaXMuX2hhbmRsZVRvdWNoTW92ZSh0KVxuICAgICksIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hlbmRcIiwgKHQpID0+IHRoaXMuX2hhbmRsZVRvdWNoRW5kKHQpKTtcbiAgfVxuICBfaGFuZGxlVG91Y2hTdGFydCh0KSB7XG4gICAgdGhpc1t0aGlzLl9ldmVudF0uaGFuZGxlVG91Y2hTdGFydCh0KTtcbiAgfVxuICBfaGFuZGxlVG91Y2hNb3ZlKHQpIHtcbiAgICB0aGlzW3RoaXMuX2V2ZW50XS5oYW5kbGVUb3VjaE1vdmUodCk7XG4gIH1cbiAgX2hhbmRsZVRvdWNoRW5kKHQpIHtcbiAgICB0aGlzW3RoaXMuX2V2ZW50XS5oYW5kbGVUb3VjaEVuZCh0KTtcbiAgfVxufTtcbmNvbnN0IFFhID0gXCJzaWRlbmF2XCIsIFRzID0gXCJ0ZS5zaWRlbmF2XCIsIGxnID0gXCJkYXRhLXRlLXNpZGVuYXYtcm90YXRlLWljb24tcmVmXCIsIG5vID0gXCJbZGF0YS10ZS1zaWRlbmF2LXRvZ2dsZS1yZWZdXCIsIGNnID0gXCJbZGF0YS10ZS1jb2xsYXBzZS1pbml0XVwiLCBoZyA9ICdbZGF0YS10ZS1zaWRlbmF2LXNsaW09XCJ0cnVlXCJdJywgZGcgPSAnW2RhdGEtdGUtc2lkZW5hdi1zbGltPVwiZmFsc2VcIl0nLCB1ZyA9IFwiW2RhdGEtdGUtc2lkZW5hdi1tZW51LXJlZl1cIiwgT2UgPSBcIltkYXRhLXRlLXNpZGVuYXYtY29sbGFwc2UtcmVmXVwiLCB1aSA9IFwiW2RhdGEtdGUtc2lkZW5hdi1saW5rLXJlZl1cIiwgcGcgPSBGKCkgPyAxMDAgOiAtMTAwLCBfZyA9IEYoKSA/IC0xMDAgOiAxMDAsIGZnID0ge1xuICBzaWRlbmF2QWNjb3JkaW9uOiBcIihib29sZWFuKVwiLFxuICBzaWRlbmF2QmFja2Ryb3A6IFwiKGJvb2xlYW4pXCIsXG4gIHNpZGVuYXZCYWNrZHJvcENsYXNzOiBcIihudWxsfHN0cmluZylcIixcbiAgc2lkZW5hdkNsb3NlT25Fc2M6IFwiKGJvb2xlYW4pXCIsXG4gIHNpZGVuYXZDb2xvcjogXCIoc3RyaW5nKVwiLFxuICBzaWRlbmF2Q29udGVudDogXCIobnVsbHxzdHJpbmcpXCIsXG4gIHNpZGVuYXZFeHBhbmRhYmxlOiBcIihib29sZWFuKVwiLFxuICBzaWRlbmF2RXhwYW5kT25Ib3ZlcjogXCIoYm9vbGVhbilcIixcbiAgc2lkZW5hdkZvY3VzVHJhcDogXCIoYm9vbGVhbilcIixcbiAgc2lkZW5hdkhpZGRlbjogXCIoYm9vbGVhbilcIixcbiAgc2lkZW5hdk1vZGU6IFwiKHN0cmluZylcIixcbiAgc2lkZW5hdk1vZGVCcmVha3BvaW50T3ZlcjogXCIobnVsbHxzdHJpbmd8bnVtYmVyKVwiLFxuICBzaWRlbmF2TW9kZUJyZWFrcG9pbnRTaWRlOiBcIihudWxsfHN0cmluZ3xudW1iZXIpXCIsXG4gIHNpZGVuYXZNb2RlQnJlYWtwb2ludFB1c2g6IFwiKG51bGx8c3RyaW5nfG51bWJlcilcIixcbiAgc2lkZW5hdkJyZWFrcG9pbnRTbTogXCIobnVtYmVyKVwiLFxuICBzaWRlbmF2QnJlYWtwb2ludE1kOiBcIihudW1iZXIpXCIsXG4gIHNpZGVuYXZCcmVha3BvaW50TGc6IFwiKG51bWJlcilcIixcbiAgc2lkZW5hdkJyZWFrcG9pbnRYbDogXCIobnVtYmVyKVwiLFxuICBzaWRlbmF2QnJlYWtwb2ludDJ4bDogXCIobnVtYmVyKVwiLFxuICBzaWRlbmF2U2Nyb2xsQ29udGFpbmVyOiBcIihudWxsfHN0cmluZylcIixcbiAgc2lkZW5hdlNsaW06IFwiKGJvb2xlYW4pXCIsXG4gIHNpZGVuYXZTbGltQ29sbGFwc2VkOiBcIihib29sZWFuKVwiLFxuICBzaWRlbmF2U2xpbVdpZHRoOiBcIihudW1iZXIpXCIsXG4gIHNpZGVuYXZQb3NpdGlvbjogXCIoc3RyaW5nKVwiLFxuICBzaWRlbmF2UmlnaHQ6IFwiKGJvb2xlYW4pXCIsXG4gIHNpZGVuYXZUcmFuc2l0aW9uRHVyYXRpb246IFwiKG51bWJlcilcIixcbiAgc2lkZW5hdldpZHRoOiBcIihudW1iZXIpXCJcbn0sIG1nID0ge1xuICBzaWRlbmF2QWNjb3JkaW9uOiAhMSxcbiAgc2lkZW5hdkJhY2tkcm9wOiAhMCxcbiAgc2lkZW5hdkJhY2tkcm9wQ2xhc3M6IG51bGwsXG4gIHNpZGVuYXZDbG9zZU9uRXNjOiAhMCxcbiAgc2lkZW5hdkNvbG9yOiBcInByaW1hcnlcIixcbiAgc2lkZW5hdkNvbnRlbnQ6IG51bGwsXG4gIHNpZGVuYXZFeHBhbmRhYmxlOiAhMCxcbiAgc2lkZW5hdkV4cGFuZE9uSG92ZXI6ICExLFxuICBzaWRlbmF2Rm9jdXNUcmFwOiAhMCxcbiAgc2lkZW5hdkhpZGRlbjogITAsXG4gIHNpZGVuYXZNb2RlOiBcIm92ZXJcIixcbiAgc2lkZW5hdk1vZGVCcmVha3BvaW50T3ZlcjogbnVsbCxcbiAgc2lkZW5hdk1vZGVCcmVha3BvaW50U2lkZTogbnVsbCxcbiAgc2lkZW5hdk1vZGVCcmVha3BvaW50UHVzaDogbnVsbCxcbiAgc2lkZW5hdkJyZWFrcG9pbnRTbTogNjQwLFxuICBzaWRlbmF2QnJlYWtwb2ludE1kOiA3NjgsXG4gIHNpZGVuYXZCcmVha3BvaW50TGc6IDEwMjQsXG4gIHNpZGVuYXZCcmVha3BvaW50WGw6IDEyODAsXG4gIHNpZGVuYXZCcmVha3BvaW50MnhsOiAxNTM2LFxuICBzaWRlbmF2U2Nyb2xsQ29udGFpbmVyOiBudWxsLFxuICBzaWRlbmF2U2xpbTogITEsXG4gIHNpZGVuYXZTbGltQ29sbGFwc2VkOiAhMSxcbiAgc2lkZW5hdlNsaW1XaWR0aDogNzcsXG4gIHNpZGVuYXZQb3NpdGlvbjogXCJmaXhlZFwiLFxuICBzaWRlbmF2UmlnaHQ6ICExLFxuICBzaWRlbmF2VHJhbnNpdGlvbkR1cmF0aW9uOiAzMDAsXG4gIHNpZGVuYXZXaWR0aDogMjQwXG59O1xuY2xhc3MgZ2kge1xuICBjb25zdHJ1Y3Rvcih0LCBlID0ge30pIHtcbiAgICB5dCh0aGlzLCBcIl9hZGRCYWNrZHJvcE9uSW5pdFwiLCAoKSA9PiB7XG4gICAgICB0aGlzLl9vcHRpb25zLnNpZGVuYXZIaWRkZW4gfHwgKHRoaXMuX2JhY2tkcm9wLnNob3coKSwgYy5vZmYodGhpcy5fZWxlbWVudCwgXCJ0cmFuc2l0aW9uZW5kXCIsIHRoaXMuX2FkZEJhY2tkcm9wT25Jbml0KSk7XG4gICAgfSk7XG4gICAgdGhpcy5fZWxlbWVudCA9IHQsIHRoaXMuX29wdGlvbnMgPSBlLCB0aGlzLl9JRCA9IHJ0KFwiXCIpLCB0aGlzLl9jb250ZW50ID0gbnVsbCwgdGhpcy5faW5pdGlhbENvbnRlbnRTdHlsZSA9IG51bGwsIHRoaXMuX3NsaW1Db2xsYXBzZWQgPSAhMSwgdGhpcy5fYWN0aXZlTm9kZSA9IG51bGwsIHRoaXMuX3RlbXBTbGltID0gITEsIHRoaXMuX2JhY2tkcm9wID0gdGhpcy5faW5pdGlhbGl6ZUJhY2tEcm9wKCksIHRoaXMuX2ZvY3VzVHJhcCA9IG51bGwsIHRoaXMuX3BlcmZlY3RTY3JvbGxiYXIgPSBudWxsLCB0aGlzLl90b3VjaCA9IG51bGwsIHRoaXMuX3NldE1vZGVGcm9tQnJlYWtwb2ludHMoKSwgdGhpcy5lc2NIYW5kbGVyID0gKGkpID0+IHtcbiAgICAgIGkua2V5Q29kZSA9PT0gRmkgJiYgdGhpcy50b2dnbGVyICYmIE50KHRoaXMudG9nZ2xlcikgJiYgKHRoaXMuX3VwZGF0ZSghMSksIGMub2ZmKHdpbmRvdywgXCJrZXlkb3duXCIsIHRoaXMuZXNjSGFuZGxlcikpO1xuICAgIH0sIHRoaXMuaGFzaEhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICB0aGlzLl9zZXRBY3RpdmVFbGVtZW50cygpO1xuICAgIH0sIHQgJiYgKHkuc2V0RGF0YSh0LCBUcywgdGhpcyksIHRoaXMuX3NldHVwKCkpLCB0aGlzLm9wdGlvbnMuc2lkZW5hdkJhY2tkcm9wICYmICF0aGlzLm9wdGlvbnMuc2lkZW5hdkhpZGRlbiAmJiB0aGlzLm9wdGlvbnMuc2lkZW5hdk1vZGUgPT09IFwib3ZlclwiICYmIGMub24odGhpcy5fZWxlbWVudCwgXCJ0cmFuc2l0aW9uZW5kXCIsIHRoaXMuX2FkZEJhY2tkcm9wT25Jbml0KSwgdGhpcy5fZGlkSW5pdCA9ICExLCB0aGlzLl9pbml0KCk7XG4gIH1cbiAgLy8gR2V0dGVyc1xuICBzdGF0aWMgZ2V0IE5BTUUoKSB7XG4gICAgcmV0dXJuIFFhO1xuICB9XG4gIGdldCBjb250YWluZXIoKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5zaWRlbmF2UG9zaXRpb24gPT09IFwiZml4ZWRcIilcbiAgICAgIHJldHVybiBkLmZpbmRPbmUoXCJib2R5XCIpO1xuICAgIGNvbnN0IHQgPSAoZSkgPT4gIWUucGFyZW50Tm9kZSB8fCBlLnBhcmVudE5vZGUgPT09IGRvY3VtZW50ID8gZSA6IGUucGFyZW50Tm9kZS5zdHlsZS5wb3NpdGlvbiA9PT0gXCJyZWxhdGl2ZVwiIHx8IGUucGFyZW50Tm9kZS5jbGFzc0xpc3QuY29udGFpbnMoXCJyZWxhdGl2ZVwiKSA/IGUucGFyZW50Tm9kZSA6IHQoZS5wYXJlbnROb2RlKTtcbiAgICByZXR1cm4gdCh0aGlzLl9lbGVtZW50KTtcbiAgfVxuICBnZXQgaXNWaXNpYmxlKCkge1xuICAgIGxldCB0ID0gMCwgZSA9IHdpbmRvdy5pbm5lcldpZHRoO1xuICAgIGlmICh0aGlzLm9wdGlvbnMuc2lkZW5hdlBvc2l0aW9uICE9PSBcImZpeGVkXCIpIHtcbiAgICAgIGNvbnN0IG4gPSB0aGlzLmNvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIHQgPSBuLngsIGUgPSBuLnggKyBuLndpZHRoO1xuICAgIH1cbiAgICBjb25zdCB7IHg6IGkgfSA9IHRoaXMuX2VsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy5zaWRlbmF2UmlnaHQgPyBNYXRoLmFicyhpIC0gZSkgPiAxMCA6IE1hdGguYWJzKGkgLSB0KSA8IDEwO1xuICB9XG4gIGdldCBsaW5rcygpIHtcbiAgICByZXR1cm4gZC5maW5kKHVpLCB0aGlzLl9lbGVtZW50KTtcbiAgfVxuICBnZXQgbmF2aWdhdGlvbigpIHtcbiAgICByZXR1cm4gZC5maW5kKHVnLCB0aGlzLl9lbGVtZW50KTtcbiAgfVxuICBnZXQgb3B0aW9ucygpIHtcbiAgICBjb25zdCB0ID0ge1xuICAgICAgLi4ubWcsXG4gICAgICAuLi5oLmdldERhdGFBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpLFxuICAgICAgLi4udGhpcy5fb3B0aW9uc1xuICAgIH07XG4gICAgcmV0dXJuIEQoUWEsIHQsIGZnKSwgdDtcbiAgfVxuICBnZXQgc2lkZW5hdlN0eWxlKCkge1xuICAgIHJldHVybiB7XG4gICAgICB3aWR0aDogYCR7dGhpcy53aWR0aH1weGAsXG4gICAgICBoZWlnaHQ6IHRoaXMub3B0aW9ucy5zaWRlbmF2UG9zaXRpb24gPT09IFwiZml4ZWRcIiA/IFwiMTAwdmhcIiA6IFwiMTAwJVwiLFxuICAgICAgcG9zaXRpb246IHRoaXMub3B0aW9ucy5zaWRlbmF2UG9zaXRpb24sXG4gICAgICB0cmFuc2l0aW9uOiBgYWxsICR7dGhpcy50cmFuc2l0aW9uRHVyYXRpb259IGxpbmVhcmBcbiAgICB9O1xuICB9XG4gIGdldCB0b2dnbGVyKCkge1xuICAgIHJldHVybiBkLmZpbmQobm8pLmZpbmQoXG4gICAgICAoZSkgPT4ge1xuICAgICAgICBjb25zdCBpID0gaC5nZXREYXRhQXR0cmlidXRlKGUsIFwidGFyZ2V0XCIpO1xuICAgICAgICByZXR1cm4gZC5maW5kT25lKGkpID09PSB0aGlzLl9lbGVtZW50O1xuICAgICAgfVxuICAgICk7XG4gIH1cbiAgZ2V0IHRyYW5zaXRpb25EdXJhdGlvbigpIHtcbiAgICByZXR1cm4gYCR7dGhpcy5vcHRpb25zLnNpZGVuYXZUcmFuc2l0aW9uRHVyYXRpb24gLyAxZTN9c2A7XG4gIH1cbiAgZ2V0IHRyYW5zbGF0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMuc2lkZW5hdlJpZ2h0ID8gX2cgOiBwZztcbiAgfVxuICBnZXQgd2lkdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NsaW1Db2xsYXBzZWQgPyB0aGlzLm9wdGlvbnMuc2lkZW5hdlNsaW1XaWR0aCA6IHRoaXMub3B0aW9ucy5zaWRlbmF2V2lkdGg7XG4gIH1cbiAgZ2V0IGlzQmFja2Ryb3BWaXNpYmxlKCkge1xuICAgIHJldHVybiAhIXRoaXMuX2JhY2tkcm9wLl9lbGVtZW50O1xuICB9XG4gIC8vIFB1YmxpY1xuICBjaGFuZ2VNb2RlKHQpIHtcbiAgICB0aGlzLl9zZXRNb2RlKHQpO1xuICB9XG4gIGRpc3Bvc2UoKSB7XG4gICAgYy5vZmYod2luZG93LCBcImtleWRvd25cIiwgdGhpcy5lc2NIYW5kbGVyKSwgdGhpcy5vcHRpb25zLnNpZGVuYXZCYWNrZHJvcCAmJiB0aGlzLl9iYWNrZHJvcC5kaXNwb3NlKCksIGMub2ZmKHdpbmRvdywgXCJoYXNoY2hhbmdlXCIsIHRoaXMuaGFzaEhhbmRsZXIpLCB0aGlzLl90b3VjaC5kaXNwb3NlKCksIHkucmVtb3ZlRGF0YSh0aGlzLl9lbGVtZW50LCBUcyksIHRoaXMuX2VsZW1lbnQgPSBudWxsO1xuICB9XG4gIGhpZGUoKSB7XG4gICAgdGhpcy5fZW1pdEV2ZW50cyghMSksIHRoaXMuX3VwZGF0ZSghMSksIHRoaXMuX29wdGlvbnMuc2lkZW5hdkJhY2tkcm9wICYmIHRoaXMuaXNCYWNrZHJvcFZpc2libGUgJiYgdGhpcy5fYmFja2Ryb3AuaGlkZSgpO1xuICB9XG4gIHNob3coKSB7XG4gICAgdGhpcy5fZW1pdEV2ZW50cyghMCksIHRoaXMuX3VwZGF0ZSghMCksIHRoaXMuX29wdGlvbnMuc2lkZW5hdkJhY2tkcm9wICYmIHRoaXMuX29wdGlvbnMuc2lkZW5hdk1vZGUgPT09IFwib3ZlclwiICYmIHRoaXMuX2JhY2tkcm9wLnNob3coKTtcbiAgfVxuICB0b2dnbGUoKSB7XG4gICAgdGhpcy5fZW1pdEV2ZW50cyghdGhpcy5pc1Zpc2libGUpLCB0aGlzLl91cGRhdGUoIXRoaXMuaXNWaXNpYmxlKTtcbiAgfVxuICB0b2dnbGVTbGltKCkge1xuICAgIHRoaXMuX3NldFNsaW0oIXRoaXMuX3NsaW1Db2xsYXBzZWQpO1xuICB9XG4gIHVwZGF0ZSh0KSB7XG4gICAgdGhpcy5fb3B0aW9ucyA9IHQsIHRoaXMuX3NldHVwKCk7XG4gIH1cbiAgZ2V0QnJlYWtwb2ludCh0KSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zZm9ybUJyZWFrcG9pbnRWYWx1ZXNUb09iamVjdCgpW3RdO1xuICB9XG4gIC8vIFByaXZhdGVcbiAgX2luaXQoKSB7XG4gICAgdGhpcy5fZGlkSW5pdCB8fCAoYy5vbihcbiAgICAgIGRvY3VtZW50LFxuICAgICAgXCJjbGlja1wiLFxuICAgICAgbm8sXG4gICAgICBnaS50b2dnbGVTaWRlbmF2KClcbiAgICApLCB0aGlzLl9kaWRJbml0ID0gITApO1xuICB9XG4gIF90cmFuc2Zvcm1CcmVha3BvaW50VmFsdWVzVG9PYmplY3QoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNtOiB0aGlzLm9wdGlvbnMuc2lkZW5hdkJyZWFrcG9pbnRTbSxcbiAgICAgIG1kOiB0aGlzLm9wdGlvbnMuc2lkZW5hdkJyZWFrcG9pbnRNZCxcbiAgICAgIGxnOiB0aGlzLm9wdGlvbnMuc2lkZW5hdkJyZWFrcG9pbnRMZyxcbiAgICAgIHhsOiB0aGlzLm9wdGlvbnMuc2lkZW5hdkJyZWFrcG9pbnRYbCxcbiAgICAgIFwiMnhsXCI6IHRoaXMub3B0aW9ucy5zaWRlbmF2QnJlYWtwb2ludDJ4bFxuICAgIH07XG4gIH1cbiAgX3NldE1vZGVGcm9tQnJlYWtwb2ludHMoKSB7XG4gICAgY29uc3QgdCA9IHdpbmRvdy5pbm5lcldpZHRoLCBlID0gdGhpcy5fdHJhbnNmb3JtQnJlYWtwb2ludFZhbHVlc1RvT2JqZWN0KCk7XG4gICAgaWYgKHQgPT09IHZvaWQgMCB8fCAhZSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBpID0gdHlwZW9mIHRoaXMub3B0aW9ucy5zaWRlbmF2TW9kZUJyZWFrcG9pbnRPdmVyID09IFwibnVtYmVyXCIgPyB0IC0gdGhpcy5vcHRpb25zLnNpZGVuYXZNb2RlQnJlYWtwb2ludE92ZXIgOiB0IC0gZVt0aGlzLm9wdGlvbnMuc2lkZW5hdk1vZGVCcmVha3BvaW50T3Zlcl0sIG4gPSB0eXBlb2YgdGhpcy5vcHRpb25zLnNpZGVuYXZNb2RlQnJlYWtwb2ludFNpZGUgPT0gXCJudW1iZXJcIiA/IHQgLSB0aGlzLm9wdGlvbnMuc2lkZW5hdk1vZGVCcmVha3BvaW50U2lkZSA6IHQgLSBlW3RoaXMub3B0aW9ucy5zaWRlbmF2TW9kZUJyZWFrcG9pbnRTaWRlXSwgbyA9IHR5cGVvZiB0aGlzLm9wdGlvbnMuc2lkZW5hdk1vZGVCcmVha3BvaW50UHVzaCA9PSBcIm51bWJlclwiID8gdCAtIHRoaXMub3B0aW9ucy5zaWRlbmF2TW9kZUJyZWFrcG9pbnRQdXNoIDogdCAtIGVbdGhpcy5vcHRpb25zLnNpZGVuYXZNb2RlQnJlYWtwb2ludFB1c2hdLCByID0gKGwsIHApID0+IGwgLSBwIDwgMCA/IC0xIDogcCAtIGwgPCAwID8gMSA6IDAsIGEgPSBbaSwgbiwgb10uZmlsdGVyKChsKSA9PiBsICE9IG51bGwgJiYgbCA+PSAwKS5zb3J0KHIpWzBdO1xuICAgIGkgPiAwICYmIGkgPT09IGEgPyAodGhpcy5fb3B0aW9ucy5zaWRlbmF2TW9kZSA9IFwib3ZlclwiLCB0aGlzLl9vcHRpb25zLnNpZGVuYXZIaWRkZW4gPSAhMCkgOiBuID4gMCAmJiBuID09PSBhID8gdGhpcy5fb3B0aW9ucy5zaWRlbmF2TW9kZSA9IFwic2lkZVwiIDogbyA+IDAgJiYgbyA9PT0gYSAmJiAodGhpcy5fb3B0aW9ucy5zaWRlbmF2TW9kZSA9IFwicHVzaFwiKTtcbiAgfVxuICBfY29sbGFwc2VJdGVtcygpIHtcbiAgICB0aGlzLm5hdmlnYXRpb24uZm9yRWFjaCgodCkgPT4ge1xuICAgICAgZC5maW5kKE9lLCB0KS5mb3JFYWNoKChpKSA9PiB7XG4gICAgICAgIFp0LmdldEluc3RhbmNlKGkpLmhpZGUoKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIF9nZXRPZmZzZXRWYWx1ZSh0LCB7IGluZGV4OiBlLCBwcm9wZXJ0eTogaSwgb2Zmc2V0czogbiB9KSB7XG4gICAgY29uc3QgbyA9IHRoaXMuX2dldFB4VmFsdWUoXG4gICAgICB0aGlzLl9pbml0aWFsQ29udGVudFN0eWxlW2VdW25baV0ucHJvcGVydHldXG4gICAgKSwgciA9IHQgPyBuW2ldLnZhbHVlIDogMDtcbiAgICByZXR1cm4gbyArIHI7XG4gIH1cbiAgX2dldFByb3BlcnR5KC4uLnQpIHtcbiAgICByZXR1cm4gdC5tYXAoKGUsIGkpID0+IGkgPT09IDAgPyBlIDogZVswXS50b1VwcGVyQ2FzZSgpLmNvbmNhdChlLnNsaWNlKDEpKSkuam9pbihcIlwiKTtcbiAgfVxuICBfZ2V0UHhWYWx1ZSh0KSB7XG4gICAgcmV0dXJuIHQgPyBwYXJzZUZsb2F0KHQpIDogMDtcbiAgfVxuICBfaGFuZGxlU3dpcGUodCwgZSkge1xuICAgIGUgJiYgdGhpcy5fc2xpbUNvbGxhcHNlZCAmJiB0aGlzLm9wdGlvbnMuc2lkZW5hdlNsaW0gJiYgdGhpcy5vcHRpb25zLnNpZGVuYXZFeHBhbmRhYmxlID8gdGhpcy50b2dnbGVTbGltKCkgOiBlIHx8ICh0aGlzLl9zbGltQ29sbGFwc2VkIHx8ICF0aGlzLm9wdGlvbnMuc2lkZW5hdlNsaW0gfHwgIXRoaXMub3B0aW9ucy5zaWRlbmF2RXhwYW5kYWJsZSA/IHRoaXMudG9nZ2xlciAmJiBOdCh0aGlzLnRvZ2dsZXIpICYmIHRoaXMudG9nZ2xlKCkgOiB0aGlzLnRvZ2dsZVNsaW0oKSk7XG4gIH1cbiAgX2lzQWN0aXZlKHQsIGUpIHtcbiAgICByZXR1cm4gZSA/IGUgPT09IHQgOiB0LmF0dHJpYnV0ZXMuaHJlZiA/IG5ldyBVUkwodCwgd2luZG93LmxvY2F0aW9uLmhyZWYpLmhyZWYgPT09IHdpbmRvdy5sb2NhdGlvbi5ocmVmIDogITE7XG4gIH1cbiAgX2lzQWxsVG9CZUNvbGxhcHNlZCgpIHtcbiAgICByZXR1cm4gZC5maW5kKFxuICAgICAgY2csXG4gICAgICB0aGlzLl9lbGVtZW50XG4gICAgKS5maWx0ZXIoXG4gICAgICAoaSkgPT4gaS5nZXRBdHRyaWJ1dGUoXCJhcmlhLWV4cGFuZGVkXCIpID09PSBcInRydWVcIlxuICAgICkubGVuZ3RoID09PSAwO1xuICB9XG4gIF9pc0FsbENvbGxhcHNlZCgpIHtcbiAgICByZXR1cm4gZC5maW5kKE9lLCB0aGlzLl9lbGVtZW50KS5maWx0ZXIoXG4gICAgICAodCkgPT4gTnQodClcbiAgICApLmxlbmd0aCA9PT0gMDtcbiAgfVxuICBfaW5pdGlhbGl6ZUJhY2tEcm9wKCkge1xuICAgIGlmICghdGhpcy5vcHRpb25zLnNpZGVuYXZCYWNrZHJvcClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB0ID0gdGhpcy5vcHRpb25zLnNpZGVuYXZCYWNrZHJvcENsYXNzID8gdGhpcy5vcHRpb25zLnNpZGVuYXZCYWNrZHJvcENsYXNzLnNwbGl0KFwiIFwiKSA6IHRoaXMub3B0aW9ucy5zaWRlbmF2UG9zaXRpb24gPyBbXG4gICAgICBcIm9wYWNpdHktNTBcIixcbiAgICAgIFwidHJhbnNpdGlvbi1hbGxcIixcbiAgICAgIFwiZHVyYXRpb24tMzAwXCIsXG4gICAgICBcImVhc2UtaW4tb3V0XCIsXG4gICAgICB0aGlzLm9wdGlvbnMuc2lkZW5hdlBvc2l0aW9uLFxuICAgICAgXCJ0b3AtMFwiLFxuICAgICAgXCJsZWZ0LTBcIixcbiAgICAgIFwiei01MFwiLFxuICAgICAgXCJiZy1ibGFjay8xMFwiLFxuICAgICAgXCJkYXJrOmJnLWJsYWNrLTYwXCIsXG4gICAgICBcInctZnVsbFwiLFxuICAgICAgXCJoLWZ1bGxcIixcbiAgICAgIHRoaXMuX2VsZW1lbnQuaWRcbiAgICBdIDogbnVsbDtcbiAgICByZXR1cm4gbmV3IGhyKHtcbiAgICAgIGlzVmlzaWJsZTogdGhpcy5vcHRpb25zLnNpZGVuYXZCYWNrZHJvcCxcbiAgICAgIGlzQW5pbWF0ZWQ6ICEwLFxuICAgICAgcm9vdEVsZW1lbnQ6IHRoaXMuX2VsZW1lbnQucGFyZW50Tm9kZSxcbiAgICAgIGJhY2tkcm9wQ2xhc3NlczogdCxcbiAgICAgIGNsaWNrQ2FsbGJhY2s6ICgpID0+IHRoaXMuaGlkZSgpXG4gICAgfSk7XG4gIH1cbiAgX3VwZGF0ZUJhY2tkcm9wKHQpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLnNpZGVuYXZNb2RlID09PSBcIm92ZXJcIikge1xuICAgICAgdCA/IHRoaXMuX2JhY2tkcm9wLnNob3coKSA6IHRoaXMuaXNCYWNrZHJvcFZpc2libGUgJiYgdGhpcy5fYmFja2Ryb3AuaGlkZSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmlzQmFja2Ryb3BWaXNpYmxlICYmIHRoaXMuX2JhY2tkcm9wLmhpZGUoKTtcbiAgfVxuICBfc2V0dXAoKSB7XG4gICAgdGhpcy5fc2V0dXBUb3VjaCgpLCB0aGlzLm9wdGlvbnMuc2lkZW5hdkZvY3VzVHJhcCAmJiB0aGlzLl9zZXR1cEZvY3VzVHJhcCgpLCB0aGlzLl9zZXR1cENvbGxhcHNlKCksIHRoaXMub3B0aW9ucy5zaWRlbmF2U2xpbSAmJiB0aGlzLl9zZXR1cFNsaW0oKSwgdGhpcy5fc2V0dXBJbml0aWFsU3R5bGluZygpLCB0aGlzLl9zZXR1cFNjcm9sbGluZygpLCB0aGlzLm9wdGlvbnMuc2lkZW5hdkNvbnRlbnQgJiYgdGhpcy5fc2V0dXBDb250ZW50KCksIHRoaXMuX3NldHVwQWN0aXZlU3RhdGUoKSwgdGhpcy5fc2V0dXBSaXBwbGVFZmZlY3QoKSwgdGhpcy5vcHRpb25zLnNpZGVuYXZIaWRkZW4gfHwgdGhpcy5fdXBkYXRlT2Zmc2V0cyghMCwgITApLCB0aGlzLm9wdGlvbnMuc2lkZW5hdk1vZGUgPT09IFwib3ZlclwiICYmIHRoaXMuX3NldFRhYmluZGV4KCEwKTtcbiAgfVxuICBfc2V0dXBBY3RpdmVTdGF0ZSgpIHtcbiAgICB0aGlzLl9zZXRBY3RpdmVFbGVtZW50cygpLCB0aGlzLmxpbmtzLmZvckVhY2goKHQpID0+IHtcbiAgICAgIGMub24odCwgXCJjbGlja1wiLCAoKSA9PiB0aGlzLl9zZXRBY3RpdmVFbGVtZW50cyh0KSksIGMub24odCwgXCJrZXlkb3duXCIsIChlKSA9PiB7XG4gICAgICAgIGUua2V5Q29kZSA9PT0gY3QgJiYgdGhpcy5fc2V0QWN0aXZlRWxlbWVudHModCk7XG4gICAgICB9KTtcbiAgICB9KSwgYy5vbih3aW5kb3csIFwiaGFzaGNoYW5nZVwiLCB0aGlzLmhhc2hIYW5kbGVyKTtcbiAgfVxuICBfc2V0dXBDb2xsYXBzZSgpIHtcbiAgICB0aGlzLm5hdmlnYXRpb24uZm9yRWFjaCgodCwgZSkgPT4ge1xuICAgICAgZC5maW5kKE9lLCB0KS5mb3JFYWNoKFxuICAgICAgICAobiwgbykgPT4gdGhpcy5fc2V0dXBDb2xsYXBzZUxpc3QoeyBsaXN0OiBuLCBpbmRleDogbywgbWVudTogdCwgbWVudUluZGV4OiBlIH0pXG4gICAgICApO1xuICAgIH0pO1xuICB9XG4gIF9nZW5lcmF0ZUNvbGxwYXNlSUQodCwgZSkge1xuICAgIHJldHVybiBgc2lkZW5hdi1jb2xsYXBzZS0ke3RoaXMuX0lEfS0ke2V9LSR7dH1gO1xuICB9XG4gIF9zZXR1cENvbGxhcHNlTGlzdCh7IGxpc3Q6IHQsIGluZGV4OiBlLCBtZW51OiBpLCBtZW51SW5kZXg6IG4gfSkge1xuICAgIGNvbnN0IG8gPSB0aGlzLl9nZW5lcmF0ZUNvbGxwYXNlSUQoZSwgbik7XG4gICAgdC5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBvKSwgdC5zZXRBdHRyaWJ1dGUoXCJkYXRhLXRlLWNvbGxhcHNlLWl0ZW1cIiwgXCJcIik7XG4gICAgY29uc3QgW3JdID0gZC5wcmV2KHQsIHVpKTtcbiAgICBoLnNldERhdGFBdHRyaWJ1dGUociwgXCJjb2xsYXBzZS1pbml0XCIsIFwiXCIpLCByLnNldEF0dHJpYnV0ZShcImhyZWZcIiwgYCMke299YCksIHIuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcImJ1dHRvblwiKTtcbiAgICBjb25zdCBhID0gWnQuZ2V0SW5zdGFuY2UodCkgfHwgbmV3IFp0KHQsIHtcbiAgICAgIHRvZ2dsZTogITEsXG4gICAgICBwYXJlbnQ6IHRoaXMub3B0aW9ucy5zaWRlbmF2QWNjb3JkaW9uID8gaSA6IHRcbiAgICB9KTtcbiAgICAodC5kYXRhc2V0LnRlU2lkZW5hdlN0YXRlU2hvdyA9PT0gXCJcIiB8fCB0LmRhdGFzZXQudGVDb2xsYXBzZVNob3cgPT09IFwiXCIpICYmIHRoaXMuX3JvdGF0ZUFycm93KHIsICExKSwgYy5vbihyLCBcImNsaWNrXCIsIChsKSA9PiB7XG4gICAgICB0aGlzLl90b2dnbGVDYXRlZ29yeShsLCBhLCB0KSwgdGhpcy5fdGVtcFNsaW0gJiYgdGhpcy5faXNBbGxUb0JlQ29sbGFwc2VkKCkgJiYgKHRoaXMuX3NldFNsaW0oITApLCB0aGlzLl90ZW1wU2xpbSA9ICExKSwgdGhpcy5vcHRpb25zLnNpZGVuYXZNb2RlID09PSBcIm92ZXJcIiAmJiB0aGlzLl9mb2N1c1RyYXAgJiYgdGhpcy5fZm9jdXNUcmFwLnVwZGF0ZSgpO1xuICAgIH0pLCBjLm9uKFxuICAgICAgdCxcbiAgICAgIFwic2hvdy50ZS5jb2xsYXBzZVwiLFxuICAgICAgKCkgPT4gdGhpcy5fcm90YXRlQXJyb3cociwgITEpXG4gICAgKSwgYy5vbihcbiAgICAgIHQsXG4gICAgICBcImhpZGUudGUuY29sbGFwc2VcIixcbiAgICAgICgpID0+IHRoaXMuX3JvdGF0ZUFycm93KHIsICEwKVxuICAgICksIGMub24odCwgXCJzaG93bi50ZS5jb2xsYXBzZVwiLCAoKSA9PiB7XG4gICAgICB0aGlzLm9wdGlvbnMuc2lkZW5hdk1vZGUgPT09IFwib3ZlclwiICYmIHRoaXMuX2ZvY3VzVHJhcCAmJiB0aGlzLl9mb2N1c1RyYXAudXBkYXRlKCk7XG4gICAgfSksIGMub24odCwgXCJoaWRkZW4udGUuY29sbGFwc2VcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5fdGVtcFNsaW0gJiYgdGhpcy5faXNBbGxDb2xsYXBzZWQoKSAmJiAodGhpcy5fc2V0U2xpbSghMCksIHRoaXMuX3RlbXBTbGltID0gITEpLCB0aGlzLm9wdGlvbnMuc2lkZW5hdk1vZGUgPT09IFwib3ZlclwiICYmIHRoaXMuX2ZvY3VzVHJhcCAmJiB0aGlzLl9mb2N1c1RyYXAudXBkYXRlKCk7XG4gICAgfSk7XG4gIH1cbiAgX3NldHVwQ29udGVudCgpIHtcbiAgICB0aGlzLl9jb250ZW50ID0gZC5maW5kKHRoaXMub3B0aW9ucy5zaWRlbmF2Q29udGVudCksIHRoaXMuX2NvbnRlbnQuZm9yRWFjaCgodCkgPT4ge1xuICAgICAgY29uc3QgZSA9IFtcbiAgICAgICAgXCIhcFwiLFxuICAgICAgICBcIiFtXCIsXG4gICAgICAgIFwiIXB4XCIsXG4gICAgICAgIFwiIXBsXCIsXG4gICAgICAgIFwiIXByXCIsXG4gICAgICAgIFwiIW14XCIsXG4gICAgICAgIFwiIW1sXCIsXG4gICAgICAgIFwiIW1yXCIsXG4gICAgICAgIFwiIS1wXCIsXG4gICAgICAgIFwiIS1tXCIsXG4gICAgICAgIFwiIS1weFwiLFxuICAgICAgICBcIiEtcGxcIixcbiAgICAgICAgXCIhLXByXCIsXG4gICAgICAgIFwiIS1teFwiLFxuICAgICAgICBcIiEtbWxcIixcbiAgICAgICAgXCIhLW1yXCJcbiAgICAgIF07XG4gICAgICBbLi4udC5jbGFzc0xpc3RdLmZpbHRlcihcbiAgICAgICAgKG4pID0+IGUuZmluZEluZGV4KChvKSA9PiBuLmluY2x1ZGVzKG8pKSA+PSAwXG4gICAgICApLmZvckVhY2goKG4pID0+IHQuY2xhc3NMaXN0LnJlbW92ZShuKSk7XG4gICAgfSksIHRoaXMuX2luaXRpYWxDb250ZW50U3R5bGUgPSB0aGlzLl9jb250ZW50Lm1hcCgodCkgPT4ge1xuICAgICAgY29uc3QgeyBwYWRkaW5nTGVmdDogZSwgcGFkZGluZ1JpZ2h0OiBpLCBtYXJnaW5MZWZ0OiBuLCBtYXJnaW5SaWdodDogbywgdHJhbnNpdGlvbjogciB9ID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUodCk7XG4gICAgICByZXR1cm4geyBwYWRkaW5nTGVmdDogZSwgcGFkZGluZ1JpZ2h0OiBpLCBtYXJnaW5MZWZ0OiBuLCBtYXJnaW5SaWdodDogbywgdHJhbnNpdGlvbjogciB9O1xuICAgIH0pO1xuICB9XG4gIF9zZXR1cEZvY3VzVHJhcCgpIHtcbiAgICB0aGlzLl9mb2N1c1RyYXAgPSBuZXcgV2koXG4gICAgICB0aGlzLl9lbGVtZW50LFxuICAgICAge1xuICAgICAgICBldmVudDogXCJrZXlkb3duXCIsXG4gICAgICAgIGNvbmRpdGlvbjogKHQpID0+IHQua2V5Q29kZSA9PT0gUGksXG4gICAgICAgIG9ubHlWaXNpYmxlOiAhMFxuICAgICAgfSxcbiAgICAgIHRoaXMudG9nZ2xlclxuICAgICk7XG4gIH1cbiAgX3NldHVwSW5pdGlhbFN0eWxpbmcoKSB7XG4gICAgdGhpcy5fc2V0Q29sb3IoKSwgaC5zdHlsZSh0aGlzLl9lbGVtZW50LCB0aGlzLnNpZGVuYXZTdHlsZSk7XG4gIH1cbiAgX3NldHVwU2Nyb2xsaW5nKCkge1xuICAgIGxldCB0ID0gdGhpcy5fZWxlbWVudDtcbiAgICBpZiAodGhpcy5vcHRpb25zLnNpZGVuYXZTY3JvbGxDb250YWluZXIpIHtcbiAgICAgIHQgPSBkLmZpbmRPbmUoXG4gICAgICAgIHRoaXMub3B0aW9ucy5zaWRlbmF2U2Nyb2xsQ29udGFpbmVyLFxuICAgICAgICB0aGlzLl9lbGVtZW50XG4gICAgICApO1xuICAgICAgY29uc3QgaSA9IEtoKHQucGFyZW50Tm9kZS5jaGlsZHJlbikuZmlsdGVyKFxuICAgICAgICAobikgPT4gbiAhPT0gdFxuICAgICAgKS5yZWR1Y2UoKG4sIG8pID0+IG4gKyBvLmNsaWVudEhlaWdodCwgMCk7XG4gICAgICBoLnN0eWxlKHQsIHtcbiAgICAgICAgbWF4SGVpZ2h0OiBgY2FsYygxMDAlIC0gJHtpfXB4KWAsXG4gICAgICAgIHBvc2l0aW9uOiBcInJlbGF0aXZlXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLl9wZXJmZWN0U2Nyb2xsYmFyID0gbmV3IG1oKHQsIHtcbiAgICAgIHN1cHByZXNzU2Nyb2xsWDogITAsXG4gICAgICBoYW5kbGVyczogW1wiY2xpY2stcmFpbFwiLCBcImRyYWctdGh1bWJcIiwgXCJ3aGVlbFwiLCBcInRvdWNoXCJdXG4gICAgfSk7XG4gIH1cbiAgX3NldHVwU2xpbSgpIHtcbiAgICB0aGlzLl9zbGltQ29sbGFwc2VkID0gdGhpcy5vcHRpb25zLnNpZGVuYXZTbGltQ29sbGFwc2VkLCB0aGlzLl90b2dnbGVTbGltRGlzcGxheSh0aGlzLl9zbGltQ29sbGFwc2VkKSwgdGhpcy5vcHRpb25zLnNpZGVuYXZFeHBhbmRPbkhvdmVyICYmICh0aGlzLl9lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWVudGVyXCIsICgpID0+IHtcbiAgICAgIHRoaXMuX3NsaW1Db2xsYXBzZWQgJiYgdGhpcy5fc2V0U2xpbSghMSk7XG4gICAgfSksIHRoaXMuX2VsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbGVhdmVcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5fc2xpbUNvbGxhcHNlZCB8fCB0aGlzLl9zZXRTbGltKCEwKTtcbiAgICB9KSk7XG4gIH1cbiAgX3NldHVwUmlwcGxlRWZmZWN0KCkge1xuICAgIHRoaXMubGlua3MuZm9yRWFjaCgodCkgPT4ge1xuICAgICAgbGV0IGUgPSBaZS5nZXRJbnN0YW5jZSh0KSwgaSA9IHRoaXMub3B0aW9ucy5zaWRlbmF2Q29sb3I7XG4gICAgICBpZiAoZSAmJiBlLl9vcHRpb25zLnNpZGVuYXZDb2xvciAhPT0gdGhpcy5vcHRpb25zLnNpZGVuYXZDb2xvcilcbiAgICAgICAgZS5kaXNwb3NlKCk7XG4gICAgICBlbHNlIGlmIChlKVxuICAgICAgICByZXR1cm47XG4gICAgICAobG9jYWxTdG9yYWdlLnRoZW1lID09PSBcImRhcmtcIiB8fCAhKFwidGhlbWVcIiBpbiBsb2NhbFN0b3JhZ2UpICYmIHdpbmRvdy5tYXRjaE1lZGlhKFwiKHByZWZlcnMtY29sb3Itc2NoZW1lOiBkYXJrKVwiKS5tYXRjaGVzKSAmJiAoaSA9IFwid2hpdGVcIiksIGUgPSBuZXcgWmUodCwgeyByaXBwbGVDb2xvcjogaSB9KTtcbiAgICB9KTtcbiAgfVxuICBfc2V0dXBUb3VjaCgpIHtcbiAgICB0aGlzLl90b3VjaCA9IG5ldyBhZyh0aGlzLl9lbGVtZW50LCBcInN3aXBlXCIsIHsgdGhyZXNob2xkOiAyMCB9KSwgdGhpcy5fdG91Y2guaW5pdCgpLCBjLm9uKFxuICAgICAgdGhpcy5fZWxlbWVudCxcbiAgICAgIFwic3dpcGVsZWZ0XCIsXG4gICAgICAodCkgPT4gdGhpcy5faGFuZGxlU3dpcGUodCwgdGhpcy5vcHRpb25zLnNpZGVuYXZSaWdodClcbiAgICApLCBjLm9uKFxuICAgICAgdGhpcy5fZWxlbWVudCxcbiAgICAgIFwic3dpcGVyaWdodFwiLFxuICAgICAgKHQpID0+IHRoaXMuX2hhbmRsZVN3aXBlKHQsICF0aGlzLm9wdGlvbnMuc2lkZW5hdlJpZ2h0KVxuICAgICk7XG4gIH1cbiAgX3NldEFjdGl2ZSh0LCBlKSB7XG4gICAgdC5zZXRBdHRyaWJ1dGUoXCJkYXRhLXRlLXNpZGViYXItc3RhdGUtYWN0aXZlXCIsIFwiXCIpLCB0aGlzLl9hY3RpdmVOb2RlICYmIHQucmVtb3ZlQXR0cmlidXRlKFwiZGF0YS10ZS1zaWRlYmFyLXN0YXRlLWFjdGl2ZVwiKSwgdGhpcy5fYWN0aXZlTm9kZSA9IHQ7XG4gICAgY29uc3QgW2ldID0gZC5wYXJlbnRzKFxuICAgICAgdGhpcy5fYWN0aXZlTm9kZSxcbiAgICAgIE9lXG4gICAgKTtcbiAgICBpZiAoIWkpIHtcbiAgICAgIHRoaXMuX3NldEFjdGl2ZUNhdGVnb3J5KCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IFtuXSA9IGQucHJldihpLCB1aSk7XG4gICAgdGhpcy5fc2V0QWN0aXZlQ2F0ZWdvcnkobiksICFlICYmICF0aGlzLl9zbGltQ29sbGFwc2VkICYmIFp0LmdldEluc3RhbmNlKGkpLnNob3coKTtcbiAgfVxuICBfc2V0QWN0aXZlQ2F0ZWdvcnkodCkge1xuICAgIHRoaXMubmF2aWdhdGlvbi5mb3JFYWNoKChlKSA9PiB7XG4gICAgICBkLmZpbmQoT2UsIGUpLmZvckVhY2goKG4pID0+IHtcbiAgICAgICAgY29uc3QgW29dID0gZC5wcmV2KG4sIHVpKTtcbiAgICAgICAgbyAhPT0gdCA/IG8ucmVtb3ZlQXR0cmlidXRlKFwiZGF0YS10ZS1zaWRlbmF2LXN0YXRlLWFjdGl2ZVwiKSA6IG8uc2V0QXR0cmlidXRlKFwiZGF0YS10ZS1zaWRlbmF2LXN0YXRlLWFjdGl2ZVwiLCBcIlwiKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIF9zZXRBY3RpdmVFbGVtZW50cyh0KSB7XG4gICAgdGhpcy5uYXZpZ2F0aW9uLmZvckVhY2goKGUpID0+IHtcbiAgICAgIGQuZmluZCh1aSwgZSkuZmlsdGVyKChuKSA9PiBkLm5leHQobiwgT2UpLmxlbmd0aCA9PT0gMCkuZm9yRWFjaCgobikgPT4ge1xuICAgICAgICB0aGlzLl9pc0FjdGl2ZShuLCB0KSAmJiBuICE9PSB0aGlzLl9hY3RpdmVOb2RlICYmIHRoaXMuX3NldEFjdGl2ZShuLCB0KTtcbiAgICAgIH0pO1xuICAgIH0pLCB0ICYmIHRoaXMuX3VwZGF0ZUZvY3VzKHRoaXMuaXNWaXNpYmxlKTtcbiAgfVxuICBfc2V0Q29sb3IoKSB7XG4gICAgY29uc3QgdCA9IFtcbiAgICAgIFwicHJpbWFyeVwiLFxuICAgICAgXCJzZWNvbmRhcnlcIixcbiAgICAgIFwic3VjY2Vzc1wiLFxuICAgICAgXCJpbmZvXCIsXG4gICAgICBcIndhcm5pbmdcIixcbiAgICAgIFwiZGFuZ2VyXCIsXG4gICAgICBcImxpZ2h0XCIsXG4gICAgICBcImRhcmtcIlxuICAgIF0sIHsgc2lkZW5hdkNvbG9yOiBlIH0gPSB0aGlzLm9wdGlvbnMsIGkgPSB0LmluY2x1ZGVzKGUpID8gZSA6IFwicHJpbWFyeVwiO1xuICAgIHQuZm9yRWFjaCgobikgPT4ge1xuICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKGBzaWRlbmF2LSR7bn1gKTtcbiAgICB9KSwgaC5hZGRDbGFzcyh0aGlzLl9lbGVtZW50LCBgc2lkZW5hdi0ke2l9YCk7XG4gIH1cbiAgX3NldENvbnRlbnRPZmZzZXRzKHQsIGUsIGkpIHtcbiAgICB0aGlzLl9jb250ZW50LmZvckVhY2goKG4sIG8pID0+IHtcbiAgICAgIGNvbnN0IHIgPSB0aGlzLl9nZXRPZmZzZXRWYWx1ZSh0LCB7XG4gICAgICAgIGluZGV4OiBvLFxuICAgICAgICBwcm9wZXJ0eTogXCJwYWRkaW5nXCIsXG4gICAgICAgIG9mZnNldHM6IGVcbiAgICAgIH0pLCBhID0gdGhpcy5fZ2V0T2Zmc2V0VmFsdWUodCwge1xuICAgICAgICBpbmRleDogbyxcbiAgICAgICAgcHJvcGVydHk6IFwibWFyZ2luXCIsXG4gICAgICAgIG9mZnNldHM6IGVcbiAgICAgIH0pLCBsID0ge307XG4gICAgICBpZiAoaSB8fCAobC50cmFuc2l0aW9uID0gYGFsbCAke3RoaXMudHJhbnNpdGlvbkR1cmF0aW9ufSBsaW5lYXJgKSwgbFtlLnBhZGRpbmcucHJvcGVydHldID0gYCR7cn1weGAsIGxbZS5tYXJnaW4ucHJvcGVydHldID0gYCR7YX1weGAsIGguc3R5bGUobiwgbCksICEhdCkge1xuICAgICAgICBpZiAoaSkge1xuICAgICAgICAgIGguc3R5bGUobiwge1xuICAgICAgICAgICAgdHJhbnNpdGlvbjogdGhpcy5faW5pdGlhbENvbnRlbnRTdHlsZVtvXS50cmFuc2l0aW9uXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGMub24obiwgXCJ0cmFuc2l0aW9uZW5kXCIsICgpID0+IHtcbiAgICAgICAgICBoLnN0eWxlKG4sIHtcbiAgICAgICAgICAgIHRyYW5zaXRpb246IHRoaXMuX2luaXRpYWxDb250ZW50U3R5bGVbb10udHJhbnNpdGlvblxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBfc2V0TW9kZSh0KSB7XG4gICAgdGhpcy5vcHRpb25zLnNpZGVuYXZNb2RlICE9PSB0ICYmICh0aGlzLl9vcHRpb25zLnNpZGVuYXZNb2RlID0gdCwgdGhpcy5fdXBkYXRlKHRoaXMuaXNWaXNpYmxlKSk7XG4gIH1cbiAgX3NldFNsaW0odCkge1xuICAgIGNvbnN0IGUgPSB0ID8gW1wiY29sbGFwc2VcIiwgXCJjb2xsYXBzZWRcIl0gOiBbXCJleHBhbmRcIiwgXCJleHBhbmRlZFwiXTtcbiAgICB0aGlzLl90cmlnZ2VyRXZlbnRzKC4uLmUpLCB0ICYmIHRoaXMuX2NvbGxhcHNlSXRlbXMoKSwgdGhpcy5fc2xpbUNvbGxhcHNlZCA9IHQsIHRoaXMuX3RvZ2dsZVNsaW1EaXNwbGF5KHQpLCBoLnN0eWxlKHRoaXMuX2VsZW1lbnQsIHsgd2lkdGg6IGAke3RoaXMud2lkdGh9cHhgIH0pLCB0aGlzLl91cGRhdGVPZmZzZXRzKHRoaXMuaXNWaXNpYmxlKTtcbiAgfVxuICBfc2V0VGFiaW5kZXgodCkge1xuICAgIHRoaXMubGlua3MuZm9yRWFjaCgoZSkgPT4ge1xuICAgICAgZS50YWJJbmRleCA9IHQgPyAwIDogLTE7XG4gICAgfSk7XG4gIH1cbiAgX2VtaXRFdmVudHModCkge1xuICAgIGNvbnN0IGUgPSB0ID8gW1wic2hvd1wiLCBcInNob3duXCJdIDogW1wiaGlkZVwiLCBcImhpZGRlblwiXTtcbiAgICB0aGlzLl90cmlnZ2VyRXZlbnRzKC4uLmUpO1xuICB9XG4gIF9yb3RhdGVBcnJvdyh0LCBlKSB7XG4gICAgY29uc3QgW2ldID0gZC5jaGlsZHJlbih0LCBgWyR7bGd9XWApO1xuICAgIGkgJiYgKGUgPyBoLnJlbW92ZUNsYXNzKGksIFwicm90YXRlLTE4MFwiKSA6IGguYWRkQ2xhc3MoaSwgXCJyb3RhdGUtMTgwXCIpKTtcbiAgfVxuICBfdG9nZ2xlQ2F0ZWdvcnkodCwgZSkge1xuICAgIHQucHJldmVudERlZmF1bHQoKSwgZS50b2dnbGUoKSwgdGhpcy5fc2xpbUNvbGxhcHNlZCAmJiB0aGlzLm9wdGlvbnMuc2lkZW5hdkV4cGFuZGFibGUgJiYgKHRoaXMuX3RlbXBTbGltID0gITAsIHRoaXMuX3NldFNsaW0oITEpKTtcbiAgfVxuICBfdG9nZ2xlU2xpbURpc3BsYXkodCkge1xuICAgIGNvbnN0IGUgPSBkLmZpbmQoXG4gICAgICBoZyxcbiAgICAgIHRoaXMuX2VsZW1lbnRcbiAgICApLCBpID0gZC5maW5kKFxuICAgICAgZGcsXG4gICAgICB0aGlzLl9lbGVtZW50XG4gICAgKSwgbiA9ICgpID0+IHtcbiAgICAgIGUuZm9yRWFjaCgobykgPT4ge1xuICAgICAgICBoLnN0eWxlKG8sIHtcbiAgICAgICAgICBkaXNwbGF5OiB0aGlzLl9zbGltQ29sbGFwc2VkID8gXCJ1bnNldFwiIDogXCJub25lXCJcbiAgICAgICAgfSk7XG4gICAgICB9KSwgaS5mb3JFYWNoKChvKSA9PiB7XG4gICAgICAgIGguc3R5bGUobywge1xuICAgICAgICAgIGRpc3BsYXk6IHRoaXMuX3NsaW1Db2xsYXBzZWQgPyBcIm5vbmVcIiA6IFwidW5zZXRcIlxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgdCA/IHNldFRpbWVvdXQoXG4gICAgICAoKSA9PiBuKCksXG4gICAgICB0aGlzLm9wdGlvbnMuc2lkZW5hdlRyYW5zaXRpb25EdXJhdGlvblxuICAgICkgOiBuKCk7XG4gIH1cbiAgYXN5bmMgX3RyaWdnZXJFdmVudHModCwgZSkge1xuICAgIGMudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBgJHt0fS50ZS5zaWRlbmF2YCksIGUgJiYgYXdhaXQgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBjLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgYCR7ZX0udGUuc2lkZW5hdmApO1xuICAgIH0sIHRoaXMub3B0aW9ucy5zaWRlbmF2VHJhbnNpdGlvbkR1cmF0aW9uICsgNSk7XG4gIH1cbiAgX2lzaVBob25lKCkge1xuICAgIHJldHVybiAvaVBob25lfGlQb2QvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuICB9XG4gIF91cGRhdGUodCkge1xuICAgIHQgJiYgdGhpcy5faXNpUGhvbmUoKSAmJiBoLmFkZENsYXNzKHRoaXMuX2VsZW1lbnQsIFwicHMtLXNjcm9sbGluZy15XCIpLCB0aGlzLnRvZ2dsZXIgJiYgdGhpcy5fdXBkYXRlVG9nZ2xlckFyaWEodCksIHRoaXMuX3VwZGF0ZURpc3BsYXkodCksIHRoaXMub3B0aW9ucy5zaWRlbmF2QmFja2Ryb3AgJiYgdGhpcy5fdXBkYXRlQmFja2Ryb3AodCksIHRoaXMuX3VwZGF0ZU9mZnNldHModCksIHQgJiYgdGhpcy5vcHRpb25zLnNpZGVuYXZDbG9zZU9uRXNjICYmIHRoaXMub3B0aW9ucy5zaWRlbmF2TW9kZSAhPT0gXCJzaWRlXCIgJiYgYy5vbih3aW5kb3csIFwia2V5ZG93blwiLCB0aGlzLmVzY0hhbmRsZXIpLCB0aGlzLm9wdGlvbnMuc2lkZW5hdkZvY3VzVHJhcCAmJiB0aGlzLl91cGRhdGVGb2N1cyh0KTtcbiAgfVxuICBfdXBkYXRlRGlzcGxheSh0KSB7XG4gICAgY29uc3QgZSA9IHQgPyAwIDogdGhpcy50cmFuc2xhdGlvbjtcbiAgICBoLnN0eWxlKHRoaXMuX2VsZW1lbnQsIHtcbiAgICAgIHRyYW5zZm9ybTogYHRyYW5zbGF0ZVgoJHtlfSUpYFxuICAgIH0pO1xuICB9XG4gIF91cGRhdGVGb2N1cyh0KSB7XG4gICAgaWYgKHRoaXMuX3NldFRhYmluZGV4KHQpLCB0aGlzLm9wdGlvbnMuc2lkZW5hdk1vZGUgPT09IFwib3ZlclwiICYmIHRoaXMub3B0aW9ucy5zaWRlbmF2Rm9jdXNUcmFwKSB7XG4gICAgICBpZiAodCkge1xuICAgICAgICB0aGlzLl9mb2N1c1RyYXAudHJhcCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLl9mb2N1c1RyYXAuZGlzYWJsZSgpO1xuICAgIH1cbiAgICB0aGlzLl9mb2N1c1RyYXAuZGlzYWJsZSgpO1xuICB9XG4gIF91cGRhdGVPZmZzZXRzKHQsIGUgPSAhMSkge1xuICAgIGNvbnN0IFtpLCBuXSA9IHRoaXMub3B0aW9ucy5zaWRlbmF2UmlnaHQgPyBbXCJyaWdodFwiLCBcImxlZnRcIl0gOiBbXCJsZWZ0XCIsIFwicmlnaHRcIl0sIG8gPSB7XG4gICAgICBwcm9wZXJ0eTogdGhpcy5fZ2V0UHJvcGVydHkoXCJwYWRkaW5nXCIsIGkpLFxuICAgICAgdmFsdWU6IHRoaXMub3B0aW9ucy5zaWRlbmF2TW9kZSA9PT0gXCJvdmVyXCIgPyAwIDogdGhpcy53aWR0aFxuICAgIH0sIHIgPSB7XG4gICAgICBwcm9wZXJ0eTogdGhpcy5fZ2V0UHJvcGVydHkoXCJtYXJnaW5cIiwgbiksXG4gICAgICB2YWx1ZTogdGhpcy5vcHRpb25zLnNpZGVuYXZNb2RlID09PSBcInB1c2hcIiA/IC0xICogdGhpcy53aWR0aCA6IDBcbiAgICB9O1xuICAgIGMudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBcInVwZGF0ZS50ZS5zaWRlbmF2XCIsIHtcbiAgICAgIG1hcmdpbjogcixcbiAgICAgIHBhZGRpbmc6IG9cbiAgICB9KSwgdGhpcy5fY29udGVudCAmJiAodGhpcy5fY29udGVudC5jbGFzc05hbWUgPSBcIlwiLCB0aGlzLl9zZXRDb250ZW50T2Zmc2V0cyh0LCB7IHBhZGRpbmc6IG8sIG1hcmdpbjogciB9LCBlKSk7XG4gIH1cbiAgX3VwZGF0ZVRvZ2dsZXJBcmlhKHQpIHtcbiAgICB0aGlzLnRvZ2dsZXIuc2V0QXR0cmlidXRlKFwiYXJpYS1leHBhbmRlZFwiLCB0KTtcbiAgfVxuICAvLyBTdGF0aWNcbiAgc3RhdGljIHRvZ2dsZVNpZGVuYXYoKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgIGNvbnN0IGUgPSBkLmNsb3Nlc3QodC50YXJnZXQsIG5vKSwgaSA9IGguZ2V0RGF0YUF0dHJpYnV0ZXMoZSkudGFyZ2V0O1xuICAgICAgZC5maW5kKGkpLmZvckVhY2goKG4pID0+IHtcbiAgICAgICAgKGdpLmdldEluc3RhbmNlKG4pIHx8IG5ldyBnaShuKSkudG9nZ2xlKCk7XG4gICAgICB9KTtcbiAgICB9O1xuICB9XG4gIHN0YXRpYyBqUXVlcnlJbnRlcmZhY2UodCwgZSkge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICBsZXQgaSA9IHkuZ2V0RGF0YSh0aGlzLCBUcyk7XG4gICAgICBjb25zdCBuID0gdHlwZW9mIHQgPT0gXCJvYmplY3RcIiAmJiB0O1xuICAgICAgaWYgKCEoIWkgJiYgL2Rpc3Bvc2UvLnRlc3QodCkpICYmIChpIHx8IChpID0gbmV3IGdpKHRoaXMsIG4pKSwgdHlwZW9mIHQgPT0gXCJzdHJpbmdcIikpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpW3RdID4gXCJ1XCIpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFwiJHt0fVwiYCk7XG4gICAgICAgIGlbdF0oZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgc3RhdGljIGdldEluc3RhbmNlKHQpIHtcbiAgICByZXR1cm4geS5nZXREYXRhKHQsIFRzKTtcbiAgfVxuICBzdGF0aWMgZ2V0T3JDcmVhdGVJbnN0YW5jZSh0LCBlID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5nZXRJbnN0YW5jZSh0KSB8fCBuZXcgdGhpcyh0LCB0eXBlb2YgZSA9PSBcIm9iamVjdFwiID8gZSA6IG51bGwpO1xuICB9XG59XG5jb25zdCBIbyA9IFwic3RlcHBlclwiLCBYcyA9IFwidGUuc3RlcHBlclwiLCBwbiA9IGAuJHtYc31gLCBZaSA9IGBkYXRhLXRlLSR7SG99YCwgYmkgPSBcImhvcml6b250YWxcIiwgeHQgPSBcInZlcnRpY2FsXCIsIGdnID0ge1xuICBzdGVwcGVyVHlwZTogXCJzdHJpbmdcIixcbiAgc3RlcHBlckxpbmVhcjogXCJib29sZWFuXCIsXG4gIHN0ZXBwZXJOb0VkaXRhYmxlOiBcImJvb2xlYW5cIixcbiAgc3RlcHBlckFjdGl2ZTogXCJzdHJpbmdcIixcbiAgc3RlcHBlckNvbXBsZXRlZDogXCJzdHJpbmdcIixcbiAgc3RlcHBlckludmFsaWQ6IFwic3RyaW5nXCIsXG4gIHN0ZXBwZXJEaXNhYmxlZDogXCJzdHJpbmdcIixcbiAgc3RlcHBlclZlcnRpY2FsQnJlYWtwb2ludDogXCJudW1iZXJcIixcbiAgc3RlcHBlck1vYmlsZUJyZWFrcG9pbnQ6IFwibnVtYmVyXCIsXG4gIHN0ZXBwZXJNb2JpbGVCYXJCcmVha3BvaW50OiBcIm51bWJlclwiXG59LCBiZyA9IHtcbiAgc3RlcHBlclR5cGU6IGJpLFxuICBzdGVwcGVyTGluZWFyOiAhMSxcbiAgc3RlcHBlck5vRWRpdGFibGU6ICExLFxuICBzdGVwcGVyQWN0aXZlOiBcIlwiLFxuICBzdGVwcGVyQ29tcGxldGVkOiBcIlwiLFxuICBzdGVwcGVySW52YWxpZDogXCJcIixcbiAgc3RlcHBlckRpc2FibGVkOiBcIlwiLFxuICBzdGVwcGVyVmVydGljYWxCcmVha3BvaW50OiAwLFxuICBzdGVwcGVyTW9iaWxlQnJlYWtwb2ludDogMCxcbiAgc3RlcHBlck1vYmlsZUJhckJyZWFrcG9pbnQ6IDRcbn0sIEphID0gYG1vdXNlZG93biR7cG59YCwgdGwgPSBga2V5ZG93biR7cG59YCwgdmcgPSBga2V5dXAke3BufWAsIGVsID0gYHJlc2l6ZSR7cG59YCwganQgPSBgWyR7WWl9LXN0ZXAtcmVmXWAsIEcgPSBgWyR7WWl9LWhlYWQtcmVmXWAsIGlsID0gYFske1lpfS1oZWFkLXRleHQtcmVmXWAsIEVzID0gYFske1lpfS1oZWFkLWljb24tcmVmXWAsIHN0ID0gYFske1lpfS1jb250ZW50LXJlZl1gO1xuY2xhc3MgWEMge1xuICBjb25zdHJ1Y3Rvcih0LCBlKSB7XG4gICAgdGhpcy5fZWxlbWVudCA9IHQsIHRoaXMuX29wdGlvbnMgPSB0aGlzLl9nZXRDb25maWcoZSksIHRoaXMuX2VsZW1lbnRIZWlnaHQgPSAwLCB0aGlzLl9zdGVwcyA9IGQuZmluZChgJHtqdH1gLCB0aGlzLl9lbGVtZW50KSwgdGhpcy5fY3VycmVudFZpZXcgPSBcIlwiLCB0aGlzLl9hY3RpdmVTdGVwSW5kZXggPSAwLCB0aGlzLl92ZXJ0aWNhbFN0ZXBwZXJTdHlsZXMgPSBbXSwgdGhpcy5fZWxlbWVudCAmJiAoeS5zZXREYXRhKHQsIFhzLCB0aGlzKSwgdGhpcy5faW5pdCgpKTtcbiAgfVxuICAvLyBHZXR0ZXJzXG4gIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICByZXR1cm4gSG87XG4gIH1cbiAgZ2V0IGFjdGl2ZVN0ZXAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0ZXBzW3RoaXMuX2FjdGl2ZVN0ZXBJbmRleF07XG4gIH1cbiAgZ2V0IGFjdGl2ZVN0ZXBJbmRleCgpIHtcbiAgICByZXR1cm4gdGhpcy5fYWN0aXZlU3RlcEluZGV4O1xuICB9XG4gIC8vIFB1YmxpY1xuICBkaXNwb3NlKCkge1xuICAgIHRoaXMuX3N0ZXBzLmZvckVhY2goKHQpID0+IHtcbiAgICAgIGMub2ZmKHQsIEphKSwgYy5vZmYodCwgdGwpO1xuICAgIH0pLCBjLm9mZih3aW5kb3csIGVsKSwgeS5yZW1vdmVEYXRhKHRoaXMuX2VsZW1lbnQsIFhzKSwgdGhpcy5fZWxlbWVudCA9IG51bGw7XG4gIH1cbiAgY2hhbmdlU3RlcCh0KSB7XG4gICAgdGhpcy5fdG9nZ2xlU3RlcCh0KTtcbiAgfVxuICBuZXh0U3RlcCgpIHtcbiAgICB0aGlzLl90b2dnbGVTdGVwKHRoaXMuX2FjdGl2ZVN0ZXBJbmRleCArIDEpO1xuICB9XG4gIHByZXZpb3VzU3RlcCgpIHtcbiAgICB0aGlzLl90b2dnbGVTdGVwKHRoaXMuX2FjdGl2ZVN0ZXBJbmRleCAtIDEpO1xuICB9XG4gIC8vIFByaXZhdGVcbiAgX2luaXQoKSB7XG4gICAgY29uc3QgdCA9IGQuZmluZChgJHtqdH1gLCB0aGlzLl9lbGVtZW50KVt0aGlzLl9hY3RpdmVTdGVwSW5kZXhdLnNldEF0dHJpYnV0ZShcImRhdGEtdGVcIiwgXCJhY3RpdmUtc3RlcFwiKSwgZSA9IGQuZmluZChcbiAgICAgIGAke2lsfWAsXG4gICAgICB0aGlzLl9lbGVtZW50XG4gICAgKSwgaSA9IGQuZmluZChcbiAgICAgIGAke0VzfWAsXG4gICAgICB0aGlzLl9lbGVtZW50XG4gICAgKTtcbiAgICBzd2l0Y2ggKHQgPyAodGhpcy5fYWN0aXZlU3RlcEluZGV4ID0gdGhpcy5fc3RlcHMuaW5kZXhPZih0KSwgdGhpcy5fdG9nZ2xlU3RlcENsYXNzKFxuICAgICAgdGhpcy5fYWN0aXZlU3RlcEluZGV4LFxuICAgICAgXCJhZGRcIixcbiAgICAgIHRoaXMuX29wdGlvbnMuc3RlcHBlckFjdGl2ZVxuICAgICksIGVbdGhpcy5fYWN0aXZlU3RlcEluZGV4XS5jbGFzc0xpc3QuYWRkKFwiZm9udC1tZWRpdW1cIiksIGlbdGhpcy5fYWN0aXZlU3RlcEluZGV4XS5jbGFzc0xpc3QuYWRkKFwiIWJnLXByaW1hcnktMTAwXCIpLCBpW3RoaXMuX2FjdGl2ZVN0ZXBJbmRleF0uY2xhc3NMaXN0LmFkZChcIiF0ZXh0LXByaW1hcnktNzAwXCIpKSA6IChlW3RoaXMuX2FjdGl2ZVN0ZXBJbmRleF0uY2xhc3NMaXN0LmFkZChcImZvbnQtbWVkaXVtXCIpLCBpW3RoaXMuX2FjdGl2ZVN0ZXBJbmRleF0uY2xhc3NMaXN0LmFkZChcIiFiZy1wcmltYXJ5LTEwMFwiKSwgaVt0aGlzLl9hY3RpdmVTdGVwSW5kZXhdLmNsYXNzTGlzdC5hZGQoXCIhdGV4dC1wcmltYXJ5LTcwMFwiKSwgdGhpcy5fdG9nZ2xlU3RlcENsYXNzKFxuICAgICAgdGhpcy5fYWN0aXZlU3RlcEluZGV4LFxuICAgICAgXCJhZGRcIixcbiAgICAgIHRoaXMuX29wdGlvbnMuc3RlcHBlckFjdGl2ZVxuICAgICkpLCB0aGlzLl9iaW5kTW91c2VEb3duKCksIHRoaXMuX2JpbmRLZXlzTmF2aWdhdGlvbigpLCB0aGlzLl9vcHRpb25zLnN0ZXBwZXJUeXBlKSB7XG4gICAgICBjYXNlIHh0OlxuICAgICAgICB0aGlzLl90b2dnbGVWZXJ0aWNhbCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRoaXMuX3RvZ2dsZUhvcml6b250YWwoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgICh0aGlzLl9vcHRpb25zLnN0ZXBwZXJWZXJ0aWNhbEJyZWFrcG9pbnQgfHwgdGhpcy5fb3B0aW9ucy5zdGVwcGVyTW9iaWxlQnJlYWtwb2ludCkgJiYgdGhpcy5fdG9nZ2xlU3RlcHBlclZpZXcoKSwgdGhpcy5fYmluZFJlc2l6ZSgpO1xuICB9XG4gIF9nZXRDb25maWcodCkge1xuICAgIGNvbnN0IGUgPSBoLmdldERhdGFBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpO1xuICAgIHJldHVybiB0ID0ge1xuICAgICAgLi4uYmcsXG4gICAgICAuLi5lLFxuICAgICAgLi4udFxuICAgIH0sIEQoSG8sIHQsIGdnKSwgdDtcbiAgfVxuICBfYmluZE1vdXNlRG93bigpIHtcbiAgICB0aGlzLl9zdGVwcy5mb3JFYWNoKCh0KSA9PiB7XG4gICAgICBjb25zdCBlID0gZC5maW5kT25lKGAke0d9YCwgdCk7XG4gICAgICBjLm9uKGUsIEphLCAoaSkgPT4ge1xuICAgICAgICBjb25zdCBuID0gZC5wYXJlbnRzKGkudGFyZ2V0LCBgJHtqdH1gKVswXSwgbyA9IHRoaXMuX3N0ZXBzLmluZGV4T2Yobik7XG4gICAgICAgIGkucHJldmVudERlZmF1bHQoKSwgdGhpcy5fdG9nZ2xlU3RlcChvKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIF9iaW5kUmVzaXplKCkge1xuICAgIGMub24od2luZG93LCBlbCwgKCkgPT4ge1xuICAgICAgdGhpcy5fY3VycmVudFZpZXcgPT09IHh0ICYmIHRoaXMuX3NldFNpbmdsZVN0ZXBIZWlnaHQodGhpcy5hY3RpdmVTdGVwKSwgdGhpcy5fY3VycmVudFZpZXcgPT09IGJpICYmIHRoaXMuX3NldEhlaWdodCh0aGlzLmFjdGl2ZVN0ZXApLCAodGhpcy5fb3B0aW9ucy5zdGVwcGVyVmVydGljYWxCcmVha3BvaW50IHx8IHRoaXMuX29wdGlvbnMuc3RlcHBlck1vYmlsZUJyZWFrcG9pbnQpICYmIHRoaXMuX3RvZ2dsZVN0ZXBwZXJWaWV3KCk7XG4gICAgfSk7XG4gIH1cbiAgX3RvZ2dsZVN0ZXBwZXJWaWV3KCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLl9vcHRpb25zLnN0ZXBwZXJWZXJ0aWNhbEJyZWFrcG9pbnQgPCB3aW5kb3cuaW5uZXJXaWR0aCwgZSA9IHRoaXMuX29wdGlvbnMuc3RlcHBlclZlcnRpY2FsQnJlYWtwb2ludCA+IHdpbmRvdy5pbm5lcldpZHRoLCBpID0gdGhpcy5fb3B0aW9ucy5zdGVwcGVyTW9iaWxlQnJlYWtwb2ludCA+IHdpbmRvdy5pbm5lcldpZHRoO1xuICAgIHQgJiYgdGhpcy5fY3VycmVudFZpZXcgIT09IGJpICYmIHRoaXMuX3RvZ2dsZUhvcml6b250YWwoKSwgZSAmJiAhaSAmJiB0aGlzLl9jdXJyZW50VmlldyAhPT0geHQgJiYgKHRoaXMuX3N0ZXBzLmZvckVhY2goKG4pID0+IHtcbiAgICAgIGNvbnN0IG8gPSBkLmZpbmRPbmUoYCR7c3R9YCwgbik7XG4gICAgICB0aGlzLl9yZXNldFN0ZXBwZXJIZWlnaHQoKSwgdGhpcy5fc2hvd0VsZW1lbnQobyk7XG4gICAgfSksIHRoaXMuX3RvZ2dsZVZlcnRpY2FsKCkpO1xuICB9XG4gIF90b2dnbGVTdGVwKHQpIHtcbiAgICB0aGlzLl9hY3RpdmVTdGVwSW5kZXggIT09IHQgJiYgKHRoaXMuX29wdGlvbnMuc3RlcHBlck5vRWRpdGFibGUgJiYgdGhpcy5fdG9nZ2xlRGlzYWJsZWQoKSwgdGhpcy5fc2hvd0VsZW1lbnQoXG4gICAgICBkLmZpbmRPbmUoYCR7c3R9YCwgdGhpcy5fc3RlcHNbdF0pXG4gICAgKSwgdGhpcy5fdG9nZ2xlQWN0aXZlKHQpLCB0ID4gdGhpcy5fYWN0aXZlU3RlcEluZGV4ICYmIHRoaXMuX3RvZ2dsZUNvbXBsZXRlZCh0aGlzLl9hY3RpdmVTdGVwSW5kZXgpLCB0aGlzLl9jdXJyZW50VmlldyA9PT0gYmkgPyB0aGlzLl9hbmltYXRlSG9yaXpvbnRhbFN0ZXAodCkgOiAodGhpcy5fYW5pbWF0ZVZlcnRpY2FsU3RlcCh0KSwgdGhpcy5fc2V0U2luZ2xlU3RlcEhlaWdodCh0aGlzLl9zdGVwc1t0XSkpLCB0aGlzLl90b2dnbGVTdGVwVGFiSW5kZXgoXG4gICAgICBkLmZpbmRPbmUoYCR7R31gLCB0aGlzLmFjdGl2ZVN0ZXApLFxuICAgICAgZC5maW5kT25lKGAke0d9YCwgdGhpcy5fc3RlcHNbdF0pXG4gICAgKSwgdGhpcy5fYWN0aXZlU3RlcEluZGV4ID0gdCwgdGhpcy5fc3RlcHNbdGhpcy5fYWN0aXZlU3RlcEluZGV4XS5zZXRBdHRyaWJ1dGUoXCJkYXRhLXRlXCIsIFwiYWN0aXZlLXN0ZXBcIiksIHRoaXMuX3N0ZXBzLmZvckVhY2goKGUsIGkpID0+IHtcbiAgICAgIGVbdGhpcy5fYWN0aXZlU3RlcEluZGV4XSAhPT0gaSAmJiBlLnJlbW92ZUF0dHJpYnV0ZShcImRhdGEtdGVcIik7XG4gICAgfSkpO1xuICB9XG4gIF9yZXNldFN0ZXBwZXJIZWlnaHQoKSB7XG4gICAgdGhpcy5fZWxlbWVudC5zdHlsZS5oZWlnaHQgPSBcIlwiO1xuICB9XG4gIF9zZXRTdGVwc0hlaWdodCgpIHtcbiAgICB0aGlzLl9zdGVwcy5mb3JFYWNoKCh0KSA9PiB7XG4gICAgICBjb25zdCBlID0gZC5maW5kT25lKGAke3N0fWAsIHQpLCBpID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZSk7XG4gICAgICB0aGlzLl92ZXJ0aWNhbFN0ZXBwZXJTdHlsZXMucHVzaCh7XG4gICAgICAgIHBhZGRpbmdUb3A6IHBhcnNlRmxvYXQoaS5wYWRkaW5nVG9wKSxcbiAgICAgICAgcGFkZGluZ0JvdHRvbTogcGFyc2VGbG9hdChpLnBhZGRpbmdCb3R0b20pXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IG4gPSBlLnNjcm9sbEhlaWdodDtcbiAgICAgIGUuc3R5bGUuaGVpZ2h0ID0gYCR7bn1weGA7XG4gICAgfSk7XG4gIH1cbiAgX3NldFNpbmdsZVN0ZXBIZWlnaHQodCkge1xuICAgIGNvbnN0IGUgPSBkLmZpbmRPbmUoYCR7c3R9YCwgdCksIGkgPSB0aGlzLmFjdGl2ZVN0ZXAgPT09IHQsIG4gPSB0aGlzLl9zdGVwcy5pbmRleE9mKHQpO1xuICAgIGxldCBvO1xuICAgIGkgPyAoZS5zdHlsZS5oZWlnaHQgPSBcIlwiLCBvID0gZS5zY3JvbGxIZWlnaHQpIDogbyA9IGUuc2Nyb2xsSGVpZ2h0ICsgdGhpcy5fdmVydGljYWxTdGVwcGVyU3R5bGVzW25dLnBhZGRpbmdUb3AgKyB0aGlzLl92ZXJ0aWNhbFN0ZXBwZXJTdHlsZXNbbl0ucGFkZGluZ0JvdHRvbSwgZS5zdHlsZS5oZWlnaHQgPSBgJHtvfXB4YDtcbiAgfVxuICBfdG9nZ2xlVmVydGljYWwoKSB7XG4gICAgdGhpcy5fY3VycmVudFZpZXcgPSB4dCwgdGhpcy5fc2V0U3RlcHNIZWlnaHQoKSwgdGhpcy5faGlkZUluYWN0aXZlU3RlcHMoKTtcbiAgfVxuICBfdG9nZ2xlSG9yaXpvbnRhbCgpIHtcbiAgICB0aGlzLl9jdXJyZW50VmlldyA9IGJpLCB0aGlzLl9zZXRIZWlnaHQodGhpcy5hY3RpdmVTdGVwKSwgdGhpcy5faGlkZUluYWN0aXZlU3RlcHMoKTtcbiAgfVxuICBfdG9nZ2xlU3RlcHBlckNsYXNzKCkge1xuICAgIGQuZmluZE9uZShcbiAgICAgIFwiW2RhdGEtdGUtc3RlcHBlci10eXBlXVwiLFxuICAgICAgdGhpcy5fZWxlbWVudFxuICAgICkgIT09IG51bGwgJiYgdGhpcy5fc3RlcHMuZm9yRWFjaCgoZSkgPT4ge1xuICAgICAgZC5maW5kT25lKGAke3N0fWAsIGUpLmNsYXNzTGlzdC5yZW1vdmUoXCIhbXktMFwiKSwgZC5maW5kT25lKGAke3N0fWAsIGUpLmNsYXNzTGlzdC5yZW1vdmUoXCIhcHktMFwiKSwgZC5maW5kT25lKGAke3N0fWAsIGUpLmNsYXNzTGlzdC5yZW1vdmUoXCIhaC0wXCIpO1xuICAgIH0pO1xuICB9XG4gIF90b2dnbGVTdGVwQ2xhc3ModCwgZSwgaSkge1xuICAgIGkgJiYgdGhpcy5fc3RlcHNbdF0uY2xhc3NMaXN0W2VdKGkpO1xuICB9XG4gIF9iaW5kS2V5c05hdmlnYXRpb24oKSB7XG4gICAgdGhpcy5fdG9nZ2xlU3RlcFRhYkluZGV4KFxuICAgICAgITEsXG4gICAgICBkLmZpbmRPbmUoYCR7R31gLCB0aGlzLmFjdGl2ZVN0ZXApXG4gICAgKSwgdGhpcy5fc3RlcHMuZm9yRWFjaCgodCkgPT4ge1xuICAgICAgY29uc3QgZSA9IGQuZmluZE9uZShgJHtHfWAsIHQpO1xuICAgICAgYy5vbihlLCB0bCwgKGkpID0+IHtcbiAgICAgICAgY29uc3QgbiA9IGQucGFyZW50cyhcbiAgICAgICAgICBpLmN1cnJlbnRUYXJnZXQsXG4gICAgICAgICAgYCR7anR9YFxuICAgICAgICApWzBdLCBvID0gZC5uZXh0KG4sIGAke2p0fWApWzBdLCByID0gZC5wcmV2KG4sIGAke2p0fWApWzBdLCBhID0gZC5maW5kT25lKFxuICAgICAgICAgIGAke0d9YCxcbiAgICAgICAgICBuXG4gICAgICAgICksIGwgPSBkLmZpbmRPbmUoXG4gICAgICAgICAgYCR7R31gLFxuICAgICAgICAgIHRoaXMuYWN0aXZlU3RlcFxuICAgICAgICApO1xuICAgICAgICBsZXQgcCA9IG51bGwsIHUgPSBudWxsO1xuICAgICAgICBpZiAobyAmJiAocCA9IGQuZmluZE9uZShgJHtHfWAsIG8pKSwgciAmJiAodSA9IGQuZmluZE9uZShgJHtHfWAsIHIpKSwgaS5rZXlDb2RlID09PSBIZSAmJiB0aGlzLl9jdXJyZW50VmlldyAhPT0geHQgJiYgKHUgPyAodGhpcy5fdG9nZ2xlU3RlcFRhYkluZGV4KGEsIHUpLCB0aGlzLl90b2dnbGVPdXRsaW5lU3R5bGVzKGEsIHUpLCB1LmZvY3VzKCkpIDogcCAmJiAodGhpcy5fdG9nZ2xlU3RlcFRhYkluZGV4KGEsIHApLCB0aGlzLl90b2dnbGVPdXRsaW5lU3R5bGVzKGEsIHApLCBwLmZvY3VzKCkpKSwgaS5rZXlDb2RlID09PSBWZSAmJiB0aGlzLl9jdXJyZW50VmlldyAhPT0geHQgJiYgKHAgPyAodGhpcy5fdG9nZ2xlU3RlcFRhYkluZGV4KGEsIHApLCB0aGlzLl90b2dnbGVPdXRsaW5lU3R5bGVzKGEsIHApLCBwLmZvY3VzKCkpIDogdSAmJiAodGhpcy5fdG9nZ2xlU3RlcFRhYkluZGV4KGEsIHUpLCB0aGlzLl90b2dnbGVPdXRsaW5lU3R5bGVzKGEsIHUpLCB1LmZvY3VzKCkpKSwgaS5rZXlDb2RlID09PSB6ICYmIHRoaXMuX2N1cnJlbnRWaWV3ID09PSB4dCAmJiAoaS5wcmV2ZW50RGVmYXVsdCgpLCBwICYmICh0aGlzLl90b2dnbGVTdGVwVGFiSW5kZXgoYSwgcCksIHRoaXMuX3RvZ2dsZU91dGxpbmVTdHlsZXMoYSwgcCksIHAuZm9jdXMoKSkpLCBpLmtleUNvZGUgPT09IGF0ICYmIHRoaXMuX2N1cnJlbnRWaWV3ID09PSB4dCAmJiAoaS5wcmV2ZW50RGVmYXVsdCgpLCB1ICYmICh0aGlzLl90b2dnbGVTdGVwVGFiSW5kZXgoYSwgdSksIHRoaXMuX3RvZ2dsZU91dGxpbmVTdHlsZXMoYSwgdSksIHUuZm9jdXMoKSkpLCBpLmtleUNvZGUgPT09IFdlKSB7XG4gICAgICAgICAgY29uc3QgXyA9IGQuZmluZE9uZShcbiAgICAgICAgICAgIGAke0d9YCxcbiAgICAgICAgICAgIHRoaXMuX3N0ZXBzWzBdXG4gICAgICAgICAgKTtcbiAgICAgICAgICB0aGlzLl90b2dnbGVTdGVwVGFiSW5kZXgoYSwgXyksIHRoaXMuX3RvZ2dsZU91dGxpbmVTdHlsZXMoYSwgXyksIF8uZm9jdXMoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaS5rZXlDb2RlID09PSBGZSkge1xuICAgICAgICAgIGNvbnN0IF8gPSB0aGlzLl9zdGVwc1t0aGlzLl9zdGVwcy5sZW5ndGggLSAxXSwgZiA9IGQuZmluZE9uZShgJHtHfWAsIF8pO1xuICAgICAgICAgIHRoaXMuX3RvZ2dsZVN0ZXBUYWJJbmRleChhLCBmKSwgdGhpcy5fdG9nZ2xlT3V0bGluZVN0eWxlcyhhLCBmKSwgZi5mb2N1cygpO1xuICAgICAgICB9XG4gICAgICAgIChpLmtleUNvZGUgPT09IGN0IHx8IGkua2V5Q29kZSA9PT0gS3MpICYmIChpLnByZXZlbnREZWZhdWx0KCksIHRoaXMuY2hhbmdlU3RlcCh0aGlzLl9zdGVwcy5pbmRleE9mKG4pKSksIGkua2V5Q29kZSA9PT0gUGkgJiYgKHRoaXMuX3RvZ2dsZVN0ZXBUYWJJbmRleChhLCBsKSwgdGhpcy5fdG9nZ2xlT3V0bGluZVN0eWxlcyhhLCAhMSksIGwuZm9jdXMoKSk7XG4gICAgICB9KSwgYy5vbihlLCB2ZywgKGkpID0+IHtcbiAgICAgICAgY29uc3QgbiA9IGQucGFyZW50cyhcbiAgICAgICAgICBpLmN1cnJlbnRUYXJnZXQsXG4gICAgICAgICAgYCR7anR9YFxuICAgICAgICApWzBdLCBvID0gZC5maW5kT25lKFxuICAgICAgICAgIGAke0d9YCxcbiAgICAgICAgICBuXG4gICAgICAgICksIHIgPSBkLmZpbmRPbmUoXG4gICAgICAgICAgYCR7R31gLFxuICAgICAgICAgIHRoaXMuYWN0aXZlU3RlcFxuICAgICAgICApO1xuICAgICAgICBpLmtleUNvZGUgPT09IFBpICYmICh0aGlzLl90b2dnbGVTdGVwVGFiSW5kZXgobywgciksIHRoaXMuX3RvZ2dsZU91dGxpbmVTdHlsZXMoITEsIHIpLCByLmZvY3VzKCkpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgX3RvZ2dsZVN0ZXBUYWJJbmRleCh0LCBlKSB7XG4gICAgdCAmJiB0LnNldEF0dHJpYnV0ZShcInRhYkluZGV4XCIsIC0xKSwgZSAmJiBlLnNldEF0dHJpYnV0ZShcInRhYkluZGV4XCIsIDApO1xuICB9XG4gIF90b2dnbGVPdXRsaW5lU3R5bGVzKHQsIGUpIHtcbiAgICB0ICYmICh0LnN0eWxlLm91dGxpbmUgPSBcIlwiKSwgZSAmJiAoZS5zdHlsZS5vdXRsaW5lID0gXCJyZXZlcnRcIik7XG4gIH1cbiAgX3RvZ2dsZURpc2FibGVkKCkge1xuICAgIGNvbnN0IHQgPSBkLmZpbmQoYCR7R31gLCB0aGlzLl9lbGVtZW50KSwgZSA9IGQuZmluZChcbiAgICAgIGAke0VzfWAsXG4gICAgICB0aGlzLl9lbGVtZW50XG4gICAgKTtcbiAgICB0W3RoaXMuX2FjdGl2ZVN0ZXBJbmRleF0uY2xhc3NMaXN0LmFkZChcImNvbG9yLVsjODU4NTg1XVwiKSwgdFt0aGlzLl9hY3RpdmVTdGVwSW5kZXhdLmNsYXNzTGlzdC5hZGQoXCJjdXJzb3ItZGVmYXVsdFwiKSwgZVt0aGlzLl9hY3RpdmVTdGVwSW5kZXhdLmNsYXNzTGlzdC5hZGQoXCIhYmctWyM4NTg1ODVdXCIpLCB0aGlzLl90b2dnbGVTdGVwQ2xhc3MoXG4gICAgICB0aGlzLl9hY3RpdmVTdGVwSW5kZXgsXG4gICAgICBcImFkZFwiLFxuICAgICAgdGhpcy5fb3B0aW9ucy5zdGVwcGVyRGlzYWJsZWRcbiAgICApO1xuICB9XG4gIF90b2dnbGVBY3RpdmUodCkge1xuICAgIGNvbnN0IGUgPSBkLmZpbmQoXG4gICAgICBgJHtpbH1gLFxuICAgICAgdGhpcy5fZWxlbWVudFxuICAgICksIGkgPSBkLmZpbmQoXG4gICAgICBgJHtFc31gLFxuICAgICAgdGhpcy5fZWxlbWVudFxuICAgICk7XG4gICAgZVt0XS5jbGFzc0xpc3QuYWRkKFwiZm9udC1tZWRpdW1cIiksIGlbdF0uY2xhc3NMaXN0LmFkZChcIiFiZy1wcmltYXJ5LTEwMFwiKSwgaVt0XS5jbGFzc0xpc3QuYWRkKFwiIXRleHQtcHJpbWFyeS03MDBcIiksIGlbdF0uY2xhc3NMaXN0LnJlbW92ZShcIiFiZy1zdWNjZXNzLTEwMFwiKSwgaVt0XS5jbGFzc0xpc3QucmVtb3ZlKFwiIXRleHQtc3VjY2Vzcy03MDBcIiksIGVbdGhpcy5fYWN0aXZlU3RlcEluZGV4XS5jbGFzc0xpc3QucmVtb3ZlKFwiZm9udC1tZWRpdW1cIiksIGlbdGhpcy5fYWN0aXZlU3RlcEluZGV4XS5jbGFzc0xpc3QucmVtb3ZlKFwiIWJnLXByaW1hcnktMTAwXCIpLCBpW3RoaXMuX2FjdGl2ZVN0ZXBJbmRleF0uY2xhc3NMaXN0LnJlbW92ZShcbiAgICAgIFwiIXRleHQtcHJpbWFyeS03MDBcIlxuICAgICksIHRoaXMuX3RvZ2dsZVN0ZXBDbGFzcyh0LCBcImFkZFwiLCB0aGlzLl9vcHRpb25zLnN0ZXBwZXJBY3RpdmUpLCB0aGlzLl90b2dnbGVTdGVwQ2xhc3MoXG4gICAgICB0aGlzLl9hY3RpdmVTdGVwSW5kZXgsXG4gICAgICBcInJlbW92ZVwiLFxuICAgICAgdGhpcy5fb3B0aW9ucy5zdGVwcGVyQWN0aXZlXG4gICAgKTtcbiAgfVxuICBfdG9nZ2xlQ29tcGxldGVkKHQpIHtcbiAgICBjb25zdCBlID0gZC5maW5kKFxuICAgICAgYCR7RXN9YCxcbiAgICAgIHRoaXMuX2VsZW1lbnRcbiAgICApO1xuICAgIGVbdF0uY2xhc3NMaXN0LmFkZChcIiFiZy1zdWNjZXNzLTEwMFwiKSwgZVt0XS5jbGFzc0xpc3QuYWRkKFwiIXRleHQtc3VjY2Vzcy03MDBcIiksIGVbdF0uY2xhc3NMaXN0LnJlbW92ZShcIiFiZy1kYW5nZXItMTAwXCIpLCBlW3RdLmNsYXNzTGlzdC5yZW1vdmUoXCIhdGV4dC1kYW5nZXItNzAwXCIpLCB0aGlzLl90b2dnbGVTdGVwQ2xhc3ModCwgXCJhZGRcIiwgdGhpcy5fb3B0aW9ucy5zdGVwcGVyQ29tcGxldGVkKSwgdGhpcy5fdG9nZ2xlU3RlcENsYXNzKHQsIFwicmVtb3ZlXCIsIHRoaXMuX29wdGlvbnMuc3RlcHBlckludmFsaWQpO1xuICB9XG4gIF9oaWRlSW5hY3RpdmVTdGVwcygpIHtcbiAgICB0aGlzLl9zdGVwcy5mb3JFYWNoKCh0KSA9PiB7XG4gICAgICB0LmdldEF0dHJpYnV0ZShcImRhdGEtdGVcIikgfHwgdGhpcy5faGlkZUVsZW1lbnQoZC5maW5kT25lKGAke3N0fWAsIHQpKTtcbiAgICB9KTtcbiAgfVxuICBfc2V0SGVpZ2h0KHQpIHtcbiAgICBjb25zdCBlID0gZC5maW5kT25lKGAke3N0fWAsIHQpLCBpID0gZ2V0Q29tcHV0ZWRTdHlsZShlKSwgbiA9IGQuZmluZE9uZShgJHtHfWAsIHQpLCBvID0gZ2V0Q29tcHV0ZWRTdHlsZShuKSwgciA9IGUub2Zmc2V0SGVpZ2h0ICsgcGFyc2VGbG9hdChpLm1hcmdpblRvcCkgKyBwYXJzZUZsb2F0KGkubWFyZ2luQm90dG9tKSwgYSA9IG4ub2Zmc2V0SGVpZ2h0ICsgcGFyc2VGbG9hdChvLm1hcmdpblRvcCkgKyBwYXJzZUZsb2F0KG8ubWFyZ2luQm90dG9tKTtcbiAgICB0aGlzLl9lbGVtZW50LnN0eWxlLmhlaWdodCA9IGAke2EgKyByfXB4YDtcbiAgfVxuICBfaGlkZUVsZW1lbnQodCkge1xuICAgICFkLnBhcmVudHMoXG4gICAgICB0LFxuICAgICAgYCR7anR9YFxuICAgIClbMF0uZ2V0QXR0cmlidXRlKFwiZGF0YS10ZVwiKSAmJiB0aGlzLl9jdXJyZW50VmlldyAhPT0geHQgfHwgKHQuY2xhc3NMaXN0LmFkZChcIiFteS0wXCIpLCB0LmNsYXNzTGlzdC5hZGQoXCIhcHktMFwiKSwgdC5jbGFzc0xpc3QuYWRkKFwiIWgtMFwiKSk7XG4gIH1cbiAgX3Nob3dFbGVtZW50KHQpIHtcbiAgICB0aGlzLl9jdXJyZW50VmlldyA9PT0geHQgPyAodC5jbGFzc0xpc3QucmVtb3ZlKFwiIW15LTBcIiksIHQuY2xhc3NMaXN0LnJlbW92ZShcIiFweS0wXCIpLCB0LmNsYXNzTGlzdC5yZW1vdmUoXCIhaC0wXCIpKSA6IHQuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcbiAgfVxuICBfYW5pbWF0ZUhvcml6b250YWxTdGVwKHQpIHtcbiAgICBjb25zdCBlID0gdCA+IHRoaXMuX2FjdGl2ZVN0ZXBJbmRleCwgaSA9IGQuZmluZE9uZShcbiAgICAgIGAke3N0fWAsXG4gICAgICB0aGlzLl9zdGVwc1t0XVxuICAgICksIG4gPSBkLmZpbmRPbmUoXG4gICAgICBgJHtzdH1gLFxuICAgICAgdGhpcy5hY3RpdmVTdGVwXG4gICAgKTtcbiAgICBsZXQgbywgcjtcbiAgICB0aGlzLl9zdGVwcy5mb3JFYWNoKCh1LCBfKSA9PiB7XG4gICAgICBjb25zdCBmID0gZC5maW5kT25lKGAke3N0fWAsIHUpO1xuICAgICAgXyAhPT0gdCAmJiBfICE9PSB0aGlzLl9hY3RpdmVTdGVwSW5kZXggJiYgdGhpcy5faGlkZUVsZW1lbnQoZik7XG4gICAgfSk7XG4gICAgY29uc3QgYSA9IFwidHJhbnNsYXRlLXgtWzE1MCVdXCIsIGwgPSBcIi10cmFuc2xhdGUteC1bMTUwJV1cIiwgcCA9IFwidHJhbnNsYXRlLTBcIjtcbiAgICBlID8gKHIgPSBsLCBvID0gcCwgaS5jbGFzc0xpc3QucmVtb3ZlKFwidHJhbnNsYXRlLXgtWzE1MCVdXCIpLCBpLmNsYXNzTGlzdC5yZW1vdmUoXCItdHJhbnNsYXRlLXgtWzE1MCVdXCIpKSA6IChyID0gYSwgbyA9IHAsIGkuY2xhc3NMaXN0LnJlbW92ZShcIi10cmFuc2xhdGUteC1bMTUwJV1cIiksIGkuY2xhc3NMaXN0LnJlbW92ZShcInRyYW5zbGF0ZS14LVsxNTAlXVwiKSksIG4uY2xhc3NMaXN0LmFkZChyKSwgaS5jbGFzc0xpc3QuYWRkKG8pLCB0aGlzLl9zZXRIZWlnaHQodGhpcy5fc3RlcHNbdF0pO1xuICB9XG4gIF9hbmltYXRlVmVydGljYWxTdGVwKHQpIHtcbiAgICBjb25zdCBlID0gZC5maW5kT25lKFxuICAgICAgYCR7c3R9YCxcbiAgICAgIHRoaXMuX3N0ZXBzW3RdXG4gICAgKSwgaSA9IGQuZmluZE9uZShcbiAgICAgIGAke3N0fWAsXG4gICAgICB0aGlzLmFjdGl2ZVN0ZXBcbiAgICApO1xuICAgIHRoaXMuX2hpZGVFbGVtZW50KGkpLCB0aGlzLl9zaG93RWxlbWVudChlKTtcbiAgfVxuICBzdGF0aWMgZ2V0SW5zdGFuY2UodCkge1xuICAgIHJldHVybiB5LmdldERhdGEodCwgWHMpO1xuICB9XG4gIHN0YXRpYyBnZXRPckNyZWF0ZUluc3RhbmNlKHQsIGUgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLmdldEluc3RhbmNlKHQpIHx8IG5ldyB0aGlzKHQsIHR5cGVvZiBlID09IFwib2JqZWN0XCIgPyBlIDogbnVsbCk7XG4gIH1cbn1cbmNvbnN0IHNsID0gXCJkYXRhLXRlLWlucHV0LXN0YXRlLWFjdGl2ZVwiLCBDcyA9IFwiZGF0YS10ZS1pbnB1dC1zZWxlY3RlZFwiLCBubCA9IFwiZGF0YS10ZS1pbnB1dC1tdWx0aXBsZS1hY3RpdmVcIiwgb2wgPSBcIltkYXRhLXRlLWZvcm0tY2hlY2staW5wdXRdXCI7XG5jbGFzcyBybCB7XG4gIGNvbnN0cnVjdG9yKHQsIGUsIGksIG4sIG8sIHIsIGEsIGwsIHAsIHUsIF8pIHtcbiAgICB0aGlzLmlkID0gdCwgdGhpcy5uYXRpdmVPcHRpb24gPSBlLCB0aGlzLm11bHRpcGxlID0gaSwgdGhpcy52YWx1ZSA9IG4sIHRoaXMubGFiZWwgPSBvLCB0aGlzLnNlbGVjdGVkID0gciwgdGhpcy5kaXNhYmxlZCA9IGEsIHRoaXMuaGlkZGVuID0gbCwgdGhpcy5zZWNvbmRhcnlUZXh0ID0gcCwgdGhpcy5ncm91cElkID0gdSwgdGhpcy5pY29uID0gXywgdGhpcy5ub2RlID0gbnVsbCwgdGhpcy5hY3RpdmUgPSAhMTtcbiAgfVxuICBzZWxlY3QoKSB7XG4gICAgdGhpcy5tdWx0aXBsZSA/IHRoaXMuX3NlbGVjdE11bHRpcGxlKCkgOiB0aGlzLl9zZWxlY3RTaW5nbGUoKTtcbiAgfVxuICBfc2VsZWN0U2luZ2xlKCkge1xuICAgIHRoaXMuc2VsZWN0ZWQgfHwgKHRoaXMubm9kZS5zZXRBdHRyaWJ1dGUoQ3MsIFwiXCIpLCB0aGlzLm5vZGUuc2V0QXR0cmlidXRlKFwiYXJpYS1zZWxlY3RlZFwiLCAhMCksIHRoaXMuc2VsZWN0ZWQgPSAhMCwgdGhpcy5uYXRpdmVPcHRpb24gJiYgKHRoaXMubmF0aXZlT3B0aW9uLnNlbGVjdGVkID0gITApKTtcbiAgfVxuICBfc2VsZWN0TXVsdGlwbGUoKSB7XG4gICAgaWYgKCF0aGlzLnNlbGVjdGVkKSB7XG4gICAgICBjb25zdCB0ID0gZC5maW5kT25lKFxuICAgICAgICBvbCxcbiAgICAgICAgdGhpcy5ub2RlXG4gICAgICApO1xuICAgICAgdC5jaGVja2VkID0gITAsIHRoaXMubm9kZS5zZXRBdHRyaWJ1dGUoQ3MsIFwiXCIpLCB0aGlzLm5vZGUuc2V0QXR0cmlidXRlKFwiYXJpYS1zZWxlY3RlZFwiLCAhMCksIHRoaXMuc2VsZWN0ZWQgPSAhMCwgdGhpcy5uYXRpdmVPcHRpb24gJiYgKHRoaXMubmF0aXZlT3B0aW9uLnNlbGVjdGVkID0gITApO1xuICAgIH1cbiAgfVxuICBkZXNlbGVjdCgpIHtcbiAgICB0aGlzLm11bHRpcGxlID8gdGhpcy5fZGVzZWxlY3RNdWx0aXBsZSgpIDogdGhpcy5fZGVzZWxlY3RTaW5nbGUoKTtcbiAgfVxuICBfZGVzZWxlY3RTaW5nbGUoKSB7XG4gICAgdGhpcy5zZWxlY3RlZCAmJiAodGhpcy5ub2RlLnJlbW92ZUF0dHJpYnV0ZShDcyksIHRoaXMubm9kZS5zZXRBdHRyaWJ1dGUoXCJhcmlhLXNlbGVjdGVkXCIsICExKSwgdGhpcy5zZWxlY3RlZCA9ICExLCB0aGlzLm5hdGl2ZU9wdGlvbiAmJiAodGhpcy5uYXRpdmVPcHRpb24uc2VsZWN0ZWQgPSAhMSkpO1xuICB9XG4gIF9kZXNlbGVjdE11bHRpcGxlKCkge1xuICAgIGlmICh0aGlzLnNlbGVjdGVkKSB7XG4gICAgICBjb25zdCB0ID0gZC5maW5kT25lKFxuICAgICAgICBvbCxcbiAgICAgICAgdGhpcy5ub2RlXG4gICAgICApO1xuICAgICAgdC5jaGVja2VkID0gITEsIHRoaXMubm9kZS5yZW1vdmVBdHRyaWJ1dGUoQ3MpLCB0aGlzLm5vZGUuc2V0QXR0cmlidXRlKFwiYXJpYS1zZWxlY3RlZFwiLCAhMSksIHRoaXMuc2VsZWN0ZWQgPSAhMSwgdGhpcy5uYXRpdmVPcHRpb24gJiYgKHRoaXMubmF0aXZlT3B0aW9uLnNlbGVjdGVkID0gITEpO1xuICAgIH1cbiAgfVxuICBzZXROb2RlKHQpIHtcbiAgICB0aGlzLm5vZGUgPSB0O1xuICB9XG4gIHNldEFjdGl2ZVN0eWxlcygpIHtcbiAgICBpZiAoIXRoaXMuYWN0aXZlKSB7XG4gICAgICBpZiAodGhpcy5tdWx0aXBsZSkge1xuICAgICAgICB0aGlzLm5vZGUuc2V0QXR0cmlidXRlKG5sLCBcIlwiKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5hY3RpdmUgPSAhMCwgdGhpcy5ub2RlLnNldEF0dHJpYnV0ZShzbCwgXCJcIik7XG4gICAgfVxuICB9XG4gIHJlbW92ZUFjdGl2ZVN0eWxlcygpIHtcbiAgICB0aGlzLmFjdGl2ZSAmJiAodGhpcy5hY3RpdmUgPSAhMSwgdGhpcy5ub2RlLnJlbW92ZUF0dHJpYnV0ZShzbCkpLCB0aGlzLm11bHRpcGxlICYmIHRoaXMubm9kZS5yZW1vdmVBdHRyaWJ1dGUobmwpO1xuICB9XG59XG5jbGFzcyBUZyB7XG4gIGNvbnN0cnVjdG9yKHQgPSAhMSkge1xuICAgIHRoaXMuX211bHRpcGxlID0gdCwgdGhpcy5fc2VsZWN0aW9ucyA9IFtdO1xuICB9XG4gIHNlbGVjdCh0KSB7XG4gICAgdGhpcy5fbXVsdGlwbGUgPyB0aGlzLl9zZWxlY3Rpb25zLnB1c2godCkgOiB0aGlzLl9zZWxlY3Rpb25zID0gW3RdO1xuICB9XG4gIGRlc2VsZWN0KHQpIHtcbiAgICBpZiAodGhpcy5fbXVsdGlwbGUpIHtcbiAgICAgIGNvbnN0IGUgPSB0aGlzLl9zZWxlY3Rpb25zLmZpbmRJbmRleChcbiAgICAgICAgKGkpID0+IHQgPT09IGlcbiAgICAgICk7XG4gICAgICB0aGlzLl9zZWxlY3Rpb25zLnNwbGljZShlLCAxKTtcbiAgICB9IGVsc2VcbiAgICAgIHRoaXMuX3NlbGVjdGlvbnMgPSBbXTtcbiAgfVxuICBjbGVhcigpIHtcbiAgICB0aGlzLl9zZWxlY3Rpb25zID0gW107XG4gIH1cbiAgZ2V0IHNlbGVjdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fc2VsZWN0aW9uc1swXTtcbiAgfVxuICBnZXQgc2VsZWN0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5fc2VsZWN0aW9ucztcbiAgfVxuICBnZXQgbGFiZWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NlbGVjdGlvbnNbMF0gJiYgdGhpcy5zZWxlY3Rpb24ubGFiZWw7XG4gIH1cbiAgZ2V0IGxhYmVscygpIHtcbiAgICByZXR1cm4gdGhpcy5fc2VsZWN0aW9ucy5tYXAoKHQpID0+IHQubGFiZWwpLmpvaW4oXCIsIFwiKTtcbiAgfVxuICBnZXQgdmFsdWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2VsZWN0aW9uc1swXSAmJiB0aGlzLnNlbGVjdGlvbi52YWx1ZTtcbiAgfVxuICBnZXQgdmFsdWVzKCkge1xuICAgIHJldHVybiB0aGlzLl9zZWxlY3Rpb25zLm1hcCgodCkgPT4gdC52YWx1ZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIFZvKHMpIHtcbiAgcmV0dXJuIHMuZmlsdGVyKCh0KSA9PiAhdC5kaXNhYmxlZCkuZXZlcnkoKHQpID0+IHQuc2VsZWN0ZWQpO1xufVxuY29uc3QgRWcgPSBcImRhdGEtdGUtc2VsZWN0LWZvcm0tb3V0bGluZS1yZWZcIiwgQ2cgPSBcImRhdGEtdGUtc2VsZWN0LXdyYXBwZXItcmVmXCIsIEFnID0gXCJkYXRhLXRlLXNlbGVjdC1pbnB1dC1yZWZcIiwgeWcgPSBcImRhdGEtdGUtc2VsZWN0LWNsZWFyLWJ0bi1yZWZcIiwgd2cgPSBcImRhdGEtdGUtc2VsZWN0LWRyb3Bkb3duLWNvbnRhaW5lci1yZWZcIiwga2cgPSBcImRhdGEtdGUtc2VsZWN0LWRyb3Bkb3duLXJlZlwiLCB4ZyA9IFwiZGF0YS10ZS1zZWxlY3Qtb3B0aW9ucy13cmFwcGVyLXJlZlwiLCBPZyA9IFwiZGF0YS10ZS1zZWxlY3Qtb3B0aW9ucy1saXN0LXJlZlwiLCBTZyA9IFwiZGF0YS10ZS1zZWxlY3QtaW5wdXQtZmlsdGVyLXJlZlwiLCBKYyA9IFwiZGF0YS10ZS1zZWxlY3Qtb3B0aW9uLXJlZlwiLCBJZyA9IFwiZGF0YS10ZS1zZWxlY3Qtb3B0aW9uLWFsbC1yZWZcIiwgRGcgPSBcImRhdGEtdGUtc2VsZWN0LW9wdGlvbi10ZXh0LXJlZlwiLCAkZyA9IFwiZGF0YS10ZS1mb3JtLWNoZWNrLWlucHV0XCIsIExnID0gXCJkYXRhLXRlLXNlbGVjdC1vcHRpb24tZ3JvdXAtcmVmXCIsIE5nID0gXCJkYXRhLXRlLXNlbGVjdC1vcHRpb24tZ3JvdXAtbGFiZWwtcmVmXCIsIHRoID0gXCJkYXRhLXRlLXNlbGVjdC1zZWxlY3RlZFwiLCBNZyA9IGBcbjxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIGZpbGw9XCJub25lXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIHN0cm9rZS13aWR0aD1cIjEuNVwiIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiPlxuICA8cGF0aCBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIiBkPVwiTTE5LjUgOC4yNWwtNy41IDcuNS03LjUtNy41XCIgLz5cbjwvc3ZnPlxuYCwgUmcgPSAocykgPT4ge1xuICBzLmNvZGUgPT09IFwiVGFiXCIgfHwgcy5jb2RlID09PSBcIkVzY1wiIHx8IHMucHJldmVudERlZmF1bHQoKTtcbn07XG5mdW5jdGlvbiBBcyhzLCB0LCBlLCBpLCBuKSB7XG4gIHQuc2VsZWN0U2l6ZSA9PT0gXCJkZWZhdWx0XCIgJiYgaC5hZGRDbGFzcyhzLCBlKSwgdC5zZWxlY3RTaXplID09PSBcInNtXCIgJiYgaC5hZGRDbGFzcyhzLCBpKSwgdC5zZWxlY3RTaXplID09PSBcImxnXCIgJiYgaC5hZGRDbGFzcyhzLCBuKTtcbn1cbmZ1bmN0aW9uIFBnKHMsIHQsIGUsIGksIG4pIHtcbiAgY29uc3QgbyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gIG8uc2V0QXR0cmlidXRlKFwiaWRcIiwgcyksIG8uc2V0QXR0cmlidXRlKENnLCBcIlwiKTtcbiAgY29uc3QgciA9ICQoXCJkaXZcIik7XG4gIHIuc2V0QXR0cmlidXRlKEVnLCBcIlwiKSwgaC5hZGRDbGFzcyhyLCBpLmZvcm1PdXRsaW5lKTtcbiAgY29uc3QgYSA9ICQoXCJpbnB1dFwiKSwgbCA9IHQuc2VsZWN0RmlsdGVyID8gXCJjb21ib2JveFwiIDogXCJsaXN0Ym94XCIsIHAgPSB0Lm11bHRpcGxlID8gXCJ0cnVlXCIgOiBcImZhbHNlXCIsIHUgPSB0LmRpc2FibGVkID8gXCJ0cnVlXCIgOiBcImZhbHNlXCI7XG4gIGEuc2V0QXR0cmlidXRlKEFnLCBcIlwiKSwgaC5hZGRDbGFzcyhhLCBpLnNlbGVjdElucHV0KSwgQXMoXG4gICAgYSxcbiAgICB0LFxuICAgIGkuc2VsZWN0SW5wdXRTaXplRGVmYXVsdCxcbiAgICBpLnNlbGVjdElucHV0U2l6ZVNtLFxuICAgIGkuc2VsZWN0SW5wdXRTaXplTGdcbiAgKSwgdC5zZWxlY3RGb3JtV2hpdGUgJiYgaC5hZGRDbGFzcyhhLCBpLnNlbGVjdElucHV0V2hpdGUpLCBhLnNldEF0dHJpYnV0ZShcInR5cGVcIiwgXCJ0ZXh0XCIpLCBhLnNldEF0dHJpYnV0ZShcInJvbGVcIiwgbCksIGEuc2V0QXR0cmlidXRlKFwiYXJpYS1tdWx0aXNlbGVjdGFibGVcIiwgcCksIGEuc2V0QXR0cmlidXRlKFwiYXJpYS1kaXNhYmxlZFwiLCB1KSwgYS5zZXRBdHRyaWJ1dGUoXCJhcmlhLWhhc3BvcHVwXCIsIFwidHJ1ZVwiKSwgYS5zZXRBdHRyaWJ1dGUoXCJhcmlhLWV4cGFuZGVkXCIsICExKSwgYS5uYW1lID0gbiwgdC50YWJJbmRleCAmJiBhLnNldEF0dHJpYnV0ZShcInRhYkluZGV4XCIsIHQudGFiSW5kZXgpLCB0LmRpc2FibGVkICYmIGEuc2V0QXR0cmlidXRlKFwiZGlzYWJsZWRcIiwgXCJcIiksIHQuc2VsZWN0UGxhY2Vob2xkZXIgIT09IFwiXCIgJiYgYS5zZXRBdHRyaWJ1dGUoXCJwbGFjZWhvbGRlclwiLCB0LnNlbGVjdFBsYWNlaG9sZGVyKSwgdC5zZWxlY3RWYWxpZGF0aW9uID8gKGguYWRkU3R5bGUoYSwge1xuICAgIFwicG9pbnRlci1ldmVudHNcIjogXCJub25lXCIsXG4gICAgXCJjYXJldC1jb2xvclwiOiBcInRyYW5zcGFyZW50XCJcbiAgfSksIGguYWRkU3R5bGUociwgeyBjdXJzb3I6IFwicG9pbnRlclwiIH0pKSA6IGEuc2V0QXR0cmlidXRlKFwicmVhZG9ubHlcIiwgXCJ0cnVlXCIpLCB0LnNlbGVjdFZhbGlkYXRpb24gJiYgKGEuc2V0QXR0cmlidXRlKFwicmVxdWlyZWRcIiwgXCJ0cnVlXCIpLCBhLnNldEF0dHJpYnV0ZShcImFyaWEtcmVxdWlyZWRcIiwgXCJ0cnVlXCIpLCBhLmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIFJnKSk7XG4gIGNvbnN0IF8gPSAkKFwiZGl2XCIpO1xuICBoLmFkZENsYXNzKF8sIGkuc2VsZWN0VmFsaWRhdGlvblZhbGlkKTtcbiAgY29uc3QgZiA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFxuICAgIGAke3Quc2VsZWN0VmFsaWRGZWVkYmFja31gXG4gICk7XG4gIF8uYXBwZW5kQ2hpbGQoZik7XG4gIGNvbnN0IGcgPSAkKFwiZGl2XCIpO1xuICBoLmFkZENsYXNzKGcsIGkuc2VsZWN0VmFsaWRhdGlvbkludmFsaWQpO1xuICBjb25zdCBtID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXG4gICAgYCR7dC5zZWxlY3RJbnZhbGlkRmVlZGJhY2t9YFxuICApO1xuICBnLmFwcGVuZENoaWxkKG0pO1xuICBjb25zdCBiID0gJChcInNwYW5cIik7XG4gIGIuc2V0QXR0cmlidXRlKHlnLCBcIlwiKSwgaC5hZGRDbGFzcyhiLCBpLnNlbGVjdENsZWFyQnRuKSwgQXMoXG4gICAgYixcbiAgICB0LFxuICAgIGkuc2VsZWN0Q2xlYXJCdG5EZWZhdWx0LFxuICAgIGkuc2VsZWN0Q2xlYXJCdG5TbSxcbiAgICBpLnNlbGVjdENsZWFyQnRuTGdcbiAgKSwgdC5zZWxlY3RGb3JtV2hpdGUgJiYgaC5hZGRDbGFzcyhiLCBpLnNlbGVjdENsZWFyQnRuV2hpdGUpO1xuICBjb25zdCB2ID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCLinJVcIik7XG4gIGIuYXBwZW5kQ2hpbGQodiksIGIuc2V0QXR0cmlidXRlKFwidGFiaW5kZXhcIiwgXCIwXCIpO1xuICBjb25zdCBDID0gJChcInNwYW5cIik7XG4gIHJldHVybiBoLmFkZENsYXNzKEMsIGkuc2VsZWN0QXJyb3cpLCBBcyhcbiAgICBDLFxuICAgIHQsXG4gICAgaS5zZWxlY3RBcnJvd0RlZmF1bHQsXG4gICAgaS5zZWxlY3RBcnJvd1NtLFxuICAgIGkuc2VsZWN0QXJyb3dMZ1xuICApLCB0LnNlbGVjdEZvcm1XaGl0ZSAmJiBoLmFkZENsYXNzKEMsIGkuc2VsZWN0QXJyb3dXaGl0ZSksIEMuaW5uZXJIVE1MID0gTWcsIHIuYXBwZW5kQ2hpbGQoYSksIGUgJiYgKGguYWRkQ2xhc3MoZSwgaS5zZWxlY3RMYWJlbCksIEFzKFxuICAgIGUsXG4gICAgdCxcbiAgICBpLnNlbGVjdExhYmVsU2l6ZURlZmF1bHQsXG4gICAgaS5zZWxlY3RMYWJlbFNpemVTbSxcbiAgICBpLnNlbGVjdExhYmVsU2l6ZUxnXG4gICksIHQuc2VsZWN0Rm9ybVdoaXRlICYmIGguYWRkQ2xhc3MoZSwgaS5zZWxlY3RMYWJlbFdoaXRlKSwgci5hcHBlbmRDaGlsZChlKSksIHQuc2VsZWN0VmFsaWRhdGlvbiAmJiAoci5hcHBlbmRDaGlsZChfKSwgci5hcHBlbmRDaGlsZChnKSksIHQuc2VsZWN0Q2xlYXJCdXR0b24gJiYgci5hcHBlbmRDaGlsZChiKSwgci5hcHBlbmRDaGlsZChDKSwgby5hcHBlbmRDaGlsZChyKSwgbztcbn1cbmZ1bmN0aW9uIGFsKHMsIHQsIGUsIGksIG4sIG8sIHIsIGEpIHtcbiAgY29uc3QgbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gIGwuc2V0QXR0cmlidXRlKHdnLCBcIlwiKSwgaC5hZGRDbGFzcyhsLCBhLnNlbGVjdERyb3Bkb3duQ29udGFpbmVyKSwgbC5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBgJHtzfWApLCBsLnN0eWxlLndpZHRoID0gYCR7ZX1weGA7XG4gIGNvbnN0IHAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICBwLnNldEF0dHJpYnV0ZShcInRhYmluZGV4XCIsIDApLCBwLnNldEF0dHJpYnV0ZShrZywgXCJcIiksIGguYWRkQ2xhc3MocCwgYS5kcm9wZG93bik7XG4gIGNvbnN0IHUgPSAkKFwiZGl2XCIpO1xuICB1LnNldEF0dHJpYnV0ZSh4ZywgXCJcIiksIGguYWRkQ2xhc3ModSwgYS5vcHRpb25zV3JhcHBlciksIGguYWRkQ2xhc3ModSwgYS5vcHRpb25zV3JhcHBlclNjcm9sbGJhciksIHUuc3R5bGUubWF4SGVpZ2h0ID0gYCR7aX1weGA7XG4gIGNvbnN0IF8gPSBlaChcbiAgICBvLFxuICAgIG4sXG4gICAgdCxcbiAgICBhXG4gICk7XG4gIHJldHVybiB1LmFwcGVuZENoaWxkKF8pLCB0LnNlbGVjdEZpbHRlciAmJiBwLmFwcGVuZENoaWxkKFxuICAgIEJnKHQuc2VsZWN0U2VhcmNoUGxhY2Vob2xkZXIsIGEpXG4gICksIHAuYXBwZW5kQ2hpbGQodSksIHIgJiYgcC5hcHBlbmRDaGlsZChyKSwgbC5hcHBlbmRDaGlsZChwKSwgbDtcbn1cbmZ1bmN0aW9uIGVoKHMsIHQsIGUsIGkpIHtcbiAgY29uc3QgbiA9ICQoXCJkaXZcIik7XG4gIG4uc2V0QXR0cmlidXRlKE9nLCBcIlwiKSwgaC5hZGRDbGFzcyhuLCBpLm9wdGlvbnNMaXN0KTtcbiAgbGV0IG87XG4gIHJldHVybiBlLm11bHRpcGxlID8gbyA9IFZnKFxuICAgIHMsXG4gICAgdCxcbiAgICBlLFxuICAgIGlcbiAgKSA6IG8gPSBIZyhzLCBlLCBpKSwgby5mb3JFYWNoKChyKSA9PiB7XG4gICAgbi5hcHBlbmRDaGlsZChyKTtcbiAgfSksIG47XG59XG5mdW5jdGlvbiBCZyhzLCB0KSB7XG4gIGNvbnN0IGUgPSAkKFwiZGl2XCIpO1xuICBoLmFkZENsYXNzKGUsIHQuaW5wdXRHcm91cCk7XG4gIGNvbnN0IGkgPSAkKFwiaW5wdXRcIik7XG4gIHJldHVybiBpLnNldEF0dHJpYnV0ZShTZywgXCJcIiksIGguYWRkQ2xhc3MoaSwgdC5zZWxlY3RGaWx0ZXJJbnB1dCksIGkucGxhY2Vob2xkZXIgPSBzLCBpLnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJzZWFyY2hib3hcIiksIGkuc2V0QXR0cmlidXRlKFwidHlwZVwiLCBcInRleHRcIiksIGUuYXBwZW5kQ2hpbGQoaSksIGU7XG59XG5mdW5jdGlvbiBIZyhzLCB0LCBlKSB7XG4gIHJldHVybiBpaChzLCB0LCBlKTtcbn1cbmZ1bmN0aW9uIFZnKHMsIHQsIGUsIGkpIHtcbiAgbGV0IG4gPSBudWxsO1xuICBlLnNlbGVjdEFsbCAmJiAobiA9IFdnKFxuICAgIHQsXG4gICAgcyxcbiAgICBlLFxuICAgIGlcbiAgKSk7XG4gIGNvbnN0IG8gPSBpaChzLCBlLCBpKTtcbiAgcmV0dXJuIG4gPyBbbiwgLi4ub10gOiBvO1xufVxuZnVuY3Rpb24gaWgocywgdCwgZSkge1xuICBjb25zdCBpID0gW107XG4gIHJldHVybiBzLmZvckVhY2goKG4pID0+IHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKFxuICAgICAgbixcbiAgICAgIFwib3B0aW9uc1wiXG4gICAgKSkge1xuICAgICAgY29uc3QgciA9IEtnKG4sIHQsIGUpO1xuICAgICAgaS5wdXNoKHIpO1xuICAgIH0gZWxzZVxuICAgICAgaS5wdXNoKHNoKG4sIHQsIGUpKTtcbiAgfSksIGk7XG59XG5mdW5jdGlvbiBXZyhzLCB0LCBlLCBpKSB7XG4gIGNvbnN0IG4gPSBWbyh0KSwgbyA9ICQoXCJkaXZcIik7XG4gIHJldHVybiBvLnNldEF0dHJpYnV0ZShKYywgXCJcIiksIGguYWRkQ2xhc3MobywgaS5zZWxlY3RPcHRpb24pLCBvLnNldEF0dHJpYnV0ZShJZywgXCJcIiksIGguYWRkU3R5bGUobywge1xuICAgIGhlaWdodDogYCR7ZS5zZWxlY3RPcHRpb25IZWlnaHR9cHhgXG4gIH0pLCBvLnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJvcHRpb25cIiksIG8uc2V0QXR0cmlidXRlKFwiYXJpYS1zZWxlY3RlZFwiLCBuKSwgbiAmJiBvLnNldEF0dHJpYnV0ZSh0aCwgXCJcIiksIG8uYXBwZW5kQ2hpbGQobmgocywgZSwgaSkpLCBzLnNldE5vZGUobyksIG87XG59XG5mdW5jdGlvbiBzaChzLCB0LCBlKSB7XG4gIGlmIChzLm5vZGUpXG4gICAgcmV0dXJuIHMubm9kZTtcbiAgY29uc3QgaSA9ICQoXCJkaXZcIik7XG4gIHJldHVybiBpLnNldEF0dHJpYnV0ZShKYywgXCJcIiksIGguYWRkQ2xhc3MoaSwgZS5zZWxlY3RPcHRpb24pLCBoLmFkZFN0eWxlKGksIHtcbiAgICBoZWlnaHQ6IGAke3Quc2VsZWN0T3B0aW9uSGVpZ2h0fXB4YFxuICB9KSwgaC5zZXREYXRhQXR0cmlidXRlKGksIFwiaWRcIiwgcy5pZCksIGkuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcIm9wdGlvblwiKSwgaS5zZXRBdHRyaWJ1dGUoXCJhcmlhLXNlbGVjdGVkXCIsIHMuc2VsZWN0ZWQpLCBpLnNldEF0dHJpYnV0ZShcImFyaWEtZGlzYWJsZWRcIiwgcy5kaXNhYmxlZCksIHMuc2VsZWN0ZWQgJiYgaS5zZXRBdHRyaWJ1dGUodGgsIFwiXCIpLCBzLmRpc2FibGVkICYmIGkuc2V0QXR0cmlidXRlKFwiZGF0YS10ZS1zZWxlY3Qtb3B0aW9uLWRpc2FibGVkXCIsICEwKSwgcy5oaWRkZW4gJiYgaC5hZGRDbGFzcyhpLCBcImhpZGRlblwiKSwgaS5hcHBlbmRDaGlsZChuaChzLCB0LCBlKSksIHMuaWNvbiAmJiBpLmFwcGVuZENoaWxkKGpnKHMsIGUpKSwgcy5zZXROb2RlKGkpLCBpO1xufVxuZnVuY3Rpb24gbmgocywgdCwgZSkge1xuICBjb25zdCBpID0gJChcInNwYW5cIik7XG4gIGkuc2V0QXR0cmlidXRlKERnLCBcIlwiKSwgaC5hZGRDbGFzcyhpLCBlLnNlbGVjdE9wdGlvblRleHQpO1xuICBjb25zdCBuID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUocy5sYWJlbCk7XG4gIHJldHVybiB0Lm11bHRpcGxlICYmIGkuYXBwZW5kQ2hpbGQoWWcocywgZSkpLCBpLmFwcGVuZENoaWxkKG4pLCAocy5zZWNvbmRhcnlUZXh0IHx8IHR5cGVvZiBzLnNlY29uZGFyeVRleHQgPT0gXCJudW1iZXJcIikgJiYgaS5hcHBlbmRDaGlsZChcbiAgICBGZyhzLnNlY29uZGFyeVRleHQsIGUpXG4gICksIGk7XG59XG5mdW5jdGlvbiBGZyhzLCB0KSB7XG4gIGNvbnN0IGUgPSAkKFwic3BhblwiKTtcbiAgaC5hZGRDbGFzcyhlLCB0LnNlbGVjdE9wdGlvblNlY29uZGFyeVRleHQpO1xuICBjb25zdCBpID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUocyk7XG4gIHJldHVybiBlLmFwcGVuZENoaWxkKGkpLCBlO1xufVxuZnVuY3Rpb24gWWcocywgdCkge1xuICBjb25zdCBlID0gJChcImlucHV0XCIpO1xuICBlLnNldEF0dHJpYnV0ZShcInR5cGVcIiwgXCJjaGVja2JveFwiKSwgaC5hZGRDbGFzcyhlLCB0LmZvcm1DaGVja0lucHV0KSwgZS5zZXRBdHRyaWJ1dGUoJGcsIFwiXCIpO1xuICBjb25zdCBpID0gJChcImxhYmVsXCIpO1xuICByZXR1cm4gcy5zZWxlY3RlZCAmJiBlLnNldEF0dHJpYnV0ZShcImNoZWNrZWRcIiwgITApLCBzLmRpc2FibGVkICYmIGUuc2V0QXR0cmlidXRlKFwiZGlzYWJsZWRcIiwgITApLCBlLmFwcGVuZENoaWxkKGkpLCBlO1xufVxuZnVuY3Rpb24gamcocywgdCkge1xuICBjb25zdCBlID0gJChcInNwYW5cIiksIGkgPSAkKFwiaW1nXCIpO1xuICByZXR1cm4gaC5hZGRDbGFzcyhpLCB0LnNlbGVjdE9wdGlvbkljb24pLCBpLnNyYyA9IHMuaWNvbiwgZS5hcHBlbmRDaGlsZChpKSwgZTtcbn1cbmZ1bmN0aW9uIEtnKHMsIHQsIGUpIHtcbiAgY29uc3QgaSA9ICQoXCJkaXZcIik7XG4gIGkuc2V0QXR0cmlidXRlKExnLCBcIlwiKSwgaC5hZGRDbGFzcyhpLCBlLnNlbGVjdE9wdGlvbkdyb3VwKSwgaS5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwiZ3JvdXBcIiksIGkuc2V0QXR0cmlidXRlKFwiaWRcIiwgcy5pZCksIHMuaGlkZGVuICYmIGguYWRkQ2xhc3MoaSwgXCJoaWRkZW5cIik7XG4gIGNvbnN0IG4gPSAkKFwibGFiZWxcIik7XG4gIHJldHVybiBuLnNldEF0dHJpYnV0ZShOZywgXCJcIiksIGguYWRkQ2xhc3MobiwgZS5zZWxlY3RPcHRpb25Hcm91cExhYmVsKSwgaC5hZGRTdHlsZShuLCB7IGhlaWdodDogYCR7dC5zZWxlY3RPcHRpb25IZWlnaHR9cHhgIH0pLCBuLnNldEF0dHJpYnV0ZShcImZvclwiLCBzLmlkKSwgbi50ZXh0Q29udGVudCA9IHMubGFiZWwsIGkuYXBwZW5kQ2hpbGQobiksIHMub3B0aW9ucy5mb3JFYWNoKChvKSA9PiB7XG4gICAgaS5hcHBlbmRDaGlsZChzaChvLCB0LCBlKSk7XG4gIH0pLCBpO1xufVxuZnVuY3Rpb24gemcocywgdCkge1xuICBjb25zdCBlID0gJChcImRpdlwiKTtcbiAgcmV0dXJuIGUuaW5uZXJIVE1MID0gcywgaC5hZGRDbGFzcyhlLCB0LnNlbGVjdExhYmVsKSwgaC5hZGRDbGFzcyhlLCB0LnNlbGVjdEZha2VWYWx1ZSksIGU7XG59XG5jb25zdCBvbyA9IFwic2VsZWN0XCIsIHZpID0gXCJ0ZS5zZWxlY3RcIiwgamkgPSBgLiR7dml9YCwgVWcgPSBgY2xvc2Uke2ppfWAsIFhnID0gYG9wZW4ke2ppfWAsIGxsID0gYG9wdGlvblNlbGVjdCR7aml9YCwgY2wgPSBgb3B0aW9uRGVzZWxlY3Qke2ppfWAsIEdnID0gYHZhbHVlQ2hhbmdlJHtqaX1gLCBxZyA9IFwiY2hhbmdlXCIsIGhsID0gXCJkYXRhLXRlLXNlbGVjdC1pbml0XCIsIG9oID0gXCJkYXRhLXRlLXNlbGVjdC1uby1yZXN1bHRzLXJlZlwiLCBkbCA9IFwiZGF0YS10ZS1zZWxlY3Qtb3BlblwiLCBxID0gXCJkYXRhLXRlLWlucHV0LXN0YXRlLWFjdGl2ZVwiLCBLdCA9IFwiZGF0YS10ZS1pbnB1dC1mb2N1c2VkXCIsIHJvID0gXCJkYXRhLXRlLWlucHV0LWRpc2FibGVkXCIsIFpnID0gXCJkYXRhLXRlLXNlbGVjdC1vcHRpb24tZ3JvdXAtbGFiZWwtcmVmXCIsIFFnID0gXCJkYXRhLXRlLXNlbGVjdC1vcHRpb24tYWxsLXJlZlwiLCBwaSA9IFwiZGF0YS10ZS1zZWxlY3Qtc2VsZWN0ZWRcIiwgSmcgPSBcIltkYXRhLXRlLXNlbGVjdC1sYWJlbC1yZWZdXCIsIHVsID0gXCJbZGF0YS10ZS1zZWxlY3QtaW5wdXQtcmVmXVwiLCB0YiA9IFwiW2RhdGEtdGUtc2VsZWN0LWlucHV0LWZpbHRlci1yZWZdXCIsIGViID0gXCJbZGF0YS10ZS1zZWxlY3QtZHJvcGRvd24tcmVmXVwiLCBpYiA9IFwiW2RhdGEtdGUtc2VsZWN0LW9wdGlvbnMtd3JhcHBlci1yZWZdXCIsIHBsID0gXCJbZGF0YS10ZS1zZWxlY3Qtb3B0aW9ucy1saXN0LXJlZl1cIiwgc2IgPSBcIltkYXRhLXRlLXNlbGVjdC1vcHRpb24tcmVmXVwiLCBuYiA9IFwiW2RhdGEtdGUtc2VsZWN0LWNsZWFyLWJ0bi1yZWZdXCIsIG9iID0gXCJbZGF0YS10ZS1zZWxlY3QtY3VzdG9tLWNvbnRlbnQtcmVmXVwiLCByYiA9IGBbJHtvaH1dYCwgX2wgPSBcIltkYXRhLXRlLXNlbGVjdC1mb3JtLW91dGxpbmUtcmVmXVwiLCBhYiA9IFwiW2RhdGEtdGUtc2VsZWN0LXRvZ2dsZV1cIiwgYW8gPSBcIltkYXRhLXRlLWlucHV0LW5vdGNoLXJlZl1cIiwgbGIgPSAyMDAsIGNiID0ge1xuICBzZWxlY3RBdXRvU2VsZWN0OiAhMSxcbiAgc2VsZWN0Q29udGFpbmVyOiBcImJvZHlcIixcbiAgc2VsZWN0Q2xlYXJCdXR0b246ICExLFxuICBkaXNhYmxlZDogITEsXG4gIHNlbGVjdERpc3BsYXllZExhYmVsczogNSxcbiAgc2VsZWN0Rm9ybVdoaXRlOiAhMSxcbiAgbXVsdGlwbGU6ICExLFxuICBzZWxlY3RPcHRpb25zU2VsZWN0ZWRMYWJlbDogXCJvcHRpb25zIHNlbGVjdGVkXCIsXG4gIHNlbGVjdE9wdGlvbkhlaWdodDogMzgsXG4gIHNlbGVjdEFsbDogITAsXG4gIHNlbGVjdEFsbExhYmVsOiBcIlNlbGVjdCBhbGxcIixcbiAgc2VsZWN0U2VhcmNoUGxhY2Vob2xkZXI6IFwiU2VhcmNoLi4uXCIsXG4gIHNlbGVjdFNpemU6IFwiZGVmYXVsdFwiLFxuICBzZWxlY3RWaXNpYmxlT3B0aW9uczogNSxcbiAgc2VsZWN0RmlsdGVyOiAhMSxcbiAgc2VsZWN0RmlsdGVyRGVib3VuY2U6IDMwMCxcbiAgc2VsZWN0Tm9SZXN1bHRUZXh0OiBcIk5vIHJlc3VsdHNcIixcbiAgc2VsZWN0VmFsaWRhdGlvbjogITEsXG4gIHNlbGVjdFZhbGlkRmVlZGJhY2s6IFwiVmFsaWRcIixcbiAgc2VsZWN0SW52YWxpZEZlZWRiYWNrOiBcIkludmFsaWRcIixcbiAgc2VsZWN0UGxhY2Vob2xkZXI6IFwiXCJcbn0sIGhiID0ge1xuICBzZWxlY3RBdXRvU2VsZWN0OiBcImJvb2xlYW5cIixcbiAgc2VsZWN0Q29udGFpbmVyOiBcInN0cmluZ1wiLFxuICBzZWxlY3RDbGVhckJ1dHRvbjogXCJib29sZWFuXCIsXG4gIGRpc2FibGVkOiBcImJvb2xlYW5cIixcbiAgc2VsZWN0RGlzcGxheWVkTGFiZWxzOiBcIm51bWJlclwiLFxuICBzZWxlY3RGb3JtV2hpdGU6IFwiYm9vbGVhblwiLFxuICBtdWx0aXBsZTogXCJib29sZWFuXCIsXG4gIHNlbGVjdE9wdGlvbnNTZWxlY3RlZExhYmVsOiBcInN0cmluZ1wiLFxuICBzZWxlY3RPcHRpb25IZWlnaHQ6IFwibnVtYmVyXCIsXG4gIHNlbGVjdEFsbDogXCJib29sZWFuXCIsXG4gIHNlbGVjdEFsbExhYmVsOiBcInN0cmluZ1wiLFxuICBzZWxlY3RTZWFyY2hQbGFjZWhvbGRlcjogXCJzdHJpbmdcIixcbiAgc2VsZWN0U2l6ZTogXCJzdHJpbmdcIixcbiAgc2VsZWN0VmlzaWJsZU9wdGlvbnM6IFwibnVtYmVyXCIsXG4gIHNlbGVjdEZpbHRlcjogXCJib29sZWFuXCIsXG4gIHNlbGVjdEZpbHRlckRlYm91bmNlOiBcIm51bWJlclwiLFxuICBzZWxlY3ROb1Jlc3VsdFRleHQ6IFwic3RyaW5nXCIsXG4gIHNlbGVjdFZhbGlkYXRpb246IFwiYm9vbGVhblwiLFxuICBzZWxlY3RWYWxpZEZlZWRiYWNrOiBcInN0cmluZ1wiLFxuICBzZWxlY3RJbnZhbGlkRmVlZGJhY2s6IFwic3RyaW5nXCIsXG4gIHNlbGVjdFBsYWNlaG9sZGVyOiBcInN0cmluZ1wiXG59LCBkYiA9IHtcbiAgZHJvcGRvd246IFwicmVsYXRpdmUgb3V0bGluZS1ub25lIG1pbi13LVsxMDBweF0gbS0wIHNjYWxlLVswLjhdIG9wYWNpdHktMCBiZy13aGl0ZSBzaGFkb3ctWzBfMnB4XzVweF8wX3JnYmEoMCwwLDAsMC4xNiksXzBfMnB4XzEwcHhfMF9yZ2JhKDAsMCwwLDAuMTIpXSB0cmFuc2l0aW9uIGR1cmF0aW9uLTIwMCBtb3Rpb24tcmVkdWNlOnRyYW5zaXRpb24tbm9uZSBkYXRhLVt0ZS1zZWxlY3Qtb3Blbl06c2NhbGUtMTAwIGRhdGEtW3RlLXNlbGVjdC1vcGVuXTpvcGFjaXR5LTEwMCBkYXJrOmJnLXppbmMtNzAwXCIsXG4gIGZvcm1DaGVja0lucHV0OiBcInJlbGF0aXZlIGZsb2F0LWxlZnQgbXQtWzAuMTVyZW1dIG1yLVs4cHhdIGgtWzEuMTI1cmVtXSB3LVsxLjEyNXJlbV0gYXBwZWFyYW5jZS1ub25lIHJvdW5kZWQtWzAuMjVyZW1dIGJvcmRlci1bMC4xMjVyZW1dIGJvcmRlci1zb2xpZCBib3JkZXItbmV1dHJhbC0zMDAgZGFyazpib3JkZXItbmV1dHJhbC02MDAgb3V0bGluZS1ub25lIGJlZm9yZTpwb2ludGVyLWV2ZW50cy1ub25lIGJlZm9yZTphYnNvbHV0ZSBiZWZvcmU6aC1bMC44NzVyZW1dIGJlZm9yZTp3LVswLjg3NXJlbV0gYmVmb3JlOnNjYWxlLTAgYmVmb3JlOnJvdW5kZWQtZnVsbCBiZWZvcmU6YmctdHJhbnNwYXJlbnQgYmVmb3JlOm9wYWNpdHktMCBiZWZvcmU6c2hhZG93LVswcHhfMHB4XzBweF8xM3B4X3RyYW5zcGFyZW50XSBiZWZvcmU6Y29udGVudC1bJyddIGNoZWNrZWQ6Ym9yZGVyLXByaW1hcnkgZGFyazpjaGVja2VkOmJvcmRlci1wcmltYXJ5IGNoZWNrZWQ6YmctcHJpbWFyeSBkYXJrOmNoZWNrZWQ6YmctcHJpbWFyeSBjaGVja2VkOmJlZm9yZTpvcGFjaXR5LVswLjE2XSBjaGVja2VkOmFmdGVyOmFic29sdXRlIGNoZWNrZWQ6YWZ0ZXI6bWwtWzAuMjVyZW1dIGNoZWNrZWQ6YWZ0ZXI6LW10LXB4IGNoZWNrZWQ6YWZ0ZXI6YmxvY2sgY2hlY2tlZDphZnRlcjpoLVswLjgxMjVyZW1dIGNoZWNrZWQ6YWZ0ZXI6dy1bMC4zNzVyZW1dIGNoZWNrZWQ6YWZ0ZXI6cm90YXRlLTQ1IGNoZWNrZWQ6YWZ0ZXI6Ym9yZGVyLVswLjEyNXJlbV0gY2hlY2tlZDphZnRlcjpib3JkZXItdC0wIGNoZWNrZWQ6YWZ0ZXI6Ym9yZGVyLWwtMCBjaGVja2VkOmFmdGVyOmJvcmRlci1zb2xpZCBjaGVja2VkOmFmdGVyOmJvcmRlci13aGl0ZSBjaGVja2VkOmFmdGVyOmJnLXRyYW5zcGFyZW50IGNoZWNrZWQ6YWZ0ZXI6Y29udGVudC1bJyddIGhvdmVyOmN1cnNvci1wb2ludGVyIGhvdmVyOmJlZm9yZTpvcGFjaXR5LVswLjA0XSBob3ZlcjpiZWZvcmU6c2hhZG93LVswcHhfMHB4XzBweF8xM3B4X3JnYmEoMCwwLDAsMC42KV0gZm9jdXM6c2hhZG93LW5vbmUgZm9jdXM6dHJhbnNpdGlvbi1bYm9yZGVyLWNvbG9yXzAuMnNdIGZvY3VzOmJlZm9yZTpzY2FsZS0xMDAgZm9jdXM6YmVmb3JlOm9wYWNpdHktWzAuMTJdIGZvY3VzOmJlZm9yZTpzaGFkb3ctWzBweF8wcHhfMHB4XzEzcHhfcmdiYSgwLDAsMCwwLjYpXSBkYXJrOmZvY3VzOmJlZm9yZTpzaGFkb3ctWzBweF8wcHhfMHB4XzEzcHhfcmdiYSgyNTUsMjU1LDI1NSwwLjQpXSBmb2N1czpiZWZvcmU6dHJhbnNpdGlvbi1bYm94LXNoYWRvd18wLjJzLHRyYW5zZm9ybV8wLjJzXSBmb2N1czphZnRlcjphYnNvbHV0ZSBmb2N1czphZnRlcjp6LVsxXSBmb2N1czphZnRlcjpibG9jayBmb2N1czphZnRlcjpoLVswLjg3NXJlbV0gZm9jdXM6YWZ0ZXI6dy1bMC44NzVyZW1dIGZvY3VzOmFmdGVyOnJvdW5kZWQtWzAuMTI1cmVtXSBmb2N1czphZnRlcjpjb250ZW50LVsnJ10gY2hlY2tlZDpmb2N1czpiZWZvcmU6c2NhbGUtMTAwIGNoZWNrZWQ6Zm9jdXM6YmVmb3JlOnNoYWRvdy1bMHB4XzBweF8wcHhfMTNweF8jM2I3MWNhXSBkYXJrOmNoZWNrZWQ6Zm9jdXM6YmVmb3JlOnNoYWRvdy1bMHB4XzBweF8wcHhfMTNweF8jM2I3MWNhXSBjaGVja2VkOmZvY3VzOmJlZm9yZTp0cmFuc2l0aW9uLVtib3gtc2hhZG93XzAuMnMsdHJhbnNmb3JtXzAuMnNdIGNoZWNrZWQ6Zm9jdXM6YWZ0ZXI6bWwtWzAuMjVyZW1dIGNoZWNrZWQ6Zm9jdXM6YWZ0ZXI6LW10LXB4IGNoZWNrZWQ6Zm9jdXM6YWZ0ZXI6aC1bMC44MTI1cmVtXSBjaGVja2VkOmZvY3VzOmFmdGVyOnctWzAuMzc1cmVtXSBjaGVja2VkOmZvY3VzOmFmdGVyOnJvdGF0ZS00NSBjaGVja2VkOmZvY3VzOmFmdGVyOnJvdW5kZWQtbm9uZSBjaGVja2VkOmZvY3VzOmFmdGVyOmJvcmRlci1bMC4xMjVyZW1dIGNoZWNrZWQ6Zm9jdXM6YWZ0ZXI6Ym9yZGVyLXQtMCBjaGVja2VkOmZvY3VzOmFmdGVyOmJvcmRlci1sLTAgY2hlY2tlZDpmb2N1czphZnRlcjpib3JkZXItc29saWQgY2hlY2tlZDpmb2N1czphZnRlcjpib3JkZXItd2hpdGUgY2hlY2tlZDpmb2N1czphZnRlcjpiZy10cmFuc3BhcmVudFwiLFxuICBmb3JtT3V0bGluZTogXCJyZWxhdGl2ZVwiLFxuICBpbml0aWFsaXplZDogXCJoaWRkZW5cIixcbiAgaW5wdXRHcm91cDogXCJmbGV4IGl0ZW1zLWNlbnRlciB3aGl0ZXNwYWNlLW5vd3JhcCBwLTIuNSB0ZXh0LWNlbnRlciB0ZXh0LWJhc2UgZm9udC1ub3JtYWwgbGVhZGluZy1bMS42XSB0ZXh0LWdyYXktNzAwIGRhcms6YmctemluYy04MDAgZGFyazp0ZXh0LWdyYXktMjAwIGRhcms6cGxhY2Vob2xkZXI6dGV4dC1ncmF5LTIwMFwiLFxuICBub1Jlc3VsdDogXCJmbGV4IGl0ZW1zLWNlbnRlciBweC00XCIsXG4gIG9wdGlvbnNMaXN0OiBcImxpc3Qtbm9uZSBtLTAgcC0wXCIsXG4gIG9wdGlvbnNXcmFwcGVyOiBcIm92ZXJmbG93LXktYXV0b1wiLFxuICBvcHRpb25zV3JhcHBlclNjcm9sbGJhcjogXCJbJjo6LXdlYmtpdC1zY3JvbGxiYXJdOnctMSBbJjo6LXdlYmtpdC1zY3JvbGxiYXJdOmgtMSBbJjo6LXdlYmtpdC1zY3JvbGxiYXItYnV0dG9uXTpibG9jayBbJjo6LXdlYmtpdC1zY3JvbGxiYXItYnV0dG9uXTpoLTAgWyY6Oi13ZWJraXQtc2Nyb2xsYmFyLWJ1dHRvbl06YmctdHJhbnNwYXJlbnQgWyY6Oi13ZWJraXQtc2Nyb2xsYmFyLXRyYWNrLXBpZWNlXTpiZy10cmFuc3BhcmVudCBbJjo6LXdlYmtpdC1zY3JvbGxiYXItdHJhY2stcGllY2VdOnJvdW5kZWQtbm9uZSBbJjo6LXdlYmtpdC1zY3JvbGxiYXItdHJhY2stcGllY2VdOiBbJjo6LXdlYmtpdC1zY3JvbGxiYXItdHJhY2stcGllY2VdOnJvdW5kZWQtbCBbJjo6LXdlYmtpdC1zY3JvbGxiYXItdGh1bWJdOmgtWzUwcHhdIFsmOjotd2Via2l0LXNjcm9sbGJhci10aHVtYl06YmctWyM5OTldIFsmOjotd2Via2l0LXNjcm9sbGJhci10aHVtYl06cm91bmRlZFwiLFxuICBzZWxlY3RBcnJvdzogXCJhYnNvbHV0ZSByaWdodC0zIHRleHQtWzAuOHJlbV0gY3Vyc29yLXBvaW50ZXIgcGVlci1mb2N1czp0ZXh0LXByaW1hcnkgcGVlci1kYXRhLVt0ZS1pbnB1dC1mb2N1c2VkXTp0ZXh0LXByaW1hcnkgZ3JvdXAtZGF0YS1bdGUtd2FzLXZhbGlkYXRlZF0vdmFsaWRhdGlvbjpwZWVyLXZhbGlkOnRleHQtZ3JlZW4tNjAwIGdyb3VwLWRhdGEtW3RlLXdhcy12YWxpZGF0ZWRdL3ZhbGlkYXRpb246cGVlci1pbnZhbGlkOnRleHQtW3JnYigyMjAsNzYsMTAwKV0gdy01IGgtNVwiLFxuICBzZWxlY3RBcnJvd1doaXRlOiBcInRleHQtZ3JheS01MCBwZWVyLWZvY3VzOiF0ZXh0LXdoaXRlIHBlZXItZGF0YS1bdGUtaW5wdXQtZm9jdXNlZF06IXRleHQtd2hpdGVcIixcbiAgc2VsZWN0QXJyb3dEZWZhdWx0OiBcInRvcC0yXCIsXG4gIHNlbGVjdEFycm93TGc6IFwidG9wLVsxM3B4XVwiLFxuICBzZWxlY3RBcnJvd1NtOiBcInRvcC0xXCIsXG4gIHNlbGVjdENsZWFyQnRuOiBcImFic29sdXRlIHRvcC0yIHJpZ2h0LTkgdGV4dC1ibGFjayBjdXJzb3ItcG9pbnRlciBmb2N1czp0ZXh0LXByaW1hcnkgb3V0bGluZS1ub25lIGRhcms6dGV4dC1ncmF5LTIwMFwiLFxuICBzZWxlY3RDbGVhckJ0bldoaXRlOiBcIiF0ZXh0LWdyYXktNTBcIixcbiAgc2VsZWN0Q2xlYXJCdG5EZWZhdWx0OiBcInRvcC0yIHRleHQtYmFzZVwiLFxuICBzZWxlY3RDbGVhckJ0bkxnOiBcInRvcC1bMTFweF0gdGV4dC1iYXNlXCIsXG4gIHNlbGVjdENsZWFyQnRuU206IFwidG9wLTEgdGV4dC1bMC44cmVtXVwiLFxuICBzZWxlY3REcm9wZG93bkNvbnRhaW5lcjogXCJ6LVsxMDcwXVwiLFxuICBzZWxlY3RGYWtlVmFsdWU6IFwidHJhbnNmb3JtLW5vbmUgaGlkZGVuIGRhdGEtW3RlLWlucHV0LXN0YXRlLWFjdGl2ZV06YmxvY2tcIixcbiAgc2VsZWN0RmlsdGVySW5wdXQ6IFwicmVsYXRpdmUgbS0wIGJsb2NrIHctZnVsbCBtaW4tdy0wIGZsZXgtYXV0byByb3VuZGVkIGJvcmRlciBib3JkZXItc29saWQgYm9yZGVyLWdyYXktMzAwIGJnLXRyYW5zcGFyZW50IGJnLWNsaXAtcGFkZGluZyBweC0zIHB5LTEuNSB0ZXh0LWJhc2UgZm9udC1ub3JtYWwgdGV4dC1ncmF5LTcwMCB0cmFuc2l0aW9uIGR1cmF0aW9uLTMwMCBlYXNlLWluLW91dCBtb3Rpb24tcmVkdWNlOnRyYW5zaXRpb24tbm9uZSBmb2N1czpib3JkZXItcHJpbWFyeSBmb2N1czp0ZXh0LWdyYXktNzAwIGZvY3VzOnNoYWRvdy10ZS1wcmltYXJ5IGZvY3VzOm91dGxpbmUtbm9uZSBkYXJrOnRleHQtZ3JheS0yMDAgZGFyazpwbGFjZWhvbGRlcjp0ZXh0LWdyYXktMjAwXCIsXG4gIHNlbGVjdElucHV0OiBcInBlZXIgYmxvY2sgbWluLWgtW2F1dG9dIHctZnVsbCByb3VuZGVkIGJvcmRlci0wIGJnLXRyYW5zcGFyZW50IG91dGxpbmUtbm9uZSB0cmFuc2l0aW9uLWFsbCBkdXJhdGlvbi0yMDAgZWFzZS1saW5lYXIgZm9jdXM6cGxhY2Vob2xkZXI6b3BhY2l0eS0xMDAgZGF0YS1bdGUtaW5wdXQtc3RhdGUtYWN0aXZlXTpwbGFjZWhvbGRlcjpvcGFjaXR5LTEwMCBtb3Rpb24tcmVkdWNlOnRyYW5zaXRpb24tbm9uZSBkYXJrOnRleHQtZ3JheS0yMDAgZGFyazpwbGFjZWhvbGRlcjp0ZXh0LWdyYXktMjAwIFsmOm5vdChbZGF0YS10ZS1pbnB1dC1wbGFjZWhvbGRlci1hY3RpdmVdKV06cGxhY2Vob2xkZXI6b3BhY2l0eS0wIGN1cnNvci1wb2ludGVyIGRhdGEtW3RlLWlucHV0LWRpc2FibGVkXTpiZy1bI2U5ZWNlZl0gZGF0YS1bdGUtaW5wdXQtZGlzYWJsZWRdOmN1cnNvci1kZWZhdWx0IGdyb3VwLWRhdGEtW3RlLXdhcy12YWxpZGF0ZWRdL3ZhbGlkYXRpb246bWItNCBkYXJrOmRhdGEtW3RlLWlucHV0LWRpc2FibGVkXTpiZy16aW5jLTYwMFwiLFxuICBzZWxlY3RJbnB1dFdoaXRlOiBcIiF0ZXh0LWdyYXktNTBcIixcbiAgc2VsZWN0SW5wdXRTaXplRGVmYXVsdDogXCJweS1bMC4zMnJlbV0gcHgtMyBsZWFkaW5nLVsxLjZdXCIsXG4gIHNlbGVjdElucHV0U2l6ZUxnOiBcInB5LVswLjMycmVtXSBweC0zIGxlYWRpbmctWzIuMTVdXCIsXG4gIHNlbGVjdElucHV0U2l6ZVNtOiBcInB5LVswLjMzcmVtXSBweC0zIHRleHQteHMgbGVhZGluZy1bMS41XVwiLFxuICBzZWxlY3RMYWJlbDogXCJwb2ludGVyLWV2ZW50cy1ub25lIGFic29sdXRlIHRvcC0wIGxlZnQtMyBtYi0wIG1heC13LVs5MCVdIG9yaWdpbi1bMF8wXSB0cnVuY2F0ZSB0ZXh0LWdyYXktNTAwIHRyYW5zaXRpb24tYWxsIGR1cmF0aW9uLTIwMCBlYXNlLW91dCBwZWVyLWZvY3VzOnNjYWxlLVswLjhdIHBlZXItZm9jdXM6dGV4dC1wcmltYXJ5IHBlZXItZGF0YS1bdGUtaW5wdXQtc3RhdGUtYWN0aXZlXTpzY2FsZS1bMC44XSBtb3Rpb24tcmVkdWNlOnRyYW5zaXRpb24tbm9uZSBkYXJrOnRleHQtZ3JheS0yMDAgZGFyazpwZWVyLWZvY3VzOnRleHQtZ3JheS0yMDAgZGF0YS1bdGUtaW5wdXQtc3RhdGUtYWN0aXZlXTpzY2FsZS1bMC44XSBkYXJrOnBlZXItZm9jdXM6dGV4dC1wcmltYXJ5XCIsXG4gIHNlbGVjdExhYmVsV2hpdGU6IFwiIXRleHQtZ3JheS01MFwiLFxuICBzZWxlY3RMYWJlbFNpemVEZWZhdWx0OiBcInB0LVswLjM3cmVtXSBsZWFkaW5nLVsxLjZdIHBlZXItZm9jdXM6LXRyYW5zbGF0ZS15LVswLjlyZW1dIHBlZXItZGF0YS1bdGUtaW5wdXQtc3RhdGUtYWN0aXZlXTotdHJhbnNsYXRlLXktWzAuOXJlbV0gZGF0YS1bdGUtaW5wdXQtc3RhdGUtYWN0aXZlXTotdHJhbnNsYXRlLXktWzAuOXJlbV1cIixcbiAgc2VsZWN0TGFiZWxTaXplTGc6IFwicHQtWzAuMzdyZW1dIGxlYWRpbmctWzIuMTVdIHBlZXItZm9jdXM6LXRyYW5zbGF0ZS15LVsxLjE1cmVtXSBwZWVyLWRhdGEtW3RlLWlucHV0LXN0YXRlLWFjdGl2ZV06LXRyYW5zbGF0ZS15LVsxLjE1cmVtXSBkYXRhLVt0ZS1pbnB1dC1zdGF0ZS1hY3RpdmVdOi10cmFuc2xhdGUteS1bMS4xNXJlbV1cIixcbiAgc2VsZWN0TGFiZWxTaXplU206IFwicHQtWzAuMzdyZW1dIHRleHQteHMgbGVhZGluZy1bMS41XSBwZWVyLWZvY3VzOi10cmFuc2xhdGUteS1bMC43NXJlbV0gcGVlci1kYXRhLVt0ZS1pbnB1dC1zdGF0ZS1hY3RpdmVdOi10cmFuc2xhdGUteS1bMC43NXJlbV0gZGF0YS1bdGUtaW5wdXQtc3RhdGUtYWN0aXZlXTotdHJhbnNsYXRlLXktWzAuNzVyZW1dXCIsXG4gIHNlbGVjdE9wdGlvbjogXCJmbGV4IGZsZXgtcm93IGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWJldHdlZW4gdy1mdWxsIHB4LTQgdHJ1bmNhdGUgdGV4dC1ncmF5LTcwMCBiZy10cmFuc3BhcmVudCBzZWxlY3Qtbm9uZSBjdXJzb3ItcG9pbnRlciBkYXRhLVt0ZS1pbnB1dC1tdWx0aXBsZS1hY3RpdmVdOmJnLWJsYWNrLzUgaG92ZXI6WyY6bm90KFtkYXRhLXRlLXNlbGVjdC1vcHRpb24tZGlzYWJsZWRdKV06YmctYmxhY2svNSBkYXRhLVt0ZS1pbnB1dC1zdGF0ZS1hY3RpdmVdOmJnLWJsYWNrLzUgZGF0YS1bdGUtc2VsZWN0LW9wdGlvbi1zZWxlY3RlZF06ZGF0YS1bdGUtaW5wdXQtc3RhdGUtYWN0aXZlXTpiZy1ibGFjay81IGRhdGEtW3RlLXNlbGVjdC1zZWxlY3RlZF06ZGF0YS1bdGUtc2VsZWN0LW9wdGlvbi1kaXNhYmxlZF06Y3Vyc29yLWRlZmF1bHQgZGF0YS1bdGUtc2VsZWN0LXNlbGVjdGVkXTpkYXRhLVt0ZS1zZWxlY3Qtb3B0aW9uLWRpc2FibGVkXTp0ZXh0LWdyYXktNDAwIGRhdGEtW3RlLXNlbGVjdC1zZWxlY3RlZF06ZGF0YS1bdGUtc2VsZWN0LW9wdGlvbi1kaXNhYmxlZF06YmctdHJhbnNwYXJlbnQgZGF0YS1bdGUtc2VsZWN0LW9wdGlvbi1zZWxlY3RlZF06YmctYmxhY2svWzAuMDJdIGRhdGEtW3RlLXNlbGVjdC1vcHRpb24tZGlzYWJsZWRdOnRleHQtZ3JheS00MDAgZGF0YS1bdGUtc2VsZWN0LW9wdGlvbi1kaXNhYmxlZF06Y3Vyc29yLWRlZmF1bHQgZ3JvdXAtZGF0YS1bdGUtc2VsZWN0LW9wdGlvbi1ncm91cC1yZWZdL29wdDpwbC03IGRhcms6dGV4dC1ncmF5LTIwMCBkYXJrOmhvdmVyOlsmOm5vdChbZGF0YS10ZS1zZWxlY3Qtb3B0aW9uLWRpc2FibGVkXSldOmJnLXdoaXRlLzMwIGRhcms6ZGF0YS1bdGUtaW5wdXQtc3RhdGUtYWN0aXZlXTpiZy13aGl0ZS8zMCBkYXJrOmRhdGEtW3RlLXNlbGVjdC1vcHRpb24tc2VsZWN0ZWRdOmRhdGEtW3RlLWlucHV0LXN0YXRlLWFjdGl2ZV06Ymctd2hpdGUvMzAgZGFyazpkYXRhLVt0ZS1zZWxlY3Qtb3B0aW9uLWRpc2FibGVkXTp0ZXh0LWdyYXktNDAwIGRhcms6ZGF0YS1bdGUtaW5wdXQtbXVsdGlwbGUtYWN0aXZlXTpiZy13aGl0ZS8zMFwiLFxuICBzZWxlY3RPcHRpb25Hcm91cDogXCJncm91cC9vcHRcIixcbiAgc2VsZWN0T3B0aW9uR3JvdXBMYWJlbDogXCJmbGV4IGZsZXgtcm93IGl0ZW1zLWNlbnRlciB3LWZ1bGwgcHgtNCB0cnVuY2F0ZSBiZy10cmFuc3BhcmVudCB0ZXh0LWJsYWNrLzUwIHNlbGVjdC1ub25lIGRhcms6dGV4dC1ncmF5LTMwMFwiLFxuICBzZWxlY3RPcHRpb25JY29uOiBcInctNyBoLTcgcm91bmRlZC1mdWxsXCIsXG4gIHNlbGVjdE9wdGlvblNlY29uZGFyeVRleHQ6IFwiYmxvY2sgdGV4dC1bMC44cmVtXSB0ZXh0LWdyYXktNTAwIGRhcms6dGV4dC1ncmF5LTMwMFwiLFxuICBzZWxlY3RPcHRpb25UZXh0OiBcImdyb3VwXCIsXG4gIHNlbGVjdFZhbGlkYXRpb25WYWxpZDogXCJoaWRkZW4gYWJzb2x1dGUgLW10LTMgdy1hdXRvIHRleHQtc20gdGV4dC1ncmVlbi02MDAgY3Vyc29yLXBvaW50ZXIgZ3JvdXAtZGF0YS1bdGUtd2FzLXZhbGlkYXRlZF0vdmFsaWRhdGlvbjpwZWVyLXZhbGlkOmJsb2NrXCIsXG4gIHNlbGVjdFZhbGlkYXRpb25JbnZhbGlkOiBcImhpZGRlbiBhYnNvbHV0ZSAtbXQtMyB3LWF1dG8gdGV4dC1zbSB0ZXh0LVtyZ2IoMjIwLDc2LDEwMCldIGN1cnNvci1wb2ludGVyIGdyb3VwLWRhdGEtW3RlLXdhcy12YWxpZGF0ZWRdL3ZhbGlkYXRpb246cGVlci1pbnZhbGlkOmJsb2NrXCJcbn0sIHViID0ge1xuICBkcm9wZG93bjogXCJzdHJpbmdcIixcbiAgZm9ybUNoZWNrSW5wdXQ6IFwic3RyaW5nXCIsXG4gIGZvcm1PdXRsaW5lOiBcInN0cmluZ1wiLFxuICBpbml0aWFsaXplZDogXCJzdHJpbmdcIixcbiAgaW5wdXRHcm91cDogXCJzdHJpbmdcIixcbiAgbm9SZXN1bHQ6IFwic3RyaW5nXCIsXG4gIG9wdGlvbnNMaXN0OiBcInN0cmluZ1wiLFxuICBvcHRpb25zV3JhcHBlcjogXCJzdHJpbmdcIixcbiAgb3B0aW9uc1dyYXBwZXJTY3JvbGxiYXI6IFwic3RyaW5nXCIsXG4gIHNlbGVjdEFycm93OiBcInN0cmluZ1wiLFxuICBzZWxlY3RBcnJvd0RlZmF1bHQ6IFwic3RyaW5nXCIsXG4gIHNlbGVjdEFycm93TGc6IFwic3RyaW5nXCIsXG4gIHNlbGVjdEFycm93U206IFwic3RyaW5nXCIsXG4gIHNlbGVjdENsZWFyQnRuOiBcInN0cmluZ1wiLFxuICBzZWxlY3RDbGVhckJ0bkRlZmF1bHQ6IFwic3RyaW5nXCIsXG4gIHNlbGVjdENsZWFyQnRuTGc6IFwic3RyaW5nXCIsXG4gIHNlbGVjdENsZWFyQnRuU206IFwic3RyaW5nXCIsXG4gIHNlbGVjdERyb3Bkb3duQ29udGFpbmVyOiBcInN0cmluZ1wiLFxuICBzZWxlY3RGYWtlVmFsdWU6IFwic3RyaW5nXCIsXG4gIHNlbGVjdEZpbHRlcklucHV0OiBcInN0cmluZ1wiLFxuICBzZWxlY3RJbnB1dDogXCJzdHJpbmdcIixcbiAgc2VsZWN0SW5wdXRTaXplRGVmYXVsdDogXCJzdHJpbmdcIixcbiAgc2VsZWN0SW5wdXRTaXplTGc6IFwic3RyaW5nXCIsXG4gIHNlbGVjdElucHV0U2l6ZVNtOiBcInN0cmluZ1wiLFxuICBzZWxlY3RMYWJlbDogXCJzdHJpbmdcIixcbiAgc2VsZWN0TGFiZWxTaXplRGVmYXVsdDogXCJzdHJpbmdcIixcbiAgc2VsZWN0TGFiZWxTaXplTGc6IFwic3RyaW5nXCIsXG4gIHNlbGVjdExhYmVsU2l6ZVNtOiBcInN0cmluZ1wiLFxuICBzZWxlY3RPcHRpb246IFwic3RyaW5nXCIsXG4gIHNlbGVjdE9wdGlvbkdyb3VwOiBcInN0cmluZ1wiLFxuICBzZWxlY3RPcHRpb25Hcm91cExhYmVsOiBcInN0cmluZ1wiLFxuICBzZWxlY3RPcHRpb25JY29uOiBcInN0cmluZ1wiLFxuICBzZWxlY3RPcHRpb25TZWNvbmRhcnlUZXh0OiBcInN0cmluZ1wiLFxuICBzZWxlY3RPcHRpb25UZXh0OiBcInN0cmluZ1wiXG59O1xuY2xhc3MgX3Ige1xuICBjb25zdHJ1Y3Rvcih0LCBlLCBpKSB7XG4gICAgdGhpcy5fZWxlbWVudCA9IHQsIHRoaXMuX2NvbmZpZyA9IHRoaXMuX2dldENvbmZpZyhlKSwgdGhpcy5fY2xhc3NlcyA9IHRoaXMuX2dldENsYXNzZXMoaSksIHRoaXMuX2NvbmZpZy5zZWxlY3RQbGFjZWhvbGRlciAmJiAhdGhpcy5fY29uZmlnLm11bHRpcGxlICYmIHRoaXMuX2FkZFBsYWNlaG9sZGVyT3B0aW9uKCksIHRoaXMuX29wdGlvbnNUb1JlbmRlciA9IHRoaXMuX2dldE9wdGlvbnNUb1JlbmRlcih0KSwgdGhpcy5fcGxhaW5PcHRpb25zID0gdGhpcy5fZ2V0UGxhaW5PcHRpb25zKHRoaXMuX29wdGlvbnNUb1JlbmRlciksIHRoaXMuX2ZpbHRlcmVkT3B0aW9uc0xpc3QgPSBudWxsLCB0aGlzLl9zZWxlY3Rpb25Nb2RlbCA9IG5ldyBUZyh0aGlzLm11bHRpcGxlKSwgdGhpcy5fYWN0aXZlT3B0aW9uSW5kZXggPSAtMSwgdGhpcy5fYWN0aXZlT3B0aW9uID0gbnVsbCwgdGhpcy5fd3JhcHBlcklkID0gcnQoXCJzZWxlY3Qtd3JhcHBlci1cIiksIHRoaXMuX2Ryb3Bkb3duQ29udGFpbmVySWQgPSBydChcInNlbGVjdC1kcm9wZG93bi1jb250YWluZXItXCIpLCB0aGlzLl9zZWxlY3RBbGxJZCA9IHJ0KFwic2VsZWN0LWFsbC1cIiksIHRoaXMuX2RlYm91bmNlVGltZW91dElkID0gbnVsbCwgdGhpcy5fZHJvcGRvd25IZWlnaHQgPSB0aGlzLl9jb25maWcuc2VsZWN0T3B0aW9uSGVpZ2h0ICogdGhpcy5fY29uZmlnLnNlbGVjdFZpc2libGVPcHRpb25zLCB0aGlzLl9wb3BwZXIgPSBudWxsLCB0aGlzLl9pbnB1dCA9IG51bGwsIHRoaXMuX2xhYmVsID0gZC5uZXh0KHRoaXMuX2VsZW1lbnQsIEpnKVswXSwgdGhpcy5fbm90Y2ggPSBudWxsLCB0aGlzLl9mYWtlVmFsdWUgPSBudWxsLCB0aGlzLl9pc0Zha2VWYWx1ZUFjdGl2ZSA9ICExLCB0aGlzLl9jdXN0b21Db250ZW50ID0gZC5uZXh0KFxuICAgICAgdCxcbiAgICAgIG9iXG4gICAgKVswXSwgdGhpcy5fdG9nZ2xlQnV0dG9uID0gbnVsbCwgdGhpcy5fZWxlbWVudFRvZ2dsZSA9IG51bGwsIHRoaXMuX3dyYXBwZXIgPSBudWxsLCB0aGlzLl9pbnB1dEVsID0gbnVsbCwgdGhpcy5fZHJvcGRvd25Db250YWluZXIgPSBudWxsLCB0aGlzLl9jb250YWluZXIgPSBudWxsLCB0aGlzLl9zZWxlY3RBbGxPcHRpb24gPSBudWxsLCB0aGlzLl9pbml0KCksIHRoaXMuX211dGF0aW9uT2JzZXJ2ZXIgPSBudWxsLCB0aGlzLl9pc09wZW4gPSAhMSwgdGhpcy5fYWRkTXV0YXRpb25PYnNlcnZlcigpLCB0aGlzLl9lbGVtZW50ICYmIHkuc2V0RGF0YSh0LCB2aSwgdGhpcyk7XG4gIH1cbiAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgIHJldHVybiBvbztcbiAgfVxuICBnZXQgZmlsdGVySW5wdXQoKSB7XG4gICAgcmV0dXJuIGQuZmluZE9uZShcbiAgICAgIHRiLFxuICAgICAgdGhpcy5fZHJvcGRvd25Db250YWluZXJcbiAgICApO1xuICB9XG4gIGdldCBkcm9wZG93bigpIHtcbiAgICByZXR1cm4gZC5maW5kT25lKGViLCB0aGlzLl9kcm9wZG93bkNvbnRhaW5lcik7XG4gIH1cbiAgZ2V0IG9wdGlvbnNMaXN0KCkge1xuICAgIHJldHVybiBkLmZpbmRPbmUoXG4gICAgICBwbCxcbiAgICAgIHRoaXMuX2Ryb3Bkb3duQ29udGFpbmVyXG4gICAgKTtcbiAgfVxuICBnZXQgb3B0aW9uc1dyYXBwZXIoKSB7XG4gICAgcmV0dXJuIGQuZmluZE9uZShcbiAgICAgIGliLFxuICAgICAgdGhpcy5fZHJvcGRvd25Db250YWluZXJcbiAgICApO1xuICB9XG4gIGdldCBjbGVhckJ1dHRvbigpIHtcbiAgICByZXR1cm4gZC5maW5kT25lKG5iLCB0aGlzLl93cmFwcGVyKTtcbiAgfVxuICBnZXQgb3B0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5fZmlsdGVyZWRPcHRpb25zTGlzdCA/IHRoaXMuX2ZpbHRlcmVkT3B0aW9uc0xpc3QgOiB0aGlzLl9wbGFpbk9wdGlvbnM7XG4gIH1cbiAgZ2V0IHZhbHVlKCkge1xuICAgIHJldHVybiB0aGlzLm11bHRpcGxlID8gdGhpcy5fc2VsZWN0aW9uTW9kZWwudmFsdWVzIDogdGhpcy5fc2VsZWN0aW9uTW9kZWwudmFsdWU7XG4gIH1cbiAgZ2V0IG11bHRpcGxlKCkge1xuICAgIHJldHVybiB0aGlzLl9jb25maWcubXVsdGlwbGU7XG4gIH1cbiAgZ2V0IGhhc1NlbGVjdEFsbCgpIHtcbiAgICByZXR1cm4gdGhpcy5tdWx0aXBsZSAmJiB0aGlzLl9jb25maWcuc2VsZWN0QWxsO1xuICB9XG4gIGdldCBoYXNTZWxlY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NlbGVjdGlvbk1vZGVsLnNlbGVjdGlvbiB8fCB0aGlzLl9zZWxlY3Rpb25Nb2RlbC5zZWxlY3Rpb25zLmxlbmd0aCA+IDA7XG4gIH1cbiAgX2dldENvbmZpZyh0KSB7XG4gICAgY29uc3QgZSA9IGguZ2V0RGF0YUF0dHJpYnV0ZXModGhpcy5fZWxlbWVudCk7XG4gICAgcmV0dXJuIHQgPSB7XG4gICAgICAuLi5jYixcbiAgICAgIC4uLmUsXG4gICAgICAuLi50XG4gICAgfSwgdGhpcy5fZWxlbWVudC5oYXNBdHRyaWJ1dGUoXCJtdWx0aXBsZVwiKSAmJiAodC5tdWx0aXBsZSA9ICEwKSwgdGhpcy5fZWxlbWVudC5oYXNBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiKSAmJiAodC5kaXNhYmxlZCA9ICEwKSwgdGhpcy5fZWxlbWVudC50YWJJbmRleCAmJiAodC50YWJJbmRleCA9IHRoaXMuX2VsZW1lbnQuZ2V0QXR0cmlidXRlKFwidGFiSW5kZXhcIikpLCBEKG9vLCB0LCBoYiksIHQ7XG4gIH1cbiAgX2dldENsYXNzZXModCkge1xuICAgIGNvbnN0IGUgPSBoLmdldERhdGFDbGFzc0F0dHJpYnV0ZXModGhpcy5fZWxlbWVudCk7XG4gICAgcmV0dXJuIHQgPSB7XG4gICAgICAuLi5kYixcbiAgICAgIC4uLmUsXG4gICAgICAuLi50XG4gICAgfSwgRChvbywgdCwgdWIpLCB0O1xuICB9XG4gIF9hZGRQbGFjZWhvbGRlck9wdGlvbigpIHtcbiAgICBjb25zdCB0ID0gbmV3IE9wdGlvbihcIlwiLCBcIlwiLCAhMCwgITApO1xuICAgIHQuaGlkZGVuID0gITAsIHQuc2VsZWN0ZWQgPSAhMCwgdGhpcy5fZWxlbWVudC5wcmVwZW5kKHQpO1xuICB9XG4gIF9nZXRPcHRpb25zVG9SZW5kZXIodCkge1xuICAgIGNvbnN0IGUgPSBbXTtcbiAgICByZXR1cm4gdC5jaGlsZE5vZGVzLmZvckVhY2goKG4pID0+IHtcbiAgICAgIGlmIChuLm5vZGVOYW1lID09PSBcIk9QVEdST1VQXCIpIHtcbiAgICAgICAgY29uc3QgbyA9IHtcbiAgICAgICAgICBpZDogcnQoXCJncm91cC1cIiksXG4gICAgICAgICAgbGFiZWw6IG4ubGFiZWwsXG4gICAgICAgICAgZGlzYWJsZWQ6IG4uaGFzQXR0cmlidXRlKFwiZGlzYWJsZWRcIiksXG4gICAgICAgICAgaGlkZGVuOiBuLmhhc0F0dHJpYnV0ZShcImhpZGRlblwiKSxcbiAgICAgICAgICBvcHRpb25zOiBbXVxuICAgICAgICB9O1xuICAgICAgICBuLmNoaWxkTm9kZXMuZm9yRWFjaCgoYSkgPT4ge1xuICAgICAgICAgIGEubm9kZU5hbWUgPT09IFwiT1BUSU9OXCIgJiYgby5vcHRpb25zLnB1c2goXG4gICAgICAgICAgICB0aGlzLl9jcmVhdGVPcHRpb25PYmplY3QoYSwgbylcbiAgICAgICAgICApO1xuICAgICAgICB9KSwgZS5wdXNoKG8pO1xuICAgICAgfSBlbHNlXG4gICAgICAgIG4ubm9kZU5hbWUgPT09IFwiT1BUSU9OXCIgJiYgZS5wdXNoKHRoaXMuX2NyZWF0ZU9wdGlvbk9iamVjdChuKSk7XG4gICAgfSksIGU7XG4gIH1cbiAgX2dldFBsYWluT3B0aW9ucyh0KSB7XG4gICAgaWYgKCFkLmZpbmRPbmUoXCJvcHRncm91cFwiLCB0aGlzLl9lbGVtZW50KSlcbiAgICAgIHJldHVybiB0O1xuICAgIGNvbnN0IGkgPSBbXTtcbiAgICByZXR1cm4gdC5mb3JFYWNoKChuKSA9PiB7XG4gICAgICBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoXG4gICAgICAgIG4sXG4gICAgICAgIFwib3B0aW9uc1wiXG4gICAgICApID8gbi5vcHRpb25zLmZvckVhY2goKHIpID0+IHtcbiAgICAgICAgaS5wdXNoKHIpO1xuICAgICAgfSkgOiBpLnB1c2gobik7XG4gICAgfSksIGk7XG4gIH1cbiAgX2NyZWF0ZU9wdGlvbk9iamVjdCh0LCBlID0ge30pIHtcbiAgICBjb25zdCBpID0gcnQoXCJvcHRpb24tXCIpLCBuID0gZS5pZCA/IGUuaWQgOiBudWxsLCBvID0gZS5kaXNhYmxlZCA/IGUuZGlzYWJsZWQgOiAhMSwgciA9IHQuc2VsZWN0ZWQgfHwgdC5oYXNBdHRyaWJ1dGUocGkpLCBhID0gdC5oYXNBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiKSB8fCBvLCBsID0gdC5oYXNBdHRyaWJ1dGUoXCJoaWRkZW5cIikgfHwgZSAmJiBlLmhpZGRlbiwgcCA9IHRoaXMubXVsdGlwbGUsIHUgPSB0LnZhbHVlLCBfID0gdC5sYWJlbCwgZiA9IGguZ2V0RGF0YUF0dHJpYnV0ZShcbiAgICAgIHQsXG4gICAgICBcInNlbGVjdFNlY29uZGFyeVRleHRcIlxuICAgICksIGcgPSBoLmdldERhdGFBdHRyaWJ1dGUodCwgXCJzZWxlY3QtaWNvblwiKTtcbiAgICByZXR1cm4gbmV3IHJsKFxuICAgICAgaSxcbiAgICAgIHQsXG4gICAgICBwLFxuICAgICAgdSxcbiAgICAgIF8sXG4gICAgICByLFxuICAgICAgYSxcbiAgICAgIGwsXG4gICAgICBmLFxuICAgICAgbixcbiAgICAgIGdcbiAgICApO1xuICB9XG4gIF9nZXROYXZpZ2F0aW9uT3B0aW9ucygpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5vcHRpb25zLmZpbHRlcigoZSkgPT4gIWUuaGlkZGVuKTtcbiAgICByZXR1cm4gdGhpcy5oYXNTZWxlY3RBbGwgPyBbdGhpcy5fc2VsZWN0QWxsT3B0aW9uLCAuLi50XSA6IHQ7XG4gIH1cbiAgX2luaXQoKSB7XG4gICAgdGhpcy5fcmVuZGVyTWF0ZXJpYWxXcmFwcGVyKCksIHRoaXMuX3dyYXBwZXIgPSBkLmZpbmRPbmUoYCMke3RoaXMuX3dyYXBwZXJJZH1gKSwgdGhpcy5faW5wdXQgPSBkLmZpbmRPbmUodWwsIHRoaXMuX3dyYXBwZXIpLCB0aGlzLl9jb25maWcuZGlzYWJsZWQgJiYgdGhpcy5faW5wdXQuc2V0QXR0cmlidXRlKHJvLCBcIlwiKTtcbiAgICBjb25zdCB0ID0gdGhpcy5fY29uZmlnLnNlbGVjdENvbnRhaW5lcjtcbiAgICB0ID09PSBcImJvZHlcIiA/IHRoaXMuX2NvbnRhaW5lciA9IGRvY3VtZW50LmJvZHkgOiB0aGlzLl9jb250YWluZXIgPSBkLmZpbmRPbmUodCksIHRoaXMuX2luaXRPdXRsaW5lSW5wdXQoKSwgdGhpcy5fc2V0RGVmYXVsdFNlbGVjdGlvbnMoKSwgdGhpcy5fdXBkYXRlSW5wdXRWYWx1ZSgpLCB0aGlzLl9hcHBlbmRGYWtlVmFsdWUoKSwgdGhpcy5fdXBkYXRlRmFrZUxhYmVsUG9zaXRpb24oKSwgdGhpcy5fdXBkYXRlTGFiZWxQb3NpdGlvbigpLCB0aGlzLl91cGRhdGVDbGVhckJ1dHRvblZpc2liaWxpdHkoKSwgdGhpcy5fYmluZENvbXBvbmVudEV2ZW50cygpLCB0aGlzLmhhc1NlbGVjdEFsbCAmJiAodGhpcy5fc2VsZWN0QWxsT3B0aW9uID0gdGhpcy5fY3JlYXRlU2VsZWN0QWxsT3B0aW9uKCkpLCB0aGlzLl9kcm9wZG93bkNvbnRhaW5lciA9IGFsKFxuICAgICAgdGhpcy5fZHJvcGRvd25Db250YWluZXJJZCxcbiAgICAgIHRoaXMuX2NvbmZpZyxcbiAgICAgIHRoaXMuX2lucHV0Lm9mZnNldFdpZHRoLFxuICAgICAgdGhpcy5fZHJvcGRvd25IZWlnaHQsXG4gICAgICB0aGlzLl9zZWxlY3RBbGxPcHRpb24sXG4gICAgICB0aGlzLl9vcHRpb25zVG9SZW5kZXIsXG4gICAgICB0aGlzLl9jdXN0b21Db250ZW50LFxuICAgICAgdGhpcy5fY2xhc3Nlc1xuICAgICksIHRoaXMuX3NldEZpcnN0QWN0aXZlT3B0aW9uKCksIHRoaXMuX2xpc3RlblRvRm9jdXNDaGFuZ2UoKTtcbiAgfVxuICBfcmVuZGVyTWF0ZXJpYWxXcmFwcGVyKCkge1xuICAgIGNvbnN0IHQgPSBQZyhcbiAgICAgIHRoaXMuX3dyYXBwZXJJZCxcbiAgICAgIHRoaXMuX2NvbmZpZyxcbiAgICAgIHRoaXMuX2xhYmVsLFxuICAgICAgdGhpcy5fY2xhc3NlcyxcbiAgICAgIHRoaXMuX2VsZW1lbnQubmFtZVxuICAgICk7XG4gICAgdGhpcy5fZWxlbWVudC5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0LCB0aGlzLl9lbGVtZW50KSwgaC5hZGRDbGFzcyh0aGlzLl9lbGVtZW50LCB0aGlzLl9jbGFzc2VzLmluaXRpYWxpemVkKSwgdC5hcHBlbmRDaGlsZCh0aGlzLl9lbGVtZW50KTtcbiAgfVxuICBfaW5pdE91dGxpbmVJbnB1dCgpIHtcbiAgICBjb25zdCB0ID0gZC5maW5kT25lKFxuICAgICAgX2wsXG4gICAgICB0aGlzLl93cmFwcGVyXG4gICAgKTtcbiAgICBuZXcgVihcbiAgICAgIHQsXG4gICAgICB7XG4gICAgICAgIGlucHV0Rm9ybVdoaXRlOiB0aGlzLl9jb25maWcuc2VsZWN0Rm9ybVdoaXRlXG4gICAgICB9LFxuICAgICAgdGhpcy5fY2xhc3Nlc1xuICAgICkuaW5pdCgpLCB0aGlzLl9ub3RjaCA9IGQuZmluZE9uZShhbywgdGhpcy5fd3JhcHBlcik7XG4gIH1cbiAgX2JpbmRDb21wb25lbnRFdmVudHMoKSB7XG4gICAgdGhpcy5fbGlzdGVuVG9Db21wb25lbnRLZXlkb3duKCksIHRoaXMuX2xpc3RlblRvV3JhcHBlckNsaWNrKCksIHRoaXMuX2xpc3RlblRvQ2xlYXJCdG5DbGljaygpLCB0aGlzLl9saXN0ZW5Ub0NsZWFyQnRuS2V5ZG93bigpO1xuICB9XG4gIF9zZXREZWZhdWx0U2VsZWN0aW9ucygpIHtcbiAgICB0aGlzLm9wdGlvbnMuZm9yRWFjaCgodCkgPT4ge1xuICAgICAgdC5zZWxlY3RlZCAmJiB0aGlzLl9zZWxlY3Rpb25Nb2RlbC5zZWxlY3QodCk7XG4gICAgfSk7XG4gIH1cbiAgX2xpc3RlblRvQ29tcG9uZW50S2V5ZG93bigpIHtcbiAgICBjLm9uKHRoaXMuX3dyYXBwZXIsIFwia2V5ZG93blwiLCB0aGlzLl9oYW5kbGVLZXlkb3duLmJpbmQodGhpcykpO1xuICB9XG4gIF9oYW5kbGVLZXlkb3duKHQpIHtcbiAgICB0aGlzLl9pc09wZW4gJiYgIXRoaXMuX2NvbmZpZy5zZWxlY3RGaWx0ZXIgPyB0aGlzLl9oYW5kbGVPcGVuS2V5ZG93bih0KSA6IHRoaXMuX2hhbmRsZUNsb3NlZEtleWRvd24odCk7XG4gIH1cbiAgX2hhbmRsZU9wZW5LZXlkb3duKHQpIHtcbiAgICBjb25zdCBlID0gdC5rZXlDb2RlLCBpID0gZSA9PT0gRmkgfHwgZSA9PT0gYXQgJiYgdC5hbHRLZXkgfHwgZSA9PT0gUGk7XG4gICAgaWYgKGUgPT09IFBpICYmIHRoaXMuX2NvbmZpZy5zZWxlY3RBdXRvU2VsZWN0ICYmICF0aGlzLm11bHRpcGxlICYmIHRoaXMuX2hhbmRsZUF1dG9TZWxlY3Rpb24odGhpcy5fYWN0aXZlT3B0aW9uKSwgaSkge1xuICAgICAgdGhpcy5jbG9zZSgpLCB0aGlzLl9pbnB1dC5mb2N1cygpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzd2l0Y2ggKGUpIHtcbiAgICAgIGNhc2UgejpcbiAgICAgICAgdGhpcy5fc2V0TmV4dE9wdGlvbkFjdGl2ZSgpLCB0aGlzLl9zY3JvbGxUb09wdGlvbih0aGlzLl9hY3RpdmVPcHRpb24pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgYXQ6XG4gICAgICAgIHRoaXMuX3NldFByZXZpb3VzT3B0aW9uQWN0aXZlKCksIHRoaXMuX3Njcm9sbFRvT3B0aW9uKHRoaXMuX2FjdGl2ZU9wdGlvbik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBXZTpcbiAgICAgICAgdGhpcy5fc2V0Rmlyc3RPcHRpb25BY3RpdmUoKSwgdGhpcy5fc2Nyb2xsVG9PcHRpb24odGhpcy5fYWN0aXZlT3B0aW9uKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEZlOlxuICAgICAgICB0aGlzLl9zZXRMYXN0T3B0aW9uQWN0aXZlKCksIHRoaXMuX3Njcm9sbFRvT3B0aW9uKHRoaXMuX2FjdGl2ZU9wdGlvbik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBjdDpcbiAgICAgICAgdC5wcmV2ZW50RGVmYXVsdCgpLCB0aGlzLl9hY3RpdmVPcHRpb24gJiYgKHRoaXMuaGFzU2VsZWN0QWxsICYmIHRoaXMuX2FjdGl2ZU9wdGlvbkluZGV4ID09PSAwID8gdGhpcy5faGFuZGxlU2VsZWN0QWxsKCkgOiB0aGlzLl9oYW5kbGVTZWxlY3Rpb24odGhpcy5fYWN0aXZlT3B0aW9uKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdC5wcmV2ZW50RGVmYXVsdCgpO1xuICB9XG4gIF9oYW5kbGVDbG9zZWRLZXlkb3duKHQpIHtcbiAgICBjb25zdCBlID0gdC5rZXlDb2RlO1xuICAgIGlmIChlID09PSBjdCAmJiB0LnByZXZlbnREZWZhdWx0KCksIChlID09PSBjdCB8fCBlID09PSB6ICYmIHQuYWx0S2V5IHx8IGUgPT09IHogJiYgdGhpcy5tdWx0aXBsZSkgJiYgdGhpcy5vcGVuKCksIHRoaXMubXVsdGlwbGUpXG4gICAgICBzd2l0Y2ggKGUpIHtcbiAgICAgICAgY2FzZSB6OlxuICAgICAgICAgIHRoaXMub3BlbigpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIGF0OlxuICAgICAgICAgIHRoaXMub3BlbigpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICBlbHNlXG4gICAgICBzd2l0Y2ggKGUpIHtcbiAgICAgICAgY2FzZSB6OlxuICAgICAgICAgIHRoaXMuX3NldE5leHRPcHRpb25BY3RpdmUoKSwgdGhpcy5faGFuZGxlU2VsZWN0aW9uKHRoaXMuX2FjdGl2ZU9wdGlvbik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgYXQ6XG4gICAgICAgICAgdGhpcy5fc2V0UHJldmlvdXNPcHRpb25BY3RpdmUoKSwgdGhpcy5faGFuZGxlU2VsZWN0aW9uKHRoaXMuX2FjdGl2ZU9wdGlvbik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgV2U6XG4gICAgICAgICAgdGhpcy5fc2V0Rmlyc3RPcHRpb25BY3RpdmUoKSwgdGhpcy5faGFuZGxlU2VsZWN0aW9uKHRoaXMuX2FjdGl2ZU9wdGlvbik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgRmU6XG4gICAgICAgICAgdGhpcy5fc2V0TGFzdE9wdGlvbkFjdGl2ZSgpLCB0aGlzLl9oYW5kbGVTZWxlY3Rpb24odGhpcy5fYWN0aXZlT3B0aW9uKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgdC5wcmV2ZW50RGVmYXVsdCgpO1xuICB9XG4gIF9zY3JvbGxUb09wdGlvbih0KSB7XG4gICAgaWYgKCF0KVxuICAgICAgcmV0dXJuO1xuICAgIGxldCBlO1xuICAgIGNvbnN0IGkgPSB0aGlzLm9wdGlvbnMuZmlsdGVyKCh1KSA9PiAhdS5oaWRkZW4pO1xuICAgIHRoaXMuaGFzU2VsZWN0QWxsID8gZSA9IGkuaW5kZXhPZih0KSArIDEgOiBlID0gaS5pbmRleE9mKHQpO1xuICAgIGNvbnN0IG4gPSB0aGlzLl9nZXROdW1iZXJPZkdyb3Vwc0JlZm9yZU9wdGlvbihlKSwgbyA9IGUgKyBuLCByID0gdGhpcy5vcHRpb25zV3JhcHBlciwgYSA9IHIub2Zmc2V0SGVpZ2h0LCBsID0gdGhpcy5fY29uZmlnLnNlbGVjdE9wdGlvbkhlaWdodCwgcCA9IHIuc2Nyb2xsVG9wO1xuICAgIGlmIChlID4gLTEpIHtcbiAgICAgIGNvbnN0IHUgPSBvICogbCwgXyA9IHUgKyBsID4gcCArIGE7XG4gICAgICB1IDwgcCA/IHIuc2Nyb2xsVG9wID0gdSA6IF8gPyByLnNjcm9sbFRvcCA9IHUgLSBhICsgbCA6IHIuc2Nyb2xsVG9wID0gcDtcbiAgICB9XG4gIH1cbiAgX2dldE51bWJlck9mR3JvdXBzQmVmb3JlT3B0aW9uKHQpIHtcbiAgICBjb25zdCBlID0gdGhpcy5vcHRpb25zLmZpbHRlcigocikgPT4gIXIuaGlkZGVuKSwgaSA9IHRoaXMuX29wdGlvbnNUb1JlbmRlci5maWx0ZXIoKHIpID0+ICFyLmhpZGRlbiksIG4gPSB0aGlzLmhhc1NlbGVjdEFsbCA/IHQgLSAxIDogdDtcbiAgICBsZXQgbyA9IDA7XG4gICAgZm9yIChsZXQgciA9IDA7IHIgPD0gbjsgcisrKVxuICAgICAgZVtyXS5ncm91cElkICYmIGlbb10gJiYgaVtvXS5pZCAmJiBlW3JdLmdyb3VwSWQgPT09IGlbb10uaWQgJiYgbysrO1xuICAgIHJldHVybiBvO1xuICB9XG4gIF9zZXROZXh0T3B0aW9uQWN0aXZlKCkge1xuICAgIGxldCB0ID0gdGhpcy5fYWN0aXZlT3B0aW9uSW5kZXggKyAxO1xuICAgIGNvbnN0IGUgPSB0aGlzLl9nZXROYXZpZ2F0aW9uT3B0aW9ucygpO1xuICAgIGlmIChlW3RdKSB7XG4gICAgICBmb3IgKDsgZVt0XS5kaXNhYmxlZDsgKVxuICAgICAgICBpZiAodCArPSAxLCAhZVt0XSlcbiAgICAgICAgICByZXR1cm47XG4gICAgICB0aGlzLl91cGRhdGVBY3RpdmVPcHRpb24oZVt0XSwgdCk7XG4gICAgfVxuICB9XG4gIF9zZXRQcmV2aW91c09wdGlvbkFjdGl2ZSgpIHtcbiAgICBsZXQgdCA9IHRoaXMuX2FjdGl2ZU9wdGlvbkluZGV4IC0gMTtcbiAgICBjb25zdCBlID0gdGhpcy5fZ2V0TmF2aWdhdGlvbk9wdGlvbnMoKTtcbiAgICBpZiAoZVt0XSkge1xuICAgICAgZm9yICg7IGVbdF0uZGlzYWJsZWQ7IClcbiAgICAgICAgaWYgKHQgLT0gMSwgIWVbdF0pXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgdGhpcy5fdXBkYXRlQWN0aXZlT3B0aW9uKGVbdF0sIHQpO1xuICAgIH1cbiAgfVxuICBfc2V0Rmlyc3RPcHRpb25BY3RpdmUoKSB7XG4gICAgY29uc3QgZSA9IHRoaXMuX2dldE5hdmlnYXRpb25PcHRpb25zKCk7XG4gICAgdGhpcy5fdXBkYXRlQWN0aXZlT3B0aW9uKGVbMF0sIDApO1xuICB9XG4gIF9zZXRMYXN0T3B0aW9uQWN0aXZlKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLl9nZXROYXZpZ2F0aW9uT3B0aW9ucygpLCBlID0gdC5sZW5ndGggLSAxO1xuICAgIHRoaXMuX3VwZGF0ZUFjdGl2ZU9wdGlvbih0W2VdLCBlKTtcbiAgfVxuICBfdXBkYXRlQWN0aXZlT3B0aW9uKHQsIGUpIHtcbiAgICBjb25zdCBpID0gdGhpcy5fYWN0aXZlT3B0aW9uO1xuICAgIGkgJiYgaS5yZW1vdmVBY3RpdmVTdHlsZXMoKSwgdC5zZXRBY3RpdmVTdHlsZXMoKSwgdGhpcy5fYWN0aXZlT3B0aW9uSW5kZXggPSBlLCB0aGlzLl9hY3RpdmVPcHRpb24gPSB0O1xuICB9XG4gIF9saXN0ZW5Ub1dyYXBwZXJDbGljaygpIHtcbiAgICBjLm9uKHRoaXMuX3dyYXBwZXIsIFwiY2xpY2tcIiwgKCkgPT4ge1xuICAgICAgdGhpcy50b2dnbGUoKTtcbiAgICB9KTtcbiAgfVxuICBfbGlzdGVuVG9DbGVhckJ0bkNsaWNrKCkge1xuICAgIGMub24odGhpcy5jbGVhckJ1dHRvbiwgXCJjbGlja1wiLCAodCkgPT4ge1xuICAgICAgdC5wcmV2ZW50RGVmYXVsdCgpLCB0LnN0b3BQcm9wYWdhdGlvbigpLCB0aGlzLl9oYW5kbGVDbGVhcigpO1xuICAgIH0pO1xuICB9XG4gIF9saXN0ZW5Ub0NsZWFyQnRuS2V5ZG93bigpIHtcbiAgICBjLm9uKHRoaXMuY2xlYXJCdXR0b24sIFwia2V5ZG93blwiLCAodCkgPT4ge1xuICAgICAgdC5rZXlDb2RlID09PSBjdCAmJiAodGhpcy5faGFuZGxlQ2xlYXIoKSwgdC5wcmV2ZW50RGVmYXVsdCgpLCB0LnN0b3BQcm9wYWdhdGlvbigpKTtcbiAgICB9KTtcbiAgfVxuICBfaGFuZGxlQ2xlYXIoKSB7XG4gICAgaWYgKHRoaXMubXVsdGlwbGUpXG4gICAgICB0aGlzLl9zZWxlY3Rpb25Nb2RlbC5jbGVhcigpLCB0aGlzLl9kZXNlbGVjdEFsbE9wdGlvbnModGhpcy5vcHRpb25zKSwgdGhpcy5oYXNTZWxlY3RBbGwgJiYgdGhpcy5fdXBkYXRlU2VsZWN0QWxsU3RhdGUoKTtcbiAgICBlbHNlIHtcbiAgICAgIGNvbnN0IHQgPSB0aGlzLl9zZWxlY3Rpb25Nb2RlbC5zZWxlY3Rpb247XG4gICAgICB0aGlzLl9zZWxlY3Rpb25Nb2RlbC5jbGVhcigpLCB0LmRlc2VsZWN0KCk7XG4gICAgfVxuICAgIHRoaXMuX2Zha2VWYWx1ZS5pbm5lckhUTUwgPSBcIlwiLCB0aGlzLl91cGRhdGVJbnB1dFZhbHVlKCksIHRoaXMuX3VwZGF0ZUZha2VMYWJlbFBvc2l0aW9uKCksIHRoaXMuX3VwZGF0ZUxhYmVsUG9zaXRpb24oKSwgdGhpcy5fdXBkYXRlQ2xlYXJCdXR0b25WaXNpYmlsaXR5KCksIHRoaXMuX2VtaXRWYWx1ZUNoYW5nZUV2ZW50KG51bGwpLCB0aGlzLl9lbWl0TmF0aXZlQ2hhbmdlRXZlbnQoKTtcbiAgfVxuICBfbGlzdGVuVG9PcHRpb25zQ2xpY2soKSB7XG4gICAgYy5vbih0aGlzLm9wdGlvbnNXcmFwcGVyLCBcImNsaWNrXCIsICh0KSA9PiB7XG4gICAgICBpZiAodC50YXJnZXQuaGFzQXR0cmlidXRlKFxuICAgICAgICBaZ1xuICAgICAgKSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY29uc3QgaSA9IHQudGFyZ2V0Lm5vZGVOYW1lID09PSBcIkRJVlwiID8gdC50YXJnZXQgOiBkLmNsb3Nlc3QodC50YXJnZXQsIHNiKTtcbiAgICAgIGlmIChpLmhhc0F0dHJpYnV0ZShRZykpIHtcbiAgICAgICAgdGhpcy5faGFuZGxlU2VsZWN0QWxsKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG8gPSBpLmRhdGFzZXQudGVJZCwgciA9IHRoaXMub3B0aW9ucy5maW5kKChhKSA9PiBhLmlkID09PSBvKTtcbiAgICAgIHIgJiYgIXIuZGlzYWJsZWQgJiYgdGhpcy5faGFuZGxlU2VsZWN0aW9uKHIpO1xuICAgIH0pO1xuICB9XG4gIF9oYW5kbGVTZWxlY3RBbGwoKSB7XG4gICAgdGhpcy5fc2VsZWN0QWxsT3B0aW9uLnNlbGVjdGVkID8gKHRoaXMuX2Rlc2VsZWN0QWxsT3B0aW9ucyh0aGlzLm9wdGlvbnMpLCB0aGlzLl9zZWxlY3RBbGxPcHRpb24uZGVzZWxlY3QoKSkgOiAodGhpcy5fc2VsZWN0QWxsT3B0aW9ucyh0aGlzLm9wdGlvbnMpLCB0aGlzLl9zZWxlY3RBbGxPcHRpb24uc2VsZWN0KCkpLCB0aGlzLl91cGRhdGVJbnB1dFZhbHVlKCksIHRoaXMuX3VwZGF0ZUZha2VMYWJlbFBvc2l0aW9uKCksIHRoaXMuX3VwZGF0ZUxhYmVsUG9zaXRpb24oKSwgdGhpcy5fdXBkYXRlQ2xlYXJCdXR0b25WaXNpYmlsaXR5KCksIHRoaXMuX2VtaXRWYWx1ZUNoYW5nZUV2ZW50KHRoaXMudmFsdWUpLCB0aGlzLl9lbWl0TmF0aXZlQ2hhbmdlRXZlbnQoKTtcbiAgfVxuICBfc2VsZWN0QWxsT3B0aW9ucyh0KSB7XG4gICAgdC5mb3JFYWNoKChlKSA9PiB7XG4gICAgICAhZS5zZWxlY3RlZCAmJiAhZS5kaXNhYmxlZCAmJiAodGhpcy5fc2VsZWN0aW9uTW9kZWwuc2VsZWN0KGUpLCBlLnNlbGVjdCgpKTtcbiAgICB9KTtcbiAgfVxuICBfZGVzZWxlY3RBbGxPcHRpb25zKHQpIHtcbiAgICB0LmZvckVhY2goKGUpID0+IHtcbiAgICAgIGUuc2VsZWN0ZWQgJiYgIWUuZGlzYWJsZWQgJiYgKHRoaXMuX3NlbGVjdGlvbk1vZGVsLmRlc2VsZWN0KGUpLCBlLmRlc2VsZWN0KCkpO1xuICAgIH0pO1xuICB9XG4gIF9oYW5kbGVTZWxlY3Rpb24odCkge1xuICAgIHRoaXMubXVsdGlwbGUgPyAodGhpcy5faGFuZGxlTXVsdGlTZWxlY3Rpb24odCksIHRoaXMuaGFzU2VsZWN0QWxsICYmIHRoaXMuX3VwZGF0ZVNlbGVjdEFsbFN0YXRlKCkpIDogdGhpcy5faGFuZGxlU2luZ2xlU2VsZWN0aW9uKHQpLCB0aGlzLl91cGRhdGVJbnB1dFZhbHVlKCksIHRoaXMuX3VwZGF0ZUZha2VMYWJlbFBvc2l0aW9uKCksIHRoaXMuX3VwZGF0ZUxhYmVsUG9zaXRpb24oKSwgdGhpcy5fdXBkYXRlQ2xlYXJCdXR0b25WaXNpYmlsaXR5KCk7XG4gIH1cbiAgX2hhbmRsZUF1dG9TZWxlY3Rpb24odCkge1xuICAgIHRoaXMuX3NpbmdsZU9wdGlvblNlbGVjdCh0KSwgdGhpcy5fdXBkYXRlSW5wdXRWYWx1ZSgpLCB0aGlzLl91cGRhdGVGYWtlTGFiZWxQb3NpdGlvbigpLCB0aGlzLl91cGRhdGVMYWJlbFBvc2l0aW9uKCksIHRoaXMuX3VwZGF0ZUNsZWFyQnV0dG9uVmlzaWJpbGl0eSgpO1xuICB9XG4gIF9oYW5kbGVTaW5nbGVTZWxlY3Rpb24odCkge1xuICAgIHRoaXMuX3NpbmdsZU9wdGlvblNlbGVjdCh0KSwgdGhpcy5jbG9zZSgpLCB0aGlzLl9pbnB1dC5mb2N1cygpO1xuICB9XG4gIF9zaW5nbGVPcHRpb25TZWxlY3QodCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLl9zZWxlY3Rpb25Nb2RlbC5zZWxlY3Rpb25zWzBdO1xuICAgIGUgJiYgZSAhPT0gdCAmJiAodGhpcy5fc2VsZWN0aW9uTW9kZWwuZGVzZWxlY3QoZSksIGUuZGVzZWxlY3QoKSwgZS5ub2RlLnNldEF0dHJpYnV0ZShwaSwgITEpLCBjLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgY2wsIHtcbiAgICAgIHZhbHVlOiBlLnZhbHVlXG4gICAgfSkpLCAoIWUgfHwgZSAmJiB0ICE9PSBlKSAmJiAodGhpcy5fc2VsZWN0aW9uTW9kZWwuc2VsZWN0KHQpLCB0LnNlbGVjdCgpLCB0Lm5vZGUuc2V0QXR0cmlidXRlKHBpLCAhMCksIGMudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBsbCwge1xuICAgICAgdmFsdWU6IHQudmFsdWVcbiAgICB9KSwgdGhpcy5fZW1pdFZhbHVlQ2hhbmdlRXZlbnQodGhpcy52YWx1ZSksIHRoaXMuX2VtaXROYXRpdmVDaGFuZ2VFdmVudCgpKTtcbiAgfVxuICBfaGFuZGxlTXVsdGlTZWxlY3Rpb24odCkge1xuICAgIHQuc2VsZWN0ZWQgPyAodGhpcy5fc2VsZWN0aW9uTW9kZWwuZGVzZWxlY3QodCksIHQuZGVzZWxlY3QoKSwgdC5ub2RlLnNldEF0dHJpYnV0ZShwaSwgITEpLCBjLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgY2wsIHtcbiAgICAgIHZhbHVlOiB0LnZhbHVlXG4gICAgfSkpIDogKHRoaXMuX3NlbGVjdGlvbk1vZGVsLnNlbGVjdCh0KSwgdC5zZWxlY3QoKSwgdC5ub2RlLnNldEF0dHJpYnV0ZShwaSwgITApLCBjLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgbGwsIHtcbiAgICAgIHZhbHVlOiB0LnZhbHVlXG4gICAgfSkpLCB0aGlzLl9lbWl0VmFsdWVDaGFuZ2VFdmVudCh0aGlzLnZhbHVlKSwgdGhpcy5fZW1pdE5hdGl2ZUNoYW5nZUV2ZW50KCk7XG4gIH1cbiAgX2VtaXRWYWx1ZUNoYW5nZUV2ZW50KHQpIHtcbiAgICBjLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgR2csIHsgdmFsdWU6IHQgfSk7XG4gIH1cbiAgX2VtaXROYXRpdmVDaGFuZ2VFdmVudCgpIHtcbiAgICBjLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgcWcpO1xuICB9XG4gIF91cGRhdGVJbnB1dFZhbHVlKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLm11bHRpcGxlID8gdGhpcy5fc2VsZWN0aW9uTW9kZWwubGFiZWxzIDogdGhpcy5fc2VsZWN0aW9uTW9kZWwubGFiZWw7XG4gICAgbGV0IGU7XG4gICAgdGhpcy5tdWx0aXBsZSAmJiB0aGlzLl9jb25maWcuc2VsZWN0RGlzcGxheWVkTGFiZWxzICE9PSAtMSAmJiB0aGlzLl9zZWxlY3Rpb25Nb2RlbC5zZWxlY3Rpb25zLmxlbmd0aCA+IHRoaXMuX2NvbmZpZy5zZWxlY3REaXNwbGF5ZWRMYWJlbHMgPyBlID0gYCR7dGhpcy5fc2VsZWN0aW9uTW9kZWwuc2VsZWN0aW9ucy5sZW5ndGh9ICR7dGhpcy5fY29uZmlnLnNlbGVjdE9wdGlvbnNTZWxlY3RlZExhYmVsfWAgOiBlID0gdCwgIXRoaXMubXVsdGlwbGUgJiYgIXRoaXMuX2lzU2VsZWN0aW9uVmFsaWQodGhpcy5fc2VsZWN0aW9uTW9kZWwuc2VsZWN0aW9uKSA/IHRoaXMuX2lucHV0LnZhbHVlID0gXCJcIiA6IHRoaXMuX2lzTGFiZWxFbXB0eSh0aGlzLl9zZWxlY3Rpb25Nb2RlbC5zZWxlY3Rpb24pID8gdGhpcy5faW5wdXQudmFsdWUgPSBcIiBcIiA6IGUgPyB0aGlzLl9pbnB1dC52YWx1ZSA9IGUgOiB0aGlzLm11bHRpcGxlIHx8ICF0aGlzLl9vcHRpb25zVG9SZW5kZXJbMF0gPyB0aGlzLl9pbnB1dC52YWx1ZSA9IFwiXCIgOiB0aGlzLl9pbnB1dC52YWx1ZSA9IHRoaXMuX29wdGlvbnNUb1JlbmRlclswXS5sYWJlbDtcbiAgfVxuICBfaXNTZWxlY3Rpb25WYWxpZCh0KSB7XG4gICAgcmV0dXJuICEodCAmJiAodC5kaXNhYmxlZCB8fCB0LnZhbHVlID09PSBcIlwiKSk7XG4gIH1cbiAgX2lzTGFiZWxFbXB0eSh0KSB7XG4gICAgcmV0dXJuICEhKHQgJiYgdC5sYWJlbCA9PT0gXCJcIik7XG4gIH1cbiAgX2FwcGVuZEZha2VWYWx1ZSgpIHtcbiAgICBpZiAoIXRoaXMuX3NlbGVjdGlvbk1vZGVsLnNlbGVjdGlvbiB8fCB0aGlzLl9zZWxlY3Rpb25Nb2RlbC5fbXVsdGlwbGUpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgdCA9IHRoaXMuX3NlbGVjdGlvbk1vZGVsLnNlbGVjdGlvbi5sYWJlbDtcbiAgICB0aGlzLl9mYWtlVmFsdWUgPSB6Zyh0LCB0aGlzLl9jbGFzc2VzKSwgZC5maW5kT25lKFxuICAgICAgX2wsXG4gICAgICB0aGlzLl93cmFwcGVyXG4gICAgKS5hcHBlbmRDaGlsZCh0aGlzLl9mYWtlVmFsdWUpO1xuICB9XG4gIF91cGRhdGVMYWJlbFBvc2l0aW9uKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLl9lbGVtZW50Lmhhc0F0dHJpYnV0ZShobCksIGUgPSB0aGlzLl9pbnB1dC52YWx1ZSAhPT0gXCJcIjtcbiAgICB0aGlzLl9sYWJlbCAmJiAodCAmJiAoZSB8fCB0aGlzLl9pc09wZW4gfHwgdGhpcy5faXNGYWtlVmFsdWVBY3RpdmUpID8gKHRoaXMuX2xhYmVsLnNldEF0dHJpYnV0ZShxLCBcIlwiKSwgdGhpcy5fbm90Y2guc2V0QXR0cmlidXRlKHEsIFwiXCIpKSA6ICh0aGlzLl9sYWJlbC5yZW1vdmVBdHRyaWJ1dGUocSksIHRoaXMuX25vdGNoLnJlbW92ZUF0dHJpYnV0ZShxLCBcIlwiKSkpO1xuICB9XG4gIF91cGRhdGVMYWJlbFBvc2l0aW9uV2hpbGVDbG9zaW5nKCkge1xuICAgIHRoaXMuX2xhYmVsICYmICh0aGlzLl9pbnB1dC52YWx1ZSAhPT0gXCJcIiB8fCB0aGlzLl9pc0Zha2VWYWx1ZUFjdGl2ZSA/ICh0aGlzLl9sYWJlbC5zZXRBdHRyaWJ1dGUocSwgXCJcIiksIHRoaXMuX25vdGNoLnNldEF0dHJpYnV0ZShxLCBcIlwiKSkgOiAodGhpcy5fbGFiZWwucmVtb3ZlQXR0cmlidXRlKHEpLCB0aGlzLl9ub3RjaC5yZW1vdmVBdHRyaWJ1dGUocSkpKTtcbiAgfVxuICBfdXBkYXRlRmFrZUxhYmVsUG9zaXRpb24oKSB7XG4gICAgdGhpcy5fZmFrZVZhbHVlICYmICh0aGlzLl9pbnB1dC52YWx1ZSA9PT0gXCJcIiAmJiB0aGlzLl9mYWtlVmFsdWUuaW5uZXJIVE1MICE9PSBcIlwiICYmICF0aGlzLl9jb25maWcuc2VsZWN0UGxhY2Vob2xkZXIgPyAodGhpcy5faXNGYWtlVmFsdWVBY3RpdmUgPSAhMCwgdGhpcy5fZmFrZVZhbHVlLnNldEF0dHJpYnV0ZShxLCBcIlwiKSkgOiAodGhpcy5faXNGYWtlVmFsdWVBY3RpdmUgPSAhMSwgdGhpcy5fZmFrZVZhbHVlLnJlbW92ZUF0dHJpYnV0ZShxKSkpO1xuICB9XG4gIF91cGRhdGVDbGVhckJ1dHRvblZpc2liaWxpdHkoKSB7XG4gICAgaWYgKCF0aGlzLmNsZWFyQnV0dG9uKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuX3NlbGVjdGlvbk1vZGVsLnNlbGVjdGlvbiB8fCB0aGlzLl9zZWxlY3Rpb25Nb2RlbC5zZWxlY3Rpb25zLmxlbmd0aCA+IDAgPyBoLmFkZFN0eWxlKHRoaXMuY2xlYXJCdXR0b24sIHsgZGlzcGxheTogXCJibG9ja1wiIH0pIDogaC5hZGRTdHlsZSh0aGlzLmNsZWFyQnV0dG9uLCB7IGRpc3BsYXk6IFwibm9uZVwiIH0pO1xuICB9XG4gIF91cGRhdGVTZWxlY3RBbGxTdGF0ZSgpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5fc2VsZWN0QWxsT3B0aW9uLnNlbGVjdGVkLCBlID0gVm8odGhpcy5vcHRpb25zKTtcbiAgICAhZSAmJiB0ID8gdGhpcy5fc2VsZWN0QWxsT3B0aW9uLmRlc2VsZWN0KCkgOiBlICYmICF0ICYmIHRoaXMuX3NlbGVjdEFsbE9wdGlvbi5zZWxlY3QoKTtcbiAgfVxuICB0b2dnbGUoKSB7XG4gICAgdGhpcy5faXNPcGVuID8gdGhpcy5jbG9zZSgpIDogdGhpcy5vcGVuKCk7XG4gIH1cbiAgb3BlbigpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5fY29uZmlnLmRpc2FibGVkLCBlID0gYy50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIFhnKTtcbiAgICB0aGlzLl9pc09wZW4gfHwgdCB8fCBlLmRlZmF1bHRQcmV2ZW50ZWQgfHwgKHRoaXMuX29wZW5Ecm9wZG93bigpLCB0aGlzLl91cGRhdGVEcm9wZG93bldpZHRoKCksIHRoaXMuX3NldEZpcnN0QWN0aXZlT3B0aW9uKCksIHRoaXMuX3Njcm9sbFRvT3B0aW9uKHRoaXMuX2FjdGl2ZU9wdGlvbiksIHRoaXMuX2NvbmZpZy5zZWxlY3RGaWx0ZXIgJiYgKHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5maWx0ZXJJbnB1dC5mb2N1cygpO1xuICAgIH0sIDApLCB0aGlzLl9saXN0ZW5Ub1NlbGVjdFNlYXJjaCgpLCB0aGlzLl9saXN0ZW5Ub0Ryb3Bkb3duS2V5ZG93bigpKSwgdGhpcy5fbGlzdGVuVG9PcHRpb25zQ2xpY2soKSwgdGhpcy5fbGlzdGVuVG9PdXRzaWRlQ2xpY2soKSwgdGhpcy5fbGlzdGVuVG9XaW5kb3dSZXNpemUoKSwgdGhpcy5faXNPcGVuID0gITAsIHRoaXMuX3VwZGF0ZUxhYmVsUG9zaXRpb24oKSwgdGhpcy5fc2V0SW5wdXRBY3RpdmVTdHlsZXMoKSk7XG4gIH1cbiAgX29wZW5Ecm9wZG93bigpIHtcbiAgICB0aGlzLl9wb3BwZXIgPSBDZSh0aGlzLl9pbnB1dCwgdGhpcy5fZHJvcGRvd25Db250YWluZXIsIHtcbiAgICAgIHBsYWNlbWVudDogXCJib3R0b20tc3RhcnRcIixcbiAgICAgIG1vZGlmaWVyczogW1xuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogXCJvZmZzZXRcIixcbiAgICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICBvZmZzZXQ6IFswLCAxXVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgXVxuICAgIH0pLCB0aGlzLl9jb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5fZHJvcGRvd25Db250YWluZXIpLCBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuZHJvcGRvd24uc2V0QXR0cmlidXRlKGRsLCBcIlwiKTtcbiAgICB9LCAwKTtcbiAgfVxuICBfdXBkYXRlRHJvcGRvd25XaWR0aCgpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5faW5wdXQub2Zmc2V0V2lkdGg7XG4gICAgaC5hZGRTdHlsZSh0aGlzLl9kcm9wZG93bkNvbnRhaW5lciwgeyB3aWR0aDogYCR7dH1weGAgfSk7XG4gIH1cbiAgX3NldEZpcnN0QWN0aXZlT3B0aW9uKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLl9nZXROYXZpZ2F0aW9uT3B0aW9ucygpLCBlID0gdGhpcy5fYWN0aXZlT3B0aW9uO1xuICAgIGUgJiYgZS5yZW1vdmVBY3RpdmVTdHlsZXMoKTtcbiAgICBjb25zdCBpID0gdGhpcy5tdWx0aXBsZSA/IHRoaXMuX3NlbGVjdGlvbk1vZGVsLnNlbGVjdGlvbnNbMF0gOiB0aGlzLl9zZWxlY3Rpb25Nb2RlbC5zZWxlY3Rpb247XG4gICAgaSA/ICh0aGlzLl9hY3RpdmVPcHRpb24gPSBpLCBpLnNldEFjdGl2ZVN0eWxlcygpLCB0aGlzLl9hY3RpdmVPcHRpb25JbmRleCA9IHQuZmluZEluZGV4KFxuICAgICAgKG4pID0+IG4gPT09IGlcbiAgICApKSA6ICh0aGlzLl9hY3RpdmVPcHRpb24gPSBudWxsLCB0aGlzLl9hY3RpdmVPcHRpb25JbmRleCA9IC0xKTtcbiAgfVxuICBfc2V0SW5wdXRBY3RpdmVTdHlsZXMoKSB7XG4gICAgdGhpcy5faW5wdXQuc2V0QXR0cmlidXRlKEt0LCBcIlwiKSwgZC5maW5kT25lKGFvLCB0aGlzLl93cmFwcGVyKS5zZXRBdHRyaWJ1dGUoXG4gICAgICBLdCxcbiAgICAgIFwiXCJcbiAgICApO1xuICB9XG4gIF9saXN0ZW5Ub1dpbmRvd1Jlc2l6ZSgpIHtcbiAgICBjLm9uKHdpbmRvdywgXCJyZXNpemVcIiwgdGhpcy5faGFuZGxlV2luZG93UmVzaXplLmJpbmQodGhpcykpO1xuICB9XG4gIF9oYW5kbGVXaW5kb3dSZXNpemUoKSB7XG4gICAgdGhpcy5fZHJvcGRvd25Db250YWluZXIgJiYgdGhpcy5fdXBkYXRlRHJvcGRvd25XaWR0aCgpO1xuICB9XG4gIF9saXN0ZW5Ub1NlbGVjdFNlYXJjaCgpIHtcbiAgICB0aGlzLmZpbHRlcklucHV0LmFkZEV2ZW50TGlzdGVuZXIoXCJpbnB1dFwiLCAodCkgPT4ge1xuICAgICAgY29uc3QgZSA9IHQudGFyZ2V0LnZhbHVlLCBpID0gdGhpcy5fY29uZmlnLnNlbGVjdEZpbHRlckRlYm91bmNlO1xuICAgICAgdGhpcy5fZGVib3VuY2VGaWx0ZXIoZSwgaSk7XG4gICAgfSk7XG4gIH1cbiAgX2RlYm91bmNlRmlsdGVyKHQsIGUpIHtcbiAgICB0aGlzLl9kZWJvdW5jZVRpbWVvdXRJZCAmJiBjbGVhclRpbWVvdXQodGhpcy5fZGVib3VuY2VUaW1lb3V0SWQpLCB0aGlzLl9kZWJvdW5jZVRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5fZmlsdGVyT3B0aW9ucyh0KTtcbiAgICB9LCBlKTtcbiAgfVxuICBfZmlsdGVyT3B0aW9ucyh0KSB7XG4gICAgY29uc3QgZSA9IFtdO1xuICAgIHRoaXMuX29wdGlvbnNUb1JlbmRlci5mb3JFYWNoKChvKSA9PiB7XG4gICAgICBjb25zdCByID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKFxuICAgICAgICBvLFxuICAgICAgICBcIm9wdGlvbnNcIlxuICAgICAgKSwgYSA9ICFyICYmIG8ubGFiZWwudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyh0LnRvTG93ZXJDYXNlKCkpLCBsID0ge307XG4gICAgICByICYmIChsLmxhYmVsID0gby5sYWJlbCwgbC5vcHRpb25zID0gdGhpcy5fZmlsdGVyKHQsIG8ub3B0aW9ucyksIGwub3B0aW9ucy5sZW5ndGggPiAwICYmIGUucHVzaChsKSksIGEgJiYgZS5wdXNoKG8pO1xuICAgIH0pO1xuICAgIGNvbnN0IGkgPSB0aGlzLl9jb25maWcuc2VsZWN0Tm9SZXN1bHRUZXh0ICE9PSBcIlwiLCBuID0gZS5sZW5ndGggIT09IDA7XG4gICAgaWYgKG4pXG4gICAgICB0aGlzLl91cGRhdGVPcHRpb25zTGlzdFRlbXBsYXRlKGUpLCB0aGlzLl9wb3BwZXIuZm9yY2VVcGRhdGUoKSwgdGhpcy5fZmlsdGVyZWRPcHRpb25zTGlzdCA9IHRoaXMuX2dldFBsYWluT3B0aW9ucyhlKSwgdGhpcy5oYXNTZWxlY3RBbGwgJiYgdGhpcy5fdXBkYXRlU2VsZWN0QWxsU3RhdGUoKSwgdGhpcy5fc2V0Rmlyc3RBY3RpdmVPcHRpb24oKTtcbiAgICBlbHNlIGlmICghbiAmJiBpKSB7XG4gICAgICBjb25zdCBvID0gdGhpcy5fZ2V0Tm9SZXN1bHRUZW1wbGF0ZSgpO1xuICAgICAgdGhpcy5vcHRpb25zV3JhcHBlci5pbm5lckhUTUwgPSBvO1xuICAgIH1cbiAgfVxuICBfdXBkYXRlT3B0aW9uc0xpc3RUZW1wbGF0ZSh0KSB7XG4gICAgY29uc3QgZSA9IGQuZmluZE9uZShwbCwgdGhpcy5fZHJvcGRvd25Db250YWluZXIpIHx8IGQuZmluZE9uZShyYiwgdGhpcy5fZHJvcGRvd25Db250YWluZXIpLCBpID0gZWgoXG4gICAgICB0LFxuICAgICAgdGhpcy5fc2VsZWN0QWxsT3B0aW9uLFxuICAgICAgdGhpcy5fY29uZmlnLFxuICAgICAgdGhpcy5fY2xhc3Nlc1xuICAgICk7XG4gICAgdGhpcy5vcHRpb25zV3JhcHBlci5yZW1vdmVDaGlsZChlKSwgdGhpcy5vcHRpb25zV3JhcHBlci5hcHBlbmRDaGlsZChpKTtcbiAgfVxuICBfZ2V0Tm9SZXN1bHRUZW1wbGF0ZSgpIHtcbiAgICByZXR1cm4gYDxkaXYgY2xhc3M9XCIke3RoaXMuX2NsYXNzZXMubm9SZXN1bHR9XCIgJHtvaH0gc3R5bGU9XCJoZWlnaHQ6ICR7dGhpcy5fY29uZmlnLnNlbGVjdE9wdGlvbkhlaWdodH1weFwiPiR7dGhpcy5fY29uZmlnLnNlbGVjdE5vUmVzdWx0VGV4dH08L2Rpdj5gO1xuICB9XG4gIF9maWx0ZXIodCwgZSkge1xuICAgIGNvbnN0IGkgPSB0LnRvTG93ZXJDYXNlKCk7XG4gICAgcmV0dXJuIGUuZmlsdGVyKFxuICAgICAgKG4pID0+IG4ubGFiZWwudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhpKVxuICAgICk7XG4gIH1cbiAgX2xpc3RlblRvRHJvcGRvd25LZXlkb3duKCkge1xuICAgIGMub24oXG4gICAgICB0aGlzLmRyb3Bkb3duLFxuICAgICAgXCJrZXlkb3duXCIsXG4gICAgICB0aGlzLl9oYW5kbGVPcGVuS2V5ZG93bi5iaW5kKHRoaXMpXG4gICAgKTtcbiAgfVxuICBfbGlzdGVuVG9PdXRzaWRlQ2xpY2soKSB7XG4gICAgdGhpcy5fb3V0c2lkZUNsaWNrID0gdGhpcy5faGFuZGxlT3V0U2lkZUNsaWNrLmJpbmQodGhpcyksIGMub24oZG9jdW1lbnQsIFwiY2xpY2tcIiwgdGhpcy5fb3V0c2lkZUNsaWNrKTtcbiAgfVxuICBfbGlzdGVuVG9Gb2N1c0NoYW5nZSh0ID0gITApIHtcbiAgICBpZiAodCA9PT0gITEpIHtcbiAgICAgIGMub2ZmKFxuICAgICAgICB0aGlzLl9pbnB1dCxcbiAgICAgICAgXCJmb2N1c1wiLFxuICAgICAgICAoKSA9PiB0aGlzLl9ub3RjaC5zZXRBdHRyaWJ1dGUoS3QsIFwiXCIpXG4gICAgICApLCBjLm9mZihcbiAgICAgICAgdGhpcy5faW5wdXQsXG4gICAgICAgIFwiYmx1clwiLFxuICAgICAgICAoKSA9PiB0aGlzLl9ub3RjaC5yZW1vdmVBdHRyaWJ1dGUoS3QpXG4gICAgICApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjLm9uKFxuICAgICAgdGhpcy5faW5wdXQsXG4gICAgICBcImZvY3VzXCIsXG4gICAgICAoKSA9PiB0aGlzLl9ub3RjaC5zZXRBdHRyaWJ1dGUoS3QsIFwiXCIpXG4gICAgKSwgYy5vbihcbiAgICAgIHRoaXMuX2lucHV0LFxuICAgICAgXCJibHVyXCIsXG4gICAgICAoKSA9PiB0aGlzLl9ub3RjaC5yZW1vdmVBdHRyaWJ1dGUoS3QpXG4gICAgKTtcbiAgfVxuICBfaGFuZGxlT3V0U2lkZUNsaWNrKHQpIHtcbiAgICBjb25zdCBlID0gdGhpcy5fd3JhcHBlciAmJiB0aGlzLl93cmFwcGVyLmNvbnRhaW5zKHQudGFyZ2V0KSwgaSA9IHQudGFyZ2V0ID09PSB0aGlzLl9kcm9wZG93bkNvbnRhaW5lciwgbiA9IHRoaXMuX2Ryb3Bkb3duQ29udGFpbmVyICYmIHRoaXMuX2Ryb3Bkb3duQ29udGFpbmVyLmNvbnRhaW5zKHQudGFyZ2V0KTtcbiAgICBsZXQgbztcbiAgICB0aGlzLl90b2dnbGVCdXR0b24gfHwgKHRoaXMuX2VsZW1lbnRUb2dnbGUgPSBkLmZpbmQoYWIpKSwgdGhpcy5fZWxlbWVudFRvZ2dsZSAmJiB0aGlzLl9lbGVtZW50VG9nZ2xlLmZvckVhY2goKHIpID0+IHtcbiAgICAgIGNvbnN0IGEgPSBoLmdldERhdGFBdHRyaWJ1dGUoXG4gICAgICAgIHIsXG4gICAgICAgIFwic2VsZWN0LXRvZ2dsZVwiXG4gICAgICApO1xuICAgICAgKGEgPT09IHRoaXMuX2VsZW1lbnQuaWQgfHwgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoYSkpICYmICh0aGlzLl90b2dnbGVCdXR0b24gPSByLCBvID0gdGhpcy5fdG9nZ2xlQnV0dG9uLmNvbnRhaW5zKHQudGFyZ2V0KSk7XG4gICAgfSksICFlICYmICFpICYmICFuICYmICFvICYmIHRoaXMuY2xvc2UoKTtcbiAgfVxuICBjbG9zZSgpIHtcbiAgICBjb25zdCB0ID0gYy50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIFVnKTtcbiAgICAhdGhpcy5faXNPcGVuIHx8IHQuZGVmYXVsdFByZXZlbnRlZCB8fCAodGhpcy5fY29uZmlnLnNlbGVjdEZpbHRlciAmJiB0aGlzLmhhc1NlbGVjdEFsbCAmJiAodGhpcy5fcmVzZXRGaWx0ZXJTdGF0ZSgpLCB0aGlzLl91cGRhdGVPcHRpb25zTGlzdFRlbXBsYXRlKHRoaXMuX29wdGlvbnNUb1JlbmRlciksIHRoaXMuX2NvbmZpZy5tdWx0aXBsZSAmJiB0aGlzLl91cGRhdGVTZWxlY3RBbGxTdGF0ZSgpKSwgdGhpcy5fcmVtb3ZlRHJvcGRvd25FdmVudHMoKSwgdGhpcy5kcm9wZG93bi5yZW1vdmVBdHRyaWJ1dGUoZGwpLCBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuX2lucHV0LnJlbW92ZUF0dHJpYnV0ZShLdCksIHRoaXMuX2lucHV0LmJsdXIoKSwgZC5maW5kT25lKGFvLCB0aGlzLl93cmFwcGVyKS5yZW1vdmVBdHRyaWJ1dGUoXG4gICAgICAgIEt0XG4gICAgICApLCB0aGlzLl9sYWJlbCAmJiAhdGhpcy5oYXNTZWxlY3Rpb24gJiYgKHRoaXMuX2xhYmVsLnJlbW92ZUF0dHJpYnV0ZShxKSwgdGhpcy5fbm90Y2guc2V0QXR0cmlidXRlKHEsIFwiXCIpLCB0aGlzLl9pbnB1dC5yZW1vdmVBdHRyaWJ1dGUocSksIHRoaXMuX25vdGNoLnJlbW92ZUF0dHJpYnV0ZShxKSksIHRoaXMuX3VwZGF0ZUxhYmVsUG9zaXRpb25XaGlsZUNsb3NpbmcoKTtcbiAgICB9LCAwKSwgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLl9jb250YWluZXIgJiYgdGhpcy5fZHJvcGRvd25Db250YWluZXIucGFyZW50Tm9kZSA9PT0gdGhpcy5fY29udGFpbmVyICYmIHRoaXMuX2NvbnRhaW5lci5yZW1vdmVDaGlsZCh0aGlzLl9kcm9wZG93bkNvbnRhaW5lciksIHRoaXMuX3BvcHBlci5kZXN0cm95KCksIHRoaXMuX2lzT3BlbiA9ICExLCBjLm9mZih0aGlzLmRyb3Bkb3duLCBcInRyYW5zaXRpb25lbmRcIik7XG4gICAgfSwgbGIpKTtcbiAgfVxuICBfcmVzZXRGaWx0ZXJTdGF0ZSgpIHtcbiAgICB0aGlzLmZpbHRlcklucHV0LnZhbHVlID0gXCJcIiwgdGhpcy5fZmlsdGVyZWRPcHRpb25zTGlzdCA9IG51bGw7XG4gIH1cbiAgX3JlbW92ZURyb3Bkb3duRXZlbnRzKCkge1xuICAgIGMub2ZmKGRvY3VtZW50LCBcImNsaWNrXCIsIHRoaXMuX291dHNpZGVDbGljayksIHRoaXMuX2NvbmZpZy5zZWxlY3RGaWx0ZXIgJiYgYy5vZmYodGhpcy5kcm9wZG93biwgXCJrZXlkb3duXCIpLCBjLm9mZih0aGlzLm9wdGlvbnNXcmFwcGVyLCBcImNsaWNrXCIpO1xuICB9XG4gIF9hZGRNdXRhdGlvbk9ic2VydmVyKCkge1xuICAgIHRoaXMuX211dGF0aW9uT2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcigoKSA9PiB7XG4gICAgICB0aGlzLl93cmFwcGVyICYmICh0aGlzLl91cGRhdGVTZWxlY3Rpb25zKCksIHRoaXMuX3VwZGF0ZURpc2FibGVkU3RhdGUoKSk7XG4gICAgfSksIHRoaXMuX29ic2VydmVNdXRhdGlvbk9ic2VydmVyKCk7XG4gIH1cbiAgX3VwZGF0ZVNlbGVjdGlvbnMoKSB7XG4gICAgdGhpcy5fb3B0aW9uc1RvUmVuZGVyID0gdGhpcy5fZ2V0T3B0aW9uc1RvUmVuZGVyKHRoaXMuX2VsZW1lbnQpLCB0aGlzLl9wbGFpbk9wdGlvbnMgPSB0aGlzLl9nZXRQbGFpbk9wdGlvbnModGhpcy5fb3B0aW9uc1RvUmVuZGVyKSwgdGhpcy5fc2VsZWN0aW9uTW9kZWwuY2xlYXIoKSwgdGhpcy5fc2V0RGVmYXVsdFNlbGVjdGlvbnMoKSwgdGhpcy5fdXBkYXRlSW5wdXRWYWx1ZSgpLCB0aGlzLl91cGRhdGVGYWtlTGFiZWxQb3NpdGlvbigpLCB0aGlzLl91cGRhdGVMYWJlbFBvc2l0aW9uKCksIHRoaXMuX3VwZGF0ZUNsZWFyQnV0dG9uVmlzaWJpbGl0eSgpLCB0aGlzLmhhc1NlbGVjdEFsbCAmJiB0aGlzLl91cGRhdGVTZWxlY3RBbGxTdGF0ZSgpO1xuICAgIGNvbnN0IHQgPSB0aGlzLl9jb25maWcuZmlsdGVyICYmIHRoaXMuZmlsdGVySW5wdXQgJiYgdGhpcy5maWx0ZXJJbnB1dC52YWx1ZTtcbiAgICB0aGlzLl9pc09wZW4gJiYgIXQgPyAodGhpcy5fdXBkYXRlT3B0aW9uc0xpc3RUZW1wbGF0ZSh0aGlzLl9vcHRpb25zVG9SZW5kZXIpLCB0aGlzLl9zZXRGaXJzdEFjdGl2ZU9wdGlvbigpKSA6IHRoaXMuX2lzT3BlbiAmJiB0ID8gKHRoaXMuX2ZpbHRlck9wdGlvbnModGhpcy5maWx0ZXJJbnB1dC52YWx1ZSksIHRoaXMuX3NldEZpcnN0QWN0aXZlT3B0aW9uKCkpIDogdGhpcy5fZHJvcGRvd25Db250YWluZXIgPSBhbChcbiAgICAgIHRoaXMuX2Ryb3Bkb3duQ29udGFpbmVySWQsXG4gICAgICB0aGlzLl9jb25maWcsXG4gICAgICB0aGlzLl9pbnB1dC5vZmZzZXRXaWR0aCxcbiAgICAgIHRoaXMuX2Ryb3Bkb3duSGVpZ2h0LFxuICAgICAgdGhpcy5fc2VsZWN0QWxsT3B0aW9uLFxuICAgICAgdGhpcy5fb3B0aW9uc1RvUmVuZGVyLFxuICAgICAgdGhpcy5fY3VzdG9tQ29udGVudCxcbiAgICAgIHRoaXMuX2NsYXNzZXNcbiAgICApO1xuICB9XG4gIF91cGRhdGVEaXNhYmxlZFN0YXRlKCkge1xuICAgIGNvbnN0IHQgPSBkLmZpbmRPbmUodWwsIHRoaXMuX3dyYXBwZXIpO1xuICAgIHRoaXMuX2VsZW1lbnQuaGFzQXR0cmlidXRlKFwiZGlzYWJsZWRcIikgPyAodGhpcy5fY29uZmlnLmRpc2FibGVkID0gITAsIHQuc2V0QXR0cmlidXRlKFwiZGlzYWJsZWRcIiwgXCJcIiksIHQuc2V0QXR0cmlidXRlKHJvLCBcIlwiKSkgOiAodGhpcy5fY29uZmlnLmRpc2FibGVkID0gITEsIHQucmVtb3ZlQXR0cmlidXRlKFwiZGlzYWJsZWRcIiksIHQucmVtb3ZlQXR0cmlidXRlKHJvKSk7XG4gIH1cbiAgX29ic2VydmVNdXRhdGlvbk9ic2VydmVyKCkge1xuICAgIHRoaXMuX211dGF0aW9uT2JzZXJ2ZXIgJiYgdGhpcy5fbXV0YXRpb25PYnNlcnZlci5vYnNlcnZlKHRoaXMuX2VsZW1lbnQsIHtcbiAgICAgIGF0dHJpYnV0ZXM6ICEwLFxuICAgICAgY2hpbGRMaXN0OiAhMCxcbiAgICAgIGNoYXJhY3RlckRhdGE6ICEwLFxuICAgICAgc3VidHJlZTogITBcbiAgICB9KTtcbiAgfVxuICBfZGlzY29ubmVjdE11dGF0aW9uT2JzZXJ2ZXIoKSB7XG4gICAgdGhpcy5tdXRhdGlvbk9ic2VydmVyICYmICh0aGlzLl9tdXRhdGlvbk9ic2VydmVyLmRpc2Nvbm5lY3QoKSwgdGhpcy5fbXV0YXRpb25PYnNlcnZlciA9IG51bGwpO1xuICB9XG4gIF9jcmVhdGVTZWxlY3RBbGxPcHRpb24oKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuX3NlbGVjdEFsbElkLCBlID0gbnVsbCwgaSA9ICEwLCBuID0gXCJzZWxlY3QtYWxsXCIsIG8gPSB0aGlzLl9jb25maWcuc2VsZWN0QWxsTGFiZWwsIHIgPSBWbyh0aGlzLm9wdGlvbnMpLCBhID0gITEsIGwgPSAhMSwgcCA9IG51bGwsIHUgPSBudWxsLCBfID0gbnVsbDtcbiAgICByZXR1cm4gbmV3IHJsKFxuICAgICAgdCxcbiAgICAgIGUsXG4gICAgICBpLFxuICAgICAgbixcbiAgICAgIG8sXG4gICAgICByLFxuICAgICAgYSxcbiAgICAgIGwsXG4gICAgICBwLFxuICAgICAgdSxcbiAgICAgIF9cbiAgICApO1xuICB9XG4gIGRpc3Bvc2UoKSB7XG4gICAgdGhpcy5fcmVtb3ZlQ29tcG9uZW50RXZlbnRzKCksIHRoaXMuX2Rlc3Ryb3lNYXRlcmlhbFNlbGVjdCgpLCB0aGlzLl9saXN0ZW5Ub0ZvY3VzQ2hhbmdlKCExKSwgeS5yZW1vdmVEYXRhKHRoaXMuX2VsZW1lbnQsIHZpKTtcbiAgfVxuICBfcmVtb3ZlQ29tcG9uZW50RXZlbnRzKCkge1xuICAgIGMub2ZmKHRoaXMuaW5wdXQsIFwiY2xpY2tcIiksIGMub2ZmKHRoaXMud3JhcHBlciwgdGhpcy5faGFuZGxlS2V5ZG93bi5iaW5kKHRoaXMpKSwgYy5vZmYodGhpcy5jbGVhckJ1dHRvbiwgXCJjbGlja1wiKSwgYy5vZmYodGhpcy5jbGVhckJ1dHRvbiwgXCJrZXlkb3duXCIpLCBjLm9mZih3aW5kb3csIFwicmVzaXplXCIsIHRoaXMuX2hhbmRsZVdpbmRvd1Jlc2l6ZS5iaW5kKHRoaXMpKTtcbiAgfVxuICBfZGVzdHJveU1hdGVyaWFsU2VsZWN0KCkge1xuICAgIHRoaXMuX2lzT3BlbiAmJiB0aGlzLmNsb3NlKCksIHRoaXMuX2Rlc3Ryb3lNYXRlcmlhbFRlbXBsYXRlKCk7XG4gIH1cbiAgX2Rlc3Ryb3lNYXRlcmlhbFRlbXBsYXRlKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLl93cmFwcGVyLnBhcmVudE5vZGUsIGUgPSBkLmZpbmQoXCJsYWJlbFwiLCB0aGlzLl93cmFwcGVyKTtcbiAgICB0LmFwcGVuZENoaWxkKHRoaXMuX2VsZW1lbnQpLCBlLmZvckVhY2goKGkpID0+IHtcbiAgICAgIHQuYXBwZW5kQ2hpbGQoaSk7XG4gICAgfSksIGUuZm9yRWFjaCgoaSkgPT4ge1xuICAgICAgaS5yZW1vdmVBdHRyaWJ1dGUocSk7XG4gICAgfSksIGgucmVtb3ZlQ2xhc3ModGhpcy5fZWxlbWVudCwgdGhpcy5fY2xhc3Nlcy5pbml0aWFsaXplZCksIHRoaXMuX2VsZW1lbnQucmVtb3ZlQXR0cmlidXRlKGhsKSwgdC5yZW1vdmVDaGlsZCh0aGlzLl93cmFwcGVyKTtcbiAgfVxuICBzZXRWYWx1ZSh0KSB7XG4gICAgdGhpcy5vcHRpb25zLmZpbHRlcigoaSkgPT4gaS5zZWxlY3RlZCkuZm9yRWFjaCgoaSkgPT4gaS5uYXRpdmVPcHRpb24uc2VsZWN0ZWQgPSAhMSksIEFycmF5LmlzQXJyYXkodCkgPyB0LmZvckVhY2goKGkpID0+IHtcbiAgICAgIHRoaXMuX3NlbGVjdEJ5VmFsdWUoaSk7XG4gICAgfSkgOiB0aGlzLl9zZWxlY3RCeVZhbHVlKHQpLCB0aGlzLl91cGRhdGVTZWxlY3Rpb25zKCk7XG4gIH1cbiAgX3NlbGVjdEJ5VmFsdWUodCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLm9wdGlvbnMuZmluZChcbiAgICAgIChpKSA9PiBpLnZhbHVlID09PSB0XG4gICAgKTtcbiAgICByZXR1cm4gZSA/IChlLm5hdGl2ZU9wdGlvbi5zZWxlY3RlZCA9ICEwLCAhMCkgOiAhMTtcbiAgfVxuICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKHQsIGUpIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgbGV0IGkgPSB5LmdldERhdGEodGhpcywgdmkpO1xuICAgICAgY29uc3QgbiA9IHR5cGVvZiB0ID09IFwib2JqZWN0XCIgJiYgdDtcbiAgICAgIGlmICghKCFpICYmIC9kaXNwb3NlLy50ZXN0KHQpKSAmJiAoaSB8fCAoaSA9IG5ldyBfcih0aGlzLCBuKSksIHR5cGVvZiB0ID09IFwic3RyaW5nXCIpKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaVt0XSA+IFwidVwiKVxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcIiR7dH1cImApO1xuICAgICAgICBpW3RdKGUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHN0YXRpYyBnZXRJbnN0YW5jZSh0KSB7XG4gICAgcmV0dXJuIHkuZ2V0RGF0YSh0LCB2aSk7XG4gIH1cbiAgc3RhdGljIGdldE9yQ3JlYXRlSW5zdGFuY2UodCwgZSA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0SW5zdGFuY2UodCkgfHwgbmV3IHRoaXModCwgdHlwZW9mIGUgPT0gXCJvYmplY3RcIiA/IGUgOiBudWxsKTtcbiAgfVxufVxuY29uc3QgcGIgPSAoeyBpbnB1dElEOiBzLCBsYWJlbFRleHQ6IHQgfSwgZSkgPT4gYDxkaXYgZGF0YS10ZS1jaGlwcy1pbnB1dC13cmFwcGVyIGRhdGEtdGUtaW5wdXQtd3JhcHBlci1pbml0IGNsYXNzPVwiJHtlLmNoaXBzSW5wdXRXcmFwcGVyfVwiPlxuICAgICAgPGlucHV0XG4gICAgICAgICAgdHlwZT1cInRleHRcIlxuICAgICAgICAgIGNsYXNzPVwiJHtlLmNoaXBzSW5wdXR9XCJcbiAgICAgICAgICBpZD1cIiR7c31cIlxuICAgICAgICAgIHBsYWNlaG9sZGVyPVwiRXhhbXBsZSBsYWJlbFwiIC8+XG4gICAgICAgIDxsYWJlbFxuICAgICAgICAgIGZvcj1cIiR7c31cIlxuICAgICAgICAgIGNsYXNzPVwiJHtlLmNoaXBzTGFiZWx9XCJcbiAgICAgICAgICA+JHt0fVxuICAgICAgICA8L2xhYmVsPlxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+YCwgX2IgPSAoeyB0ZXh0OiBzLCBpY29uU1ZHOiB0IH0sIGUpID0+IGA8ZGl2IGRhdGEtdGUtY2hpcC1pbml0IGRhdGEtdGUtcmlwcGxlLWluaXQgY2xhc3M9XCIke2UuY2hpcEVsZW1lbnR9XCI+XG4gICAgPHNwYW4gZGF0YS10ZS1jaGlwLXRleHQ+JHtzfTwvc3Bhbj4gXG4gICAgICA8c3BhbiBkYXRhLXRlLWNoaXAtY2xvc2UgY2xhc3M9XCIke2UuY2hpcENsb3NlSWNvbn1cIj5cbiAgICAgICAgJHt0fVxuICAgICAgPC9zcGFuPlxuICA8L2Rpdj5gLCBHcyA9IFwiY2hpcFwiLCBmYiA9IGB0ZS4ke0dzfWAsIHJoID0gXCJkYXRhLXRlLWNoaXAtY2xvc2VcIiwgbG8gPSBgWyR7cmh9XWAsIG1iID0gXCJkZWxldGUudGUuY2hpcHNcIiwgZ2IgPSBcInNlbGVjdC50ZS5jaGlwXCIsIGJiID0gJzxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIGZpbGw9XCJub25lXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIHN0cm9rZS13aWR0aD1cIjEuNVwiIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIGNsYXNzPVwidy0zIGgtM1wiPiA8cGF0aCBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIiBkPVwiTTYgMThMMTggNk02IDZsMTIgMTJcIiAvPjwvc3ZnPicsIHZiID0ge1xuICB0ZXh0OiBcInN0cmluZ1wiLFxuICBjbG9zZUljb246IFwiYm9vbGVhblwiLFxuICBpbWc6IFwib2JqZWN0XCIsXG4gIGljb25TVkc6IFwic3RyaW5nXCJcbn0sIFRiID0ge1xuICB0ZXh0OiBcIlwiLFxuICBjbG9zZUljb246ICExLFxuICBpbWc6IHsgcGF0aDogXCJcIiwgYWx0OiBcIlwiIH0sXG4gIGljb25TVkc6IGJiXG59LCBFYiA9IHtcbiAgaWNvbjogXCJmbG9hdC1yaWdodCBwbC1bOHB4XSB0ZXh0LVsxNnB4XSBvcGFjaXR5LVsuNTNdIGN1cnNvci1wb2ludGVyIGZpbGwtWyNhZmFmYWZdIGhvdmVyOnRleHQtWyM4YjhiOGJdIHRyYW5zaXRpb24tYWxsIGR1cmF0aW9uLTIwMCBlYXNlLWluLW91dFwiLFxuICBjaGlwRWxlbWVudDogXCJmbGV4IGp1c3RpZnktYmV0d2VlbiBpdGVtcy1jZW50ZXIgaC1bMzJweF0gbGVhZGluZy1sb29zZSBweS1bNXB4XSBweC1bMTJweF0gbXItNCBteS1bNXB4XSB0ZXh0LVsxM3B4XSBmb250LW5vcm1hbCB0ZXh0LVsjNGY0ZjRmXSBjdXJzb3ItcG9pbnRlciBiZy1bI2VjZWZmMV0gZGFyazp0ZXh0LXdoaXRlIGRhcms6YmctbmV1dHJhbC02MDAgcm91bmRlZC1bMTZweF0gdHJhbnNpdGlvbi1bb3BhY2l0eV0gZHVyYXRpb24tMzAwIGVhc2UtbGluZWFyIFt3b3JkLXdyYXA6IGJyZWFrLXdvcmRdIHNoYWRvdy1ub25lIG5vcm1hbC1jYXNlIGhvdmVyOiFzaGFkb3ctbm9uZSBhY3RpdmU6YmctWyNjYWNmZDFdIGlubGluZS1ibG9jayBmb250LW1lZGl1bSBsZWFkaW5nLW5vcm1hbCB0ZXh0LVsjNGY0ZjRmXSB0ZXh0LWNlbnRlciBuby11bmRlcmxpbmUgYWxpZ24tbWlkZGxlIGN1cnNvci1wb2ludGVyIHNlbGVjdC1ub25lIGJvcmRlci1bLjEyNXJlbV0gYm9yZGVyLXNvbGlkIGJvcmRlci10cmFuc3BhcmVudCBweS0xLjUgcHgtMyB0ZXh0LXhzIHJvdW5kZWRcIixcbiAgY2hpcENsb3NlSWNvbjogXCJ3LTQgZmxvYXQtcmlnaHQgcGwtWzhweF0gdGV4dC1bMTZweF0gb3BhY2l0eS1bLjUzXSBjdXJzb3ItcG9pbnRlciBmaWxsLVsjYWZhZmFmXSBob3ZlcjpmaWxsLVsjOGI4YjhiXSBkYXJrOmZpbGwtZ3JheS00MDAgZGFyazpob3ZlcjpmaWxsLWdyYXktMTAwIHRyYW5zaXRpb24tYWxsIGR1cmF0aW9uLTIwMCBlYXNlLWluLW91dFwiXG59LCBDYiA9IHtcbiAgaWNvbjogXCJzdHJpbmdcIixcbiAgY2hpcEVsZW1lbnQ6IFwic3RyaW5nXCIsXG4gIGNoaXBDbG9zZUljb246IFwic3RyaW5nXCJcbn07XG5jbGFzcyBfaSB7XG4gIGNvbnN0cnVjdG9yKHQsIGUgPSB7fSwgaSkge1xuICAgIHRoaXMuX2VsZW1lbnQgPSB0LCB0aGlzLl9vcHRpb25zID0gdGhpcy5fZ2V0Q29uZmlnKGUpLCB0aGlzLl9jbGFzc2VzID0gdGhpcy5fZ2V0Q2xhc3NlcyhpKTtcbiAgfVxuICAvLyBHZXR0ZXJzXG4gIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICByZXR1cm4gR3M7XG4gIH1cbiAgLy8gUHVibGljXG4gIGluaXQoKSB7XG4gICAgdGhpcy5fYXBwZW5kQ2xvc2VJY29uKCksIHRoaXMuX2hhbmRsZURlbGV0ZSgpLCB0aGlzLl9oYW5kbGVUZXh0Q2hpcCgpLCB0aGlzLl9oYW5kbGVDbGlja09uQ2hpcCgpO1xuICB9XG4gIGRpc3Bvc2UoKSB7XG4gICAgdGhpcy5fZWxlbWVudCA9IG51bGwsIHRoaXMuX29wdGlvbnMgPSBudWxsLCBjLm9mZih0aGlzLl9lbGVtZW50LCBcImNsaWNrXCIpO1xuICB9XG4gIGFwcGVuZENoaXAoKSB7XG4gICAgY29uc3QgeyB0ZXh0OiB0LCBjbG9zZUljb246IGUsIGljb25TVkc6IGkgfSA9IHRoaXMuX29wdGlvbnM7XG4gICAgcmV0dXJuIF9iKHsgdGV4dDogdCwgY2xvc2VJY29uOiBlLCBpY29uU1ZHOiBpIH0sIHRoaXMuX2NsYXNzZXMpO1xuICB9XG4gIC8vIFByaXZhdGVcbiAgX2FwcGVuZENsb3NlSWNvbih0ID0gdGhpcy5fZWxlbWVudCkge1xuICAgIGlmICghKGQuZmluZChsbywgdGhpcy5fZWxlbWVudCkubGVuZ3RoID4gMCkgJiYgdGhpcy5fb3B0aW9ucy5jbG9zZUljb24pIHtcbiAgICAgIGNvbnN0IGUgPSAkKFwic3BhblwiKTtcbiAgICAgIGUuY2xhc3NMaXN0ID0gdGhpcy5fY2xhc3Nlcy5pY29uLCBlLnNldEF0dHJpYnV0ZShyaCksIGUuaW5uZXJIVE1MID0gdGhpcy5fb3B0aW9ucy5pY29uU1ZHLCB0Lmluc2VydEFkamFjZW50RWxlbWVudChcImJlZm9yZWVuZFwiLCBlKTtcbiAgICB9XG4gIH1cbiAgX2hhbmRsZUNsaWNrT25DaGlwKCkge1xuICAgIGMub24odGhpcy5fZWxlbWVudCwgXCJjbGlja1wiLCAodCkgPT4ge1xuICAgICAgY29uc3QgeyB0ZXh0Q29udGVudDogZSB9ID0gdC50YXJnZXQsIGkgPSB7fTtcbiAgICAgIGkudGFnID0gZS50cmltKCksIGMudHJpZ2dlcihnYiwgeyBldmVudDogdCwgb2JqOiBpIH0pO1xuICAgIH0pO1xuICB9XG4gIF9oYW5kbGVEZWxldGUoKSB7XG4gICAgZC5maW5kKFxuICAgICAgbG8sXG4gICAgICB0aGlzLl9lbGVtZW50XG4gICAgKS5sZW5ndGggIT09IDAgJiYgYy5vbih0aGlzLl9lbGVtZW50LCBcImNsaWNrXCIsIGxvLCAoKSA9PiB7XG4gICAgICBjLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgbWIpLCB0aGlzLl9lbGVtZW50LnJlbW92ZSgpO1xuICAgIH0pO1xuICB9XG4gIF9oYW5kbGVUZXh0Q2hpcCgpIHtcbiAgICB0aGlzLl9lbGVtZW50LmlubmVyVGV4dCA9PT0gXCJcIiAmJiAodGhpcy5fZWxlbWVudC5pbm5lclRleHQgPSB0aGlzLl9vcHRpb25zLnRleHQpO1xuICB9XG4gIF9nZXRDb25maWcodCkge1xuICAgIGNvbnN0IGUgPSB7XG4gICAgICAuLi5UYixcbiAgICAgIC4uLmguZ2V0RGF0YUF0dHJpYnV0ZXModGhpcy5fZWxlbWVudCksXG4gICAgICAuLi50XG4gICAgfTtcbiAgICByZXR1cm4gRChHcywgZSwgdmIpLCBlO1xuICB9XG4gIF9nZXRDbGFzc2VzKHQpIHtcbiAgICBjb25zdCBlID0gaC5nZXREYXRhQ2xhc3NBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpO1xuICAgIHJldHVybiB0ID0ge1xuICAgICAgLi4uRWIsXG4gICAgICAuLi5lLFxuICAgICAgLi4udFxuICAgIH0sIEQoR3MsIHQsIENiKSwgdDtcbiAgfVxuICBzdGF0aWMgZ2V0SW5zdGFuY2UodCkge1xuICAgIHJldHVybiB5LmdldERhdGEodCwgZmIpO1xuICB9XG4gIHN0YXRpYyBnZXRPckNyZWF0ZUluc3RhbmNlKHQsIGUgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLmdldEluc3RhbmNlKHQpIHx8IG5ldyB0aGlzKHQsIHR5cGVvZiBlID09IFwib2JqZWN0XCIgPyBlIDogbnVsbCk7XG4gIH1cbn1cbmNvbnN0IExpID0gXCJjaGlwc1wiLCBLaSA9IGBkYXRhLXRlLSR7TGl9YCwgZmwgPSBgdGUuJHtMaX1gLCBBYiA9IGAke0tpfS1pbnB1dC1pbml0YCwgbXQgPSBgJHtLaX0tYWN0aXZlYCwgbWwgPSBgJHtLaX0taW5pdGlhbGAsIGFoID0gYCR7S2l9LXBsYWNlaG9sZGVyYCwgeWIgPSBgJHtLaX0taW5wdXQtd3JhcHBlcmAsIFdvID0gXCJkYXRhLXRlLWNoaXAtaW5pdFwiLCBsaCA9IFwiZGF0YS10ZS1jaGlwLWNsb3NlXCIsIGNoID0gXCJkYXRhLXRlLWNoaXAtdGV4dFwiLCB3YiA9IGBbJHttdH1dYCwgRm8gPSBgWyR7V299XWAsIGtiID0gYCR7Rm99JHt3Yn1gLCBjbyA9IGBbJHtsaH1dYCwgeGIgPSBgWyR7eWJ9XWAsIE9iID0gYFske2NofV1gLCBTYiA9IGBbJHthaH1dYCwgSWIgPSBcImRhdGEtdGUtaW5wdXQtbm90Y2gtbGVhZGluZy1yZWZcIiwgRGIgPSBcImRhdGEtdGUtaW5wdXQtbm90Y2gtbWlkZGxlLXJlZlwiLCAkYiA9IGBbJHtJYn1dYCwgTGIgPSBgWyR7RGJ9XWAsIFNlID0gXCJkYXRhLXRlLWlucHV0LXN0YXRlLWFjdGl2ZVwiLCBobyA9IFwiW2RhdGEtdGUtaW5wdXQtbm90Y2gtcmVmXVwiLCBOYiA9IFwiYWRkLnRlLmNoaXBzXCIsIE1iID0gXCJhcnJvd0Rvd24udGUuY2hpcHNcIiwgUmIgPSBcImFycm93TGVmdC50ZS5jaGlwc1wiLCBQYiA9IFwiYXJyb3dSaWdodC50ZS5jaGlwc1wiLCBCYiA9IFwiYXJyb3dVcC50ZS5jaGlwc1wiLCBnbCA9IFwiZGVsZXRlLnRlLmNoaXBzXCIsIGJsID0gXCJzZWxlY3QudGUuY2hpcHNcIiwgSGIgPSB7XG4gIGlucHV0SUQ6IFwic3RyaW5nXCIsXG4gIHBhcmVudFNlbGVjdG9yOiBcInN0cmluZ1wiLFxuICBpbml0aWFsVmFsdWVzOiBcImFycmF5XCIsXG4gIGVkaXRhYmxlOiBcImJvb2xlYW5cIixcbiAgbGFiZWxUZXh0OiBcInN0cmluZ1wiLFxuICBpbnB1dENsYXNzZXM6IFwib2JqZWN0XCIsXG4gIGlucHV0T3B0aW9uczogXCJvYmplY3RcIlxufSwgVmIgPSB7XG4gIGlucHV0SUQ6IHJ0KFwiY2hpcHMtaW5wdXQtXCIpLFxuICBwYXJlbnRTZWxlY3RvcjogXCJcIixcbiAgaW5pdGlhbFZhbHVlczogW3sgdGFnOiBcImluaXQxXCIgfSwgeyB0YWc6IFwiaW5pdDJcIiB9XSxcbiAgZWRpdGFibGU6ICExLFxuICBsYWJlbFRleHQ6IFwiRXhhbXBsZSBsYWJlbFwiLFxuICBpbnB1dENsYXNzZXM6IHt9LFxuICBpbnB1dE9wdGlvbnM6IHt9XG59LCBXYiA9IHtcbiAgb3BhY2l0eTogXCJvcGFjaXR5LTBcIixcbiAgaW5wdXRXcmFwcGVyUGFkZGluZzogXCJwLVs1cHhdXCIsXG4gIHRyYW5zaXRpb246IFwidHJhbnNpdGlvbi1hbGwgZHVyYXRpb24tMzAwIGVhc2UtW2N1YmljLWJlemllcigwLjI1LDAuMSwwLjI1LDEpXVwiLFxuICBjb250ZW50RWRpdGFibGU6IFwib3V0bGluZS1ub25lICFib3JkZXItWzNweF0gIWJvcmRlci1zb2xpZCAhYm9yZGVyLVsjYjJiM2I0XVwiLFxuICBjaGlwc0lucHV0V3JhcHBlcjogXCJyZWxhdGl2ZSBmbGV4IGl0ZW1zLWNlbnRlciBmbGV4LXdyYXAgdHJhbnNpdGlvbi1hbGwgZHVyYXRpb24tMzAwIGVhc2UtW2N1YmljLWJlemllcigwLjI1LDAuMSwwLjI1LDEpXVwiLFxuICBjaGlwc0lucHV0OiBcInBlZXIgYmxvY2sgbWluLWgtW2F1dG9dIHctWzE1MHB4XSByb3VuZGVkIGJvcmRlci0wIGJnLXRyYW5zcGFyZW50IHB5LVswLjMycmVtXSBweC0zIGxlYWRpbmctWzEuNl0gb3V0bGluZS1ub25lIHRyYW5zaXRpb24tYWxsIGR1cmF0aW9uLTIwMCBlYXNlLWxpbmVhciBmb2N1czpwbGFjZWhvbGRlcjpvcGFjaXR5LTEwMCBkYXRhLVt0ZS1pbnB1dC1zdGF0ZS1hY3RpdmVdOnBsYWNlaG9sZGVyOm9wYWNpdHktMTAwIG1vdGlvbi1yZWR1Y2U6dHJhbnNpdGlvbi1ub25lIGRhcms6dGV4dC1ncmF5LTIwMCBkYXJrOnBsYWNlaG9sZGVyOnRleHQtZ3JheS0yMDAgWyY6bm90KFtkYXRhLXRlLWlucHV0LXBsYWNlaG9sZGVyLWFjdGl2ZV0pXTpwbGFjZWhvbGRlcjpvcGFjaXR5LTBcIixcbiAgY2hpcHNMYWJlbDogXCJwb2ludGVyLWV2ZW50cy1ub25lIGFic29sdXRlIHRvcC0wIGxlZnQtMyBtYi0wIG1heC13LVs5MCVdIG9yaWdpbi1bMF8wXSB0cnVuY2F0ZSBwdC1bMC4zN3JlbV0gbGVhZGluZy1bMS42XSB0ZXh0LWdyYXktNTAwIHRyYW5zaXRpb24tYWxsIGR1cmF0aW9uLTIwMCBlYXNlLW91dCBwZWVyLWZvY3VzOi10cmFuc2xhdGUteS1bMC45cmVtXSBwZWVyLWZvY3VzOnNjYWxlLVswLjhdIHBlZXItZm9jdXM6dGV4dC1wcmltYXJ5IHBlZXItZGF0YS1bdGUtaW5wdXQtc3RhdGUtYWN0aXZlXTotdHJhbnNsYXRlLXktWzAuOXJlbV0gcGVlci1kYXRhLVt0ZS1pbnB1dC1zdGF0ZS1hY3RpdmVdOnNjYWxlLVswLjhdIG1vdGlvbi1yZWR1Y2U6dHJhbnNpdGlvbi1ub25lIGRhcms6dGV4dC1ncmF5LTIwMCBkYXJrOnBlZXItZm9jdXM6dGV4dC1ncmF5LTIwMFwiXG59LCBGYiA9IHtcbiAgb3BhY2l0eTogXCJzdHJpbmdcIixcbiAgaW5wdXRXcmFwcGVyUGFkZGluZzogXCJzdHJpbmdcIixcbiAgdHJhbnNpdGlvbjogXCJzdHJpbmdcIixcbiAgY29udGVudEVkaXRhYmxlOiBcInN0cmluZ1wiLFxuICBjaGlwc0lucHV0V3JhcHBlcjogXCJzdHJpbmdcIixcbiAgY2hpcHNJbnB1dDogXCJzdHJpbmdcIixcbiAgY2hpcHNMYWJlbDogXCJzdHJpbmdcIlxufTtcbmNsYXNzIEdDIGV4dGVuZHMgX2kge1xuICBjb25zdHJ1Y3RvcihlLCBpID0ge30sIG4pIHtcbiAgICBzdXBlcihlLCBpKTtcbiAgICB5dCh0aGlzLCBcIl9oYW5kbGVCbHVySW5wdXRcIiwgKHsgdGFyZ2V0OiBlIH0pID0+IHtcbiAgICAgIGUudmFsdWUubGVuZ3RoID4gMCAmJiB0aGlzLl9oYW5kbGVDcmVhdGVDaGlwKGUsIGUudmFsdWUpLCB0aGlzLmFsbENoaXBzLmxlbmd0aCA+IDAgPyAoZS5zZXRBdHRyaWJ1dGUobXQsIFwiXCIpLCB0aGlzLmlucHV0LnNldEF0dHJpYnV0ZShTZSwgXCJcIiksIGQuZmluZE9uZShcbiAgICAgICAgaG8sXG4gICAgICAgIHRoaXMuaW5wdXQucGFyZW50Tm9kZVxuICAgICAgKS5zZXRBdHRyaWJ1dGUoU2UsIFwiXCIpLCB0aGlzLmNoaXBzSW5wdXRXcmFwcGVyLmNsYXNzTGlzdC5hZGQoXG4gICAgICAgIC4uLnRoaXMuX2NsYXNzZXMuaW5wdXRXcmFwcGVyUGFkZGluZy5zcGxpdChcIiBcIilcbiAgICAgICkpIDogKGUucmVtb3ZlQXR0cmlidXRlKG10KSwgdGhpcy5pbnB1dC5yZW1vdmVBdHRyaWJ1dGUoU2UpLCBkLmZpbmRPbmUoXG4gICAgICAgIGhvLFxuICAgICAgICB0aGlzLmlucHV0LnBhcmVudE5vZGVcbiAgICAgICkucmVtb3ZlQXR0cmlidXRlKFNlKSwgdGhpcy5jaGlwc0lucHV0V3JhcHBlci5jbGFzc0xpc3QucmVtb3ZlKFxuICAgICAgICAuLi50aGlzLl9jbGFzc2VzLmlucHV0V3JhcHBlclBhZGRpbmcuc3BsaXQoXCIgXCIpXG4gICAgICApKSwgdGhpcy5hbGxDaGlwcy5mb3JFYWNoKChpKSA9PiBpLnJlbW92ZUF0dHJpYnV0ZShtdCkpO1xuICAgIH0pO1xuICAgIHRoaXMuX2VsZW1lbnQgPSBlLCB0aGlzLl9pbnB1dEluc3RhbmNlID0gbnVsbCwgdGhpcy5fZWxlbWVudCAmJiB5LnNldERhdGEoZSwgZmwsIHRoaXMpLCB0aGlzLl9vcHRpb25zID0gdGhpcy5fZ2V0Q29uZmlnKGkpLCB0aGlzLl9jbGFzc2VzID0gdGhpcy5fZ2V0Q2xhc3NlcyhuKSwgdGhpcy5udW1iZXJDbGlja3MgPSAwLCB0aGlzLmluaXQoKTtcbiAgfVxuICAvLyBHZXR0ZXJzXG4gIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICByZXR1cm4gTGk7XG4gIH1cbiAgZ2V0IGFjdGl2ZUNoaXAoKSB7XG4gICAgcmV0dXJuIGQuZmluZE9uZShrYiwgdGhpcy5fZWxlbWVudCk7XG4gIH1cbiAgZ2V0IGlucHV0KCkge1xuICAgIHJldHVybiBkLmZpbmRPbmUoXCJpbnB1dFwiLCB0aGlzLl9lbGVtZW50KTtcbiAgfVxuICBnZXQgYWxsQ2hpcHMoKSB7XG4gICAgcmV0dXJuIGQuZmluZChGbywgdGhpcy5fZWxlbWVudCk7XG4gIH1cbiAgZ2V0IGNoaXBzSW5wdXRXcmFwcGVyKCkge1xuICAgIHJldHVybiBkLmZpbmRPbmUoeGIsIHRoaXMuX2VsZW1lbnQpO1xuICB9XG4gIC8vIFB1YmxpY1xuICBpbml0KCkge1xuICAgIHRoaXMuX3NldENoaXBzQ2xhc3MoKSwgdGhpcy5fYXBwZW5kSW5wdXRUb0VsZW1lbnQoYWgpLCB0aGlzLl9oYW5kbGVJbml0aWFsVmFsdWUoKSwgdGhpcy5faGFuZGxlSW5wdXRUZXh0KCksIHRoaXMuX2hhbmRsZUtleWJvYXJkKCksIHRoaXMuX2hhbmRsZUNoaXBzT25TZWxlY3QoKSwgdGhpcy5faGFuZGxlRWRpdGFibGUoKSwgdGhpcy5faGFuZGxlQ2hpcHNGb2N1cygpLCB0aGlzLl9oYW5kbGVDbGlja3NPbkNoaXBzKCksIHRoaXMuX2lucHV0SW5zdGFuY2UuX2dldExhYmVsV2lkdGgoKSwgdGhpcy5faW5wdXRJbnN0YW5jZS5fYXBwbHlOb3RjaCgpO1xuICB9XG4gIGRpc3Bvc2UoKSB7XG4gICAgdGhpcy5fZWxlbWVudCA9IG51bGwsIHRoaXMuX29wdGlvbnMgPSBudWxsO1xuICB9XG4gIC8vIFByaXZhdGVcbiAgX2dldE5vdGNoRGF0YSgpIHtcbiAgICB0aGlzLl9ub3RjaE1pZGRsZSA9IGQuZmluZE9uZShcbiAgICAgIExiLFxuICAgICAgdGhpcy5fZWxlbWVudFxuICAgICksIHRoaXMuX25vdGNoTGVhZGluZyA9IGQuZmluZE9uZShcbiAgICAgICRiLFxuICAgICAgdGhpcy5fZWxlbWVudFxuICAgICk7XG4gIH1cbiAgX3NldENoaXBzQ2xhc3MoKSB7XG4gICAgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoQWIsIFwiXCIpO1xuICB9XG4gIF9oYW5kbGVEZWxldGVFdmVudHMoZSkge1xuICAgIGNvbnN0IFtpXSA9IHRoaXMuYWxsQ2hpcHMuc2xpY2UoLTEpO1xuICAgIGlmICh0aGlzLmFjdGl2ZUNoaXAgPT09IG51bGwpXG4gICAgICBpLnJlbW92ZSgpLCB0aGlzLl9oYW5kbGVFdmVudHMoZSwgZ2wpO1xuICAgIGVsc2Uge1xuICAgICAgY29uc3QgbiA9IHRoaXMuYWxsQ2hpcHMuZmluZEluZGV4KChhKSA9PiBhID09PSB0aGlzLmFjdGl2ZUNoaXApLCBvID0gdGhpcy5faGFuZGxlQWN0aXZlQ2hpcEFmdGVyUmVtb3ZlKG4pLCByID0gW107XG4gICAgICBpZiAodGhpcy5hY3RpdmVDaGlwID09PSBudWxsKVxuICAgICAgICByZXR1cm47XG4gICAgICB0aGlzLmFjdGl2ZUNoaXAucmVtb3ZlKCksIHRoaXMuX2hhbmRsZUV2ZW50cyhlLCBnbCksIHRoaXMubnVtYmVyQ2xpY2tzID0gbiwgby5zZXRBdHRyaWJ1dGUobXQsIFwiXCIpLCB0aGlzLmFsbENoaXBzLmZvckVhY2goKGEpID0+IHtcbiAgICAgICAgYS5oYXNBdHRyaWJ1dGUobXQpICYmIChyLnB1c2goYSksIHIubGVuZ3RoID4gMSAmJiB0aGlzLmFsbENoaXBzLmZvckVhY2goKGwpID0+IGwucmVtb3ZlKCkpKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBfaGFuZGxlVXBFdmVudHMoZSkge1xuICAgIHRoaXMubnVtYmVyQ2xpY2tzICs9IDEsIHRoaXMubnVtYmVyQ2xpY2tzID09PSB0aGlzLmFsbENoaXBzLmxlbmd0aCArIDEgJiYgKHRoaXMubnVtYmVyQ2xpY2tzID0gMCksIHRoaXMuX2hhbmRsZVJpZ2h0S2V5Ym9hcmRBcnJvdyh0aGlzLm51bWJlckNsaWNrcyksIHRoaXMuX2hhbmRsZUV2ZW50cyhlLCBQYiksIHRoaXMuX2hhbmRsZUV2ZW50cyhlLCBCYik7XG4gIH1cbiAgX2hhbmRsZURvd25FdmVudHMoZSkge1xuICAgIHRoaXMubnVtYmVyQ2xpY2tzIC09IDEsIHRoaXMubnVtYmVyQ2xpY2tzIDw9IDAgJiYgKHRoaXMubnVtYmVyQ2xpY2tzID0gdGhpcy5hbGxDaGlwcy5sZW5ndGgpLCB0aGlzLl9oYW5kbGVMZWZ0S2V5Ym9hcmRBcnJvdyh0aGlzLm51bWJlckNsaWNrcyksIHRoaXMuX2hhbmRsZUV2ZW50cyhlLCBSYiksIHRoaXMuX2hhbmRsZUV2ZW50cyhlLCBNYik7XG4gIH1cbiAgX2tleWJvYXJkRXZlbnRzKGUpIHtcbiAgICBjb25zdCB7IHRhcmdldDogaSwga2V5Q29kZTogbiwgY3RybEtleTogbyB9ID0gZTtcbiAgICBpLnZhbHVlLmxlbmd0aCA+IDAgfHwgdGhpcy5hbGxDaGlwcy5sZW5ndGggPT09IDAgfHwgKG4gPT09IE5mIHx8IG4gPT09IE1mID8gdGhpcy5faGFuZGxlRGVsZXRlRXZlbnRzKGUpIDogbiA9PT0gVmUgfHwgbiA9PT0gYXQgPyB0aGlzLl9oYW5kbGVVcEV2ZW50cyhlKSA6IG4gPT09IEhlIHx8IG4gPT09IHogPyB0aGlzLl9oYW5kbGVEb3duRXZlbnRzKGUpIDogbiA9PT0gNjUgJiYgbyAmJiB0aGlzLl9oYW5kbGVBZGRBY3RpdmVDbGFzcygpKTtcbiAgfVxuICBfaGFuZGxlS2V5Ym9hcmQoKSB7XG4gICAgYy5vbihcbiAgICAgIHRoaXMuaW5wdXQsXG4gICAgICBcImtleWRvd25cIixcbiAgICAgIChlKSA9PiB0aGlzLl9rZXlib2FyZEV2ZW50cyhlKVxuICAgICk7XG4gIH1cbiAgX2hhbmRsZUVkaXRhYmxlKCkge1xuICAgIGNvbnN0IHsgZWRpdGFibGU6IGUgfSA9IHRoaXMuX29wdGlvbnM7XG4gICAgZSAmJiB0aGlzLmFsbENoaXBzLmZvckVhY2goKGkpID0+IHtcbiAgICAgIGMub24oaSwgXCJkYmxjbGlja1wiLCAobikgPT4ge1xuICAgICAgICBjb25zdCBvID0gZC5maW5kT25lKGNvLCBpKTtcbiAgICAgICAgaS5jbGFzc0xpc3QuYWRkKC4uLnRoaXMuX2NsYXNzZXMuY29udGVudEVkaXRhYmxlLnNwbGl0KFwiIFwiKSksIGkuY29udGVudEVkaXRhYmxlID0gITAsIGkuZm9jdXMoKSwgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgaC5hZGRTdHlsZShvLCB7IGRpc3BsYXk6IFwibm9uZVwiIH0pO1xuICAgICAgICB9LCAyMDApLCBvLmNsYXNzTGlzdC5hZGQoLi4udGhpcy5fY2xhc3Nlcy5vcGFjaXR5LnNwbGl0KFwiIFwiKSksIG4udGFyZ2V0LnRleHRDb250ZW50LCBjLnRyaWdnZXIoaSwgYmwsIHtcbiAgICAgICAgICBldmVudDogbixcbiAgICAgICAgICBhbGxDaGlwczogdGhpcy5hbGxDaGlwc1xuICAgICAgICB9KTtcbiAgICAgIH0pLCBjLm9uKGRvY3VtZW50LCBcImNsaWNrXCIsICh7IHRhcmdldDogbiB9KSA9PiB7XG4gICAgICAgIGNvbnN0IG8gPSBkLmZpbmRPbmUoY28sIGkpLCByID0gZC5maW5kT25lKE9iLCBpKSwgYSA9IG4gPT09IGksIGwgPSBpICYmIGkuY29udGFpbnMobik7XG4gICAgICAgICFhICYmICFsICYmIChpLmNvbnRlbnRFZGl0YWJsZSA9ICExLCBpLmNsYXNzTGlzdC5yZW1vdmUoLi4udGhpcy5fY2xhc3Nlcy5jb250ZW50RWRpdGFibGUuc3BsaXQoXCIgXCIpKSwgci50ZXh0Q29udGVudCAhPT0gXCJcIiAmJiBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBoLmFkZFN0eWxlKG8sIHsgZGlzcGxheTogXCJibG9ja1wiIH0pLCBvLmNsYXNzTGlzdC5yZW1vdmUoLi4udGhpcy5fY2xhc3Nlcy5vcGFjaXR5LnNwbGl0KFwiIFwiKSk7XG4gICAgICAgIH0sIDE2MCkpLCByLnRleHRDb250ZW50ID09PSBcIlwiICYmIChzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBpLmNsYXNzTGlzdC5hZGQoLi4udGhpcy5fY2xhc3Nlcy5vcGFjaXR5LnNwbGl0KFwiIFwiKSk7XG4gICAgICAgIH0sIDIwMCksIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIGkucmVtb3ZlKCk7XG4gICAgICAgIH0sIDMwMCkpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgX2hhbmRsZVJlbW92ZUFjdGl2ZUNsYXNzKCkge1xuICAgIHRoaXMuYWxsQ2hpcHMuZm9yRWFjaCgoZSkgPT4gZS5yZW1vdmVBdHRyaWJ1dGUobXQpKTtcbiAgfVxuICBfaGFuZGxlQWRkQWN0aXZlQ2xhc3MoKSB7XG4gICAgdGhpcy5hbGxDaGlwcy5mb3JFYWNoKChlKSA9PiBlLnNldEF0dHJpYnV0ZShtdCwgXCJcIikpO1xuICB9XG4gIF9oYW5kbGVSaWdodEtleWJvYXJkQXJyb3coZSkge1xuICAgIHRoaXMuX2hhbmRsZVJlbW92ZUFjdGl2ZUNsYXNzKCksIGUgPT09IDAgJiYgKGUgPSAxKSwgdGhpcy5faGFuZGxlQWRkQWN0aXZlQ2xhc3NXaXRoS2VieWJvYXJkKGUpO1xuICB9XG4gIF9oYW5kbGVMZWZ0S2V5Ym9hcmRBcnJvdyhlKSB7XG4gICAgdGhpcy5faGFuZGxlUmVtb3ZlQWN0aXZlQ2xhc3MoKSwgdGhpcy5faGFuZGxlQWRkQWN0aXZlQ2xhc3NXaXRoS2VieWJvYXJkKGUpO1xuICB9XG4gIF9oYW5kbGVBY3RpdmVDaGlwQWZ0ZXJSZW1vdmUoZSkge1xuICAgIGNvbnN0IGkgPSBlID09PSAwID8gMSA6IGUgLSAxO1xuICAgIHJldHVybiB0aGlzLmFsbENoaXBzW2ldO1xuICB9XG4gIF9oYW5kbGVDbGlja3NPbkNoaXBzKCkge1xuICAgIGMub24odGhpcy5fZWxlbWVudCwgXCJjbGlja1wiLCAoKSA9PiB7XG4gICAgICB0aGlzLmFsbENoaXBzLmxlbmd0aCA9PT0gMCAmJiAodGhpcy5jaGlwc0lucHV0V3JhcHBlci5jbGFzc0xpc3QucmVtb3ZlKFxuICAgICAgICAuLi50aGlzLl9jbGFzc2VzLmlucHV0V3JhcHBlclBhZGRpbmcuc3BsaXQoXCIgXCIpXG4gICAgICApLCB0aGlzLmlucHV0LnJlbW92ZUF0dHJpYnV0ZShtdCkpO1xuICAgIH0pO1xuICB9XG4gIF9oYW5kbGVUZXh0Q29udGVudCgpIHtcbiAgICBjb25zdCBlID0gW107XG4gICAgcmV0dXJuIHRoaXMuYWxsQ2hpcHMuZm9yRWFjaCgoaSkgPT4gZS5wdXNoKHsgdGFnOiBpLnRleHRDb250ZW50LnRyaW0oKSB9KSksIGU7XG4gIH1cbiAgX2hhbmRsZUV2ZW50cyhlLCBpKSB7XG4gICAgY29uc3QgbiA9IHRoaXMuX2hhbmRsZVRleHRDb250ZW50KCksIG8gPSB0aGlzLmFsbENoaXBzLmZpbHRlcihcbiAgICAgIChyKSA9PiByLmhhc0F0dHJpYnV0ZShtdCkgJiYgclxuICAgICk7XG4gICAgYy50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIGksIHtcbiAgICAgIGV2ZW50OiBlLFxuICAgICAgYWxsQ2hpcHM6IHRoaXMuYWxsQ2hpcHMsXG4gICAgICBhcnJPZk9iamVjdHM6IG4sXG4gICAgICBhY3RpdmU6IG8sXG4gICAgICBhY3RpdmVPYmo6IHtcbiAgICAgICAgdGFnOiBvLmxlbmd0aCA8PSAwID8gXCJcIiA6IG9bMF0udGV4dENvbnRlbnQudHJpbSgpXG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgX2hhbmRsZUNoaXBzRm9jdXMoKSB7XG4gICAgYy5vbih0aGlzLl9lbGVtZW50LCBcImNsaWNrXCIsICh7IHRhcmdldDogeyBhdHRyaWJ1dGVzOiBlIH0gfSkgPT4ge1xuICAgICAgY29uc3QgaSA9IFsuLi5lXTtcbiAgICAgIGkuaW5jbHVkZXMoV28pIHx8IGkuaW5jbHVkZXMobGgpIHx8IGkuaW5jbHVkZXMoY2gpIHx8IHRoaXMuaW5wdXQuZm9jdXMoKTtcbiAgICB9KTtcbiAgfVxuICBfaGFuZGxlSW5pdGlhbFZhbHVlKCkge1xuICAgIGlmICh0aGlzLl9hcHBlbmRJbnB1dFRvRWxlbWVudChtbCksIHRoaXMuX2VsZW1lbnQuaGFzQXR0cmlidXRlKG1sKSkge1xuICAgICAgY29uc3QgeyBpbml0aWFsVmFsdWVzOiBlIH0gPSB0aGlzLl9vcHRpb25zO1xuICAgICAgZS5mb3JFYWNoKFxuICAgICAgICAoeyB0YWc6IGkgfSkgPT4gdGhpcy5faGFuZGxlQ3JlYXRlQ2hpcCh0aGlzLmlucHV0LCBpKVxuICAgICAgKSwgZC5maW5kT25lKFxuICAgICAgICBobyxcbiAgICAgICAgdGhpcy5pbnB1dC5wYXJlbnROb2RlXG4gICAgICApLnNldEF0dHJpYnV0ZShTZSwgXCJcIiksIHRoaXMuaW5wdXQuc2V0QXR0cmlidXRlKG10LCBcIlwiKSwgdGhpcy5pbnB1dC5zZXRBdHRyaWJ1dGUoU2UsIFwiXCIpO1xuICAgIH1cbiAgICB0aGlzLmFsbENoaXBzLmxlbmd0aCA+IDAgJiYgKHRoaXMuY2hpcHNJbnB1dFdyYXBwZXIuY2xhc3NMaXN0LmFkZChcbiAgICAgIC4uLnRoaXMuX2NsYXNzZXMuaW5wdXRXcmFwcGVyUGFkZGluZy5zcGxpdChcIiBcIilcbiAgICApLCB0aGlzLmNoaXBzSW5wdXRXcmFwcGVyLmNsYXNzTGlzdC5hZGQoXG4gICAgICAuLi50aGlzLl9jbGFzc2VzLnRyYW5zaXRpb24uc3BsaXQoXCIgXCIpXG4gICAgKSk7XG4gIH1cbiAgX2hhbmRsZUtleXNJbnB1dFRvRWxlbWVudChlKSB7XG4gICAgY29uc3QgeyBrZXlDb2RlOiBpLCB0YXJnZXQ6IG4gfSA9IGU7XG4gICAgaWYgKG4uaGFzQXR0cmlidXRlKFdvKSkge1xuICAgICAgY29uc3QgbyA9IGQuZmluZE9uZShjbywgbik7XG4gICAgICBpID09PSBjdCAmJiAobi5jb250ZW50RWRpdGFibGUgPSAhMSwgbi5jbGFzc0xpc3QucmVtb3ZlKC4uLnRoaXMuX2NsYXNzZXMuY29udGVudEVkaXRhYmxlLnNwbGl0KFwiIFwiKSksIG4udGV4dENvbnRlbnQgIT09IFwiXCIgPyBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgaC5hZGRTdHlsZShvLCB7IGRpc3BsYXk6IFwiYmxvY2tcIiB9KSwgby5jbGFzc0xpc3QucmVtb3ZlKC4uLnRoaXMuX2NsYXNzZXMub3BhY2l0eS5zcGxpdChcIiBcIikpO1xuICAgICAgfSwgMTYwKSA6IG4udGV4dENvbnRlbnQgPT09IFwiXCIgJiYgKHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBuLmNsYXNzTGlzdC5hZGQoLi4udGhpcy5fY2xhc3Nlcy5vcGFjaXR5LnNwbGl0KFwiIFwiKSk7XG4gICAgICB9LCAyMDApLCBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgbi5yZW1vdmUoKTtcbiAgICAgIH0sIDMwMCkpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGkgPT09IGN0KSB7XG4gICAgICBpZiAobi52YWx1ZSA9PT0gXCJcIilcbiAgICAgICAgcmV0dXJuO1xuICAgICAgdGhpcy5faGFuZGxlQ3JlYXRlQ2hpcChuLCBuLnZhbHVlKSwgdGhpcy5faGFuZGxlUmVtb3ZlQWN0aXZlQ2xhc3MoKSwgdGhpcy5udW1iZXJDbGlja3MgPSB0aGlzLmFsbENoaXBzLmxlbmd0aCArIDEsIHRoaXMuX2hhbmRsZUV2ZW50cyhlLCBOYik7XG4gICAgfVxuICAgIHRoaXMuYWxsQ2hpcHMubGVuZ3RoID4gMCA/ICh0aGlzLmNoaXBzSW5wdXRXcmFwcGVyLmNsYXNzTGlzdC5hZGQoXG4gICAgICAuLi50aGlzLl9jbGFzc2VzLmlucHV0V3JhcHBlclBhZGRpbmcuc3BsaXQoXCIgXCIpXG4gICAgKSwgdGhpcy5jaGlwc0lucHV0V3JhcHBlci5jbGFzc0xpc3QuYWRkKFxuICAgICAgLi4udGhpcy5fY2xhc3Nlcy50cmFuc2l0aW9uLnNwbGl0KFwiIFwiKVxuICAgICkpIDogdGhpcy5jaGlwc0lucHV0V3JhcHBlci5jbGFzc0xpc3QucmVtb3ZlKFxuICAgICAgLi4udGhpcy5fY2xhc3Nlcy5pbnB1dFdyYXBwZXJQYWRkaW5nLnNwbGl0KFwiIFwiKVxuICAgICk7XG4gIH1cbiAgX2hhbmRsZUlucHV0VGV4dCgpIHtcbiAgICBjb25zdCBlID0gZC5maW5kT25lKFxuICAgICAgU2IsXG4gICAgICB0aGlzLl9lbGVtZW50XG4gICAgKTtcbiAgICBjLm9uKFxuICAgICAgdGhpcy5fZWxlbWVudCxcbiAgICAgIFwia2V5dXBcIixcbiAgICAgIGUsXG4gICAgICAoaSkgPT4gdGhpcy5faGFuZGxlS2V5c0lucHV0VG9FbGVtZW50KGkpXG4gICAgKSwgYy5vbih0aGlzLmlucHV0LCBcImJsdXJcIiwgKGkpID0+IHRoaXMuX2hhbmRsZUJsdXJJbnB1dChpKSk7XG4gIH1cbiAgX2FwcGVuZElucHV0VG9FbGVtZW50KGUpIHtcbiAgICBpZiAoIXRoaXMuX2VsZW1lbnQuaGFzQXR0cmlidXRlKGUpKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGkgPSBwYih0aGlzLl9vcHRpb25zLCB0aGlzLl9jbGFzc2VzKTtcbiAgICB0aGlzLl9lbGVtZW50Lmluc2VydEFkamFjZW50SFRNTChcImJlZm9yZWVuZFwiLCBpKTtcbiAgICBjb25zdCBuID0gZC5maW5kT25lKFxuICAgICAgXCJbZGF0YS10ZS1jaGlwcy1pbnB1dC13cmFwcGVyXVwiLFxuICAgICAgdGhpcy5fZWxlbWVudFxuICAgICk7XG4gICAgdGhpcy5faW5wdXRJbnN0YW5jZSA9IG5ldyBWKFxuICAgICAgbixcbiAgICAgIHRoaXMuX29wdGlvbnMuaW5wdXRPcHRpb25zLFxuICAgICAgdGhpcy5fb3B0aW9ucy5pbnB1dENsYXNzZXNcbiAgICApO1xuICB9XG4gIF9oYW5kbGVDcmVhdGVDaGlwKGUsIGkpIHtcbiAgICBjb25zdCBuID0gJChcImRpdlwiKSwgbyA9IF9pLmdldEluc3RhbmNlKG4pLCByID0gbmV3IF9pKG8sIHsgdGV4dDogaSB9LCB0aGlzLl9jbGFzc2VzKTtcbiAgICB0aGlzLl9vcHRpb25zLnBhcmVudFNlbGVjdG9yICE9PSBcIlwiID8gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0aGlzLl9vcHRpb25zLnBhcmVudFNlbGVjdG9yKS5pbnNlcnRBZGphY2VudEhUTUwoXCJiZWZvcmVlbmRcIiwgci5hcHBlbmRDaGlwKCkpIDogZS5pbnNlcnRBZGphY2VudEhUTUwoXCJiZWZvcmViZWdpblwiLCByLmFwcGVuZENoaXAoKSksIGUudmFsdWUgPSBcIlwiLCBkLmZpbmQoRm8pLmZvckVhY2goKGEpID0+IHtcbiAgICAgIGxldCBsID0gX2kuZ2V0SW5zdGFuY2UoYSk7XG4gICAgICByZXR1cm4gbCB8fCAobCA9IG5ldyBfaShhLCB7fSwgdGhpcy5fY2xhc3NlcykpLCBsLmluaXQoKTtcbiAgICB9KSwgdGhpcy5faGFuZGxlRWRpdGFibGUoKTtcbiAgfVxuICBfaGFuZGxlQ2hpcHNPblNlbGVjdCgpIHtcbiAgICB0aGlzLmFsbENoaXBzLmZvckVhY2goKGUpID0+IHtcbiAgICAgIGMub24odGhpcy5fZWxlbWVudCwgXCJjbGlja1wiLCAoaSkgPT4ge1xuICAgICAgICBjLnRyaWdnZXIoZSwgYmwsIHtcbiAgICAgICAgICBldmVudDogaSxcbiAgICAgICAgICBhbGxDaGlwczogdGhpcy5hbGxDaGlwc1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIF9oYW5kbGVBZGRBY3RpdmVDbGFzc1dpdGhLZWJ5Ym9hcmQoZSkge1xuICAgIGxldCBpO1xuICAgIHRoaXMuYWxsQ2hpcHNbZSAtIDFdID09PSB2b2lkIDAgPyBpID0gdGhpcy5hbGxDaGlwc1tlIC0gMl0gOiBpID0gdGhpcy5hbGxDaGlwc1tlIC0gMV0sIGkuc2V0QXR0cmlidXRlKG10KTtcbiAgfVxuICBfZ2V0Q29uZmlnKGUpIHtcbiAgICBjb25zdCBpID0ge1xuICAgICAgLi4uVmIsXG4gICAgICAuLi5oLmdldERhdGFBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpLFxuICAgICAgLi4uZVxuICAgIH07XG4gICAgcmV0dXJuIEQoTGksIGksIEhiKSwgaTtcbiAgfVxuICBfZ2V0Q2xhc3NlcyhlKSB7XG4gICAgY29uc3QgaSA9IGguZ2V0RGF0YUNsYXNzQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KTtcbiAgICByZXR1cm4gZSA9IHtcbiAgICAgIC4uLldiLFxuICAgICAgLi4uaSxcbiAgICAgIC4uLmVcbiAgICB9LCBEKExpLCBlLCBGYiksIGU7XG4gIH1cbiAgc3RhdGljIGdldEluc3RhbmNlKGUpIHtcbiAgICByZXR1cm4geS5nZXREYXRhKGUsIGZsKTtcbiAgfVxuICBzdGF0aWMgZ2V0T3JDcmVhdGVJbnN0YW5jZShlLCBpID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5nZXRJbnN0YW5jZShlKSB8fCBuZXcgdGhpcyhlLCB0eXBlb2YgaSA9PSBcIm9iamVjdFwiID8gaSA6IG51bGwpO1xuICB9XG59XG5jb25zdCB6dCA9IHtcbiAgcGx1Z2luczoge1xuICAgIGxlZ2VuZDoge1xuICAgICAgbGFiZWxzOiB7XG4gICAgICAgIGNvbG9yOiBcInJnYigxMDIsMTAyLDEwMilcIlxuICAgICAgfVxuICAgIH1cbiAgfVxufSwgVGkgPSB7XG4gIGxpbmU6IHtcbiAgICBvcHRpb25zOiB7XG4gICAgICAuLi56dCxcbiAgICAgIGVsZW1lbnRzOiB7XG4gICAgICAgIGxpbmU6IHtcbiAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwicmdiYSg1OSwgMTEyLCAyMDIsIDAuMClcIixcbiAgICAgICAgICBib3JkZXJDb2xvcjogXCJyZ2IoNTksIDExMiwgMjAyKVwiLFxuICAgICAgICAgIGJvcmRlcldpZHRoOiAyLFxuICAgICAgICAgIHRlbnNpb246IDBcbiAgICAgICAgfSxcbiAgICAgICAgcG9pbnQ6IHtcbiAgICAgICAgICBib3JkZXJDb2xvcjogXCJyZ2IoNTksIDExMiwgMjAyKVwiLFxuICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogXCJyZ2IoNTksIDExMiwgMjAyKVwiXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICByZXNwb25zaXZlOiAhMCxcbiAgICAgIGxlZ2VuZDoge1xuICAgICAgICBkaXNwbGF5OiAhMFxuICAgICAgfSxcbiAgICAgIHRvb2x0aXBzOiB7XG4gICAgICAgIGludGVyc2VjdDogITEsXG4gICAgICAgIG1vZGU6IFwiaW5kZXhcIlxuICAgICAgfSxcbiAgICAgIGRhdGFzZXRzOiB7XG4gICAgICAgIGJvcmRlckNvbG9yOiBcInJlZFwiXG4gICAgICB9LFxuICAgICAgc2NhbGVzOiB7XG4gICAgICAgIHg6IHtcbiAgICAgICAgICBzdGFja2VkOiAhMCxcbiAgICAgICAgICBncmlkOiB7XG4gICAgICAgICAgICBkaXNwbGF5OiAhMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgdGlja3M6IHtcbiAgICAgICAgICAgIGZvbnRDb2xvcjogXCJyZ2JhKDAsMCwwLCAwLjUpXCJcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHk6IHtcbiAgICAgICAgICBzdGFja2VkOiAhMSxcbiAgICAgICAgICBncmlkOiB7XG4gICAgICAgICAgICBib3JkZXJEYXNoOiBbMl0sXG4gICAgICAgICAgICBkcmF3Qm9yZGVyOiAhMSxcbiAgICAgICAgICAgIHplcm9MaW5lQ29sb3I6IFwicmdiYSgwLDAsMCwwKVwiLFxuICAgICAgICAgICAgemVyb0xpbmVCb3JkZXJEYXNoOiBbMl0sXG4gICAgICAgICAgICB6ZXJvTGluZUJvcmRlckRhc2hPZmZzZXQ6IFsyXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgdGlja3M6IHtcbiAgICAgICAgICAgIGZvbnRDb2xvcjogXCJyZ2JhKDAsMCwwLCAwLjUpXCJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGJhcjoge1xuICAgIG9wdGlvbnM6IHtcbiAgICAgIC4uLnp0LFxuICAgICAgYmFja2dyb3VuZENvbG9yOiBcInJnYig1OSwgMTEyLCAyMDIpXCIsXG4gICAgICBib3JkZXJXaWR0aDogMCxcbiAgICAgIHJlc3BvbnNpdmU6ICEwLFxuICAgICAgbGVnZW5kOiB7XG4gICAgICAgIGRpc3BsYXk6ICEwXG4gICAgICB9LFxuICAgICAgdG9vbHRpcHM6IHtcbiAgICAgICAgaW50ZXJzZWN0OiAhMSxcbiAgICAgICAgbW9kZTogXCJpbmRleFwiXG4gICAgICB9LFxuICAgICAgc2NhbGVzOiB7XG4gICAgICAgIHg6IHtcbiAgICAgICAgICBzdGFja2VkOiAhMCxcbiAgICAgICAgICBncmlkOiB7XG4gICAgICAgICAgICBkaXNwbGF5OiAhMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgdGlja3M6IHtcbiAgICAgICAgICAgIGZvbnRDb2xvcjogXCJyZ2JhKDAsMCwwLCAwLjUpXCJcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHk6IHtcbiAgICAgICAgICBzdGFja2VkOiAhMCxcbiAgICAgICAgICBncmlkOiB7XG4gICAgICAgICAgICBib3JkZXJEYXNoOiBbMl0sXG4gICAgICAgICAgICBkcmF3Qm9yZGVyOiAhMSxcbiAgICAgICAgICAgIHplcm9MaW5lQ29sb3I6IFwicmdiYSgwLDAsMCwwKVwiLFxuICAgICAgICAgICAgemVyb0xpbmVCb3JkZXJEYXNoOiBbMl0sXG4gICAgICAgICAgICB6ZXJvTGluZUJvcmRlckRhc2hPZmZzZXQ6IFsyXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgdGlja3M6IHtcbiAgICAgICAgICAgIGZvbnRDb2xvcjogXCJyZ2JhKDAsMCwwLCAwLjUpXCJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIHBpZToge1xuICAgIG9wdGlvbnM6IHtcbiAgICAgIC4uLnp0LFxuICAgICAgZWxlbWVudHM6IHtcbiAgICAgICAgYXJjOiB7IGJhY2tncm91bmRDb2xvcjogXCJyZ2IoNTksIDExMiwgMjAyKVwiIH1cbiAgICAgIH0sXG4gICAgICByZXNwb25zaXZlOiAhMCxcbiAgICAgIGxlZ2VuZDoge1xuICAgICAgICBkaXNwbGF5OiAhMFxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgZG91Z2hudXQ6IHtcbiAgICBvcHRpb25zOiB7XG4gICAgICAuLi56dCxcbiAgICAgIGVsZW1lbnRzOiB7XG4gICAgICAgIGFyYzogeyBiYWNrZ3JvdW5kQ29sb3I6IFwicmdiKDU5LCAxMTIsIDIwMilcIiB9XG4gICAgICB9LFxuICAgICAgcmVzcG9uc2l2ZTogITAsXG4gICAgICBsZWdlbmQ6IHtcbiAgICAgICAgZGlzcGxheTogITBcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIHBvbGFyQXJlYToge1xuICAgIG9wdGlvbnM6IHtcbiAgICAgIC4uLnp0LFxuICAgICAgZWxlbWVudHM6IHtcbiAgICAgICAgYXJjOiB7IGJhY2tncm91bmRDb2xvcjogXCJyZ2JhKDU5LCAxMTIsIDIwMiwgMC41KVwiIH1cbiAgICAgIH0sXG4gICAgICByZXNwb25zaXZlOiAhMCxcbiAgICAgIGxlZ2VuZDoge1xuICAgICAgICBkaXNwbGF5OiAhMFxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgcmFkYXI6IHtcbiAgICBvcHRpb25zOiB7XG4gICAgICAuLi56dCxcbiAgICAgIGVsZW1lbnRzOiB7XG4gICAgICAgIGxpbmU6IHtcbiAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwicmdiYSg1OSwgMTEyLCAyMDIsIDAuNSlcIixcbiAgICAgICAgICBib3JkZXJDb2xvcjogXCJyZ2IoNTksIDExMiwgMjAyKVwiLFxuICAgICAgICAgIGJvcmRlcldpZHRoOiAyXG4gICAgICAgIH0sXG4gICAgICAgIHBvaW50OiB7XG4gICAgICAgICAgYm9yZGVyQ29sb3I6IFwicmdiKDU5LCAxMTIsIDIwMilcIixcbiAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwicmdiKDU5LCAxMTIsIDIwMilcIlxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgcmVzcG9uc2l2ZTogITAsXG4gICAgICBsZWdlbmQ6IHtcbiAgICAgICAgZGlzcGxheTogITBcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIHNjYXR0ZXI6IHtcbiAgICBvcHRpb25zOiB7XG4gICAgICAuLi56dCxcbiAgICAgIGVsZW1lbnRzOiB7XG4gICAgICAgIGxpbmU6IHtcbiAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwicmdiYSg1OSwgMTEyLCAyMDIsIDAuNSlcIixcbiAgICAgICAgICBib3JkZXJDb2xvcjogXCJyZ2IoNTksIDExMiwgMjAyKVwiLFxuICAgICAgICAgIGJvcmRlcldpZHRoOiAyLFxuICAgICAgICAgIHRlbnNpb246IDBcbiAgICAgICAgfSxcbiAgICAgICAgcG9pbnQ6IHtcbiAgICAgICAgICBib3JkZXJDb2xvcjogXCJyZ2IoNTksIDExMiwgMjAyKVwiLFxuICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogXCJyZ2JhKDU5LCAxMTIsIDIwMiwgMC41KVwiXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICByZXNwb25zaXZlOiAhMCxcbiAgICAgIGxlZ2VuZDoge1xuICAgICAgICBkaXNwbGF5OiAhMFxuICAgICAgfSxcbiAgICAgIHRvb2x0aXBzOiB7XG4gICAgICAgIGludGVyc2VjdDogITEsXG4gICAgICAgIG1vZGU6IFwiaW5kZXhcIlxuICAgICAgfSxcbiAgICAgIGRhdGFzZXRzOiB7XG4gICAgICAgIGJvcmRlckNvbG9yOiBcInJlZFwiXG4gICAgICB9LFxuICAgICAgc2NhbGVzOiB7XG4gICAgICAgIHg6IHtcbiAgICAgICAgICBzdGFja2VkOiAhMCxcbiAgICAgICAgICBncmlkOiB7XG4gICAgICAgICAgICBkaXNwbGF5OiAhMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgdGlja3M6IHtcbiAgICAgICAgICAgIGZvbnRDb2xvcjogXCJyZ2JhKDAsMCwwLCAwLjUpXCJcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHk6IHtcbiAgICAgICAgICBzdGFja2VkOiAhMSxcbiAgICAgICAgICBncmlkOiB7XG4gICAgICAgICAgICBib3JkZXJEYXNoOiBbMl0sXG4gICAgICAgICAgICBkcmF3Qm9yZGVyOiAhMSxcbiAgICAgICAgICAgIHplcm9MaW5lQ29sb3I6IFwicmdiYSgwLDAsMCwwKVwiLFxuICAgICAgICAgICAgemVyb0xpbmVCb3JkZXJEYXNoOiBbMl0sXG4gICAgICAgICAgICB6ZXJvTGluZUJvcmRlckRhc2hPZmZzZXQ6IFsyXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgdGlja3M6IHtcbiAgICAgICAgICAgIGZvbnRDb2xvcjogXCJyZ2JhKDAsMCwwLCAwLjUpXCJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGJ1YmJsZToge1xuICAgIG9wdGlvbnM6IHtcbiAgICAgIC4uLnp0LFxuICAgICAgZWxlbWVudHM6IHtcbiAgICAgICAgcG9pbnQ6IHtcbiAgICAgICAgICBib3JkZXJDb2xvcjogXCJyZ2IoNTksIDExMiwgMjAyKVwiLFxuICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogXCJyZ2JhKDU5LCAxMTIsIDIwMiwgMC41KVwiXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICByZXNwb25zaXZlOiAhMCxcbiAgICAgIGxlZ2VuZDoge1xuICAgICAgICBkaXNwbGF5OiAhMFxuICAgICAgfSxcbiAgICAgIHNjYWxlczoge1xuICAgICAgICB4OiB7XG4gICAgICAgICAgZ3JpZDoge1xuICAgICAgICAgICAgZGlzcGxheTogITFcbiAgICAgICAgICB9LFxuICAgICAgICAgIHRpY2tzOiB7XG4gICAgICAgICAgICBmb250Q29sb3I6IFwicmdiYSgwLDAsMCwgMC41KVwiXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB5OiB7XG4gICAgICAgICAgZ3JpZDoge1xuICAgICAgICAgICAgYm9yZGVyRGFzaDogWzJdLFxuICAgICAgICAgICAgZHJhd0JvcmRlcjogITEsXG4gICAgICAgICAgICB6ZXJvTGluZUNvbG9yOiBcInJnYmEoMCwwLDAsMClcIixcbiAgICAgICAgICAgIHplcm9MaW5lQm9yZGVyRGFzaDogWzJdLFxuICAgICAgICAgICAgemVyb0xpbmVCb3JkZXJEYXNoT2Zmc2V0OiBbMl1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHRpY2tzOiB7XG4gICAgICAgICAgICBmb250Q29sb3I6IFwicmdiYSgwLDAsMCwgMC41KVwiXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xudmFyIFliID0gZnVuY3Rpb24odCkge1xuICByZXR1cm4gamIodCkgJiYgIUtiKHQpO1xufTtcbmZ1bmN0aW9uIGpiKHMpIHtcbiAgcmV0dXJuICEhcyAmJiB0eXBlb2YgcyA9PSBcIm9iamVjdFwiO1xufVxuZnVuY3Rpb24gS2Iocykge1xuICB2YXIgdCA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChzKTtcbiAgcmV0dXJuIHQgPT09IFwiW29iamVjdCBSZWdFeHBdXCIgfHwgdCA9PT0gXCJbb2JqZWN0IERhdGVdXCIgfHwgWGIocyk7XG59XG52YXIgemIgPSB0eXBlb2YgU3ltYm9sID09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuZm9yLCBVYiA9IHpiID8gU3ltYm9sLmZvcihcInJlYWN0LmVsZW1lbnRcIikgOiA2MDEwMztcbmZ1bmN0aW9uIFhiKHMpIHtcbiAgcmV0dXJuIHMuJCR0eXBlb2YgPT09IFViO1xufVxuZnVuY3Rpb24gR2Iocykge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShzKSA/IFtdIDoge307XG59XG5mdW5jdGlvbiBCaShzLCB0KSB7XG4gIHJldHVybiB0LmNsb25lICE9PSAhMSAmJiB0LmlzTWVyZ2VhYmxlT2JqZWN0KHMpID8gUWUoR2IocyksIHMsIHQpIDogcztcbn1cbmZ1bmN0aW9uIHFiKHMsIHQsIGUpIHtcbiAgcmV0dXJuIHMuY29uY2F0KHQpLm1hcChmdW5jdGlvbihpKSB7XG4gICAgcmV0dXJuIEJpKGksIGUpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIFpiKHMsIHQpIHtcbiAgaWYgKCF0LmN1c3RvbU1lcmdlKVxuICAgIHJldHVybiBRZTtcbiAgdmFyIGUgPSB0LmN1c3RvbU1lcmdlKHMpO1xuICByZXR1cm4gdHlwZW9mIGUgPT0gXCJmdW5jdGlvblwiID8gZSA6IFFlO1xufVxuZnVuY3Rpb24gUWIocykge1xuICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocykuZmlsdGVyKGZ1bmN0aW9uKHQpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocywgdCk7XG4gIH0pIDogW107XG59XG5mdW5jdGlvbiB2bChzKSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyhzKS5jb25jYXQoUWIocykpO1xufVxuZnVuY3Rpb24gaGgocywgdCkge1xuICB0cnkge1xuICAgIHJldHVybiB0IGluIHM7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiAhMTtcbiAgfVxufVxuZnVuY3Rpb24gSmIocywgdCkge1xuICByZXR1cm4gaGgocywgdCkgJiYgIShPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChzLCB0KSAmJiBPYmplY3QucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCB0KSk7XG59XG5mdW5jdGlvbiB0dihzLCB0LCBlKSB7XG4gIHZhciBpID0ge307XG4gIHJldHVybiBlLmlzTWVyZ2VhYmxlT2JqZWN0KHMpICYmIHZsKHMpLmZvckVhY2goZnVuY3Rpb24obikge1xuICAgIGlbbl0gPSBCaShzW25dLCBlKTtcbiAgfSksIHZsKHQpLmZvckVhY2goZnVuY3Rpb24obikge1xuICAgIEpiKHMsIG4pIHx8IChoaChzLCBuKSAmJiBlLmlzTWVyZ2VhYmxlT2JqZWN0KHRbbl0pID8gaVtuXSA9IFpiKG4sIGUpKHNbbl0sIHRbbl0sIGUpIDogaVtuXSA9IEJpKHRbbl0sIGUpKTtcbiAgfSksIGk7XG59XG5mdW5jdGlvbiBRZShzLCB0LCBlKSB7XG4gIGUgPSBlIHx8IHt9LCBlLmFycmF5TWVyZ2UgPSBlLmFycmF5TWVyZ2UgfHwgcWIsIGUuaXNNZXJnZWFibGVPYmplY3QgPSBlLmlzTWVyZ2VhYmxlT2JqZWN0IHx8IFliLCBlLmNsb25lVW5sZXNzT3RoZXJ3aXNlU3BlY2lmaWVkID0gQmk7XG4gIHZhciBpID0gQXJyYXkuaXNBcnJheSh0KSwgbiA9IEFycmF5LmlzQXJyYXkocyksIG8gPSBpID09PSBuO1xuICByZXR1cm4gbyA/IGkgPyBlLmFycmF5TWVyZ2UocywgdCwgZSkgOiB0dihzLCB0LCBlKSA6IEJpKHQsIGUpO1xufVxuUWUuYWxsID0gZnVuY3Rpb24odCwgZSkge1xuICBpZiAoIUFycmF5LmlzQXJyYXkodCkpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiZmlyc3QgYXJndW1lbnQgc2hvdWxkIGJlIGFuIGFycmF5XCIpO1xuICByZXR1cm4gdC5yZWR1Y2UoZnVuY3Rpb24oaSwgbikge1xuICAgIHJldHVybiBRZShpLCBuLCBlKTtcbiAgfSwge30pO1xufTtcbnZhciBldiA9IFFlLCBZbyA9IGV2O1xuY29uc3QgVGwgPSBcImNoYXJ0XCIsIHlzID0gXCJ0ZS5jaGFydFwiLCBpdiA9IFwiY2hhcnRcIiwgdW8gPSAocywgdCwgZSkgPT4ge1xuICBjb25zdCBpID0gKG4sIG8sIHIpID0+IHtcbiAgICBjb25zdCBhID0gbi5zbGljZSgpO1xuICAgIHJldHVybiBvLmZvckVhY2goKGwsIHApID0+IHtcbiAgICAgIHR5cGVvZiBhW3BdID4gXCJ1XCIgPyBhW3BdID0gci5jbG9uZVVubGVzc090aGVyd2lzZVNwZWNpZmllZChcbiAgICAgICAgbCxcbiAgICAgICAgclxuICAgICAgKSA6IHIuaXNNZXJnZWFibGVPYmplY3QobCkgPyBhW3BdID0gWW8obltwXSwgbCwgcikgOiBuLmluZGV4T2YobCkgPT09IC0xICYmIGEucHVzaChsKTtcbiAgICB9KSwgYTtcbiAgfTtcbiAgcmV0dXJuIFlvKGVbdF0sIHMsIHtcbiAgICBhcnJheU1lcmdlOiBpXG4gIH0pO1xufSwgc3YgPSB7XG4gIGRhcmtUaWNrc0NvbG9yOiBcIiNmZmZcIixcbiAgZGFya0xhYmVsQ29sb3I6IFwiI2ZmZlwiLFxuICBkYXJrR3JpZExpbmVzQ29sb3I6IFwiIzU1NVwiLFxuICBkYXJrbW9kZU9mZjogXCJ1bmRlZmluZWRcIixcbiAgZGFya01vZGU6IG51bGwsXG4gIGRhcmtCZ0NvbG9yOiBcIiMyNjI2MjZcIixcbiAgZGFya0JnQ29sb3JMaWdodDogXCIjZmZmXCIsXG4gIG9wdGlvbnM6IG51bGxcbn0sIG52ID0ge1xuICBkYXJrVGlja3NDb2xvcjogXCJzdHJpbmdcIixcbiAgZGFya0xhYmVsQ29sb3I6IFwic3RyaW5nXCIsXG4gIGRhcmtHcmlkTGluZXNDb2xvcjogXCJzdHJpbmdcIixcbiAgZGFya21vZGVPZmY6IFwiKHN0cmluZ3xudWxsKVwiLFxuICBkYXJrTW9kZTogXCIoc3RyaW5nfG51bGwpXCIsXG4gIGRhcmtCZ0NvbG9yOiBcInN0cmluZ1wiLFxuICBkYXJrQmdDb2xvckxpZ2h0OiBcInN0cmluZ1wiLFxuICBvcHRpb25zOiBcIihvYmplY3R8bnVsbClcIlxufTtcbmNsYXNzIGRoIHtcbiAgY29uc3RydWN0b3IodCwgZSwgaSA9IHt9LCBuID0ge30pIHtcbiAgICB0aGlzLl93YWl0Rm9yQ2hhcnRzKHQsIGUsIGksIG4pO1xuICB9XG4gIGFzeW5jIF9nZXRDaGFydGpzKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIENoYXJ0OiB0LFxuICAgICAgQXJjRWxlbWVudDogZSxcbiAgICAgIExpbmVFbGVtZW50OiBpLFxuICAgICAgQmFyRWxlbWVudDogbixcbiAgICAgIFBvaW50RWxlbWVudDogbyxcbiAgICAgIEJhckNvbnRyb2xsZXI6IHIsXG4gICAgICBCdWJibGVDb250cm9sbGVyOiBhLFxuICAgICAgRG91Z2hudXRDb250cm9sbGVyOiBsLFxuICAgICAgTGluZUNvbnRyb2xsZXI6IHAsXG4gICAgICBQaWVDb250cm9sbGVyOiB1LFxuICAgICAgUG9sYXJBcmVhQ29udHJvbGxlcjogXyxcbiAgICAgIFJhZGFyQ29udHJvbGxlcjogZixcbiAgICAgIFNjYXR0ZXJDb250cm9sbGVyOiBnLFxuICAgICAgQ2F0ZWdvcnlTY2FsZTogbSxcbiAgICAgIExpbmVhclNjYWxlOiBiLFxuICAgICAgTG9nYXJpdGhtaWNTY2FsZTogdixcbiAgICAgIFJhZGlhbExpbmVhclNjYWxlOiBDLFxuICAgICAgVGltZVNjYWxlOiB3LFxuICAgICAgVGltZVNlcmllc1NjYWxlOiBFLFxuICAgICAgRGVjaW1hdGlvbjogVCxcbiAgICAgIEZpbGxlcjogQSxcbiAgICAgIExlZ2VuZDogayxcbiAgICAgIFRpdGxlOiBJLFxuICAgICAgVG9vbHRpcDogTyxcbiAgICAgIFN1YlRpdGxlOiB4XG4gICAgfSA9IGF3YWl0IGltcG9ydChcIi4vY2hhcnQuZXMuanNcIikudGhlbigoTCkgPT4gTC5mKTtcbiAgICByZXR1cm4gdC5yZWdpc3RlcihcbiAgICAgIGUsXG4gICAgICBpLFxuICAgICAgbixcbiAgICAgIG8sXG4gICAgICByLFxuICAgICAgYSxcbiAgICAgIGwsXG4gICAgICBwLFxuICAgICAgdSxcbiAgICAgIF8sXG4gICAgICBmLFxuICAgICAgZyxcbiAgICAgIG0sXG4gICAgICBiLFxuICAgICAgdixcbiAgICAgIEMsXG4gICAgICB3LFxuICAgICAgRSxcbiAgICAgIFQsXG4gICAgICBBLFxuICAgICAgayxcbiAgICAgIEksXG4gICAgICBPLFxuICAgICAgeFxuICAgICksIHQ7XG4gIH1cbiAgYXN5bmMgX2dldENoYXJ0RGF0YUxhYmVscygpIHtcbiAgICByZXR1cm4gYXdhaXQgaW1wb3J0KFwiLi9jaGFydGpzLXBsdWdpbi1kYXRhbGFiZWxzLmVzLmpzXCIpO1xuICB9XG4gIGFzeW5jIF93YWl0Rm9yQ2hhcnRzKHQsIGUsIGkgPSB7fSwgbiA9IHt9KSB7XG4gICAgaWYgKHRoaXMuX0NoYXJ0anMgPSBhd2FpdCB0aGlzLl9nZXRDaGFydGpzKCksIHRoaXMuX0NoYXJ0RGF0YUxhYmVscyA9IGF3YWl0IHRoaXMuX2dldENoYXJ0RGF0YUxhYmVscygpLCB0aGlzLl9lbGVtZW50ID0gdCwgdGhpcy5fZGF0YSA9IGUsIHRoaXMuX29wdGlvbnMgPSBpLCB0aGlzLl90eXBlID0gZS50eXBlLCB0aGlzLl9jYW52YXMgPSBudWxsLCB0aGlzLl9jaGFydCA9IG51bGwsIHRoaXMuX2RhcmtPcHRpb25zID0gdGhpcy5fZ2V0RGFya0NvbmZpZyhuKSwgdGhpcy5fZGFya01vZGVDbGFzc0NvbnRhaW5lciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCJodG1sXCIpLCB0aGlzLl9wcmV2Q29uZmlnID0gbnVsbCwgdGhpcy5fb2JzZXJ2ZXIgPSBudWxsLCB0aGlzLl9lbGVtZW50ICYmICh5LnNldERhdGEodCwgeXMsIHRoaXMpLCBoLmFkZENsYXNzKHRoaXMuX2VsZW1lbnQsIGl2KSwgdGhpcy5fY2hhcnRDb25zdHJ1Y3RvcigpKSwgdGhpcy5fZGFya09wdGlvbnMuZGFya21vZGVPZmYgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IG8gPSB0aGlzLl9kYXJrT3B0aW9ucy5kYXJrTW9kZSA9PT0gXCJkYXJrXCIgPyBcImRhcmtcIiA6IHRoaXMuX2RhcmtPcHRpb25zLmRhcmtNb2RlID09PSBcImxpZ2h0XCIgPyBcImxpZ2h0XCIgOiB0aGlzLnN5c3RlbUNvbG9yTW9kZTtcbiAgICAgIHRoaXMuX2hhbmRsZU1vZGUobyksIHRoaXMuX29ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIodGhpcy5fb2JzZXJ2ZXJDYWxsYmFjay5iaW5kKHRoaXMpKSwgdGhpcy5fb2JzZXJ2ZXIub2JzZXJ2ZSh0aGlzLl9kYXJrTW9kZUNsYXNzQ29udGFpbmVyLCB7XG4gICAgICAgIGF0dHJpYnV0ZXM6ICEwXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgLy8gR2V0dGVyc1xuICBzdGF0aWMgZ2V0IE5BTUUoKSB7XG4gICAgcmV0dXJuIFRsO1xuICB9XG4gIGdldCBzeXN0ZW1Db2xvck1vZGUoKSB7XG4gICAgcmV0dXJuIGxvY2FsU3RvcmFnZS50aGVtZSB8fCAodGhpcy5fZGFya01vZGVDbGFzc0NvbnRhaW5lci5jbGFzc0xpc3QuY29udGFpbnMoXCJkYXJrXCIpID8gXCJkYXJrXCIgOiBcImxpZ2h0XCIpO1xuICB9XG4gIC8vIFB1YmxpY1xuICBkaXNwb3NlKCkge1xuICAgIHRoaXMuX29ic2VydmVyLmRpc2Nvbm5lY3QoKSwgeS5yZW1vdmVEYXRhKHRoaXMuX2VsZW1lbnQsIHlzKSwgdGhpcy5fZWxlbWVudCA9IG51bGw7XG4gIH1cbiAgdXBkYXRlKHQsIGUpIHtcbiAgICB0ICYmICh0aGlzLl9kYXRhID0geyAuLi50aGlzLl9kYXRhLCAuLi50IH0sIHRoaXMuX2NoYXJ0LmRhdGEgPSB0aGlzLl9kYXRhKTtcbiAgICBjb25zdCBpID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKFxuICAgICAgZSxcbiAgICAgIFwib3B0aW9uc1wiXG4gICAgKSA/IGUgOiB7IG9wdGlvbnM6IHsgLi4uZSB9IH07XG4gICAgdGhpcy5fb3B0aW9ucyA9IFlvKHRoaXMuX29wdGlvbnMsIGkpLCB0aGlzLl9jaGFydC5vcHRpb25zID0gdW8oXG4gICAgICB0aGlzLl9vcHRpb25zLFxuICAgICAgdGhpcy5fdHlwZSxcbiAgICAgIFRpXG4gICAgKS5vcHRpb25zLCB0aGlzLl9jaGFydC51cGRhdGUoKTtcbiAgfVxuICBzZXRUaGVtZSh0KSB7XG4gICAgdCAhPT0gXCJkYXJrXCIgJiYgdCAhPT0gXCJsaWdodFwiIHx8ICF0aGlzLl9kYXRhIHx8IHRoaXMuX2hhbmRsZU1vZGUodCk7XG4gIH1cbiAgLy8gUHJpdmF0ZVxuICBfZ2V0RGFya0NvbmZpZyh0KSB7XG4gICAgbGV0IGUgPSB7fTtcbiAgICBjb25zdCBpID0gaC5nZXREYXRhQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KTtcbiAgICBPYmplY3Qua2V5cyhpKS5mb3JFYWNoKFxuICAgICAgKHApID0+IHAuc3RhcnRzV2l0aChcImRhcmtcIikgJiYgKGVbcF0gPSBpW3BdKVxuICAgICksIGUgPSB7XG4gICAgICAuLi5zdixcbiAgICAgIC4uLmVcbiAgICB9O1xuICAgIGNvbnN0IG4gPSB7XG4gICAgICB5OiB7XG4gICAgICAgIHRpY2tzOiB7XG4gICAgICAgICAgY29sb3I6IGUuZGFya1RpY2tzQ29sb3JcbiAgICAgICAgfSxcbiAgICAgICAgZ3JpZDoge1xuICAgICAgICAgIGNvbG9yOiBlLmRhcmtHcmlkTGluZXNDb2xvclxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgeDoge1xuICAgICAgICB0aWNrczoge1xuICAgICAgICAgIGNvbG9yOiBlLmRhcmtUaWNrc0NvbG9yXG4gICAgICAgIH0sXG4gICAgICAgIGdyaWQ6IHtcbiAgICAgICAgICBjb2xvcjogZS5kYXJrR3JpZExpbmVzQ29sb3JcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIG8gPSB7XG4gICAgICByOiB7XG4gICAgICAgIHRpY2tzOiB7XG4gICAgICAgICAgY29sb3I6IGUuZGFya1RpY2tzQ29sb3IsXG4gICAgICAgICAgYmFja2Ryb3BDb2xvcjogZS5kYXJrQmdDb2xvclxuICAgICAgICB9LFxuICAgICAgICBncmlkOiB7XG4gICAgICAgICAgY29sb3I6IGUuZGFya0dyaWRMaW5lc0NvbG9yXG4gICAgICAgIH0sXG4gICAgICAgIHBvaW50TGFiZWxzOiB7XG4gICAgICAgICAgY29sb3I6IGUuZGFya1RpY2tzQ29sb3JcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIGwgPSB7XG4gICAgICBzY2FsZXM6IFtcInBpZVwiLCBcImRvdWdobnV0XCIsIFwicG9sYXJBcmVhXCIsIFwicmFkYXJcIl0uaW5jbHVkZXModGhpcy5fdHlwZSkgPyBbXCJwb2xhckFyZWFcIiwgXCJyYWRhclwiXS5pbmNsdWRlcyh0aGlzLl90eXBlKSA/IG8gOiB7fSA6IG4sXG4gICAgICBwbHVnaW5zOiB7XG4gICAgICAgIGxlZ2VuZDoge1xuICAgICAgICAgIGxhYmVsczoge1xuICAgICAgICAgICAgY29sb3I6IGUuZGFya0xhYmVsQ29sb3JcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiB0ID0ge1xuICAgICAgLi4uZSxcbiAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgLi4ubFxuICAgICAgfSxcbiAgICAgIC4uLnRcbiAgICB9LCBEKFRsLCB0LCBudiksIHQ7XG4gIH1cbiAgX2NoYXJ0Q29uc3RydWN0b3IoKSB7XG4gICAgaWYgKHRoaXMuX2RhdGEpIHtcbiAgICAgIHRoaXMuX2NyZWF0ZUNhbnZhcygpO1xuICAgICAgY29uc3QgdCA9IHVvKHRoaXMuX29wdGlvbnMsIHRoaXMuX3R5cGUsIFRpKSwgZSA9IFtdO1xuICAgICAgdC5kYXRhTGFiZWxzUGx1Z2luICYmIGUucHVzaCh0aGlzLl9DaGFydERhdGFMYWJlbHMuZGVmYXVsdCksIHRoaXMuX3ByZXZDb25maWcgPSB0LCB0aGlzLl9jaGFydCA9IG5ldyB0aGlzLl9DaGFydGpzKHRoaXMuX2NhbnZhcywge1xuICAgICAgICAuLi50aGlzLl9kYXRhLFxuICAgICAgICAuLi50LFxuICAgICAgICBwbHVnaW5zOiBlXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgX2NyZWF0ZUNhbnZhcygpIHtcbiAgICB0aGlzLl9jYW52YXMgfHwgKHRoaXMuX2VsZW1lbnQubm9kZU5hbWUgPT09IFwiQ0FOVkFTXCIgPyB0aGlzLl9jYW52YXMgPSB0aGlzLl9lbGVtZW50IDogKHRoaXMuX2NhbnZhcyA9ICQoXCJjYW52YXNcIiksIHRoaXMuX2VsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5fY2FudmFzKSkpO1xuICB9XG4gIF9oYW5kbGVNb2RlKHQpIHtcbiAgICB0ID09PSBcImRhcmtcIiA/ICh0aGlzLl9jaGFuZ2VEYXRhc2V0Qm9yZGVyQ29sb3IoKSwgdGhpcy51cGRhdGUobnVsbCwgdGhpcy5fZGFya09wdGlvbnMub3B0aW9ucykpIDogKHRoaXMuX2NoYW5nZURhdGFzZXRCb3JkZXJDb2xvcighMSksIHRoaXMuX3ByZXZDb25maWcgJiYgdGhpcy51cGRhdGUobnVsbCwgdGhpcy5fcHJldkNvbmZpZykpO1xuICB9XG4gIF9vYnNlcnZlckNhbGxiYWNrKHQpIHtcbiAgICBmb3IgKGNvbnN0IGUgb2YgdClcbiAgICAgIGUudHlwZSA9PT0gXCJhdHRyaWJ1dGVzXCIgJiYgdGhpcy5faGFuZGxlTW9kZSh0aGlzLnN5c3RlbUNvbG9yTW9kZSk7XG4gIH1cbiAgX2NoYW5nZURhdGFzZXRCb3JkZXJDb2xvcih0ID0gITApIHtcbiAgICBbLi4udGhpcy5fZGF0YS5kYXRhLmRhdGFzZXRzXS5mb3JFYWNoKFxuICAgICAgKGUpID0+IFtcInBpZVwiLCBcImRvdWdobnV0XCIsIFwicG9sYXJBcmVhXCJdLmluY2x1ZGVzKHRoaXMuX3R5cGUpICYmIChlLmJvcmRlckNvbG9yID0gdCA/IHRoaXMuX2RhcmtPcHRpb25zLmRhcmtCZ0NvbG9yIDogdGhpcy5fZGFya09wdGlvbnMuZGFya0JnQ29sb3JMaWdodClcbiAgICApO1xuICB9XG4gIHN0YXRpYyBqUXVlcnlJbnRlcmZhY2UodCwgZSwgaSkge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICBsZXQgbiA9IHkuZ2V0RGF0YSh0aGlzLCB5cyk7XG4gICAgICBpZiAoISghbiAmJiAvZGlzcG9zZS8udGVzdCh0KSkpIHtcbiAgICAgICAgaWYgKCFuKSB7XG4gICAgICAgICAgY29uc3QgbyA9IGUgPyB1byhlLCBpLCBUaSkgOiBUaVtpXTtcbiAgICAgICAgICBuID0gbmV3IGRoKHRoaXMsIHtcbiAgICAgICAgICAgIC4uLnQsXG4gICAgICAgICAgICAuLi5vXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB0ID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIG5bdF0gPiBcInVcIilcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcIiR7dH1cImApO1xuICAgICAgICAgIG5bdF0oZSwgaSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBzdGF0aWMgZ2V0SW5zdGFuY2UodCkge1xuICAgIHJldHVybiB5LmdldERhdGEodCwgeXMpO1xuICB9XG4gIHN0YXRpYyBnZXRPckNyZWF0ZUluc3RhbmNlKHQsIGUgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLmdldEluc3RhbmNlKHQpIHx8IG5ldyB0aGlzKHQsIHR5cGVvZiBlID09IFwib2JqZWN0XCIgPyBlIDogbnVsbCk7XG4gIH1cbn1cbi8qIVxuICogcGVyZmVjdC1zY3JvbGxiYXIgdjEuNS4zXG4gKiBDb3B5cmlnaHQgMjAyMSBIeXVuamUgSnVuLCBNREJvb3RzdHJhcCBhbmQgQ29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciBNSVRcbiAqL1xuZnVuY3Rpb24gTHQocykge1xuICByZXR1cm4gZ2V0Q29tcHV0ZWRTdHlsZShzKTtcbn1cbmZ1bmN0aW9uIG90KHMsIHQpIHtcbiAgZm9yICh2YXIgZSBpbiB0KSB7XG4gICAgdmFyIGkgPSB0W2VdO1xuICAgIHR5cGVvZiBpID09IFwibnVtYmVyXCIgJiYgKGkgPSBpICsgXCJweFwiKSwgcy5zdHlsZVtlXSA9IGk7XG4gIH1cbiAgcmV0dXJuIHM7XG59XG5mdW5jdGlvbiB3cyhzKSB7XG4gIHZhciB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgcmV0dXJuIHQuY2xhc3NOYW1lID0gcywgdDtcbn1cbnZhciBFbCA9IHR5cGVvZiBFbGVtZW50IDwgXCJ1XCIgJiYgKEVsZW1lbnQucHJvdG90eXBlLm1hdGNoZXMgfHwgRWxlbWVudC5wcm90b3R5cGUud2Via2l0TWF0Y2hlc1NlbGVjdG9yIHx8IEVsZW1lbnQucHJvdG90eXBlLm1vek1hdGNoZXNTZWxlY3RvciB8fCBFbGVtZW50LnByb3RvdHlwZS5tc01hdGNoZXNTZWxlY3Rvcik7XG5mdW5jdGlvbiBRdChzLCB0KSB7XG4gIGlmICghRWwpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gZWxlbWVudCBtYXRjaGluZyBtZXRob2Qgc3VwcG9ydGVkXCIpO1xuICByZXR1cm4gRWwuY2FsbChzLCB0KTtcbn1cbmZ1bmN0aW9uIFBlKHMpIHtcbiAgcy5yZW1vdmUgPyBzLnJlbW92ZSgpIDogcy5wYXJlbnROb2RlICYmIHMucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzKTtcbn1cbmZ1bmN0aW9uIENsKHMsIHQpIHtcbiAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5maWx0ZXIuY2FsbChcbiAgICBzLmNoaWxkcmVuLFxuICAgIGZ1bmN0aW9uKGUpIHtcbiAgICAgIHJldHVybiBRdChlLCB0KTtcbiAgICB9XG4gICk7XG59XG52YXIgaiA9IHtcbiAgbWFpbjogXCJwc1wiLFxuICBydGw6IFwicHNfX3J0bFwiLFxuICBlbGVtZW50OiB7XG4gICAgdGh1bWI6IGZ1bmN0aW9uKHMpIHtcbiAgICAgIHJldHVybiBcInBzX190aHVtYi1cIiArIHM7XG4gICAgfSxcbiAgICByYWlsOiBmdW5jdGlvbihzKSB7XG4gICAgICByZXR1cm4gXCJwc19fcmFpbC1cIiArIHM7XG4gICAgfSxcbiAgICBjb25zdW1pbmc6IFwicHNfX2NoaWxkLS1jb25zdW1lXCJcbiAgfSxcbiAgc3RhdGU6IHtcbiAgICBmb2N1czogXCJwcy0tZm9jdXNcIixcbiAgICBjbGlja2luZzogXCJwcy0tY2xpY2tpbmdcIixcbiAgICBhY3RpdmU6IGZ1bmN0aW9uKHMpIHtcbiAgICAgIHJldHVybiBcInBzLS1hY3RpdmUtXCIgKyBzO1xuICAgIH0sXG4gICAgc2Nyb2xsaW5nOiBmdW5jdGlvbihzKSB7XG4gICAgICByZXR1cm4gXCJwcy0tc2Nyb2xsaW5nLVwiICsgcztcbiAgICB9XG4gIH1cbn0sIHVoID0geyB4OiBudWxsLCB5OiBudWxsIH07XG5mdW5jdGlvbiBwaChzLCB0KSB7XG4gIHZhciBlID0gcy5lbGVtZW50LmNsYXNzTGlzdCwgaSA9IGouc3RhdGUuc2Nyb2xsaW5nKHQpO1xuICBlLmNvbnRhaW5zKGkpID8gY2xlYXJUaW1lb3V0KHVoW3RdKSA6IGUuYWRkKGkpO1xufVxuZnVuY3Rpb24gX2gocywgdCkge1xuICB1aFt0XSA9IHNldFRpbWVvdXQoXG4gICAgZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gcy5pc0FsaXZlICYmIHMuZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKGouc3RhdGUuc2Nyb2xsaW5nKHQpKTtcbiAgICB9LFxuICAgIHMuc2V0dGluZ3Muc2Nyb2xsaW5nVGhyZXNob2xkXG4gICk7XG59XG5mdW5jdGlvbiBvdihzLCB0KSB7XG4gIHBoKHMsIHQpLCBfaChzLCB0KTtcbn1cbnZhciB6aSA9IGZ1bmN0aW9uKHQpIHtcbiAgdGhpcy5lbGVtZW50ID0gdCwgdGhpcy5oYW5kbGVycyA9IHt9O1xufSwgZmggPSB7IGlzRW1wdHk6IHsgY29uZmlndXJhYmxlOiAhMCB9IH07XG56aS5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uKHQsIGUpIHtcbiAgdHlwZW9mIHRoaXMuaGFuZGxlcnNbdF0gPiBcInVcIiAmJiAodGhpcy5oYW5kbGVyc1t0XSA9IFtdKSwgdGhpcy5oYW5kbGVyc1t0XS5wdXNoKGUpLCB0aGlzLmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcih0LCBlLCAhMSk7XG59O1xuemkucHJvdG90eXBlLnVuYmluZCA9IGZ1bmN0aW9uKHQsIGUpIHtcbiAgdmFyIGkgPSB0aGlzO1xuICB0aGlzLmhhbmRsZXJzW3RdID0gdGhpcy5oYW5kbGVyc1t0XS5maWx0ZXIoZnVuY3Rpb24obikge1xuICAgIHJldHVybiBlICYmIG4gIT09IGUgPyAhMCA6IChpLmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0LCBuLCAhMSksICExKTtcbiAgfSk7XG59O1xuemkucHJvdG90eXBlLnVuYmluZEFsbCA9IGZ1bmN0aW9uKCkge1xuICBmb3IgKHZhciB0IGluIHRoaXMuaGFuZGxlcnMpXG4gICAgdGhpcy51bmJpbmQodCk7XG59O1xuZmguaXNFbXB0eS5nZXQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHMgPSB0aGlzO1xuICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5oYW5kbGVycykuZXZlcnkoXG4gICAgZnVuY3Rpb24odCkge1xuICAgICAgcmV0dXJuIHMuaGFuZGxlcnNbdF0ubGVuZ3RoID09PSAwO1xuICAgIH1cbiAgKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyh6aS5wcm90b3R5cGUsIGZoKTtcbnZhciBzaSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmV2ZW50RWxlbWVudHMgPSBbXTtcbn07XG5zaS5wcm90b3R5cGUuZXZlbnRFbGVtZW50ID0gZnVuY3Rpb24odCkge1xuICB2YXIgZSA9IHRoaXMuZXZlbnRFbGVtZW50cy5maWx0ZXIoZnVuY3Rpb24oaSkge1xuICAgIHJldHVybiBpLmVsZW1lbnQgPT09IHQ7XG4gIH0pWzBdO1xuICByZXR1cm4gZSB8fCAoZSA9IG5ldyB6aSh0KSwgdGhpcy5ldmVudEVsZW1lbnRzLnB1c2goZSkpLCBlO1xufTtcbnNpLnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24odCwgZSwgaSkge1xuICB0aGlzLmV2ZW50RWxlbWVudCh0KS5iaW5kKGUsIGkpO1xufTtcbnNpLnByb3RvdHlwZS51bmJpbmQgPSBmdW5jdGlvbih0LCBlLCBpKSB7XG4gIHZhciBuID0gdGhpcy5ldmVudEVsZW1lbnQodCk7XG4gIG4udW5iaW5kKGUsIGkpLCBuLmlzRW1wdHkgJiYgdGhpcy5ldmVudEVsZW1lbnRzLnNwbGljZSh0aGlzLmV2ZW50RWxlbWVudHMuaW5kZXhPZihuKSwgMSk7XG59O1xuc2kucHJvdG90eXBlLnVuYmluZEFsbCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmV2ZW50RWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbih0KSB7XG4gICAgcmV0dXJuIHQudW5iaW5kQWxsKCk7XG4gIH0pLCB0aGlzLmV2ZW50RWxlbWVudHMgPSBbXTtcbn07XG5zaS5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uKHQsIGUsIGkpIHtcbiAgdmFyIG4gPSB0aGlzLmV2ZW50RWxlbWVudCh0KSwgbyA9IGZ1bmN0aW9uKHIpIHtcbiAgICBuLnVuYmluZChlLCBvKSwgaShyKTtcbiAgfTtcbiAgbi5iaW5kKGUsIG8pO1xufTtcbmZ1bmN0aW9uIGtzKHMpIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cuQ3VzdG9tRXZlbnQgPT0gXCJmdW5jdGlvblwiKVxuICAgIHJldHVybiBuZXcgQ3VzdG9tRXZlbnQocyk7XG4gIHZhciB0ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoXCJDdXN0b21FdmVudFwiKTtcbiAgcmV0dXJuIHQuaW5pdEN1c3RvbUV2ZW50KHMsICExLCAhMSwgdm9pZCAwKSwgdDtcbn1cbmZ1bmN0aW9uIG9uKHMsIHQsIGUsIGksIG4pIHtcbiAgaSA9PT0gdm9pZCAwICYmIChpID0gITApLCBuID09PSB2b2lkIDAgJiYgKG4gPSAhMSk7XG4gIHZhciBvO1xuICBpZiAodCA9PT0gXCJ0b3BcIilcbiAgICBvID0gW1xuICAgICAgXCJjb250ZW50SGVpZ2h0XCIsXG4gICAgICBcImNvbnRhaW5lckhlaWdodFwiLFxuICAgICAgXCJzY3JvbGxUb3BcIixcbiAgICAgIFwieVwiLFxuICAgICAgXCJ1cFwiLFxuICAgICAgXCJkb3duXCJcbiAgICBdO1xuICBlbHNlIGlmICh0ID09PSBcImxlZnRcIilcbiAgICBvID0gW1xuICAgICAgXCJjb250ZW50V2lkdGhcIixcbiAgICAgIFwiY29udGFpbmVyV2lkdGhcIixcbiAgICAgIFwic2Nyb2xsTGVmdFwiLFxuICAgICAgXCJ4XCIsXG4gICAgICBcImxlZnRcIixcbiAgICAgIFwicmlnaHRcIlxuICAgIF07XG4gIGVsc2VcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJBIHByb3BlciBheGlzIHNob3VsZCBiZSBwcm92aWRlZFwiKTtcbiAgcnYocywgZSwgbywgaSwgbik7XG59XG5mdW5jdGlvbiBydihzLCB0LCBlLCBpLCBuKSB7XG4gIHZhciBvID0gZVswXSwgciA9IGVbMV0sIGEgPSBlWzJdLCBsID0gZVszXSwgcCA9IGVbNF0sIHUgPSBlWzVdO1xuICBpID09PSB2b2lkIDAgJiYgKGkgPSAhMCksIG4gPT09IHZvaWQgMCAmJiAobiA9ICExKTtcbiAgdmFyIF8gPSBzLmVsZW1lbnQ7XG4gIHMucmVhY2hbbF0gPSBudWxsLCBfW2FdIDwgMSAmJiAocy5yZWFjaFtsXSA9IFwic3RhcnRcIiksIF9bYV0gPiBzW29dIC0gc1tyXSAtIDEgJiYgKHMucmVhY2hbbF0gPSBcImVuZFwiKSwgdCAmJiAoXy5kaXNwYXRjaEV2ZW50KGtzKFwicHMtc2Nyb2xsLVwiICsgbCkpLCB0IDwgMCA/IF8uZGlzcGF0Y2hFdmVudChrcyhcInBzLXNjcm9sbC1cIiArIHApKSA6IHQgPiAwICYmIF8uZGlzcGF0Y2hFdmVudChrcyhcInBzLXNjcm9sbC1cIiArIHUpKSwgaSAmJiBvdihzLCBsKSksIHMucmVhY2hbbF0gJiYgKHQgfHwgbikgJiYgXy5kaXNwYXRjaEV2ZW50KGtzKFwicHMtXCIgKyBsICsgXCItcmVhY2gtXCIgKyBzLnJlYWNoW2xdKSk7XG59XG5mdW5jdGlvbiBXKHMpIHtcbiAgcmV0dXJuIHBhcnNlSW50KHMsIDEwKSB8fCAwO1xufVxuZnVuY3Rpb24gYXYocykge1xuICByZXR1cm4gUXQocywgXCJpbnB1dCxbY29udGVudGVkaXRhYmxlXVwiKSB8fCBRdChzLCBcInNlbGVjdCxbY29udGVudGVkaXRhYmxlXVwiKSB8fCBRdChzLCBcInRleHRhcmVhLFtjb250ZW50ZWRpdGFibGVdXCIpIHx8IFF0KHMsIFwiYnV0dG9uLFtjb250ZW50ZWRpdGFibGVdXCIpO1xufVxuZnVuY3Rpb24gbHYocykge1xuICB2YXIgdCA9IEx0KHMpO1xuICByZXR1cm4gVyh0LndpZHRoKSArIFcodC5wYWRkaW5nTGVmdCkgKyBXKHQucGFkZGluZ1JpZ2h0KSArIFcodC5ib3JkZXJMZWZ0V2lkdGgpICsgVyh0LmJvcmRlclJpZ2h0V2lkdGgpO1xufVxudmFyIE5lID0ge1xuICBpc1dlYktpdDogdHlwZW9mIGRvY3VtZW50IDwgXCJ1XCIgJiYgXCJXZWJraXRBcHBlYXJhbmNlXCIgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLFxuICBzdXBwb3J0c1RvdWNoOiB0eXBlb2Ygd2luZG93IDwgXCJ1XCIgJiYgKFwib250b3VjaHN0YXJ0XCIgaW4gd2luZG93IHx8IFwibWF4VG91Y2hQb2ludHNcIiBpbiB3aW5kb3cubmF2aWdhdG9yICYmIHdpbmRvdy5uYXZpZ2F0b3IubWF4VG91Y2hQb2ludHMgPiAwIHx8IHdpbmRvdy5Eb2N1bWVudFRvdWNoICYmIGRvY3VtZW50IGluc3RhbmNlb2Ygd2luZG93LkRvY3VtZW50VG91Y2gpLFxuICBzdXBwb3J0c0llUG9pbnRlcjogdHlwZW9mIG5hdmlnYXRvciA8IFwidVwiICYmIG5hdmlnYXRvci5tc01heFRvdWNoUG9pbnRzLFxuICBpc0Nocm9tZTogdHlwZW9mIG5hdmlnYXRvciA8IFwidVwiICYmIC9DaHJvbWUvaS50ZXN0KG5hdmlnYXRvciAmJiBuYXZpZ2F0b3IudXNlckFnZW50KVxufTtcbmZ1bmN0aW9uIEJ0KHMpIHtcbiAgdmFyIHQgPSBzLmVsZW1lbnQsIGUgPSBNYXRoLmZsb29yKHQuc2Nyb2xsVG9wKSwgaSA9IHQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIHMuY29udGFpbmVyV2lkdGggPSBNYXRoLnJvdW5kKGkud2lkdGgpLCBzLmNvbnRhaW5lckhlaWdodCA9IE1hdGgucm91bmQoaS5oZWlnaHQpLCBzLmNvbnRlbnRXaWR0aCA9IHQuc2Nyb2xsV2lkdGgsIHMuY29udGVudEhlaWdodCA9IHQuc2Nyb2xsSGVpZ2h0LCB0LmNvbnRhaW5zKHMuc2Nyb2xsYmFyWFJhaWwpIHx8IChDbCh0LCBqLmVsZW1lbnQucmFpbChcInhcIikpLmZvckVhY2goXG4gICAgZnVuY3Rpb24obikge1xuICAgICAgcmV0dXJuIFBlKG4pO1xuICAgIH1cbiAgKSwgdC5hcHBlbmRDaGlsZChzLnNjcm9sbGJhclhSYWlsKSksIHQuY29udGFpbnMocy5zY3JvbGxiYXJZUmFpbCkgfHwgKENsKHQsIGouZWxlbWVudC5yYWlsKFwieVwiKSkuZm9yRWFjaChcbiAgICBmdW5jdGlvbihuKSB7XG4gICAgICByZXR1cm4gUGUobik7XG4gICAgfVxuICApLCB0LmFwcGVuZENoaWxkKHMuc2Nyb2xsYmFyWVJhaWwpKSwgIXMuc2V0dGluZ3Muc3VwcHJlc3NTY3JvbGxYICYmIHMuY29udGFpbmVyV2lkdGggKyBzLnNldHRpbmdzLnNjcm9sbFhNYXJnaW5PZmZzZXQgPCBzLmNvbnRlbnRXaWR0aCA/IChzLnNjcm9sbGJhclhBY3RpdmUgPSAhMCwgcy5yYWlsWFdpZHRoID0gcy5jb250YWluZXJXaWR0aCAtIHMucmFpbFhNYXJnaW5XaWR0aCwgcy5yYWlsWFJhdGlvID0gcy5jb250YWluZXJXaWR0aCAvIHMucmFpbFhXaWR0aCwgcy5zY3JvbGxiYXJYV2lkdGggPSBBbChcbiAgICBzLFxuICAgIFcocy5yYWlsWFdpZHRoICogcy5jb250YWluZXJXaWR0aCAvIHMuY29udGVudFdpZHRoKVxuICApLCBzLnNjcm9sbGJhclhMZWZ0ID0gVyhcbiAgICAocy5uZWdhdGl2ZVNjcm9sbEFkanVzdG1lbnQgKyB0LnNjcm9sbExlZnQpICogKHMucmFpbFhXaWR0aCAtIHMuc2Nyb2xsYmFyWFdpZHRoKSAvIChzLmNvbnRlbnRXaWR0aCAtIHMuY29udGFpbmVyV2lkdGgpXG4gICkpIDogcy5zY3JvbGxiYXJYQWN0aXZlID0gITEsICFzLnNldHRpbmdzLnN1cHByZXNzU2Nyb2xsWSAmJiBzLmNvbnRhaW5lckhlaWdodCArIHMuc2V0dGluZ3Muc2Nyb2xsWU1hcmdpbk9mZnNldCA8IHMuY29udGVudEhlaWdodCA/IChzLnNjcm9sbGJhcllBY3RpdmUgPSAhMCwgcy5yYWlsWUhlaWdodCA9IHMuY29udGFpbmVySGVpZ2h0IC0gcy5yYWlsWU1hcmdpbkhlaWdodCwgcy5yYWlsWVJhdGlvID0gcy5jb250YWluZXJIZWlnaHQgLyBzLnJhaWxZSGVpZ2h0LCBzLnNjcm9sbGJhcllIZWlnaHQgPSBBbChcbiAgICBzLFxuICAgIFcocy5yYWlsWUhlaWdodCAqIHMuY29udGFpbmVySGVpZ2h0IC8gcy5jb250ZW50SGVpZ2h0KVxuICApLCBzLnNjcm9sbGJhcllUb3AgPSBXKFxuICAgIGUgKiAocy5yYWlsWUhlaWdodCAtIHMuc2Nyb2xsYmFyWUhlaWdodCkgLyAocy5jb250ZW50SGVpZ2h0IC0gcy5jb250YWluZXJIZWlnaHQpXG4gICkpIDogcy5zY3JvbGxiYXJZQWN0aXZlID0gITEsIHMuc2Nyb2xsYmFyWExlZnQgPj0gcy5yYWlsWFdpZHRoIC0gcy5zY3JvbGxiYXJYV2lkdGggJiYgKHMuc2Nyb2xsYmFyWExlZnQgPSBzLnJhaWxYV2lkdGggLSBzLnNjcm9sbGJhclhXaWR0aCksIHMuc2Nyb2xsYmFyWVRvcCA+PSBzLnJhaWxZSGVpZ2h0IC0gcy5zY3JvbGxiYXJZSGVpZ2h0ICYmIChzLnNjcm9sbGJhcllUb3AgPSBzLnJhaWxZSGVpZ2h0IC0gcy5zY3JvbGxiYXJZSGVpZ2h0KSwgY3YodCwgcyksIHMuc2Nyb2xsYmFyWEFjdGl2ZSA/IHQuY2xhc3NMaXN0LmFkZChqLnN0YXRlLmFjdGl2ZShcInhcIikpIDogKHQuY2xhc3NMaXN0LnJlbW92ZShqLnN0YXRlLmFjdGl2ZShcInhcIikpLCBzLnNjcm9sbGJhclhXaWR0aCA9IDAsIHMuc2Nyb2xsYmFyWExlZnQgPSAwLCB0LnNjcm9sbExlZnQgPSBzLmlzUnRsID09PSAhMCA/IHMuY29udGVudFdpZHRoIDogMCksIHMuc2Nyb2xsYmFyWUFjdGl2ZSA/IHQuY2xhc3NMaXN0LmFkZChqLnN0YXRlLmFjdGl2ZShcInlcIikpIDogKHQuY2xhc3NMaXN0LnJlbW92ZShqLnN0YXRlLmFjdGl2ZShcInlcIikpLCBzLnNjcm9sbGJhcllIZWlnaHQgPSAwLCBzLnNjcm9sbGJhcllUb3AgPSAwLCB0LnNjcm9sbFRvcCA9IDApO1xufVxuZnVuY3Rpb24gQWwocywgdCkge1xuICByZXR1cm4gcy5zZXR0aW5ncy5taW5TY3JvbGxiYXJMZW5ndGggJiYgKHQgPSBNYXRoLm1heCh0LCBzLnNldHRpbmdzLm1pblNjcm9sbGJhckxlbmd0aCkpLCBzLnNldHRpbmdzLm1heFNjcm9sbGJhckxlbmd0aCAmJiAodCA9IE1hdGgubWluKHQsIHMuc2V0dGluZ3MubWF4U2Nyb2xsYmFyTGVuZ3RoKSksIHQ7XG59XG5mdW5jdGlvbiBjdihzLCB0KSB7XG4gIHZhciBlID0geyB3aWR0aDogdC5yYWlsWFdpZHRoIH0sIGkgPSBNYXRoLmZsb29yKHMuc2Nyb2xsVG9wKTtcbiAgdC5pc1J0bCA/IGUubGVmdCA9IHQubmVnYXRpdmVTY3JvbGxBZGp1c3RtZW50ICsgcy5zY3JvbGxMZWZ0ICsgdC5jb250YWluZXJXaWR0aCAtIHQuY29udGVudFdpZHRoIDogZS5sZWZ0ID0gcy5zY3JvbGxMZWZ0LCB0LmlzU2Nyb2xsYmFyWFVzaW5nQm90dG9tID8gZS5ib3R0b20gPSB0LnNjcm9sbGJhclhCb3R0b20gLSBpIDogZS50b3AgPSB0LnNjcm9sbGJhclhUb3AgKyBpLCBvdCh0LnNjcm9sbGJhclhSYWlsLCBlKTtcbiAgdmFyIG4gPSB7IHRvcDogaSwgaGVpZ2h0OiB0LnJhaWxZSGVpZ2h0IH07XG4gIHQuaXNTY3JvbGxiYXJZVXNpbmdSaWdodCA/IHQuaXNSdGwgPyBuLnJpZ2h0ID0gdC5jb250ZW50V2lkdGggLSAodC5uZWdhdGl2ZVNjcm9sbEFkanVzdG1lbnQgKyBzLnNjcm9sbExlZnQpIC0gdC5zY3JvbGxiYXJZUmlnaHQgLSB0LnNjcm9sbGJhcllPdXRlcldpZHRoIC0gOSA6IG4ucmlnaHQgPSB0LnNjcm9sbGJhcllSaWdodCAtIHMuc2Nyb2xsTGVmdCA6IHQuaXNSdGwgPyBuLmxlZnQgPSB0Lm5lZ2F0aXZlU2Nyb2xsQWRqdXN0bWVudCArIHMuc2Nyb2xsTGVmdCArIHQuY29udGFpbmVyV2lkdGggKiAyIC0gdC5jb250ZW50V2lkdGggLSB0LnNjcm9sbGJhcllMZWZ0IC0gdC5zY3JvbGxiYXJZT3V0ZXJXaWR0aCA6IG4ubGVmdCA9IHQuc2Nyb2xsYmFyWUxlZnQgKyBzLnNjcm9sbExlZnQsIG90KHQuc2Nyb2xsYmFyWVJhaWwsIG4pLCBvdCh0LnNjcm9sbGJhclgsIHtcbiAgICBsZWZ0OiB0LnNjcm9sbGJhclhMZWZ0LFxuICAgIHdpZHRoOiB0LnNjcm9sbGJhclhXaWR0aCAtIHQucmFpbEJvcmRlclhXaWR0aFxuICB9KSwgb3QodC5zY3JvbGxiYXJZLCB7XG4gICAgdG9wOiB0LnNjcm9sbGJhcllUb3AsXG4gICAgaGVpZ2h0OiB0LnNjcm9sbGJhcllIZWlnaHQgLSB0LnJhaWxCb3JkZXJZV2lkdGhcbiAgfSk7XG59XG5mdW5jdGlvbiBodihzKSB7XG4gIHMuZWxlbWVudCwgcy5ldmVudC5iaW5kKHMuc2Nyb2xsYmFyWSwgXCJtb3VzZWRvd25cIiwgZnVuY3Rpb24odCkge1xuICAgIHJldHVybiB0LnN0b3BQcm9wYWdhdGlvbigpO1xuICB9KSwgcy5ldmVudC5iaW5kKHMuc2Nyb2xsYmFyWVJhaWwsIFwibW91c2Vkb3duXCIsIGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgZSA9IHQucGFnZVkgLSB3aW5kb3cucGFnZVlPZmZzZXQgLSBzLnNjcm9sbGJhcllSYWlsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcCwgaSA9IGUgPiBzLnNjcm9sbGJhcllUb3AgPyAxIDogLTE7XG4gICAgcy5lbGVtZW50LnNjcm9sbFRvcCArPSBpICogcy5jb250YWluZXJIZWlnaHQsIEJ0KHMpLCB0LnN0b3BQcm9wYWdhdGlvbigpO1xuICB9KSwgcy5ldmVudC5iaW5kKHMuc2Nyb2xsYmFyWCwgXCJtb3VzZWRvd25cIiwgZnVuY3Rpb24odCkge1xuICAgIHJldHVybiB0LnN0b3BQcm9wYWdhdGlvbigpO1xuICB9KSwgcy5ldmVudC5iaW5kKHMuc2Nyb2xsYmFyWFJhaWwsIFwibW91c2Vkb3duXCIsIGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgZSA9IHQucGFnZVggLSB3aW5kb3cucGFnZVhPZmZzZXQgLSBzLnNjcm9sbGJhclhSYWlsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQsIGkgPSBlID4gcy5zY3JvbGxiYXJYTGVmdCA/IDEgOiAtMTtcbiAgICBzLmVsZW1lbnQuc2Nyb2xsTGVmdCArPSBpICogcy5jb250YWluZXJXaWR0aCwgQnQocyksIHQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gIH0pO1xufVxuZnVuY3Rpb24gZHYocykge1xuICB5bChzLCBbXG4gICAgXCJjb250YWluZXJXaWR0aFwiLFxuICAgIFwiY29udGVudFdpZHRoXCIsXG4gICAgXCJwYWdlWFwiLFxuICAgIFwicmFpbFhXaWR0aFwiLFxuICAgIFwic2Nyb2xsYmFyWFwiLFxuICAgIFwic2Nyb2xsYmFyWFdpZHRoXCIsXG4gICAgXCJzY3JvbGxMZWZ0XCIsXG4gICAgXCJ4XCIsXG4gICAgXCJzY3JvbGxiYXJYUmFpbFwiXG4gIF0pLCB5bChzLCBbXG4gICAgXCJjb250YWluZXJIZWlnaHRcIixcbiAgICBcImNvbnRlbnRIZWlnaHRcIixcbiAgICBcInBhZ2VZXCIsXG4gICAgXCJyYWlsWUhlaWdodFwiLFxuICAgIFwic2Nyb2xsYmFyWVwiLFxuICAgIFwic2Nyb2xsYmFyWUhlaWdodFwiLFxuICAgIFwic2Nyb2xsVG9wXCIsXG4gICAgXCJ5XCIsXG4gICAgXCJzY3JvbGxiYXJZUmFpbFwiXG4gIF0pO1xufVxuZnVuY3Rpb24geWwocywgdCkge1xuICB2YXIgZSA9IHRbMF0sIGkgPSB0WzFdLCBuID0gdFsyXSwgbyA9IHRbM10sIHIgPSB0WzRdLCBhID0gdFs1XSwgbCA9IHRbNl0sIHAgPSB0WzddLCB1ID0gdFs4XSwgXyA9IHMuZWxlbWVudCwgZiA9IG51bGwsIGcgPSBudWxsLCBtID0gbnVsbDtcbiAgZnVuY3Rpb24gYih3KSB7XG4gICAgdy50b3VjaGVzICYmIHcudG91Y2hlc1swXSAmJiAod1tuXSA9IHcudG91Y2hlc1swXS5wYWdlWSksIF9bbF0gPSBmICsgbSAqICh3W25dIC0gZyksIHBoKHMsIHApLCBCdChzKSwgdy5zdG9wUHJvcGFnYXRpb24oKSwgdy50eXBlLnN0YXJ0c1dpdGgoXCJ0b3VjaFwiKSAmJiB3LmNoYW5nZWRUb3VjaGVzLmxlbmd0aCA+IDEgJiYgdy5wcmV2ZW50RGVmYXVsdCgpO1xuICB9XG4gIGZ1bmN0aW9uIHYoKSB7XG4gICAgX2gocywgcCksIHNbdV0uY2xhc3NMaXN0LnJlbW92ZShqLnN0YXRlLmNsaWNraW5nKSwgcy5ldmVudC51bmJpbmQocy5vd25lckRvY3VtZW50LCBcIm1vdXNlbW92ZVwiLCBiKTtcbiAgfVxuICBmdW5jdGlvbiBDKHcsIEUpIHtcbiAgICBmID0gX1tsXSwgRSAmJiB3LnRvdWNoZXMgJiYgKHdbbl0gPSB3LnRvdWNoZXNbMF0ucGFnZVkpLCBnID0gd1tuXSwgbSA9IChzW2ldIC0gc1tlXSkgLyAoc1tvXSAtIHNbYV0pLCBFID8gcy5ldmVudC5iaW5kKHMub3duZXJEb2N1bWVudCwgXCJ0b3VjaG1vdmVcIiwgYikgOiAocy5ldmVudC5iaW5kKHMub3duZXJEb2N1bWVudCwgXCJtb3VzZW1vdmVcIiwgYiksIHMuZXZlbnQub25jZShzLm93bmVyRG9jdW1lbnQsIFwibW91c2V1cFwiLCB2KSwgdy5wcmV2ZW50RGVmYXVsdCgpKSwgc1t1XS5jbGFzc0xpc3QuYWRkKGouc3RhdGUuY2xpY2tpbmcpLCB3LnN0b3BQcm9wYWdhdGlvbigpO1xuICB9XG4gIHMuZXZlbnQuYmluZChzW3JdLCBcIm1vdXNlZG93blwiLCBmdW5jdGlvbih3KSB7XG4gICAgQyh3KTtcbiAgfSksIHMuZXZlbnQuYmluZChzW3JdLCBcInRvdWNoc3RhcnRcIiwgZnVuY3Rpb24odykge1xuICAgIEModywgITApO1xuICB9KTtcbn1cbmZ1bmN0aW9uIHV2KHMpIHtcbiAgdmFyIHQgPSBzLmVsZW1lbnQsIGUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gUXQodCwgXCI6aG92ZXJcIik7XG4gIH0sIGkgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gUXQocy5zY3JvbGxiYXJYLCBcIjpmb2N1c1wiKSB8fCBRdChzLnNjcm9sbGJhclksIFwiOmZvY3VzXCIpO1xuICB9O1xuICBmdW5jdGlvbiBuKG8sIHIpIHtcbiAgICB2YXIgYSA9IE1hdGguZmxvb3IodC5zY3JvbGxUb3ApO1xuICAgIGlmIChvID09PSAwKSB7XG4gICAgICBpZiAoIXMuc2Nyb2xsYmFyWUFjdGl2ZSlcbiAgICAgICAgcmV0dXJuICExO1xuICAgICAgaWYgKGEgPT09IDAgJiYgciA+IDAgfHwgYSA+PSBzLmNvbnRlbnRIZWlnaHQgLSBzLmNvbnRhaW5lckhlaWdodCAmJiByIDwgMClcbiAgICAgICAgcmV0dXJuICFzLnNldHRpbmdzLndoZWVsUHJvcGFnYXRpb247XG4gICAgfVxuICAgIHZhciBsID0gdC5zY3JvbGxMZWZ0O1xuICAgIGlmIChyID09PSAwKSB7XG4gICAgICBpZiAoIXMuc2Nyb2xsYmFyWEFjdGl2ZSlcbiAgICAgICAgcmV0dXJuICExO1xuICAgICAgaWYgKGwgPT09IDAgJiYgbyA8IDAgfHwgbCA+PSBzLmNvbnRlbnRXaWR0aCAtIHMuY29udGFpbmVyV2lkdGggJiYgbyA+IDApXG4gICAgICAgIHJldHVybiAhcy5zZXR0aW5ncy53aGVlbFByb3BhZ2F0aW9uO1xuICAgIH1cbiAgICByZXR1cm4gITA7XG4gIH1cbiAgcy5ldmVudC5iaW5kKHMub3duZXJEb2N1bWVudCwgXCJrZXlkb3duXCIsIGZ1bmN0aW9uKG8pIHtcbiAgICBpZiAoIShvLmlzRGVmYXVsdFByZXZlbnRlZCAmJiBvLmlzRGVmYXVsdFByZXZlbnRlZCgpIHx8IG8uZGVmYXVsdFByZXZlbnRlZCkgJiYgISghZSgpICYmICFpKCkpKSB7XG4gICAgICB2YXIgciA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPyBkb2N1bWVudC5hY3RpdmVFbGVtZW50IDogcy5vd25lckRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG4gICAgICBpZiAocikge1xuICAgICAgICBpZiAoci50YWdOYW1lID09PSBcIklGUkFNRVwiKVxuICAgICAgICAgIHIgPSByLmNvbnRlbnREb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICAgICAgICBlbHNlXG4gICAgICAgICAgZm9yICg7IHIuc2hhZG93Um9vdDsgKVxuICAgICAgICAgICAgciA9IHIuc2hhZG93Um9vdC5hY3RpdmVFbGVtZW50O1xuICAgICAgICBpZiAoYXYocikpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGEgPSAwLCBsID0gMDtcbiAgICAgIHN3aXRjaCAoby53aGljaCkge1xuICAgICAgICBjYXNlIDM3OlxuICAgICAgICAgIG8ubWV0YUtleSA/IGEgPSAtcy5jb250ZW50V2lkdGggOiBvLmFsdEtleSA/IGEgPSAtcy5jb250YWluZXJXaWR0aCA6IGEgPSAtMzA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzg6XG4gICAgICAgICAgby5tZXRhS2V5ID8gbCA9IHMuY29udGVudEhlaWdodCA6IG8uYWx0S2V5ID8gbCA9IHMuY29udGFpbmVySGVpZ2h0IDogbCA9IDMwO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM5OlxuICAgICAgICAgIG8ubWV0YUtleSA/IGEgPSBzLmNvbnRlbnRXaWR0aCA6IG8uYWx0S2V5ID8gYSA9IHMuY29udGFpbmVyV2lkdGggOiBhID0gMzA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNDA6XG4gICAgICAgICAgby5tZXRhS2V5ID8gbCA9IC1zLmNvbnRlbnRIZWlnaHQgOiBvLmFsdEtleSA/IGwgPSAtcy5jb250YWluZXJIZWlnaHQgOiBsID0gLTMwO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDMyOlxuICAgICAgICAgIG8uc2hpZnRLZXkgPyBsID0gcy5jb250YWluZXJIZWlnaHQgOiBsID0gLXMuY29udGFpbmVySGVpZ2h0O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDMzOlxuICAgICAgICAgIGwgPSBzLmNvbnRhaW5lckhlaWdodDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzNDpcbiAgICAgICAgICBsID0gLXMuY29udGFpbmVySGVpZ2h0O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM2OlxuICAgICAgICAgIGwgPSBzLmNvbnRlbnRIZWlnaHQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzU6XG4gICAgICAgICAgbCA9IC1zLmNvbnRlbnRIZWlnaHQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcy5zZXR0aW5ncy5zdXBwcmVzc1Njcm9sbFggJiYgYSAhPT0gMCB8fCBzLnNldHRpbmdzLnN1cHByZXNzU2Nyb2xsWSAmJiBsICE9PSAwIHx8ICh0LnNjcm9sbFRvcCAtPSBsLCB0LnNjcm9sbExlZnQgKz0gYSwgQnQocyksIG4oYSwgbCkgJiYgby5wcmV2ZW50RGVmYXVsdCgpKTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gcHYocykge1xuICB2YXIgdCA9IHMuZWxlbWVudDtcbiAgZnVuY3Rpb24gZShyLCBhKSB7XG4gICAgdmFyIGwgPSBNYXRoLmZsb29yKHQuc2Nyb2xsVG9wKSwgcCA9IHQuc2Nyb2xsVG9wID09PSAwLCB1ID0gbCArIHQub2Zmc2V0SGVpZ2h0ID09PSB0LnNjcm9sbEhlaWdodCwgXyA9IHQuc2Nyb2xsTGVmdCA9PT0gMCwgZiA9IHQuc2Nyb2xsTGVmdCArIHQub2Zmc2V0V2lkdGggPT09IHQuc2Nyb2xsV2lkdGgsIGc7XG4gICAgcmV0dXJuIE1hdGguYWJzKGEpID4gTWF0aC5hYnMocikgPyBnID0gcCB8fCB1IDogZyA9IF8gfHwgZiwgZyA/ICFzLnNldHRpbmdzLndoZWVsUHJvcGFnYXRpb24gOiAhMDtcbiAgfVxuICBmdW5jdGlvbiBpKHIpIHtcbiAgICB2YXIgYSA9IHIuZGVsdGFYLCBsID0gLTEgKiByLmRlbHRhWTtcbiAgICByZXR1cm4gKHR5cGVvZiBhID4gXCJ1XCIgfHwgdHlwZW9mIGwgPiBcInVcIikgJiYgKGEgPSAtMSAqIHIud2hlZWxEZWx0YVggLyA2LCBsID0gci53aGVlbERlbHRhWSAvIDYpLCByLmRlbHRhTW9kZSAmJiByLmRlbHRhTW9kZSA9PT0gMSAmJiAoYSAqPSAxMCwgbCAqPSAxMCksIGEgIT09IGEgJiYgbCAhPT0gbCAmJiAoYSA9IDAsIGwgPSByLndoZWVsRGVsdGEpLCByLnNoaWZ0S2V5ID8gWy1sLCAtYV0gOiBbYSwgbF07XG4gIH1cbiAgZnVuY3Rpb24gbihyLCBhLCBsKSB7XG4gICAgaWYgKCFOZS5pc1dlYktpdCAmJiB0LnF1ZXJ5U2VsZWN0b3IoXCJzZWxlY3Q6Zm9jdXNcIikpXG4gICAgICByZXR1cm4gITA7XG4gICAgaWYgKCF0LmNvbnRhaW5zKHIpKVxuICAgICAgcmV0dXJuICExO1xuICAgIGZvciAodmFyIHAgPSByOyBwICYmIHAgIT09IHQ7ICkge1xuICAgICAgaWYgKHAuY2xhc3NMaXN0LmNvbnRhaW5zKGouZWxlbWVudC5jb25zdW1pbmcpKVxuICAgICAgICByZXR1cm4gITA7XG4gICAgICB2YXIgdSA9IEx0KHApO1xuICAgICAgaWYgKGwgJiYgdS5vdmVyZmxvd1kubWF0Y2goLyhzY3JvbGx8YXV0bykvKSkge1xuICAgICAgICB2YXIgXyA9IHAuc2Nyb2xsSGVpZ2h0IC0gcC5jbGllbnRIZWlnaHQ7XG4gICAgICAgIGlmIChfID4gMCAmJiAocC5zY3JvbGxUb3AgPiAwICYmIGwgPCAwIHx8IHAuc2Nyb2xsVG9wIDwgXyAmJiBsID4gMCkpXG4gICAgICAgICAgcmV0dXJuICEwO1xuICAgICAgfVxuICAgICAgaWYgKGEgJiYgdS5vdmVyZmxvd1gubWF0Y2goLyhzY3JvbGx8YXV0bykvKSkge1xuICAgICAgICB2YXIgZiA9IHAuc2Nyb2xsV2lkdGggLSBwLmNsaWVudFdpZHRoO1xuICAgICAgICBpZiAoZiA+IDAgJiYgKHAuc2Nyb2xsTGVmdCA+IDAgJiYgYSA8IDAgfHwgcC5zY3JvbGxMZWZ0IDwgZiAmJiBhID4gMCkpXG4gICAgICAgICAgcmV0dXJuICEwO1xuICAgICAgfVxuICAgICAgcCA9IHAucGFyZW50Tm9kZTtcbiAgICB9XG4gICAgcmV0dXJuICExO1xuICB9XG4gIGZ1bmN0aW9uIG8ocikge1xuICAgIHZhciBhID0gaShyKSwgbCA9IGFbMF0sIHAgPSBhWzFdO1xuICAgIGlmICghbihyLnRhcmdldCwgbCwgcCkpIHtcbiAgICAgIHZhciB1ID0gITE7XG4gICAgICBzLnNldHRpbmdzLnVzZUJvdGhXaGVlbEF4ZXMgPyBzLnNjcm9sbGJhcllBY3RpdmUgJiYgIXMuc2Nyb2xsYmFyWEFjdGl2ZSA/IChwID8gdC5zY3JvbGxUb3AgLT0gcCAqIHMuc2V0dGluZ3Mud2hlZWxTcGVlZCA6IHQuc2Nyb2xsVG9wICs9IGwgKiBzLnNldHRpbmdzLndoZWVsU3BlZWQsIHUgPSAhMCkgOiBzLnNjcm9sbGJhclhBY3RpdmUgJiYgIXMuc2Nyb2xsYmFyWUFjdGl2ZSAmJiAobCA/IHQuc2Nyb2xsTGVmdCArPSBsICogcy5zZXR0aW5ncy53aGVlbFNwZWVkIDogdC5zY3JvbGxMZWZ0IC09IHAgKiBzLnNldHRpbmdzLndoZWVsU3BlZWQsIHUgPSAhMCkgOiAodC5zY3JvbGxUb3AgLT0gcCAqIHMuc2V0dGluZ3Mud2hlZWxTcGVlZCwgdC5zY3JvbGxMZWZ0ICs9IGwgKiBzLnNldHRpbmdzLndoZWVsU3BlZWQpLCBCdChzKSwgdSA9IHUgfHwgZShsLCBwKSwgdSAmJiAhci5jdHJsS2V5ICYmIChyLnN0b3BQcm9wYWdhdGlvbigpLCByLnByZXZlbnREZWZhdWx0KCkpO1xuICAgIH1cbiAgfVxuICB0eXBlb2Ygd2luZG93Lm9ud2hlZWwgPCBcInVcIiA/IHMuZXZlbnQuYmluZCh0LCBcIndoZWVsXCIsIG8pIDogdHlwZW9mIHdpbmRvdy5vbm1vdXNld2hlZWwgPCBcInVcIiAmJiBzLmV2ZW50LmJpbmQodCwgXCJtb3VzZXdoZWVsXCIsIG8pO1xufVxuZnVuY3Rpb24gX3Yocykge1xuICBpZiAoIU5lLnN1cHBvcnRzVG91Y2ggJiYgIU5lLnN1cHBvcnRzSWVQb2ludGVyKVxuICAgIHJldHVybjtcbiAgdmFyIHQgPSBzLmVsZW1lbnQ7XG4gIGZ1bmN0aW9uIGUobSwgYikge1xuICAgIHZhciB2ID0gTWF0aC5mbG9vcih0LnNjcm9sbFRvcCksIEMgPSB0LnNjcm9sbExlZnQsIHcgPSBNYXRoLmFicyhtKSwgRSA9IE1hdGguYWJzKGIpO1xuICAgIGlmIChFID4gdykge1xuICAgICAgaWYgKGIgPCAwICYmIHYgPT09IHMuY29udGVudEhlaWdodCAtIHMuY29udGFpbmVySGVpZ2h0IHx8IGIgPiAwICYmIHYgPT09IDApXG4gICAgICAgIHJldHVybiB3aW5kb3cuc2Nyb2xsWSA9PT0gMCAmJiBiID4gMCAmJiBOZS5pc0Nocm9tZTtcbiAgICB9IGVsc2UgaWYgKHcgPiBFICYmIChtIDwgMCAmJiBDID09PSBzLmNvbnRlbnRXaWR0aCAtIHMuY29udGFpbmVyV2lkdGggfHwgbSA+IDAgJiYgQyA9PT0gMCkpXG4gICAgICByZXR1cm4gITA7XG4gICAgcmV0dXJuICEwO1xuICB9XG4gIGZ1bmN0aW9uIGkobSwgYikge1xuICAgIHQuc2Nyb2xsVG9wIC09IGIsIHQuc2Nyb2xsTGVmdCAtPSBtLCBCdChzKTtcbiAgfVxuICB2YXIgbiA9IHt9LCBvID0gMCwgciA9IHt9LCBhID0gbnVsbDtcbiAgZnVuY3Rpb24gbChtKSB7XG4gICAgcmV0dXJuIG0udGFyZ2V0VG91Y2hlcyA/IG0udGFyZ2V0VG91Y2hlc1swXSA6IG07XG4gIH1cbiAgZnVuY3Rpb24gcChtKSB7XG4gICAgcmV0dXJuIG0ucG9pbnRlclR5cGUgJiYgbS5wb2ludGVyVHlwZSA9PT0gXCJwZW5cIiAmJiBtLmJ1dHRvbnMgPT09IDAgPyAhMSA6ICEhKG0udGFyZ2V0VG91Y2hlcyAmJiBtLnRhcmdldFRvdWNoZXMubGVuZ3RoID09PSAxIHx8IG0ucG9pbnRlclR5cGUgJiYgbS5wb2ludGVyVHlwZSAhPT0gXCJtb3VzZVwiICYmIG0ucG9pbnRlclR5cGUgIT09IG0uTVNQT0lOVEVSX1RZUEVfTU9VU0UpO1xuICB9XG4gIGZ1bmN0aW9uIHUobSkge1xuICAgIGlmIChwKG0pKSB7XG4gICAgICB2YXIgYiA9IGwobSk7XG4gICAgICBuLnBhZ2VYID0gYi5wYWdlWCwgbi5wYWdlWSA9IGIucGFnZVksIG8gPSAoLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCkpLmdldFRpbWUoKSwgYSAhPT0gbnVsbCAmJiBjbGVhckludGVydmFsKGEpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBfKG0sIGIsIHYpIHtcbiAgICBpZiAoIXQuY29udGFpbnMobSkpXG4gICAgICByZXR1cm4gITE7XG4gICAgZm9yICh2YXIgQyA9IG07IEMgJiYgQyAhPT0gdDsgKSB7XG4gICAgICBpZiAoQy5jbGFzc0xpc3QuY29udGFpbnMoai5lbGVtZW50LmNvbnN1bWluZykpXG4gICAgICAgIHJldHVybiAhMDtcbiAgICAgIHZhciB3ID0gTHQoQyk7XG4gICAgICBpZiAodiAmJiB3Lm92ZXJmbG93WS5tYXRjaCgvKHNjcm9sbHxhdXRvKS8pKSB7XG4gICAgICAgIHZhciBFID0gQy5zY3JvbGxIZWlnaHQgLSBDLmNsaWVudEhlaWdodDtcbiAgICAgICAgaWYgKEUgPiAwICYmIChDLnNjcm9sbFRvcCA+IDAgJiYgdiA8IDAgfHwgQy5zY3JvbGxUb3AgPCBFICYmIHYgPiAwKSlcbiAgICAgICAgICByZXR1cm4gITA7XG4gICAgICB9XG4gICAgICBpZiAoYiAmJiB3Lm92ZXJmbG93WC5tYXRjaCgvKHNjcm9sbHxhdXRvKS8pKSB7XG4gICAgICAgIHZhciBUID0gQy5zY3JvbGxXaWR0aCAtIEMuY2xpZW50V2lkdGg7XG4gICAgICAgIGlmIChUID4gMCAmJiAoQy5zY3JvbGxMZWZ0ID4gMCAmJiBiIDwgMCB8fCBDLnNjcm9sbExlZnQgPCBUICYmIGIgPiAwKSlcbiAgICAgICAgICByZXR1cm4gITA7XG4gICAgICB9XG4gICAgICBDID0gQy5wYXJlbnROb2RlO1xuICAgIH1cbiAgICByZXR1cm4gITE7XG4gIH1cbiAgZnVuY3Rpb24gZihtKSB7XG4gICAgaWYgKHAobSkpIHtcbiAgICAgIHZhciBiID0gbChtKSwgdiA9IHsgcGFnZVg6IGIucGFnZVgsIHBhZ2VZOiBiLnBhZ2VZIH0sIEMgPSB2LnBhZ2VYIC0gbi5wYWdlWCwgdyA9IHYucGFnZVkgLSBuLnBhZ2VZO1xuICAgICAgaWYgKF8obS50YXJnZXQsIEMsIHcpKVxuICAgICAgICByZXR1cm47XG4gICAgICBpKEMsIHcpLCBuID0gdjtcbiAgICAgIHZhciBFID0gKC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpKS5nZXRUaW1lKCksIFQgPSBFIC0gbztcbiAgICAgIFQgPiAwICYmIChyLnggPSBDIC8gVCwgci55ID0gdyAvIFQsIG8gPSBFKSwgZShDLCB3KSAmJiBtLnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGcoKSB7XG4gICAgcy5zZXR0aW5ncy5zd2lwZUVhc2luZyAmJiAoY2xlYXJJbnRlcnZhbChhKSwgYSA9IHNldEludGVydmFsKGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHMuaXNJbml0aWFsaXplZCkge1xuICAgICAgICBjbGVhckludGVydmFsKGEpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoIXIueCAmJiAhci55KSB7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwoYSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChNYXRoLmFicyhyLngpIDwgMC4wMSAmJiBNYXRoLmFicyhyLnkpIDwgMC4wMSkge1xuICAgICAgICBjbGVhckludGVydmFsKGEpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoIXMuZWxlbWVudCkge1xuICAgICAgICBjbGVhckludGVydmFsKGEpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpKHIueCAqIDMwLCByLnkgKiAzMCksIHIueCAqPSAwLjgsIHIueSAqPSAwLjg7XG4gICAgfSwgMTApKTtcbiAgfVxuICBOZS5zdXBwb3J0c1RvdWNoID8gKHMuZXZlbnQuYmluZCh0LCBcInRvdWNoc3RhcnRcIiwgdSksIHMuZXZlbnQuYmluZCh0LCBcInRvdWNobW92ZVwiLCBmKSwgcy5ldmVudC5iaW5kKHQsIFwidG91Y2hlbmRcIiwgZykpIDogTmUuc3VwcG9ydHNJZVBvaW50ZXIgJiYgKHdpbmRvdy5Qb2ludGVyRXZlbnQgPyAocy5ldmVudC5iaW5kKHQsIFwicG9pbnRlcmRvd25cIiwgdSksIHMuZXZlbnQuYmluZCh0LCBcInBvaW50ZXJtb3ZlXCIsIGYpLCBzLmV2ZW50LmJpbmQodCwgXCJwb2ludGVydXBcIiwgZykpIDogd2luZG93Lk1TUG9pbnRlckV2ZW50ICYmIChzLmV2ZW50LmJpbmQodCwgXCJNU1BvaW50ZXJEb3duXCIsIHUpLCBzLmV2ZW50LmJpbmQodCwgXCJNU1BvaW50ZXJNb3ZlXCIsIGYpLCBzLmV2ZW50LmJpbmQodCwgXCJNU1BvaW50ZXJVcFwiLCBnKSkpO1xufVxudmFyIGZ2ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB7XG4gICAgaGFuZGxlcnM6IFtcImNsaWNrLXJhaWxcIiwgXCJkcmFnLXRodW1iXCIsIFwia2V5Ym9hcmRcIiwgXCJ3aGVlbFwiLCBcInRvdWNoXCJdLFxuICAgIG1heFNjcm9sbGJhckxlbmd0aDogbnVsbCxcbiAgICBtaW5TY3JvbGxiYXJMZW5ndGg6IG51bGwsXG4gICAgc2Nyb2xsaW5nVGhyZXNob2xkOiAxZTMsXG4gICAgc2Nyb2xsWE1hcmdpbk9mZnNldDogMCxcbiAgICBzY3JvbGxZTWFyZ2luT2Zmc2V0OiAwLFxuICAgIHN1cHByZXNzU2Nyb2xsWDogITEsXG4gICAgc3VwcHJlc3NTY3JvbGxZOiAhMSxcbiAgICBzd2lwZUVhc2luZzogITAsXG4gICAgdXNlQm90aFdoZWVsQXhlczogITEsXG4gICAgd2hlZWxQcm9wYWdhdGlvbjogITAsXG4gICAgd2hlZWxTcGVlZDogMVxuICB9O1xufSwgbXYgPSB7XG4gIFwiY2xpY2stcmFpbFwiOiBodixcbiAgXCJkcmFnLXRodW1iXCI6IGR2LFxuICBrZXlib2FyZDogdXYsXG4gIHdoZWVsOiBwdixcbiAgdG91Y2g6IF92XG59LCBVaSA9IGZ1bmN0aW9uKHQsIGUpIHtcbiAgdmFyIGkgPSB0aGlzO1xuICBpZiAoZSA9PT0gdm9pZCAwICYmIChlID0ge30pLCB0eXBlb2YgdCA9PSBcInN0cmluZ1wiICYmICh0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0KSksICF0IHx8ICF0Lm5vZGVOYW1lKVxuICAgIHRocm93IG5ldyBFcnJvcihcIm5vIGVsZW1lbnQgaXMgc3BlY2lmaWVkIHRvIGluaXRpYWxpemUgUGVyZmVjdFNjcm9sbGJhclwiKTtcbiAgdGhpcy5lbGVtZW50ID0gdCwgdC5jbGFzc0xpc3QuYWRkKGoubWFpbiksIHRoaXMuc2V0dGluZ3MgPSBmdigpO1xuICBmb3IgKHZhciBuIGluIGUpXG4gICAgdGhpcy5zZXR0aW5nc1tuXSA9IGVbbl07XG4gIHRoaXMuY29udGFpbmVyV2lkdGggPSBudWxsLCB0aGlzLmNvbnRhaW5lckhlaWdodCA9IG51bGwsIHRoaXMuY29udGVudFdpZHRoID0gbnVsbCwgdGhpcy5jb250ZW50SGVpZ2h0ID0gbnVsbDtcbiAgdmFyIG8gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdC5jbGFzc0xpc3QuYWRkKGouc3RhdGUuZm9jdXMpO1xuICB9LCByID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHQuY2xhc3NMaXN0LnJlbW92ZShqLnN0YXRlLmZvY3VzKTtcbiAgfTtcbiAgdGhpcy5pc1J0bCA9IEx0KHQpLmRpcmVjdGlvbiA9PT0gXCJydGxcIiwgdGhpcy5pc1J0bCA9PT0gITAgJiYgdC5jbGFzc0xpc3QuYWRkKGoucnRsKSwgdGhpcy5pc05lZ2F0aXZlU2Nyb2xsID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHAgPSB0LnNjcm9sbExlZnQsIHUgPSBudWxsO1xuICAgIHJldHVybiB0LnNjcm9sbExlZnQgPSAtMSwgdSA9IHQuc2Nyb2xsTGVmdCA8IDAsIHQuc2Nyb2xsTGVmdCA9IHAsIHU7XG4gIH0oKSwgdGhpcy5uZWdhdGl2ZVNjcm9sbEFkanVzdG1lbnQgPSB0aGlzLmlzTmVnYXRpdmVTY3JvbGwgPyB0LnNjcm9sbFdpZHRoIC0gdC5jbGllbnRXaWR0aCA6IDAsIHRoaXMuZXZlbnQgPSBuZXcgc2koKSwgdGhpcy5vd25lckRvY3VtZW50ID0gdC5vd25lckRvY3VtZW50IHx8IGRvY3VtZW50LCB0aGlzLnNjcm9sbGJhclhSYWlsID0gd3Moai5lbGVtZW50LnJhaWwoXCJ4XCIpKSwgdC5hcHBlbmRDaGlsZCh0aGlzLnNjcm9sbGJhclhSYWlsKSwgdGhpcy5zY3JvbGxiYXJYID0gd3Moai5lbGVtZW50LnRodW1iKFwieFwiKSksIHRoaXMuc2Nyb2xsYmFyWFJhaWwuYXBwZW5kQ2hpbGQodGhpcy5zY3JvbGxiYXJYKSwgdGhpcy5zY3JvbGxiYXJYLnNldEF0dHJpYnV0ZShcInRhYmluZGV4XCIsIDApLCB0aGlzLmV2ZW50LmJpbmQodGhpcy5zY3JvbGxiYXJYLCBcImZvY3VzXCIsIG8pLCB0aGlzLmV2ZW50LmJpbmQodGhpcy5zY3JvbGxiYXJYLCBcImJsdXJcIiwgciksIHRoaXMuc2Nyb2xsYmFyWEFjdGl2ZSA9IG51bGwsIHRoaXMuc2Nyb2xsYmFyWFdpZHRoID0gbnVsbCwgdGhpcy5zY3JvbGxiYXJYTGVmdCA9IG51bGw7XG4gIHZhciBhID0gTHQodGhpcy5zY3JvbGxiYXJYUmFpbCk7XG4gIHRoaXMuc2Nyb2xsYmFyWEJvdHRvbSA9IHBhcnNlSW50KGEuYm90dG9tLCAxMCksIGlzTmFOKHRoaXMuc2Nyb2xsYmFyWEJvdHRvbSkgPyAodGhpcy5pc1Njcm9sbGJhclhVc2luZ0JvdHRvbSA9ICExLCB0aGlzLnNjcm9sbGJhclhUb3AgPSBXKGEudG9wKSkgOiB0aGlzLmlzU2Nyb2xsYmFyWFVzaW5nQm90dG9tID0gITAsIHRoaXMucmFpbEJvcmRlclhXaWR0aCA9IFcoYS5ib3JkZXJMZWZ0V2lkdGgpICsgVyhhLmJvcmRlclJpZ2h0V2lkdGgpLCBvdCh0aGlzLnNjcm9sbGJhclhSYWlsLCB7IGRpc3BsYXk6IFwiYmxvY2tcIiB9KSwgdGhpcy5yYWlsWE1hcmdpbldpZHRoID0gVyhhLm1hcmdpbkxlZnQpICsgVyhhLm1hcmdpblJpZ2h0KSwgb3QodGhpcy5zY3JvbGxiYXJYUmFpbCwgeyBkaXNwbGF5OiBcIlwiIH0pLCB0aGlzLnJhaWxYV2lkdGggPSBudWxsLCB0aGlzLnJhaWxYUmF0aW8gPSBudWxsLCB0aGlzLnNjcm9sbGJhcllSYWlsID0gd3Moai5lbGVtZW50LnJhaWwoXCJ5XCIpKSwgdC5hcHBlbmRDaGlsZCh0aGlzLnNjcm9sbGJhcllSYWlsKSwgdGhpcy5zY3JvbGxiYXJZID0gd3Moai5lbGVtZW50LnRodW1iKFwieVwiKSksIHRoaXMuc2Nyb2xsYmFyWVJhaWwuYXBwZW5kQ2hpbGQodGhpcy5zY3JvbGxiYXJZKSwgdGhpcy5zY3JvbGxiYXJZLnNldEF0dHJpYnV0ZShcInRhYmluZGV4XCIsIDApLCB0aGlzLmV2ZW50LmJpbmQodGhpcy5zY3JvbGxiYXJZLCBcImZvY3VzXCIsIG8pLCB0aGlzLmV2ZW50LmJpbmQodGhpcy5zY3JvbGxiYXJZLCBcImJsdXJcIiwgciksIHRoaXMuc2Nyb2xsYmFyWUFjdGl2ZSA9IG51bGwsIHRoaXMuc2Nyb2xsYmFyWUhlaWdodCA9IG51bGwsIHRoaXMuc2Nyb2xsYmFyWVRvcCA9IG51bGw7XG4gIHZhciBsID0gTHQodGhpcy5zY3JvbGxiYXJZUmFpbCk7XG4gIHRoaXMuc2Nyb2xsYmFyWVJpZ2h0ID0gcGFyc2VJbnQobC5yaWdodCwgMTApLCBpc05hTih0aGlzLnNjcm9sbGJhcllSaWdodCkgPyAodGhpcy5pc1Njcm9sbGJhcllVc2luZ1JpZ2h0ID0gITEsIHRoaXMuc2Nyb2xsYmFyWUxlZnQgPSBXKGwubGVmdCkpIDogdGhpcy5pc1Njcm9sbGJhcllVc2luZ1JpZ2h0ID0gITAsIHRoaXMuc2Nyb2xsYmFyWU91dGVyV2lkdGggPSB0aGlzLmlzUnRsID8gbHYodGhpcy5zY3JvbGxiYXJZKSA6IG51bGwsIHRoaXMucmFpbEJvcmRlcllXaWR0aCA9IFcobC5ib3JkZXJUb3BXaWR0aCkgKyBXKGwuYm9yZGVyQm90dG9tV2lkdGgpLCBvdCh0aGlzLnNjcm9sbGJhcllSYWlsLCB7IGRpc3BsYXk6IFwiYmxvY2tcIiB9KSwgdGhpcy5yYWlsWU1hcmdpbkhlaWdodCA9IFcobC5tYXJnaW5Ub3ApICsgVyhsLm1hcmdpbkJvdHRvbSksIG90KHRoaXMuc2Nyb2xsYmFyWVJhaWwsIHsgZGlzcGxheTogXCJcIiB9KSwgdGhpcy5yYWlsWUhlaWdodCA9IG51bGwsIHRoaXMucmFpbFlSYXRpbyA9IG51bGwsIHRoaXMucmVhY2ggPSB7XG4gICAgeDogdC5zY3JvbGxMZWZ0IDw9IDAgPyBcInN0YXJ0XCIgOiB0LnNjcm9sbExlZnQgPj0gdGhpcy5jb250ZW50V2lkdGggLSB0aGlzLmNvbnRhaW5lcldpZHRoID8gXCJlbmRcIiA6IG51bGwsXG4gICAgeTogdC5zY3JvbGxUb3AgPD0gMCA/IFwic3RhcnRcIiA6IHQuc2Nyb2xsVG9wID49IHRoaXMuY29udGVudEhlaWdodCAtIHRoaXMuY29udGFpbmVySGVpZ2h0ID8gXCJlbmRcIiA6IG51bGxcbiAgfSwgdGhpcy5pc0FsaXZlID0gITAsIHRoaXMuc2V0dGluZ3MuaGFuZGxlcnMuZm9yRWFjaChmdW5jdGlvbihwKSB7XG4gICAgcmV0dXJuIG12W3BdKGkpO1xuICB9KSwgdGhpcy5sYXN0U2Nyb2xsVG9wID0gTWF0aC5mbG9vcih0LnNjcm9sbFRvcCksIHRoaXMubGFzdFNjcm9sbExlZnQgPSB0LnNjcm9sbExlZnQsIHRoaXMuZXZlbnQuYmluZCh0aGlzLmVsZW1lbnQsIFwic2Nyb2xsXCIsIGZ1bmN0aW9uKHApIHtcbiAgICByZXR1cm4gaS5vblNjcm9sbChwKTtcbiAgfSksIEJ0KHRoaXMpO1xufTtcblVpLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5pc0FsaXZlICYmICh0aGlzLm5lZ2F0aXZlU2Nyb2xsQWRqdXN0bWVudCA9IHRoaXMuaXNOZWdhdGl2ZVNjcm9sbCA/IHRoaXMuZWxlbWVudC5zY3JvbGxXaWR0aCAtIHRoaXMuZWxlbWVudC5jbGllbnRXaWR0aCA6IDAsIG90KHRoaXMuc2Nyb2xsYmFyWFJhaWwsIHsgZGlzcGxheTogXCJibG9ja1wiIH0pLCBvdCh0aGlzLnNjcm9sbGJhcllSYWlsLCB7IGRpc3BsYXk6IFwiYmxvY2tcIiB9KSwgdGhpcy5yYWlsWE1hcmdpbldpZHRoID0gVyhMdCh0aGlzLnNjcm9sbGJhclhSYWlsKS5tYXJnaW5MZWZ0KSArIFcoTHQodGhpcy5zY3JvbGxiYXJYUmFpbCkubWFyZ2luUmlnaHQpLCB0aGlzLnJhaWxZTWFyZ2luSGVpZ2h0ID0gVyhMdCh0aGlzLnNjcm9sbGJhcllSYWlsKS5tYXJnaW5Ub3ApICsgVyhMdCh0aGlzLnNjcm9sbGJhcllSYWlsKS5tYXJnaW5Cb3R0b20pLCBvdCh0aGlzLnNjcm9sbGJhclhSYWlsLCB7IGRpc3BsYXk6IFwibm9uZVwiIH0pLCBvdCh0aGlzLnNjcm9sbGJhcllSYWlsLCB7IGRpc3BsYXk6IFwibm9uZVwiIH0pLCBCdCh0aGlzKSwgb24odGhpcywgXCJ0b3BcIiwgMCwgITEsICEwKSwgb24odGhpcywgXCJsZWZ0XCIsIDAsICExLCAhMCksIG90KHRoaXMuc2Nyb2xsYmFyWFJhaWwsIHsgZGlzcGxheTogXCJcIiB9KSwgb3QodGhpcy5zY3JvbGxiYXJZUmFpbCwgeyBkaXNwbGF5OiBcIlwiIH0pKTtcbn07XG5VaS5wcm90b3R5cGUub25TY3JvbGwgPSBmdW5jdGlvbih0KSB7XG4gIHRoaXMuaXNBbGl2ZSAmJiAoQnQodGhpcyksIG9uKHRoaXMsIFwidG9wXCIsIHRoaXMuZWxlbWVudC5zY3JvbGxUb3AgLSB0aGlzLmxhc3RTY3JvbGxUb3ApLCBvbihcbiAgICB0aGlzLFxuICAgIFwibGVmdFwiLFxuICAgIHRoaXMuZWxlbWVudC5zY3JvbGxMZWZ0IC0gdGhpcy5sYXN0U2Nyb2xsTGVmdFxuICApLCB0aGlzLmxhc3RTY3JvbGxUb3AgPSBNYXRoLmZsb29yKHRoaXMuZWxlbWVudC5zY3JvbGxUb3ApLCB0aGlzLmxhc3RTY3JvbGxMZWZ0ID0gdGhpcy5lbGVtZW50LnNjcm9sbExlZnQpO1xufTtcblVpLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuaXNBbGl2ZSAmJiAodGhpcy5ldmVudC51bmJpbmRBbGwoKSwgUGUodGhpcy5zY3JvbGxiYXJYKSwgUGUodGhpcy5zY3JvbGxiYXJZKSwgUGUodGhpcy5zY3JvbGxiYXJYUmFpbCksIFBlKHRoaXMuc2Nyb2xsYmFyWVJhaWwpLCB0aGlzLnJlbW92ZVBzQ2xhc3NlcygpLCB0aGlzLmVsZW1lbnQgPSBudWxsLCB0aGlzLnNjcm9sbGJhclggPSBudWxsLCB0aGlzLnNjcm9sbGJhclkgPSBudWxsLCB0aGlzLnNjcm9sbGJhclhSYWlsID0gbnVsbCwgdGhpcy5zY3JvbGxiYXJZUmFpbCA9IG51bGwsIHRoaXMuaXNBbGl2ZSA9ICExKTtcbn07XG5VaS5wcm90b3R5cGUucmVtb3ZlUHNDbGFzc2VzID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuZWxlbWVudC5jbGFzc05hbWUgPSB0aGlzLmVsZW1lbnQuY2xhc3NOYW1lLnNwbGl0KFwiIFwiKS5maWx0ZXIoZnVuY3Rpb24odCkge1xuICAgIHJldHVybiAhdC5tYXRjaCgvXnBzKFstX10uK3wpJC8pO1xuICB9KS5qb2luKFwiIFwiKTtcbn07XG5jb25zdCBwbyA9IFwicGVyZmVjdFNjcm9sbGJhclwiLCBndiA9IFwicGVyZmVjdC1zY3JvbGxiYXJcIiwgeHMgPSBcInRlLnBlcmZlY3RTY3JvbGxiYXJcIiwgT3QgPSBcInRlXCIsIFN0ID0gXCJwc1wiLCBfbyA9IFtcbiAgeyB0ZTogYHNjcm9sbFguJHtPdH0uJHtTdH1gLCBwczogXCJwcy1zY3JvbGwteFwiIH0sXG4gIHsgdGU6IGBzY3JvbGxZLiR7T3R9LiR7U3R9YCwgcHM6IFwicHMtc2Nyb2xsLXlcIiB9LFxuICB7IHRlOiBgc2Nyb2xsVXAuJHtPdH0uJHtTdH1gLCBwczogXCJwcy1zY3JvbGwtdXBcIiB9LFxuICB7IHRlOiBgc2Nyb2xsRG93bi4ke090fS4ke1N0fWAsIHBzOiBcInBzLXNjcm9sbC1kb3duXCIgfSxcbiAgeyB0ZTogYHNjcm9sbExlZnQuJHtPdH0uJHtTdH1gLCBwczogXCJwcy1zY3JvbGwtbGVmdFwiIH0sXG4gIHsgdGU6IGBzY3JvbGxSaWdodC4ke090fS4ke1N0fWAsIHBzOiBcInBzLXNjcm9sbC1yaWdodFwiIH0sXG4gIHsgdGU6IGBzY3JvbGxYRW5kLiR7T3R9LiR7U3R9YCwgcHM6IFwicHMteC1yZWFjaC1lbmRcIiB9LFxuICB7IHRlOiBgc2Nyb2xsWUVuZC4ke090fS4ke1N0fWAsIHBzOiBcInBzLXktcmVhY2gtZW5kXCIgfSxcbiAgeyB0ZTogYHNjcm9sbFhTdGFydC4ke090fS4ke1N0fWAsIHBzOiBcInBzLXgtcmVhY2gtc3RhcnRcIiB9LFxuICB7IHRlOiBgc2Nyb2xsWVN0YXJ0LiR7T3R9LiR7U3R9YCwgcHM6IFwicHMteS1yZWFjaC1zdGFydFwiIH1cbl0sIGJ2ID0ge1xuICBoYW5kbGVyczogW1wiY2xpY2stcmFpbFwiLCBcImRyYWctdGh1bWJcIiwgXCJrZXlib2FyZFwiLCBcIndoZWVsXCIsIFwidG91Y2hcIl0sXG4gIHdoZWVsU3BlZWQ6IDEsXG4gIHdoZWVsUHJvcGFnYXRpb246ICEwLFxuICBzd2lwZUVhc2luZzogITAsXG4gIG1pblNjcm9sbGJhckxlbmd0aDogbnVsbCxcbiAgbWF4U2Nyb2xsYmFyTGVuZ3RoOiBudWxsLFxuICBzY3JvbGxpbmdUaHJlc2hvbGQ6IDFlMyxcbiAgdXNlQm90aFdoZWVsQXhlczogITEsXG4gIHN1cHByZXNzU2Nyb2xsWDogITEsXG4gIHN1cHByZXNzU2Nyb2xsWTogITEsXG4gIHNjcm9sbFhNYXJnaW5PZmZzZXQ6IDAsXG4gIHNjcm9sbFlNYXJnaW5PZmZzZXQ6IDAsXG4gIHBvc2l0aW9uUmlnaHQ6ICEwXG59LCB2diA9IHtcbiAgaGFuZGxlcnM6IFwiKHN0cmluZ3xhcnJheSlcIixcbiAgd2hlZWxTcGVlZDogXCJudW1iZXJcIixcbiAgd2hlZWxQcm9wYWdhdGlvbjogXCJib29sZWFuXCIsXG4gIHN3aXBlRWFzaW5nOiBcImJvb2xlYW5cIixcbiAgbWluU2Nyb2xsYmFyTGVuZ3RoOiBcIihudW1iZXJ8bnVsbClcIixcbiAgbWF4U2Nyb2xsYmFyTGVuZ3RoOiBcIihudW1iZXJ8bnVsbClcIixcbiAgc2Nyb2xsaW5nVGhyZXNob2xkOiBcIm51bWJlclwiLFxuICB1c2VCb3RoV2hlZWxBeGVzOiBcImJvb2xlYW5cIixcbiAgc3VwcHJlc3NTY3JvbGxYOiBcImJvb2xlYW5cIixcbiAgc3VwcHJlc3NTY3JvbGxZOiBcImJvb2xlYW5cIixcbiAgc2Nyb2xsWE1hcmdpbk9mZnNldDogXCJudW1iZXJcIixcbiAgc2Nyb2xsWU1hcmdpbk9mZnNldDogXCJudW1iZXJcIixcbiAgcG9zaXRpb25SaWdodDogXCJib29sZWFuXCJcbn0sIFR2ID0ge1xuICBwczogXCJncm91cC9wcyBvdmVyZmxvdy1oaWRkZW4gW292ZXJmbG93LWFuY2hvcjpub25lXSB0b3VjaC1ub25lXCIsXG4gIHJhaWxYOiBcImdyb3VwL3ggYWJzb2x1dGUgYm90dG9tLTAgaC1bMC45Mzc1cmVtXSBoaWRkZW4gb3BhY2l0eS0wIHRyYW5zaXRpb24tW2JhY2tncm91bmQtY29sb3IsX29wYWNpdHldIGR1cmF0aW9uLTIwMCBlYXNlLWxpbmVhciBtb3Rpb24tcmVkdWNlOnRyYW5zaXRpb24tbm9uZSB6LVsxMDM1XSBncm91cC1bJi5wcy0tYWN0aXZlLXhdL3BzOmJsb2NrIGdyb3VwLWhvdmVyL3BzOm9wYWNpdHktNjAgZ3JvdXAtZm9jdXMvcHM6b3BhY2l0eS02MCBncm91cC1bJi5wcy0tc2Nyb2xsaW5nLXhdL3BzOm9wYWNpdHktNjAgaG92ZXI6IW9wYWNpdHktOTAgZm9jdXM6IW9wYWNpdHktOTAgWyYucHMtLWNsaWNraW5nXTohb3BhY2l0eS05MCBvdXRsaW5lLW5vbmVcIixcbiAgcmFpbFhDb2xvcnM6IFwiZ3JvdXAtWyYucHMtLWFjdGl2ZS14XS9wczpiZy10cmFuc3BhcmVudCBob3ZlcjohYmctWyNlZWVdIGZvY3VzOiFiZy1bI2VlZV0gWyYucHMtLWNsaWNraW5nXTohYmctWyNlZWVdIGRhcms6aG92ZXI6IWJnLVsjNTU1XSBkYXJrOmZvY3VzOiFiZy1bIzU1NV0gZGFyazpbJi5wcy0tY2xpY2tpbmddOiFiZy1bIzU1NV1cIixcbiAgcmFpbFhUaHVtYjogXCJhYnNvbHV0ZSBib3R0b20tMC41IHJvdW5kZWQtbWQgaC0xLjUgZ3JvdXAtZm9jdXMvcHM6b3BhY2l0eS0xMDAgZ3JvdXAtYWN0aXZlL3BzOm9wYWNpdHktMTAwIFt0cmFuc2l0aW9uOmJhY2tncm91bmQtY29sb3JfLjJzX2xpbmVhcixfaGVpZ2h0Xy4yc19lYXNlLWluLW91dF0gZ3JvdXAtaG92ZXIveDpoLVsxMXB4XSBncm91cC1mb2N1cy94OmgtWzAuNjg3NXJlbV0gZ3JvdXAtWyYucHMtLWNsaWNraW5nXS94OmJnLVsjOTk5XSBncm91cC1bJi5wcy0tY2xpY2tpbmddL3g6aC1bMTFweF0gb3V0bGluZS1ub25lXCIsXG4gIHJhaWxYVGh1bWJDb2xvcnM6IFwiYmctWyNhYWFdIGdyb3VwLWhvdmVyL3g6YmctWyM5OTldIGdyb3VwLWZvY3VzL3g6YmctWyM5OTldXCIsXG4gIHJhaWxZOiBcImdyb3VwL3kgYWJzb2x1dGUgcmlnaHQtMCB3LVswLjkzNzVyZW1dIGhpZGRlbiBvcGFjaXR5LTAgdHJhbnNpdGlvbi1bYmFja2dyb3VuZC1jb2xvcixfb3BhY2l0eV0gZHVyYXRpb24tMjAwIGVhc2UtbGluZWFyIG1vdGlvbi1yZWR1Y2U6dHJhbnNpdGlvbi1ub25lIHotWzEwMzVdIGdyb3VwLVsmLnBzLS1hY3RpdmUteV0vcHM6YmxvY2sgZ3JvdXAtaG92ZXIvcHM6b3BhY2l0eS02MCBncm91cC1mb2N1cy9wczpvcGFjaXR5LTYwIGdyb3VwLVsmLnBzLS1zY3JvbGxpbmcteV0vcHM6b3BhY2l0eS02MCBob3Zlcjohb3BhY2l0eS05MCBmb2N1czohb3BhY2l0eS05MCBbJi5wcy0tY2xpY2tpbmddOiFvcGFjaXR5LTkwIG91dGxpbmUtbm9uZVwiLFxuICByYWlsWUNvbG9yczogXCJncm91cC1bJi5wcy0tYWN0aXZlLXldL3BzOmJnLXRyYW5zcGFyZW50IGhvdmVyOiFiZy1bI2VlZV0gZm9jdXM6IWJnLVsjZWVlXSBbJi5wcy0tY2xpY2tpbmddOiFiZy1bI2VlZV0gZGFyazpob3ZlcjohYmctWyM1NTVdIGRhcms6Zm9jdXM6IWJnLVsjNTU1XSBkYXJrOlsmLnBzLS1jbGlja2luZ106IWJnLVsjNTU1XVwiLFxuICByYWlsWVRodW1iOiBcImFic29sdXRlIHJpZ2h0LTAuNSByb3VuZGVkLW1kIHctMS41IGdyb3VwLWZvY3VzL3BzOm9wYWNpdHktMTAwIGdyb3VwLWFjdGl2ZS9wczpvcGFjaXR5LTEwMCBbdHJhbnNpdGlvbjpiYWNrZ3JvdW5kLWNvbG9yXy4yc19saW5lYXIsX3dpZHRoXy4yc19lYXNlLWluLW91dCxfb3BhY2l0eV0gZ3JvdXAtaG92ZXIveTp3LVsxMXB4XSBncm91cC1mb2N1cy95OnctWzAuNjg3NXJlbV0gZ3JvdXAtWyYucHMtLWNsaWNraW5nXS95OnctWzExcHhdIG91dGxpbmUtbm9uZVwiLFxuICByYWlsWVRodW1iQ29sb3JzOiBcImJnLVsjYWFhXSBncm91cC1ob3Zlci95OmJnLVsjOTk5XSBncm91cC1mb2N1cy95OmJnLVsjOTk5XSBncm91cC1bJi5wcy0tY2xpY2tpbmddL3k6YmctWyM5OTldXCJcbn0sIEV2ID0ge1xuICBwczogXCJzdHJpbmdcIixcbiAgcmFpbFg6IFwic3RyaW5nXCIsXG4gIHJhaWxYQ29sb3JzOiBcInN0cmluZ1wiLFxuICByYWlsWFRodW1iOiBcInN0cmluZ1wiLFxuICByYWlsWFRodW1iQ29sb3JzOiBcInN0cmluZ1wiLFxuICByYWlsWTogXCJzdHJpbmdcIixcbiAgcmFpbFlDb2xvcnM6IFwic3RyaW5nXCIsXG4gIHJhaWxZVGh1bWI6IFwic3RyaW5nXCIsXG4gIHJhaWxZVGh1bWJDb2xvcnM6IFwic3RyaW5nXCJcbn07XG5jbGFzcyBmciB7XG4gIGNvbnN0cnVjdG9yKHQsIGUgPSB7fSwgaSA9IHt9KSB7XG4gICAgdGhpcy5fZWxlbWVudCA9IHQsIHRoaXMuX29wdGlvbnMgPSB0aGlzLl9nZXRDb25maWcoZSksIHRoaXMuX2NsYXNzZXMgPSB0aGlzLl9nZXRDbGFzc2VzKGkpLCB0aGlzLnBlcmZlY3RTY3JvbGxiYXIgPSBudWxsLCB0aGlzLl9vYnNlcnZlciA9IG51bGwsIHRoaXMuX3BzQ2xhc3NlcyA9IFtcbiAgICAgIHtcbiAgICAgICAgcHM6IFwicHNfX3JhaWwteFwiLFxuICAgICAgICB0ZTogdGhpcy5fY2xhc3Nlcy5yYWlsWCxcbiAgICAgICAgdGVDb2xvcjogdGhpcy5fY2xhc3Nlcy5yYWlsWENvbG9yc1xuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgcHM6IFwicHNfX3JhaWwteVwiLFxuICAgICAgICB0ZTogdGhpcy5fY2xhc3Nlcy5yYWlsWSxcbiAgICAgICAgdGVDb2xvcjogdGhpcy5fY2xhc3Nlcy5yYWlsWUNvbG9yc1xuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgcHM6IFwicHNfX3RodW1iLXhcIixcbiAgICAgICAgdGU6IHRoaXMuX2NsYXNzZXMucmFpbFhUaHVtYixcbiAgICAgICAgdGVDb2xvcjogdGhpcy5fY2xhc3Nlcy5yYWlsWFRodW1iQ29sb3JzXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBwczogXCJwc19fdGh1bWIteVwiLFxuICAgICAgICB0ZTogdGhpcy5fY2xhc3Nlcy5yYWlsWVRodW1iLFxuICAgICAgICB0ZUNvbG9yOiB0aGlzLl9jbGFzc2VzLnJhaWxZVGh1bWJDb2xvcnNcbiAgICAgIH1cbiAgICBdLCB0aGlzLl9lbGVtZW50ICYmICh5LnNldERhdGEodCwgeHMsIHRoaXMpLCBoLmFkZENsYXNzKHRoaXMuX2VsZW1lbnQsIGd2KSksIHRoaXMuaW5pdCgpO1xuICB9XG4gIC8vIEdldHRlcnNcbiAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgIHJldHVybiBwbztcbiAgfVxuICBnZXQgcmFpbFgoKSB7XG4gICAgcmV0dXJuIGQuZmluZE9uZShcIi5wc19fcmFpbC14XCIsIHRoaXMuX2VsZW1lbnQpO1xuICB9XG4gIGdldCByYWlsWSgpIHtcbiAgICByZXR1cm4gZC5maW5kT25lKFwiLnBzX19yYWlsLXlcIiwgdGhpcy5fZWxlbWVudCk7XG4gIH1cbiAgX2dldENvbmZpZyh0KSB7XG4gICAgY29uc3QgZSA9IGguZ2V0RGF0YUF0dHJpYnV0ZXModGhpcy5fZWxlbWVudCk7XG4gICAgcmV0dXJuIGUuaGFuZGxlcnMgIT09IHZvaWQgMCAmJiAoZS5oYW5kbGVycyA9IGUuaGFuZGxlcnMuc3BsaXQoXCIgXCIpKSwgdCA9IHtcbiAgICAgIC4uLmJ2LFxuICAgICAgLi4uZSxcbiAgICAgIC4uLnRcbiAgICB9LCBEKHBvLCB0LCB2diksIHQ7XG4gIH1cbiAgX2dldENsYXNzZXModCkge1xuICAgIGNvbnN0IGUgPSBoLmdldERhdGFDbGFzc0F0dHJpYnV0ZXModGhpcy5fZWxlbWVudCk7XG4gICAgcmV0dXJuIHQgPSB7XG4gICAgICAuLi5UdixcbiAgICAgIC4uLmUsXG4gICAgICAuLi50XG4gICAgfSwgRChwbywgdCwgRXYpLCB0O1xuICB9XG4gIC8vIFB1YmxpY1xuICBkaXNwb3NlKCkge1xuICAgIHRoaXMuX29wdGlvbnMucG9zaXRpb25SaWdodCAmJiB0aGlzLl9vYnNlcnZlci5kaXNjb25uZWN0KCksIHkucmVtb3ZlRGF0YSh0aGlzLl9lbGVtZW50LCB4cyksIHRoaXMuX2VsZW1lbnQgPSBudWxsLCB0aGlzLl9kYXRhQXR0ck9wdGlvbnMgPSBudWxsLCB0aGlzLl9vcHRpb25zID0gbnVsbCwgdGhpcy5wZXJmZWN0U2Nyb2xsYmFyLmRlc3Ryb3koKSwgdGhpcy5yZW1vdmVFdmVudChfbyksIHRoaXMucGVyZmVjdFNjcm9sbGJhciA9IG51bGw7XG4gIH1cbiAgaW5pdCgpIHtcbiAgICBpZiAodGhpcy5wZXJmZWN0U2Nyb2xsYmFyID0gbmV3IFVpKHRoaXMuX2VsZW1lbnQsIHRoaXMuX29wdGlvbnMpLCB0aGlzLl9hZGRQZXJmZWN0U2Nyb2xsYmFyU3R5bGVzKCksIHRoaXMuX3VwZGF0ZVNjcm9sbFBvc2l0aW9uKCksIHRoaXMucGVyZmVjdFNjcm9sbGJhci51cGRhdGUoKSwgdGhpcy5faW5pdEV2ZW50cyhfbyksIHRoaXMuX29wdGlvbnMucG9zaXRpb25SaWdodCkge1xuICAgICAgdGhpcy5fb2JzZXJ2ZXIgPSBuZXcgUmVzaXplT2JzZXJ2ZXIoKCkgPT4ge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICB0aGlzLl91cGRhdGVTY3JvbGxQb3NpdGlvbigpO1xuICAgICAgICB9LCAxMDApO1xuICAgICAgfSk7XG4gICAgICBjb25zdCB0ID0ge1xuICAgICAgICBhdHRyaWJ1dGVzOiAhMCxcbiAgICAgICAgYXR0cmlidXRlRmlsdGVyOiBbXCJjbGFzc1wiLCBcImNsYXNzTmFtZVwiXVxuICAgICAgfTtcbiAgICAgIHRoaXMuX29ic2VydmVyLm9ic2VydmUodGhpcy5fZWxlbWVudCwgdCk7XG4gICAgfVxuICB9XG4gIF91cGRhdGVTY3JvbGxQb3NpdGlvbigpIHtcbiAgICBjb25zdCB0ID0gZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLl9lbGVtZW50KS5nZXRQcm9wZXJ0eVZhbHVlKFwiaGVpZ2h0XCIpLCBlID0gZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLl9lbGVtZW50KS5nZXRQcm9wZXJ0eVZhbHVlKFwid2lkdGhcIik7XG4gICAgdGhpcy5yYWlsWCAmJiAodGhpcy5yYWlsWC5zdHlsZS50cmFuc2Zvcm0gPSBgdHJhbnNsYXRlWShjYWxjKC0xMDAlICsgJHt0aGlzLl9jYW5UcmFuc2Zvcm0odCkgPyB0IDogXCIwcHhcIn0pKWApLCB0aGlzLnJhaWxZICYmICh0aGlzLnJhaWxZLnN0eWxlLnRyYW5zZm9ybSA9IGB0cmFuc2xhdGVYKGNhbGMoLTEwMCUgKyAke3RoaXMuX2NhblRyYW5zZm9ybShlKSA/IGUgOiBcIjBweFwifSkpYCk7XG4gIH1cbiAgX2NhblRyYW5zZm9ybSh0KSB7XG4gICAgcmV0dXJuIHQgJiYgdC5pbmNsdWRlcyhcInB4XCIpO1xuICB9XG4gIHVwZGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5wZXJmZWN0U2Nyb2xsYmFyLnVwZGF0ZSgpO1xuICB9XG4gIF9pbml0RXZlbnRzKHQgPSBbXSkge1xuICAgIHQuZm9yRWFjaChcbiAgICAgICh7IHBzOiBlLCB0ZTogaSB9KSA9PiBjLm9uKFxuICAgICAgICB0aGlzLl9lbGVtZW50LFxuICAgICAgICBlLFxuICAgICAgICAobikgPT4gYy50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIGksIHsgZTogbiB9KVxuICAgICAgKVxuICAgICk7XG4gIH1cbiAgX2FkZFBlcmZlY3RTY3JvbGxiYXJTdHlsZXMoKSB7XG4gICAgdGhpcy5fcHNDbGFzc2VzLmZvckVhY2goKHQpID0+IHtcbiAgICAgIGNvbnN0IGUgPSBkLmZpbmRPbmUoYC4ke3QucHN9YCwgdGhpcy5fZWxlbWVudCk7XG4gICAgICBoLmFkZENsYXNzKGUsIHQudGUpLCBoLmFkZENsYXNzKGUsIHQudGVDb2xvcik7XG4gICAgfSksIGguYWRkQ2xhc3ModGhpcy5fZWxlbWVudCwgdGhpcy5fY2xhc3Nlcy5wcyksIGgucmVtb3ZlQ2xhc3ModGhpcy5fZWxlbWVudCwgXCJwc1wiKTtcbiAgfVxuICByZW1vdmVFdmVudCh0KSB7XG4gICAgbGV0IGUgPSBbXTtcbiAgICB0eXBlb2YgdCA9PSBcInN0cmluZ1wiICYmIChlID0gX28uZmlsdGVyKCh7IHRlOiBpIH0pID0+IGkgPT09IHQpKSwgZS5mb3JFYWNoKCh7IHBzOiBpLCB0ZTogbiB9KSA9PiB7XG4gICAgICBjLm9mZih0aGlzLl9lbGVtZW50LCBpKSwgYy5vZmYodGhpcy5fZWxlbWVudCwgbik7XG4gICAgfSk7XG4gIH1cbiAgLy8gU3RhdGljXG4gIHN0YXRpYyBqUXVlcnlJbnRlcmZhY2UodCkge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICBsZXQgZSA9IHkuZ2V0RGF0YSh0aGlzLCB4cyk7XG4gICAgICBjb25zdCBpID0gdHlwZW9mIHQgPT0gXCJvYmplY3RcIiAmJiB0O1xuICAgICAgaWYgKCEoIWUgJiYgL2Rpc3Bvc2V8aGlkZS8udGVzdCh0KSkgJiYgKGUgfHwgKGUgPSBuZXcgZnIodGhpcywgaSkpLCB0eXBlb2YgdCA9PSBcInN0cmluZ1wiKSkge1xuICAgICAgICBpZiAodHlwZW9mIGVbdF0gPiBcInVcIilcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBObyBtZXRob2QgbmFtZWQgXCIke3R9XCJgKTtcbiAgICAgICAgZVt0XSgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHN0YXRpYyBnZXRJbnN0YW5jZSh0KSB7XG4gICAgcmV0dXJuIHkuZ2V0RGF0YSh0LCB4cyk7XG4gIH1cbiAgc3RhdGljIGdldE9yQ3JlYXRlSW5zdGFuY2UodCwgZSA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0SW5zdGFuY2UodCkgfHwgbmV3IHRoaXModCwgdHlwZW9mIGUgPT0gXCJvYmplY3RcIiA/IGUgOiBudWxsKTtcbiAgfVxufVxuY29uc3QgbWggPSBmciwgQ3YgPSBcImRhdGEtdGUtZGF0YXRhYmxlLXNlbGVjdC1yZWZcIiwgQXYgPSBcImRhdGEtdGUtZGF0YXRhYmxlLXBhZ2luYXRpb24tbmF2LXJlZlwiLCB5diA9IFwiZGF0YS10ZS1kYXRhdGFibGUtcGFnaW5hdGlvbi1yaWdodC1yZWZcIiwgd3YgPSBcImRhdGEtdGUtZGF0YXRhYmxlLXBhZ2luYXRpb24tbGVmdC1yZWZcIiwga3YgPSBcImRhdGEtdGUtZGF0YXRhYmxlLXBhZ2luYXRpb24tc3RhcnQtcmVmXCIsIHh2ID0gXCJkYXRhLXRlLWRhdGF0YWJsZS1wYWdpbmF0aW9uLWVuZC1yZWZcIiwgT3YgPSAoe1xuICB0ZXh0OiBzLFxuICBlbnRyaWVzOiB0LFxuICBlbnRyaWVzT3B0aW9uczogZSxcbiAgZnVsbFBhZ2luYXRpb246IGksXG4gIHJvd3NUZXh0OiBuLFxuICBhbGxUZXh0OiBvLFxuICBwYWdpbmF0aW9uU3RhcnRJY29uVGVtcGxhdGU6IHIsXG4gIHBhZ2luYXRpb25MZWZ0SWNvblRlbXBsYXRlOiBhLFxuICBwYWdpbmF0aW9uUmlnaHRJY29uVGVtcGxhdGU6IGwsXG4gIHBhZ2luYXRpb25FbmRJY29uVGVtcGxhdGU6IHAsXG4gIGNsYXNzZXM6IHVcbn0sIF8sIGYpID0+IHtcbiAgY29uc3QgZyA9IGUubWFwKChtKSA9PiBtID09PSBcIkFsbFwiID8gYDxvcHRpb24gdmFsdWU9XCIke219XCIgJHttID09PSB0ID8gXCJzZWxlY3RlZFwiIDogXCJcIn0+JHtvfTwvb3B0aW9uPmAgOiBgPG9wdGlvbiB2YWx1ZT1cIiR7bX1cIiAke20gPT09IHQgPyBcInNlbGVjdGVkXCIgOiBcIlwifT4ke219PC9vcHRpb24+YCkuam9pbihgXG5gKTtcbiAgcmV0dXJuIGBcbjxkaXYgY2xhc3M9XCIke3UucGFnaW5hdGlvbn0gJHtmID8gYCR7dS5wYWdpbmF0aW9uQm9yZGVyZWR9YCA6IFwiXCJ9ICR7dS5ib3JkZXJDb2xvcn0gJHt1LmNvbG9yfVwiPlxuICA8ZGl2IGNsYXNzPVwiJHt1LnNlbGVjdEl0ZW1zV3JhcHBlcn1cIj4gIFxuICAgIDxwIGNsYXNzPVwiJHt1LnBhZ2luYXRpb25Sb3dzVGV4dH0gJHtfID8gYCR7dS5sb2FkaW5nUGFnaW5hdGlvblJvd3NUZXh0fWAgOiBcIlwifVwiPiR7bn08L3A+XG4gICAgPGRpdiBjbGFzcz1cIiR7dS5zZWxlY3RXcmFwcGVyfSAke18gPyBgJHt1LmxvYWRpbmdQYWdpbmF0aW9uU2VsZWN0V3JhcHBlcn1gIDogXCJcIn1cIj5cbiAgICAgIDxzZWxlY3QgbmFtZT1cImVudHJpZXNcIlxuICAgICAgICAke18gPyBcImRpc2FibGVkXCIgOiBcIlwifSBjbGFzcz1cInNlbGVjdFwiICR7Q3Z9PlxuICAgICAgICAke2d9XG4gICAgICA8L3NlbGVjdD5cbiAgICA8L2Rpdj5cbiAgPC9kaXY+XG4gIDxkaXYgY2xhc3M9XCIke3UucGFnaW5hdGlvbk5hdn0gJHtfID8gYCR7dS5sb2FkaW5nUGFnaW5hdGlvbk5hdn1gIDogXCJcIn1cIiAke0F2fT5cbiAgJHtzfVxuICA8L2Rpdj5cbiAgPGRpdiBjbGFzcz1cIiR7dS5wYWdpbmF0aW9uQnV0dG9uc1dyYXBwZXJ9XCI+XG4gICAgJHtpID8gYDxidXR0b24gZGF0YS10ZS1yaXBwbGUtaW5pdCBkYXRhLXRlLXJpcHBsZS1jb2xvcj1cImRhcmtcIiBjbGFzcz1cIiR7dS5wYWdpbmF0aW9uU3RhcnRCdXR0b259XCIgJHtrdn0+XG4gICAgICAgICAgICR7cn1cbiAgICAgICAgICA8L2J1dHRvbj5gIDogXCJcIn1cbiAgICA8YnV0dG9uIGRhdGEtdGUtcmlwcGxlLWluaXQgZGF0YS10ZS1yaXBwbGUtY29sb3I9XCJkYXJrXCIgY2xhc3M9XCIke3UucGFnaW5hdGlvbkxlZnRCdXR0b259XCIgJHt3dn0+XG4gICAgICAke2F9XG4gIDwvYnV0dG9uPlxuICAgIDxidXR0b24gZGF0YS10ZS1yaXBwbGUtaW5pdCBkYXRhLXRlLXJpcHBsZS1jb2xvcj1cImRhcmtcIiBjbGFzcz1cIiR7dS5wYWdpbmF0aW9uUmlnaHRCdXR0b259XCIgJHt5dn0+XG4gICAgICAke2x9XG4gIDwvYnV0dG9uPlxuICAgICR7aSA/IGA8YnV0dG9uIGRhdGEtdGUtcmlwcGxlLWluaXQgZGF0YS10ZS1yaXBwbGUtY29sb3I9XCJkYXJrXCIgY2xhc3M9XCIke3UucGFnaW5hdGlvbkVuZEJ1dHRvbn1cIiAke3h2fT5cbiAgICAgICAgICAgJHtwfVxuICAgICAgICAgIDwvYnV0dG9uPmAgOiBcIlwifVxuICA8L2Rpdj5cbjwvZGl2PlxuYDtcbn0sIFN2ID0gXCJkYXRhLXRlLWRhdGF0YWJsZS1zb3J0LWljb24tcmVmXCIsIEl2ID0gXCJkYXRhLXRlLWRhdGF0YWJsZS1oZWFkZXItY2hlY2tib3gtcmVmXCIsIER2ID0gKHMsIHQsIGUsIGksIG4sIG8sIHIsIGEpID0+IHtcbiAgY29uc3QgbCA9IGUgPyBgXG4gIDx0aCBzY29wZT1cImNvbFwiPlxuICAgIDxkaXYgY2xhc3M9XCIke2EuY2hlY2tib3hIZWFkZXJXcmFwcGVyfVwiPlxuICAgICAgPGlucHV0XG4gICAgICAgIGNsYXNzPVwiJHthLmNoZWNrYm94SGVhZGVyfVwiXG4gICAgICAgIHR5cGU9XCJjaGVja2JveFwiXG4gICAgICAgIHZhbHVlPVwiXCJcbiAgICAgICAgJHtJdn1cbiAgICAgICAgLz5cbiAgICA8L2Rpdj5cbiAgPC90aD5cbiAgYCA6ICc8dGggc2NvcGU9XCJjb2xcIj48L3RoPicsIHAgPSBzLm1hcCgodSwgXykgPT4ge1xuICAgIGNvbnN0IGYgPSB1LmZpeGVkID8gcy5maWx0ZXIoKGcsIG0pID0+IGcuZml4ZWQgPT09IHUuZml4ZWQgJiYgbSA8IF8pLnJlZHVjZSgoZywgbSkgPT4gZyArIG0ud2lkdGgsIDApIDogbnVsbDtcbiAgICByZXR1cm4gYDx0aCBjbGFzcz1cIiR7YS5jb2x1bW59ICR7aSA/IGAke2EudGFibGVCb3JkZXJlZH1gIDogXCJcIn0gJHthLmJvcmRlckNvbG9yfSAke24gPyBgJHthLnNtfWAgOiBcIlwifSAke3UuZml4ZWQgPyBgJHthLmZpeGVkSGVhZGVyfSAke2EuY29sb3J9YCA6IFwiXCJ9ICR7byA/IGAke2EubG9hZGluZ0NvbHVtbn1gIDogXCJcIn1cIiBzdHlsZT1cIiR7dS5maXhlZCA/IGAke3UuZml4ZWQgPT09IFwicmlnaHRcIiA/IFwicmlnaHRcIiA6IFwibGVmdFwifTogJHtmfXB4O2AgOiBcIlwifVwiIHNjb3BlPVwiY29sXCI+JHt1LnNvcnQgPyBgPGRpdiBjbGFzcz1cIiR7YS5zb3J0SWNvbldyYXBwZXJ9XCI+PHNwYW4gY2xhc3M9XCIke2Euc29ydEljb259ICR7byA/IFwiaW52aXNpYmxlXCIgOiBcIlwifVwiIGRhdGEtdGUtc29ydD1cIiR7dS5maWVsZH1cIiAke1N2fT4ke3J9PC9zcGFuPmAgOiBcIlwifSA8c3BhbiBjbGFzcz1cIiR7dS5zb3J0ID8gXCJcIiA6IFwicGwtWzE4cHhdXCJ9XCI+JHt1LmxhYmVsfTwvc3Bhbj48L2Rpdj48L3RoPmA7XG4gIH0pO1xuICByZXR1cm4gW3QgPyBsIDogXCJcIiwgLi4ucF0uam9pbihgXG5gKTtcbn0sICR2ID0gXCJkYXRhLXRlLWRhdGF0YWJsZS1yb3ctcmVmXCIsIEx2ID0gXCJkYXRhLXRlLWRhdGF0YWJsZS1yb3ctY2hlY2tib3gtcmVmXCIsIE52ID0gXCJkYXRhLXRlLWRhdGF0YWJsZS1jZWxsLXJlZlwiLCBNdiA9ICh7XG4gIHJvd3M6IHMsXG4gIGNvbHVtbnM6IHQsXG4gIG5vRm91bmRNZXNzYWdlOiBlLFxuICBlZGl0OiBpLFxuICBzZWxlY3RhYmxlOiBuLFxuICBsb2FkaW5nOiBvLFxuICBib3JkZXJlZDogcixcbiAgYm9yZGVybGVzczogYSxcbiAgc3RyaXBlZDogbCxcbiAgaG92ZXI6IHAsXG4gIHNtOiB1LFxuICBjbGFzc2VzOiBfXG59KSA9PiB7XG4gIGNvbnN0IGYgPSBzLm1hcCgoZykgPT4ge1xuICAgIGNvbnN0IG0gPSBgXG4gICAgICA8dGQgZGF0YS10ZS1maWVsZD1cImNoZWNrYm94XCIgY2xhc3M9XCIke3IgPyBgJHtfLnRhYmxlQm9yZGVyZWR9ICR7Xy5ib3JkZXJDb2xvcn1gIDogXCJcIn1cIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cIiR7Xy5jaGVja2JveFJvd1dyYXBwZXJ9XCI+XG4gICAgICAgICAgPGlucHV0XG4gICAgICAgICAgICBjbGFzcz1cIiR7Xy5jaGVja2JveFJvd31cIlxuICAgICAgICAgICAgdHlwZT1cImNoZWNrYm94XCJcbiAgICAgICAgICAgIHZhbHVlPVwiXCJcbiAgICAgICAgICAgIGRhdGEtdGUtcm93LWluZGV4PVwiJHtnLnJvd0luZGV4fVwiICAke0x2fS8+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC90ZD5gLCBiID0gdC5tYXAoKHYsIEMpID0+IHtcbiAgICAgIGNvbnN0IHcgPSB7fTtcbiAgICAgIGlmICh2LndpZHRoICYmICh3W1wibWluLXdpZHRoXCJdID0gYCR7di53aWR0aCAtIDF9cHhgLCB3W1wibWF4LXdpZHRoXCJdID0gYCR7di53aWR0aH1weGAsIHcud2lkdGggPSBgJHt2LndpZHRofXB4YCksIHYuZml4ZWQpIHtcbiAgICAgICAgY29uc3QgVCA9IHQuZmlsdGVyKChBLCBrKSA9PiBBLmZpeGVkID09PSB2LmZpeGVkICYmIGsgPCBDKS5yZWR1Y2UoKEEsIGspID0+IEEgKyBrLndpZHRoLCAwKTtcbiAgICAgICAgd1t2LmZpeGVkID09PSBcInJpZ2h0XCIgPyBcInJpZ2h0XCIgOiBcImxlZnRcIl0gPSBgJHtUfXB4YDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBgPHRkIHN0eWxlPVwiJHtPYmplY3Qua2V5cyh3KS5tYXAoKFQpID0+IGAke1R9OiAke3dbVF19YCkuam9pbihcIjsgXCIpfVwiIGNsYXNzPVwiJHtfLnJvd0l0ZW19ICR7Xy5ib3JkZXJDb2xvcn0gJHtpID8gYCR7Xy5lZGl0fWAgOiBcIlwifSAke3IgPyBgJHtfLnRhYmxlQm9yZGVyZWR9YCA6IFwiXCJ9ICR7dSA/IGAke18uc219YCA6IFwiXCJ9ICR7di5maXhlZCA/IGAke18uZml4ZWRIZWFkZXJ9ICR7Xy5jb2xvcn1gIDogXCJcIn1cIiAke052fSBkYXRhLXRlLWZpZWxkPVwiJHt2LmZpZWxkfVwiICR7aSAmJiAnY29udGVudGVkaXRhYmxlPVwidHJ1ZVwiJ30+JHtnW3YuZmllbGRdfTwvdGQ+YDtcbiAgICB9KS5qb2luKFwiXCIpO1xuICAgIHJldHVybiBgPHRyIHNjb3BlPVwicm93XCIgY2xhc3M9XCIke18ucm93fSAke18uYm9yZGVyQ29sb3J9ICR7Xy5yb3dBbmltYXRpb259ICR7bCA/IGAke18uc3RyaXBlZH1gIDogXCJcIn0gJHthID8gYCR7Xy5ib3JkZXJsZXNzfWAgOiBcIlwifSAke3AgPyBgJHtfLmhvdmVyUm93fWAgOiBcIlwifVwiIGRhdGEtdGUtaW5kZXg9XCIke2cucm93SW5kZXh9XCIgJHskdn0+JHtuID8gbSA6IFwiXCJ9JHtifTwvdHI+YDtcbiAgfSk7XG4gIHJldHVybiBzLmxlbmd0aCA+IDAgfHwgbyA/IGYuam9pbihgXG5gKSA6IGA8dHIgY2xhc3M9XCIke18ubm9Gb3VuZE1lc3NhZ2VXcmFwcGVyfSAke18uYm9yZGVyQ29sb3J9XCI+PHRkIGNsYXNzPVwiJHtfLm5vRm91bmRNZXNzYWdlfVwiPiR7ZX08L3RkPjwvdHI+YDtcbn0sIFJ2ID0gXCJkYXRhLXRlLWRhdGF0YWJsZS1pbm5lci1yZWZcIiwgUHYgPSBcImRhdGEtdGUtZGF0YXRhYmxlLWhlYWRlci1yZWZcIiwgd2wgPSAoe1xuICBjb2x1bW5zOiBzLFxuICByb3dzOiB0LFxuICBub0ZvdW5kTWVzc2FnZTogZSxcbiAgZWRpdDogaSxcbiAgbXVsdGk6IG4sXG4gIHNlbGVjdGFibGU6IG8sXG4gIGxvYWRpbmc6IHIsXG4gIGxvYWRpbmdNZXNzYWdlOiBhLFxuICBwYWdpbmF0aW9uOiBsLFxuICBib3JkZXJlZDogcCxcbiAgYm9yZGVybGVzczogdSxcbiAgc3RyaXBlZDogXyxcbiAgaG92ZXI6IGYsXG4gIGZpeGVkSGVhZGVyOiBnLFxuICBzbTogbSxcbiAgc29ydEljb25UZW1wbGF0ZTogYixcbiAgY2xhc3NlczogdlxufSkgPT4ge1xuICBjb25zdCBDID0gTXYoe1xuICAgIHJvd3M6IHQsXG4gICAgY29sdW1uczogcyxcbiAgICBub0ZvdW5kTWVzc2FnZTogZSxcbiAgICBlZGl0OiBpLFxuICAgIGxvYWRpbmc6IHIsXG4gICAgc2VsZWN0YWJsZTogbyxcbiAgICBib3JkZXJlZDogcCxcbiAgICBib3JkZXJsZXNzOiB1LFxuICAgIHN0cmlwZWQ6IF8sXG4gICAgaG92ZXI6IGYsXG4gICAgc206IG0sXG4gICAgY2xhc3NlczogdlxuICB9KSwgdyA9IER2KFxuICAgIHMsXG4gICAgbyxcbiAgICBuLFxuICAgIHAsXG4gICAgbSxcbiAgICByLFxuICAgIGIsXG4gICAgdlxuICApO1xuICByZXR1cm4geyB0YWJsZTogYFxuPGRpdiBjbGFzcz1cIiR7di5jb2xvcn1cIiAke1J2fT5cbiAgPHRhYmxlIGNsYXNzPVwiJHt2LnRhYmxlfVwiPlxuICAgIDx0aGVhZCBjbGFzcz1cIiR7di50YWJsZUhlYWRlcn0gJHtwID8gYCR7di50YWJsZUJvcmRlcmVkfWAgOiBcIlwifSAke3UgPyBgJHt2LmJvcmRlcmxlc3N9YCA6IFwiXCJ9ICR7di5ib3JkZXJDb2xvcn1cIiAke1B2fT5cbiAgICAgIDx0cj5cbiAgICAgICAgJHt3fVxuICAgICAgPC90cj5cbiAgICA8L3RoZWFkPlxuICAgIDx0Ym9keSBjbGFzcz1cIiR7ZyA/IGAke3YuZml4ZWRIZWFkZXJCb2R5fWAgOiBcIlwifVwiPlxuICAgICAgJHtyID8gXCJcIiA6IEN9XG4gICAgPC90Ym9keT5cbiAgPC90YWJsZT5cbjwvZGl2PlxuJHtyID8gYFxuICA8ZGl2IGNsYXNzPVwiJHt2LmxvYWRpbmdJdGVtc1dyYXBwZXJ9XCI+XG4gICAgPGRpdiBjbGFzcz1cIiR7di5sb2FkaW5nUHJvZ3Jlc3NCYXJXcmFwcGVyfVwiPlxuICAgICAgPGRpdiBjbGFzcz1cIiR7di5sb2FkaW5nUHJvZ3Jlc3NCYXJ9XCI+PC9kaXY+XG4gICAgPC9kaXY+XG4gIDwvZGl2PlxuPHAgY2xhc3M9XCIke3YubG9hZGluZ01lc3NhZ2V9XCI+JHthfTwvcD5cbmAgOiBcIlwifVxuJHtsLmVuYWJsZSA/IE92KGwsIHIsIHApIDogXCJcIn1cbiAgYCwgcm93czogQywgY29sdW1uOiB3IH07XG59LCBCdiA9ICh7IHJvd3M6IHMsIGZpZWxkOiB0LCBvcmRlcjogZSB9KSA9PiBzLnNvcnQoKG4sIG8pID0+IHtcbiAgbGV0IHIgPSBuW3RdLCBhID0gb1t0XTtcbiAgcmV0dXJuIHR5cGVvZiByID09IFwic3RyaW5nXCIgJiYgKHIgPSByLnRvTG93ZXJDYXNlKCkpLCB0eXBlb2YgYSA9PSBcInN0cmluZ1wiICYmIChhID0gYS50b0xvd2VyQ2FzZSgpKSwgciA8IGEgPyBlID09PSBcImRlc2NcIiA/IDEgOiAtMSA6IHIgPiBhID8gZSA9PT0gXCJkZXNjXCIgPyAtMSA6IDEgOiAwO1xufSksIEh2ID0gKHMsIHQsIGUpID0+IHtcbiAgaWYgKCF0KVxuICAgIHJldHVybiBzO1xuICBjb25zdCBpID0gKG4pID0+IHtcbiAgICBjb25zdCBvID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICByZXR1cm4gby5pbm5lckhUTUwgPSBuLCBuID0gby50ZXh0Q29udGVudCB8fCBvLmlubmVyVGV4dCB8fCBcIlwiLCBuLnRvU3RyaW5nKCkudG9Mb3dlckNhc2UoKS5tYXRjaCh0LnRvTG93ZXJDYXNlKCkpO1xuICB9O1xuICByZXR1cm4gcy5maWx0ZXIoKG4pID0+IHtcbiAgICBpZiAoZSAmJiB0eXBlb2YgZSA9PSBcInN0cmluZ1wiKVxuICAgICAgcmV0dXJuIGkobltlXSk7XG4gICAgbGV0IG8gPSBPYmplY3QudmFsdWVzKG4pO1xuICAgIHJldHVybiBlICYmIEFycmF5LmlzQXJyYXkoZSkgJiYgKG8gPSBPYmplY3Qua2V5cyhuKS5maWx0ZXIoKHIpID0+IGUuaW5jbHVkZXMocikpLm1hcCgocikgPT4gbltyXSkpLCBvLmZpbHRlcigocikgPT4gaShyKSkubGVuZ3RoID4gMDtcbiAgfSk7XG59LCBrbCA9ICh7IHJvd3M6IHMsIGVudHJpZXM6IHQsIGFjdGl2ZVBhZ2U6IGUgfSkgPT4ge1xuICBjb25zdCBpID0gZSAqIHQ7XG4gIHJldHVybiBzLnNsaWNlKGksIGkgKyBOdW1iZXIodCkpO1xufSwgTmkgPSBcImRhdGF0YWJsZVwiLCBmdCA9IGBkYXRhLXRlLSR7Tml9YCwgRWkgPSBgdGUuJHtOaX1gLCBfbiA9IGAuJHtFaX1gLCBWdiA9IGBbJHtmdH0taW5uZXItcmVmXWAsIGZvID0gYFske2Z0fS1jZWxsLXJlZl1gLCBXdiA9IGBbJHtmdH0taGVhZGVyLXJlZl1gLCBGdiA9IGBbJHtmdH0taGVhZGVyLWNoZWNrYm94LXJlZl1gLCBZdiA9IGBbJHtmdH0tcGFnaW5hdGlvbi1yaWdodC1yZWZdYCwganYgPSBgWyR7ZnR9LXBhZ2luYXRpb24tbGVmdC1yZWZdYCwgS3YgPSBgWyR7ZnR9LXBhZ2luYXRpb24tc3RhcnQtcmVmXWAsIHp2ID0gYFske2Z0fS1wYWdpbmF0aW9uLWVuZC1yZWZdYCwgVXYgPSBgWyR7ZnR9LXBhZ2luYXRpb24tbmF2LXJlZl1gLCBYdiA9IGBbJHtmdH0tc2VsZWN0LXJlZl1gLCBtbyA9IGBbJHtmdH0tc29ydC1pY29uLXJlZl1gLCBmaSA9IGBbJHtmdH0tcm93LXJlZl1gLCBnbyA9IGBbJHtmdH0tcm93LWNoZWNrYm94LXJlZl1gLCBHdiA9IGBzZWxlY3RSb3dzJHtfbn1gLCB4bCA9IGByZW5kZXIke19ufWAsIHF2ID0gYHJvd0NsaWNrJHtfbn1gLCBadiA9IGB1cGRhdGUke19ufWAsIFF2ID0gYDxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIGZpbGw9XCJjdXJyZW50Q29sb3JcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgc3Ryb2tlLXdpZHRoPVwiM1wiIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiPlxuICA8cGF0aCBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIiBkPVwiTTQuNSAxMC41TDEyIDNtMCAwbDcuNSA3LjVNMTIgM3YxOFwiIC8+XG48L3N2Zz5gLCBKdiA9IGA8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiBmaWxsPVwibm9uZVwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBzdHJva2Utd2lkdGg9XCIxLjVcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBjbGFzcz1cInctNCBoLTRcIj5cbiAgPHBhdGggc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCIgZD1cIk0xOC43NSAxOS41bC03LjUtNy41IDcuNS03LjVtLTYgMTVMNS4yNSAxMmw3LjUtNy41XCIgLz5cbjwvc3ZnPmAsIHRUID0gYDxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIGZpbGw9XCJub25lXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIHN0cm9rZS13aWR0aD1cIjEuNVwiIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIGNsYXNzPVwidy00IGgtNFwiPlxuICA8cGF0aCBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIiBkPVwiTTE1Ljc1IDE5LjVMOC4yNSAxMmw3LjUtNy41XCIgLz5cbjwvc3ZnPmAsIGVUID0gYDxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIGZpbGw9XCJub25lXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIHN0cm9rZS13aWR0aD1cIjEuNVwiIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIGNsYXNzPVwidy00IGgtNFwiPlxuICA8cGF0aCBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIiBkPVwiTTguMjUgNC41bDcuNSA3LjUtNy41IDcuNVwiIC8+XG48L3N2Zz5gLCBpVCA9IGA8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiBmaWxsPVwibm9uZVwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBzdHJva2Utd2lkdGg9XCIxLjVcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBjbGFzcz1cInctNCBoLTRcIj5cbiAgPHBhdGggc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCIgZD1cIk0xMS4yNSA0LjVsNy41IDcuNS03LjUgNy41bS02LTE1bDcuNSA3LjUtNy41IDcuNVwiLz5cbjwvc3ZnPmAsIHNUID0gXCJib3JkZXItbmV1dHJhbC0yMDAgZGFyazpib3JkZXItbmV1dHJhbC01MDBcIiwgblQgPSBcImJvcmRlci1ub25lXCIsIG9UID0gXCJyZWxhdGl2ZSBmbG9hdC1sZWZ0IC1tbC1bMS41cmVtXSBtci1bNnB4XSBtdC1bMC4xNXJlbV0gaC1bMS4xMjVyZW1dIHctWzEuMTI1cmVtXSBhcHBlYXJhbmNlLW5vbmUgcm91bmRlZC1bMC4yNXJlbV0gYm9yZGVyLVswLjEyNXJlbV0gYm9yZGVyLXNvbGlkIGJvcmRlci1uZXV0cmFsLTMwMCBvdXRsaW5lLW5vbmUgYmVmb3JlOnBvaW50ZXItZXZlbnRzLW5vbmUgYmVmb3JlOmFic29sdXRlIGJlZm9yZTpoLVswLjg3NXJlbV0gYmVmb3JlOnctWzAuODc1cmVtXSBiZWZvcmU6c2NhbGUtMCBiZWZvcmU6cm91bmRlZC1mdWxsIGJlZm9yZTpiZy10cmFuc3BhcmVudCBiZWZvcmU6b3BhY2l0eS0wIGJlZm9yZTpzaGFkb3ctWzBweF8wcHhfMHB4XzEzcHhfdHJhbnNwYXJlbnRdIGJlZm9yZTpjb250ZW50LVsnJ10gY2hlY2tlZDpib3JkZXItcHJpbWFyeSBjaGVja2VkOmJnLXByaW1hcnkgY2hlY2tlZDpiZWZvcmU6b3BhY2l0eS1bMC4xNl0gY2hlY2tlZDphZnRlcjphYnNvbHV0ZSBjaGVja2VkOmFmdGVyOi1tdC1weCBjaGVja2VkOmFmdGVyOm1sLVswLjI1cmVtXSBjaGVja2VkOmFmdGVyOmJsb2NrIGNoZWNrZWQ6YWZ0ZXI6aC1bMC44MTI1cmVtXSBjaGVja2VkOmFmdGVyOnctWzAuMzc1cmVtXSBjaGVja2VkOmFmdGVyOnJvdGF0ZS00NSBjaGVja2VkOmFmdGVyOmJvcmRlci1bMC4xMjVyZW1dIGNoZWNrZWQ6YWZ0ZXI6Ym9yZGVyLWwtMCBjaGVja2VkOmFmdGVyOmJvcmRlci10LTAgY2hlY2tlZDphZnRlcjpib3JkZXItc29saWQgY2hlY2tlZDphZnRlcjpib3JkZXItd2hpdGUgY2hlY2tlZDphZnRlcjpiZy10cmFuc3BhcmVudCBjaGVja2VkOmFmdGVyOmNvbnRlbnQtWycnXSBob3ZlcjpjdXJzb3ItcG9pbnRlciBob3ZlcjpiZWZvcmU6b3BhY2l0eS1bMC4wNF0gaG92ZXI6YmVmb3JlOnNoYWRvdy1bMHB4XzBweF8wcHhfMTNweF9yZ2JhKDAsMCwwLDAuNildIGZvY3VzOnNoYWRvdy1ub25lIGZvY3VzOnRyYW5zaXRpb24tW2JvcmRlci1jb2xvcl8wLjJzXSBmb2N1czpiZWZvcmU6c2NhbGUtMTAwIGZvY3VzOmJlZm9yZTpvcGFjaXR5LVswLjEyXSBmb2N1czpiZWZvcmU6c2hhZG93LVswcHhfMHB4XzBweF8xM3B4X3JnYmEoMCwwLDAsMC42KV0gZm9jdXM6YmVmb3JlOnRyYW5zaXRpb24tW2JveC1zaGFkb3dfMC4ycyx0cmFuc2Zvcm1fMC4yc10gZm9jdXM6YWZ0ZXI6YWJzb2x1dGUgZm9jdXM6YWZ0ZXI6ei1bMV0gZm9jdXM6YWZ0ZXI6YmxvY2sgZm9jdXM6YWZ0ZXI6aC1bMC44NzVyZW1dIGZvY3VzOmFmdGVyOnctWzAuODc1cmVtXSBmb2N1czphZnRlcjpyb3VuZGVkLVswLjEyNXJlbV0gZm9jdXM6YWZ0ZXI6Y29udGVudC1bJyddIGNoZWNrZWQ6Zm9jdXM6YmVmb3JlOnNjYWxlLTEwMCBjaGVja2VkOmZvY3VzOmJlZm9yZTpzaGFkb3ctWzBweF8wcHhfMHB4XzEzcHhfIzNiNzFjYV0gY2hlY2tlZDpmb2N1czpiZWZvcmU6dHJhbnNpdGlvbi1bYm94LXNoYWRvd18wLjJzLHRyYW5zZm9ybV8wLjJzXSBjaGVja2VkOmZvY3VzOmFmdGVyOi1tdC1weCBjaGVja2VkOmZvY3VzOmFmdGVyOm1sLVswLjI1cmVtXSBjaGVja2VkOmZvY3VzOmFmdGVyOmgtWzAuODEyNXJlbV0gY2hlY2tlZDpmb2N1czphZnRlcjp3LVswLjM3NXJlbV0gY2hlY2tlZDpmb2N1czphZnRlcjpyb3RhdGUtNDUgY2hlY2tlZDpmb2N1czphZnRlcjpyb3VuZGVkLW5vbmUgY2hlY2tlZDpmb2N1czphZnRlcjpib3JkZXItWzAuMTI1cmVtXSBjaGVja2VkOmZvY3VzOmFmdGVyOmJvcmRlci1sLTAgY2hlY2tlZDpmb2N1czphZnRlcjpib3JkZXItdC0wIGNoZWNrZWQ6Zm9jdXM6YWZ0ZXI6Ym9yZGVyLXNvbGlkIGNoZWNrZWQ6Zm9jdXM6YWZ0ZXI6Ym9yZGVyLXdoaXRlIGNoZWNrZWQ6Zm9jdXM6YWZ0ZXI6YmctdHJhbnNwYXJlbnQgZGFyazpib3JkZXItbmV1dHJhbC02MDAgZGFyazpjaGVja2VkOmJvcmRlci1wcmltYXJ5IGRhcms6Y2hlY2tlZDpiZy1wcmltYXJ5IGRhcms6Zm9jdXM6YmVmb3JlOnNoYWRvdy1bMHB4XzBweF8wcHhfMTNweF9yZ2JhKDI1NSwyNTUsMjU1LDAuNCldIGRhcms6Y2hlY2tlZDpmb2N1czpiZWZvcmU6c2hhZG93LVswcHhfMHB4XzBweF8xM3B4XyMzYjcxY2FdIGRhcms6Ym9yZGVyLW5ldXRyYWwtNDAwXCIsIHJUID0gXCJtYi1bMC4xMjVyZW1dIG1pbi1oLVsxLjVyZW1dIHBsLVsxLjVyZW1dIG1sLTMgZmxleCBpdGVtcy1jZW50ZXJcIiwgYVQgPSBcInJlbGF0aXZlIGZsb2F0LWxlZnQgLW1sLVsxLjVyZW1dIG1yLVs2cHhdIG10LVswLjE1cmVtXSBoLVsxLjEyNXJlbV0gdy1bMS4xMjVyZW1dIGFwcGVhcmFuY2Utbm9uZSByb3VuZGVkLVswLjI1cmVtXSBib3JkZXItWzAuMTI1cmVtXSBib3JkZXItc29saWQgYm9yZGVyLW5ldXRyYWwtMzAwIG91dGxpbmUtbm9uZSBiZWZvcmU6cG9pbnRlci1ldmVudHMtbm9uZSBiZWZvcmU6YWJzb2x1dGUgYmVmb3JlOmgtWzAuODc1cmVtXSBiZWZvcmU6dy1bMC44NzVyZW1dIGJlZm9yZTpzY2FsZS0wIGJlZm9yZTpyb3VuZGVkLWZ1bGwgYmVmb3JlOmJnLXRyYW5zcGFyZW50IGJlZm9yZTpvcGFjaXR5LTAgYmVmb3JlOnNoYWRvdy1bMHB4XzBweF8wcHhfMTNweF90cmFuc3BhcmVudF0gYmVmb3JlOmNvbnRlbnQtWycnXSBjaGVja2VkOmJvcmRlci1wcmltYXJ5IGNoZWNrZWQ6YmctcHJpbWFyeSBjaGVja2VkOmJlZm9yZTpvcGFjaXR5LVswLjE2XSBjaGVja2VkOmFmdGVyOmFic29sdXRlIGNoZWNrZWQ6YWZ0ZXI6LW10LXB4IGNoZWNrZWQ6YWZ0ZXI6bWwtWzAuMjVyZW1dIGNoZWNrZWQ6YWZ0ZXI6YmxvY2sgY2hlY2tlZDphZnRlcjpoLVswLjgxMjVyZW1dIGNoZWNrZWQ6YWZ0ZXI6dy1bMC4zNzVyZW1dIGNoZWNrZWQ6YWZ0ZXI6cm90YXRlLTQ1IGNoZWNrZWQ6YWZ0ZXI6Ym9yZGVyLVswLjEyNXJlbV0gY2hlY2tlZDphZnRlcjpib3JkZXItbC0wIGNoZWNrZWQ6YWZ0ZXI6Ym9yZGVyLXQtMCBjaGVja2VkOmFmdGVyOmJvcmRlci1zb2xpZCBjaGVja2VkOmFmdGVyOmJvcmRlci13aGl0ZSBjaGVja2VkOmFmdGVyOmJnLXRyYW5zcGFyZW50IGNoZWNrZWQ6YWZ0ZXI6Y29udGVudC1bJyddIGhvdmVyOmN1cnNvci1wb2ludGVyIGhvdmVyOmJlZm9yZTpvcGFjaXR5LVswLjA0XSBob3ZlcjpiZWZvcmU6c2hhZG93LVswcHhfMHB4XzBweF8xM3B4X3JnYmEoMCwwLDAsMC42KV0gZm9jdXM6c2hhZG93LW5vbmUgZm9jdXM6dHJhbnNpdGlvbi1bYm9yZGVyLWNvbG9yXzAuMnNdIGZvY3VzOmJlZm9yZTpzY2FsZS0xMDAgZm9jdXM6YmVmb3JlOm9wYWNpdHktWzAuMTJdIGZvY3VzOmJlZm9yZTpzaGFkb3ctWzBweF8wcHhfMHB4XzEzcHhfcmdiYSgwLDAsMCwwLjYpXSBmb2N1czpiZWZvcmU6dHJhbnNpdGlvbi1bYm94LXNoYWRvd18wLjJzLHRyYW5zZm9ybV8wLjJzXSBmb2N1czphZnRlcjphYnNvbHV0ZSBmb2N1czphZnRlcjp6LVsxXSBmb2N1czphZnRlcjpibG9jayBmb2N1czphZnRlcjpoLVswLjg3NXJlbV0gZm9jdXM6YWZ0ZXI6dy1bMC44NzVyZW1dIGZvY3VzOmFmdGVyOnJvdW5kZWQtWzAuMTI1cmVtXSBmb2N1czphZnRlcjpjb250ZW50LVsnJ10gY2hlY2tlZDpmb2N1czpiZWZvcmU6c2NhbGUtMTAwIGNoZWNrZWQ6Zm9jdXM6YmVmb3JlOnNoYWRvdy1bMHB4XzBweF8wcHhfMTNweF8jM2I3MWNhXSBjaGVja2VkOmZvY3VzOmJlZm9yZTp0cmFuc2l0aW9uLVtib3gtc2hhZG93XzAuMnMsdHJhbnNmb3JtXzAuMnNdIGNoZWNrZWQ6Zm9jdXM6YWZ0ZXI6LW10LXB4IGNoZWNrZWQ6Zm9jdXM6YWZ0ZXI6bWwtWzAuMjVyZW1dIGNoZWNrZWQ6Zm9jdXM6YWZ0ZXI6aC1bMC44MTI1cmVtXSBjaGVja2VkOmZvY3VzOmFmdGVyOnctWzAuMzc1cmVtXSBjaGVja2VkOmZvY3VzOmFmdGVyOnJvdGF0ZS00NSBjaGVja2VkOmZvY3VzOmFmdGVyOnJvdW5kZWQtbm9uZSBjaGVja2VkOmZvY3VzOmFmdGVyOmJvcmRlci1bMC4xMjVyZW1dIGNoZWNrZWQ6Zm9jdXM6YWZ0ZXI6Ym9yZGVyLWwtMCBjaGVja2VkOmZvY3VzOmFmdGVyOmJvcmRlci10LTAgY2hlY2tlZDpmb2N1czphZnRlcjpib3JkZXItc29saWQgY2hlY2tlZDpmb2N1czphZnRlcjpib3JkZXItd2hpdGUgY2hlY2tlZDpmb2N1czphZnRlcjpiZy10cmFuc3BhcmVudCBkYXJrOmJvcmRlci1uZXV0cmFsLTYwMCBkYXJrOmNoZWNrZWQ6Ym9yZGVyLXByaW1hcnkgZGFyazpjaGVja2VkOmJnLXByaW1hcnkgZGFyazpmb2N1czpiZWZvcmU6c2hhZG93LVswcHhfMHB4XzBweF8xM3B4X3JnYmEoMjU1LDI1NSwyNTUsMC40KV0gZGFyazpjaGVja2VkOmZvY3VzOmJlZm9yZTpzaGFkb3ctWzBweF8wcHhfMHB4XzEzcHhfIzNiNzFjYV0gZGFyazpib3JkZXItbmV1dHJhbC00MDBcIiwgbFQgPSBcIm1iLVswLjEyNXJlbV0gbWluLWgtWzEuNXJlbV0gcGwtWzEuNXJlbV0gbWwtMyBmbGV4IGl0ZW1zLWNlbnRlclwiLCBjVCA9IFwiYmctd2hpdGUgZGFyazpiZy1uZXV0cmFsLTgwMFwiLCBoVCA9IFwicHktNCBwbC0xIHRleHQtY2xpcCBvdmVyZmxvdy1oaWRkZW4gdGV4dC1bIzIxMjUyOV0gZGFyazp0ZXh0LXdoaXRlXCIsIGRUID0gXCJmb2N1czpvdXRsaW5lLW5vbmVcIiwgdVQgPSBcInN0aWNreSB0b3AtMCB6LTMwXCIsIHBUID0gXCJzdGlja3kgei0xMCBiZy1pbmhlcml0XCIsIF9UID0gXCJob3ZlcjpiZy1uZXV0cmFsLTEwMCBkYXJrOmhvdmVyOmJnLW5ldXRyYWwtNzAwXCIsIGZUID0gXCJwb2ludGVyLWV2ZW50cy1ub25lIGN1cnNvci1ub25lIHRleHQtbmV1dHJhbC00MDAgZGFyazp0ZXh0LW5ldXRyYWwtMzAwXCIsIG1UID0gXCJoLVsycHhdIHJlbGF0aXZlIHctZnVsbCBvdmVyZmxvdy1oaWRkZW5cIiwgZ1QgPSBcInRleHQtY2VudGVyIHRleHQtbmV1dHJhbC01MDAgZm9udC1saWdoIHRleHQtc20gbXktNCBkYXJrOnRleHQtbmV1dHJhbC00MDBcIiwgYlQgPSBcInRleHQtbmV1dHJhbC01MDAgZGFyazp0ZXh0LW5ldXRyYWwtMzAwXCIsIHZUID0gXCJ0ZXh0LW5ldXRyYWwtNTAwIGRhcms6dGV4dC1uZXV0cmFsLTMwMFwiLCBUVCA9IFwicG9pbnRlci1ldmVudHMtbm9uZSBjdXJzb3Itbm9uZVwiLCBFVCA9IFwiaC1mdWxsIHctWzQ1JV0gYmctcHJpbWFyeS00MDAgZGFyazpiZy1wcmltYXJ5LTYwMFwiLCBDVCA9IFwiaC1mdWxsIGFuaW1hdGUtW3Byb2dyZXNzXzNzX2Vhc2UtaW4tb3V0X2luZmluaXRlXVwiLCBBVCA9IFwicGwtMiBweS0zIGZvbnQtbGlnaHQgdGV4dC1zbSBkYXJrOnRleHQtbmV1dHJhbC0zMDBcIiwgeVQgPSBcImJvcmRlci1iXCIsIHdUID0gXCJmbGV4IG1kOmZsZXgtcm93IGp1c3RpZnktZW5kIGl0ZW1zLWNlbnRlciBweS0yIHNwYWNlLXgtNCB0ZXh0LXNtIGZsZXgtY29sIGxlYWRpbmctWzEuNl1cIiwga1QgPSBcImJvcmRlciBib3JkZXItdC0wXCIsIHhUID0gXCJvcmRlci0xIG15LTMgbWQ6b3JkZXItbm9uZSBtZDpteS0wIG1kOnByLTFcIiwgT1QgPSBcImlubGluZS1ibG9jayByb3VuZGVkIHAtMi41IHRleHQteHMgZm9udC1tZWRpdW0gdXBwZXJjYXNlIGxlYWRpbmctbm9ybWFsIHRyYW5zaXRpb24gZHVyYXRpb24tMTUwIGVhc2UtaW4tb3V0IGhvdmVyOmJnLW5ldXRyYWwtMTAwIGhvdmVyOnRleHQtcHJpbWFyeS02MDAgZm9jdXM6dGV4dC1wcmltYXJ5LTYwMCBmb2N1czpvdXRsaW5lLW5vbmUgZm9jdXM6cmluZy0wIGFjdGl2ZTp0ZXh0LXByaW1hcnktNzAwIGRpc2FibGVkOnRleHQtc2xhdGUtMzAwIGRpc2FibGVkOmhvdmVyOmJnLXRyYW5zcGFyZW50IGRhcms6aG92ZXI6YmctbmV1dHJhbC01MDAgZGFyazpkaXNhYmxlZDpob3ZlcjpiZy10cmFuc3BhcmVudCBkYXJrOmRpc2FibGVkOnRleHQtbmV1dHJhbC02MDBcIiwgU1QgPSBcImlubGluZS1ibG9jayByb3VuZGVkIHAtMi41IGZvbnQtbWVkaXVtIHVwcGVyY2FzZSBsZWFkaW5nLW5vcm1hbCB0cmFuc2l0aW9uIGR1cmF0aW9uLTE1MCBlYXNlLWluLW91dCBob3ZlcjpiZy1uZXV0cmFsLTEwMCBob3Zlcjp0ZXh0LXByaW1hcnktNjAwIGZvY3VzOnRleHQtcHJpbWFyeS02MDAgZm9jdXM6b3V0bGluZS1ub25lIGZvY3VzOnJpbmctMCBhY3RpdmU6dGV4dC1wcmltYXJ5LTcwMCBkaXNhYmxlZDp0ZXh0LXNsYXRlLTMwMCBkaXNhYmxlZDpob3ZlcjpiZy10cmFuc3BhcmVudCBkYXJrOmhvdmVyOmJnLW5ldXRyYWwtNTAwIGRhcms6ZGlzYWJsZWQ6aG92ZXI6YmctdHJhbnNwYXJlbnQgZGFyazpkaXNhYmxlZDp0ZXh0LW5ldXRyYWwtNjAwXCIsIElUID0gXCJmb250LW5vcm1hbCBvcmRlci0yIG1iLTMgbWQ6b3JkZXItbm9uZSBtZDptYi0wXCIsIERUID0gXCJpbmxpbmUtYmxvY2sgcm91bmRlZCBwLTIuNSBmb250LW1lZGl1bSB1cHBlcmNhc2UgbGVhZGluZy1ub3JtYWwgdHJhbnNpdGlvbiBkdXJhdGlvbi0xNTAgZWFzZS1pbi1vdXQgaG92ZXI6YmctbmV1dHJhbC0xMDAgaG92ZXI6dGV4dC1wcmltYXJ5LTYwMCBmb2N1czp0ZXh0LXByaW1hcnktNjAwIGZvY3VzOm91dGxpbmUtbm9uZSBmb2N1czpyaW5nLTAgYWN0aXZlOnRleHQtcHJpbWFyeS03MDAgZGlzYWJsZWQ6dGV4dC1zbGF0ZS0zMDAgZGlzYWJsZWQ6aG92ZXI6YmctdHJhbnNwYXJlbnQgZGFyazpob3ZlcjpiZy1uZXV0cmFsLTUwMCBkYXJrOmRpc2FibGVkOmhvdmVyOmJnLXRyYW5zcGFyZW50IGRhcms6ZGlzYWJsZWQ6dGV4dC1uZXV0cmFsLTYwMFwiLCAkVCA9IFwiZm9udC1saWdodFwiLCBMVCA9IFwiaW5saW5lLWJsb2NrIHJvdW5kZWQgcC0yLjUgZm9udC1tZWRpdW0gdXBwZXJjYXNlIGxlYWRpbmctbm9ybWFsIHRyYW5zaXRpb24gZHVyYXRpb24tMTUwIGVhc2UtaW4tb3V0IGhvdmVyOmJnLW5ldXRyYWwtMTAwIGhvdmVyOnRleHQtcHJpbWFyeS02MDAgZm9jdXM6dGV4dC1wcmltYXJ5LTYwMCBmb2N1czpvdXRsaW5lLW5vbmUgZm9jdXM6cmluZy0wIGFjdGl2ZTp0ZXh0LXByaW1hcnktNzAwIGRpc2FibGVkOnRleHQtc2xhdGUtMzAwIGRpc2FibGVkOmhvdmVyOmJnLXRyYW5zcGFyZW50IGRhcms6aG92ZXI6YmctbmV1dHJhbC01MDAgZGFyazpkaXNhYmxlZDpob3ZlcjpiZy10cmFuc3BhcmVudCBkYXJrOmRpc2FibGVkOnRleHQtbmV1dHJhbC02MDBcIiwgTlQgPSBcImJvcmRlci1iXCIsIE1UID0gXCJ0cmFuc2l0aW9uIGVhc2UtaW4tb3V0IGR1cmF0aW9uLTMwMCBtb3Rpb24tcmVkdWNlOnRyYW5zaXRpb24tbm9uZVwiLCBSVCA9IFwid2hpdGVzcGFjZS1ub3dyYXAgdGV4dC1jbGlwIG92ZXJmbG93LWhpZGRlbiBweC1bMS40cmVtXSBweS00XCIsIFBUID0gXCJyZWxhdGl2ZVwiLCBCVCA9IFwiIWJnLW5ldXRyYWwtMTAwIGRhcms6IWJnLW5ldXRyYWwtNjAwXCIsIEhUID0gXCJmbGV4IGl0ZW1zLWNlbnRlciBzcGFjZS14LTQgb3JkZXItMyBtZDpvcmRlci1ub25lXCIsIFZUID0gXCJ3LVs3MHB4XVwiLCBXVCA9IFwiIXB5LTJcIiwgRlQgPSBcInctWzE1cHhdIGgtWzEwcHhdIG9yaWdpbi1ib3R0b20gZm9udC1ibGFjayBtci0xIG9wYWNpdHktMCB0ZXh0LW5ldXRyYWwtNTAwIGdyb3VwLWhvdmVyOm9wYWNpdHktMTAwIHRyYW5zaXRpb24gaG92ZXI6ZWFzZS1pbi1vdXQgdHJhbnNmb3JtIGVhc2UtbGluZWFyIGR1cmF0aW9uLTMwMCBtb3Rpb24tcmVkdWNlOnRyYW5zaXRpb24tbm9uZSBkYXJrOnRleHQtbmV1dHJhbC00MDBcIiwgWVQgPSBcImZsZXggZmxleC1yb3cgZ3JvdXBcIiwgalQgPSBcIlsmOm50aC1jaGlsZChvZGQpXTpiZy1uZXV0cmFsLTUwIFsmOm50aC1jaGlsZChvZGQpXTpkYXJrOmJnLW5ldXRyYWwtNzAwXCIsIEtUID0gXCJib3JkZXJcIiwgelQgPSBcImJvcmRlci1iIGZvbnQtbm9ybWFsIHB4LVsxLjRyZW1dXCIsIFVUID0gXCJ0ZXh0LWxlZnQgdGV4dC1zbSBmb250LWxpZ2h0IHctZnVsbCBsZWFkaW5nLVsxLjZdXCIsIFhUID0ge1xuICBib3JkZXJlZDogXCJib29sZWFuXCIsXG4gIGJvcmRlcmxlc3M6IFwiYm9vbGVhblwiLFxuICBjbGlja2FibGVSb3dzOiBcImJvb2xlYW5cIixcbiAgZGVmYXVsdFZhbHVlOiBcInN0cmluZ1wiLFxuICBlZGl0OiBcImJvb2xlYW5cIixcbiAgZW50cmllczogXCIobnVtYmVyfHN0cmluZylcIixcbiAgZW50cmllc09wdGlvbnM6IFwiYXJyYXlcIixcbiAgZnVsbFBhZ2luYXRpb246IFwiYm9vbGVhblwiLFxuICBob3ZlcjogXCJib29sZWFuXCIsXG4gIGxvYWRpbmc6IFwiYm9vbGVhblwiLFxuICBsb2FkaW5nTWVzc2FnZTogXCJzdHJpbmdcIixcbiAgbWF4V2lkdGg6IFwiKG51bGx8bnVtYmVyfHN0cmluZylcIixcbiAgbWF4SGVpZ2h0OiBcIihudWxsfG51bWJlcnxzdHJpbmcpXCIsXG4gIG11bHRpOiBcImJvb2xlYW5cIixcbiAgbm9Gb3VuZE1lc3NhZ2U6IFwic3RyaW5nXCIsXG4gIHBhZ2luYXRpb246IFwiYm9vbGVhblwiLFxuICBzZWxlY3RhYmxlOiBcImJvb2xlYW5cIixcbiAgc206IFwiYm9vbGVhblwiLFxuICBzb3J0RmllbGQ6IFwiKG51bGx8c3RyaW5nKVwiLFxuICBzb3J0T3JkZXI6IFwic3RyaW5nXCIsXG4gIGZpeGVkSGVhZGVyOiBcImJvb2xlYW5cIixcbiAgc3RyaXBlZDogXCJib29sZWFuXCIsXG4gIHJvd3NUZXh0OiBcInN0cmluZ1wiLFxuICBvZlRleHQ6IFwic3RyaW5nXCIsXG4gIGFsbFRleHQ6IFwic3RyaW5nXCIsXG4gIGZvcmNlU29ydDogXCJib29sZWFuXCIsXG4gIHNvcnRJY29uVGVtcGxhdGU6IFwic3RyaW5nXCIsXG4gIHBhZ2luYXRpb25TdGFydEljb25UZW1wbGF0ZTogXCJzdHJpbmdcIixcbiAgcGFnaW5hdGlvbkVuZEljb25UZW1wbGF0ZTogXCJzdHJpbmdcIixcbiAgcGFnaW5hdGlvbkxlZnRJY29uVGVtcGxhdGU6IFwic3RyaW5nXCIsXG4gIHBhZ2luYXRpb25SaWdodEljb25UZW1wbGF0ZTogXCJzdHJpbmdcIlxufSwgR1QgPSB7XG4gIGJvcmRlcmVkOiAhMSxcbiAgYm9yZGVybGVzczogITEsXG4gIGNsaWNrYWJsZVJvd3M6ICExLFxuICBkZWZhdWx0VmFsdWU6IFwiLVwiLFxuICBlZGl0OiAhMSxcbiAgZW50cmllczogMTAsXG4gIGVudHJpZXNPcHRpb25zOiBbMTAsIDI1LCA1MCwgMjAwXSxcbiAgZml4ZWRIZWFkZXI6ICExLFxuICBmdWxsUGFnaW5hdGlvbjogITEsXG4gIGhvdmVyOiAhMSxcbiAgbG9hZGluZzogITEsXG4gIGxvYWRpbmdNZXNzYWdlOiBcIkxvYWRpbmcgcmVzdWx0cy4uLlwiLFxuICBtYXhXaWR0aDogbnVsbCxcbiAgbWF4SGVpZ2h0OiBudWxsLFxuICBtdWx0aTogITEsXG4gIG5vRm91bmRNZXNzYWdlOiBcIk5vIG1hdGNoaW5nIHJlc3VsdHMgZm91bmRcIixcbiAgcGFnaW5hdGlvbjogITAsXG4gIHNlbGVjdGFibGU6ICExLFxuICBzbTogITEsXG4gIHNvcnRGaWVsZDogbnVsbCxcbiAgc29ydE9yZGVyOiBcImFzY1wiLFxuICBzdHJpcGVkOiAhMSxcbiAgcm93c1RleHQ6IFwiUm93cyBwZXIgcGFnZTpcIixcbiAgb2ZUZXh0OiBcIm9mXCIsXG4gIGFsbFRleHQ6IFwiQWxsXCIsXG4gIGZvcmNlU29ydDogITEsXG4gIHNvcnRJY29uVGVtcGxhdGU6IFF2LFxuICBwYWdpbmF0aW9uU3RhcnRJY29uVGVtcGxhdGU6IEp2LFxuICBwYWdpbmF0aW9uRW5kSWNvblRlbXBsYXRlOiBpVCxcbiAgcGFnaW5hdGlvbkxlZnRJY29uVGVtcGxhdGU6IHRULFxuICBwYWdpbmF0aW9uUmlnaHRJY29uVGVtcGxhdGU6IGVUXG59LCBxVCA9IHtcbiAgbGFiZWw6IFwic3RyaW5nXCIsXG4gIGZpZWxkOiBcInN0cmluZ1wiLFxuICBmaXhlZDogXCIoYm9vbGVhbnxzdHJpbmcpXCIsXG4gIGZvcm1hdDogXCIoZnVuY3Rpb258bnVsbClcIixcbiAgd2lkdGg6IFwiKG51bWJlcnxudWxsKVwiLFxuICBzb3J0OiBcImJvb2xlYW5cIixcbiAgY29sdW1uSW5kZXg6IFwibnVtYmVyXCJcbn0sIFpUID0ge1xuICBsYWJlbDogXCJcIixcbiAgZmllbGQ6IFwiXCIsXG4gIGZpeGVkOiAhMSxcbiAgZm9ybWF0OiBudWxsLFxuICB3aWR0aDogbnVsbCxcbiAgc29ydDogITAsXG4gIGNvbHVtbkluZGV4OiAwXG59LCBRVCA9IHtcbiAgdGFibGU6IFVULFxuICB0YWJsZUhlYWRlcjogelQsXG4gIGNvbHVtbjogaFQsXG4gIHBhZ2luYXRpb246IHdULFxuICBzZWxlY3RXcmFwcGVyOiBWVCxcbiAgc2Nyb2xsOiBQVCxcbiAgdGFibGVCb3JkZXJlZDogS1QsXG4gIHBhZ2luYXRpb25Cb3JkZXJlZDoga1QsXG4gIGJvcmRlcmxlc3M6IG5ULFxuICBjaGVja2JveFJvd1dyYXBwZXI6IGxULFxuICBjaGVja2JveFJvdzogYVQsXG4gIGNoZWNrYm94SGVhZGVyV3JhcHBlcjogclQsXG4gIGNoZWNrYm94SGVhZGVyOiBvVCxcbiAgcm93OiBOVCxcbiAgcm93SXRlbTogUlQsXG4gIHN0cmlwZWQ6IGpULFxuICBzb3J0SWNvbldyYXBwZXI6IFlULFxuICBzb3J0SWNvbjogRlQsXG4gIHBhZ2luYXRpb25Sb3dzVGV4dDogJFQsXG4gIHBhZ2luYXRpb25OYXY6IElULFxuICBwYWdpbmF0aW9uQnV0dG9uc1dyYXBwZXI6IHhULFxuICBob3ZlclJvdzogX1QsXG4gIGJvcmRlckNvbG9yOiBzVCxcbiAgY29sb3I6IGNULFxuICBmaXhlZEhlYWRlcjogdVQsXG4gIGZpeGVkSGVhZGVyQm9keTogcFQsXG4gIHNlbGVjdGFibGVSb3c6IEJULFxuICByb3dBbmltYXRpb246IE1ULFxuICBzbTogV1QsXG4gIGVkaXQ6IGRULFxuICBzZWxlY3RJdGVtc1dyYXBwZXI6IEhULFxuICBwYWdpbmF0aW9uU3RhcnRCdXR0b246IExULFxuICBwYWdpbmF0aW9uTGVmdEJ1dHRvbjogU1QsXG4gIHBhZ2luYXRpb25SaWdodEJ1dHRvbjogRFQsXG4gIHBhZ2luYXRpb25FbmRCdXR0b246IE9ULFxuICBsb2FkaW5nSXRlbXNXcmFwcGVyOiBtVCxcbiAgbG9hZGluZ1Byb2dyZXNzQmFyV3JhcHBlcjogQ1QsXG4gIGxvYWRpbmdQcm9ncmVzc0JhcjogRVQsXG4gIGxvYWRpbmdNZXNzYWdlOiBnVCxcbiAgbG9hZGluZ1BhZ2luYXRpb25Sb3dzVGV4dDogdlQsXG4gIGxvYWRpbmdQYWdpbmF0aW9uU2VsZWN0V3JhcHBlcjogVFQsXG4gIGxvYWRpbmdQYWdpbmF0aW9uTmF2OiBiVCxcbiAgbG9hZGluZ0NvbHVtbjogZlQsXG4gIG5vRm91bmRNZXNzYWdlV3JhcHBlcjogeVQsXG4gIG5vRm91bmRNZXNzYWdlOiBBVFxufSwgSlQgPSB7XG4gIHRhYmxlOiBcInN0cmluZ1wiLFxuICB0YWJsZUhlYWRlcjogXCJzdHJpbmdcIixcbiAgY29sdW1uOiBcInN0cmluZ1wiLFxuICBwYWdpbmF0aW9uOiBcInN0cmluZ1wiLFxuICBzZWxlY3RXcmFwcGVyOiBcInN0cmluZ1wiLFxuICBzY3JvbGw6IFwic3RyaW5nXCIsXG4gIHRhYmxlQm9yZGVyZWQ6IFwic3RyaW5nXCIsXG4gIHBhZ2luYXRpb25Cb3JkZXJlZDogXCJzdHJpbmdcIixcbiAgYm9yZGVybGVzczogXCJzdHJpbmdcIixcbiAgY2hlY2tib3hSb3dXcmFwcGVyOiBcInN0cmluZ1wiLFxuICBjaGVja2JveFJvdzogXCJzdHJpbmdcIixcbiAgY2hlY2tib3hIZWFkZXJXcmFwcGVyOiBcInN0cmluZ1wiLFxuICBjaGVja2JveEhlYWRlcjogXCJzdHJpbmdcIixcbiAgcm93OiBcInN0cmluZ1wiLFxuICByb3dJdGVtOiBcInN0cmluZ1wiLFxuICBzdHJpcGVkOiBcInN0cmluZ1wiLFxuICBzb3J0SWNvbldyYXBwZXI6IFwic3RyaW5nXCIsXG4gIHNvcnRJY29uOiBcInN0cmluZ1wiLFxuICBwYWdpbmF0aW9uUm93c1RleHQ6IFwic3RyaW5nXCIsXG4gIHBhZ2luYXRpb25OYXY6IFwic3RyaW5nXCIsXG4gIHBhZ2luYXRpb25CdXR0b25zV3JhcHBlcjogXCJzdHJpbmdcIixcbiAgaG92ZXJSb3c6IFwic3RyaW5nXCIsXG4gIGJvcmRlckNvbG9yOiBcInN0cmluZ1wiLFxuICBjb2xvcjogXCJzdHJpbmdcIixcbiAgZml4ZWRIZWFkZXI6IFwic3RyaW5nXCIsXG4gIGZpeGVkSGVhZGVyQm9keTogXCJzdHJpbmdcIixcbiAgc2VsZWN0YWJsZVJvdzogXCJzdHJpbmdcIixcbiAgcm93QW5pbWF0aW9uOiBcInN0cmluZ1wiLFxuICBzbTogXCJzdHJpbmdcIixcbiAgZWRpdDogXCJzdHJpbmdcIixcbiAgc2VsZWN0SXRlbXNXcmFwcGVyOiBcInN0cmluZ1wiLFxuICBwYWdpbmF0aW9uU3RhcnRCdXR0b246IFwic3RyaW5nXCIsXG4gIHBhZ2luYXRpb25MZWZ0QnV0dG9uOiBcInN0cmluZ1wiLFxuICBwYWdpbmF0aW9uUmlnaHRCdXR0b246IFwic3RyaW5nXCIsXG4gIHBhZ2luYXRpb25FbmRCdXR0b246IFwic3RyaW5nXCIsXG4gIGxvYWRpbmdJdGVtc1dyYXBwZXI6IFwic3RyaW5nXCIsXG4gIGxvYWRpbmdQcm9ncmVzc0JhcldyYXBwZXI6IFwic3RyaW5nXCIsXG4gIGxvYWRpbmdQcm9ncmVzc0JhcjogXCJzdHJpbmdcIixcbiAgbG9hZGluZ01lc3NhZ2U6IFwic3RyaW5nXCIsXG4gIGxvYWRpbmdQYWdpbmF0aW9uUm93c1RleHQ6IFwic3RyaW5nXCIsXG4gIGxvYWRpbmdQYWdpbmF0aW9uU2VsZWN0V3JhcHBlcjogXCJzdHJpbmdcIixcbiAgbG9hZGluZ1BhZ2luYXRpb25OYXY6IFwic3RyaW5nXCIsXG4gIGxvYWRpbmdDb2x1bW46IFwic3RyaW5nXCIsXG4gIG5vRm91bmRNZXNzYWdlV3JhcHBlcjogXCJzdHJpbmdcIixcbiAgbm9Gb3VuZE1lc3NhZ2U6IFwic3RyaW5nXCJcbn07XG5jbGFzcyBnaCB7XG4gIGNvbnN0cnVjdG9yKHQsIGUgPSB7fSwgaSA9IHt9LCBuID0ge30pIHtcbiAgICB0aGlzLl9lbGVtZW50ID0gdCwgdGhpcy5fb3B0aW9ucyA9IHRoaXMuX2dldE9wdGlvbnMoaSksIHRoaXMuX2NsYXNzZXMgPSB0aGlzLl9nZXRDbGFzc2VzKG4pLCB0aGlzLl9zb3J0UmV2ZXJzZSA9ICExLCB0aGlzLl9hY3RpdmVQYWdlID0gMCwgdGhpcy5fc2VhcmNoID0gXCJcIiwgdGhpcy5fc2VhcmNoQ29sdW1uID0gbnVsbCwgdGhpcy5fcGFnaW5hdGlvbkxlZnQgPSBudWxsLCB0aGlzLl9wYWdpbmF0aW9uUmlnaHQgPSBudWxsLCB0aGlzLl9wYWdpbmF0aW9uU3RhcnQgPSBudWxsLCB0aGlzLl9wYWdpbmF0aW9uRW5kID0gbnVsbCwgdGhpcy5fc2VsZWN0ID0gbnVsbCwgdGhpcy5fc2VsZWN0SW5zdGFuY2UgPSBudWxsLCB0aGlzLl9zZWxlY3RlZCA9IFtdLCB0aGlzLl9jaGVja2JveGVzID0gbnVsbCwgdGhpcy5faGVhZGVyQ2hlY2tib3ggPSBudWxsLCB0aGlzLl9yb3dzID0gdGhpcy5fZ2V0Um93cyhlLnJvd3MpLCB0aGlzLl9jb2x1bW5zID0gdGhpcy5fZ2V0Q29sdW1ucyhlLmNvbHVtbnMpLCB0aGlzLl9lbGVtZW50ICYmICh5LnNldERhdGEodCwgRWksIHRoaXMpLCB0aGlzLl9wZXJmZWN0U2Nyb2xsYmFyID0gbnVsbCwgdGhpcy5fc2V0dXAoKSk7XG4gIH1cbiAgLy8gR2V0dGVyc1xuICBzdGF0aWMgZ2V0IE5BTUUoKSB7XG4gICAgcmV0dXJuIE5pO1xuICB9XG4gIGdldCBjb2x1bW5zKCkge1xuICAgIHJldHVybiB0aGlzLl9jb2x1bW5zLm1hcCgodCwgZSkgPT4ge1xuICAgICAgbGV0IGkgPSB7XG4gICAgICAgIC4uLlpULFxuICAgICAgICBmaWVsZDogYGZpZWxkXyR7ZX1gLFxuICAgICAgICBjb2x1bW5JbmRleDogZVxuICAgICAgfTtcbiAgICAgIHJldHVybiB0eXBlb2YgdCA9PSBcInN0cmluZ1wiID8gaS5sYWJlbCA9IHQgOiB0eXBlb2YgdCA9PSBcIm9iamVjdFwiICYmIChpID0ge1xuICAgICAgICAuLi5pLFxuICAgICAgICAuLi50XG4gICAgICB9KSwgRChcImNvbHVtblwiLCBpLCBxVCksIGk7XG4gICAgfSk7XG4gIH1cbiAgZ2V0IHJvd3MoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Jvd3MubWFwKCh0LCBlKSA9PiB7XG4gICAgICBjb25zdCBpID0ge1xuICAgICAgICByb3dJbmRleDogZVxuICAgICAgfTtcbiAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KHQpID8gdGhpcy5jb2x1bW5zLmZvckVhY2goKG4sIG8pID0+IHtcbiAgICAgICAgdFtvXSA9PT0gMCA/IGlbbi5maWVsZF0gPSB0W29dIDogaVtuLmZpZWxkXSA9IHRbb10gfHwgdGhpcy5fb3B0aW9ucy5kZWZhdWx0VmFsdWU7XG4gICAgICB9KSA6IHR5cGVvZiB0ID09IFwib2JqZWN0XCIgJiYgdGhpcy5jb2x1bW5zLmZvckVhY2goKG4pID0+IHtcbiAgICAgICAgdFtuLmZpZWxkXSA9PT0gMCA/IGlbbi5maWVsZF0gPSB0W24uZmllbGRdIDogaVtuLmZpZWxkXSA9IHRbbi5maWVsZF0gfHwgdGhpcy5fb3B0aW9ucy5kZWZhdWx0VmFsdWU7XG4gICAgICB9KSwgaTtcbiAgICB9KTtcbiAgfVxuICBnZXQgc2VhcmNoUmVzdWx0KCkge1xuICAgIHJldHVybiBIdih0aGlzLnJvd3MsIHRoaXMuX3NlYXJjaCwgdGhpcy5fc2VhcmNoQ29sdW1uKTtcbiAgfVxuICBnZXQgY29tcHV0ZWRSb3dzKCkge1xuICAgIGxldCB0ID0gWy4uLnRoaXMuc2VhcmNoUmVzdWx0XTtcbiAgICByZXR1cm4gdGhpcy5fb3B0aW9ucy5zb3J0T3JkZXIgJiYgKHQgPSBCdih7XG4gICAgICByb3dzOiB0LFxuICAgICAgZmllbGQ6IHRoaXMuX29wdGlvbnMuc29ydEZpZWxkLFxuICAgICAgb3JkZXI6IHRoaXMuX29wdGlvbnMuc29ydE9yZGVyXG4gICAgfSkpLCB0aGlzLl9vcHRpb25zLnBhZ2luYXRpb24gJiYgKHRoaXMuX29wdGlvbnMuZW50cmllcyA9PT0gXCJBbGxcIiA/IHQgPSBrbCh7XG4gICAgICByb3dzOiB0LFxuICAgICAgZW50cmllczogdC5sZW5ndGgsXG4gICAgICBhY3RpdmVQYWdlOiB0aGlzLl9hY3RpdmVQYWdlXG4gICAgfSkgOiB0ID0ga2woe1xuICAgICAgcm93czogdCxcbiAgICAgIGVudHJpZXM6IHRoaXMuX29wdGlvbnMuZW50cmllcyxcbiAgICAgIGFjdGl2ZVBhZ2U6IHRoaXMuX2FjdGl2ZVBhZ2VcbiAgICB9KSksIHQ7XG4gIH1cbiAgZ2V0IHBhZ2VzKCkge1xuICAgIHJldHVybiB0aGlzLl9vcHRpb25zLmVudHJpZXMgPT09IFwiQWxsXCIgPyAxIDogTWF0aC5jZWlsKHRoaXMuc2VhcmNoUmVzdWx0Lmxlbmd0aCAvIHRoaXMuX29wdGlvbnMuZW50cmllcyk7XG4gIH1cbiAgZ2V0IG5hdmlnYXRpb25UZXh0KCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLl9hY3RpdmVQYWdlICogdGhpcy5fb3B0aW9ucy5lbnRyaWVzO1xuICAgIHJldHVybiB0aGlzLnNlYXJjaFJlc3VsdC5sZW5ndGggPT09IDAgPyBgMCAke3RoaXMuX29wdGlvbnMub2ZUZXh0fSAwYCA6IHRoaXMuX29wdGlvbnMuZW50cmllcyA9PT0gXCJBbGxcIiA/IGAxIC0gJHt0aGlzLnNlYXJjaFJlc3VsdC5sZW5ndGh9ICR7dGhpcy5fb3B0aW9ucy5vZlRleHR9ICR7dGhpcy5zZWFyY2hSZXN1bHQubGVuZ3RofWAgOiBgJHt0ICsgMX0gLSAke3RoaXMuY29tcHV0ZWRSb3dzLmxlbmd0aCArIHR9ICR7dGhpcy5fb3B0aW9ucy5vZlRleHR9ICR7dGhpcy5zZWFyY2hSZXN1bHQubGVuZ3RofWA7XG4gIH1cbiAgZ2V0IHRhYmxlT3B0aW9ucygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY2xhc3NlczogdGhpcy5fY2xhc3NlcyxcbiAgICAgIGNvbHVtbnM6IHRoaXMuY29sdW1ucyxcbiAgICAgIHJvd3M6IHRoaXMuY29tcHV0ZWRSb3dzLFxuICAgICAgbm9Gb3VuZE1lc3NhZ2U6IHRoaXMuX29wdGlvbnMubm9Gb3VuZE1lc3NhZ2UsXG4gICAgICBlZGl0OiB0aGlzLl9vcHRpb25zLmVkaXQsXG4gICAgICBsb2FkaW5nOiB0aGlzLl9vcHRpb25zLmxvYWRpbmcsXG4gICAgICBsb2FkZXJDbGFzczogdGhpcy5fb3B0aW9ucy5sb2FkZXJDbGFzcyxcbiAgICAgIGxvYWRpbmdNZXNzYWdlOiB0aGlzLl9vcHRpb25zLmxvYWRpbmdNZXNzYWdlLFxuICAgICAgc2VsZWN0YWJsZTogdGhpcy5fb3B0aW9ucy5zZWxlY3RhYmxlLFxuICAgICAgbXVsdGk6IHRoaXMuX29wdGlvbnMubXVsdGksXG4gICAgICBib3JkZXJlZDogdGhpcy5fb3B0aW9ucy5ib3JkZXJlZCxcbiAgICAgIGJvcmRlcmxlc3M6IHRoaXMuX29wdGlvbnMuYm9yZGVybGVzcyxcbiAgICAgIHN0cmlwZWQ6IHRoaXMuX29wdGlvbnMuc3RyaXBlZCxcbiAgICAgIGhvdmVyOiB0aGlzLl9vcHRpb25zLmhvdmVyLFxuICAgICAgZml4ZWRIZWFkZXI6IHRoaXMuX29wdGlvbnMuZml4ZWRIZWFkZXIsXG4gICAgICBzbTogdGhpcy5fb3B0aW9ucy5zbSxcbiAgICAgIHNvcnRJY29uVGVtcGxhdGU6IHRoaXMuX29wdGlvbnMuc29ydEljb25UZW1wbGF0ZSxcbiAgICAgIHBhZ2luYXRpb246IHtcbiAgICAgICAgZW5hYmxlOiB0aGlzLl9vcHRpb25zLnBhZ2luYXRpb24sXG4gICAgICAgIHRleHQ6IHRoaXMubmF2aWdhdGlvblRleHQsXG4gICAgICAgIGVudHJpZXM6IHRoaXMuX29wdGlvbnMuZW50cmllcyxcbiAgICAgICAgZW50cmllc09wdGlvbnM6IHRoaXMuX29wdGlvbnMuZW50cmllc09wdGlvbnMsXG4gICAgICAgIGZ1bGxQYWdpbmF0aW9uOiB0aGlzLl9vcHRpb25zLmZ1bGxQYWdpbmF0aW9uLFxuICAgICAgICByb3dzVGV4dDogdGhpcy5fb3B0aW9ucy5yb3dzVGV4dCxcbiAgICAgICAgb2ZUZXh0OiB0aGlzLl9vcHRpb25zLm9mVGV4dCxcbiAgICAgICAgYWxsVGV4dDogdGhpcy5fb3B0aW9ucy5hbGxUZXh0LFxuICAgICAgICBwYWdpbmF0aW9uU3RhcnRJY29uVGVtcGxhdGU6IHRoaXMuX29wdGlvbnMucGFnaW5hdGlvblN0YXJ0SWNvblRlbXBsYXRlLFxuICAgICAgICBwYWdpbmF0aW9uTGVmdEljb25UZW1wbGF0ZTogdGhpcy5fb3B0aW9ucy5wYWdpbmF0aW9uTGVmdEljb25UZW1wbGF0ZSxcbiAgICAgICAgcGFnaW5hdGlvblJpZ2h0SWNvblRlbXBsYXRlOiB0aGlzLl9vcHRpb25zLnBhZ2luYXRpb25SaWdodEljb25UZW1wbGF0ZSxcbiAgICAgICAgcGFnaW5hdGlvbkVuZEljb25UZW1wbGF0ZTogdGhpcy5fb3B0aW9ucy5wYWdpbmF0aW9uRW5kSWNvblRlbXBsYXRlLFxuICAgICAgICBjbGFzc2VzOiB0aGlzLl9jbGFzc2VzXG4gICAgICB9LFxuICAgICAgZm9yY2VTb3J0OiB0aGlzLl9vcHRpb25zLmZvcmNlU29ydFxuICAgIH07XG4gIH1cbiAgLy8gUHVibGljXG4gIHVwZGF0ZSh0LCBlID0ge30pIHtcbiAgICB0ICYmIHQucm93cyAmJiAodGhpcy5fcm93cyA9IHQucm93cyksIHQgJiYgdC5jb2x1bW5zICYmICh0aGlzLl9jb2x1bW5zID0gdC5jb2x1bW5zKSwgdGhpcy5fY2xlYXJDbGFzc0xpc3QoZSksIHRoaXMuX29wdGlvbnMgPSB0aGlzLl9nZXRPcHRpb25zKHsgLi4udGhpcy5fb3B0aW9ucywgLi4uZSB9KSwgdGhpcy5fc2V0dXAoKSwgdGhpcy5fcGVyZm9ybVNvcnQoKTtcbiAgfVxuICBkaXNwb3NlKCkge1xuICAgIHRoaXMuX3NlbGVjdEluc3RhbmNlICYmIHRoaXMuX3NlbGVjdEluc3RhbmNlLmRpc3Bvc2UoKSwgeS5yZW1vdmVEYXRhKHRoaXMuX2VsZW1lbnQsIEVpKSwgdGhpcy5fcmVtb3ZlRXZlbnRMaXN0ZW5lcnMoKSwgdGhpcy5fcGVyZmVjdFNjcm9sbGJhci5kZXN0cm95KCksIHRoaXMuX2VsZW1lbnQgPSBudWxsO1xuICB9XG4gIHNlYXJjaCh0LCBlKSB7XG4gICAgdGhpcy5fc2VhcmNoID0gdCwgdGhpcy5fc2VhcmNoQ29sdW1uID0gZSwgdGhpcy5fYWN0aXZlUGFnZSA9IDAsIHRoaXMuX29wdGlvbnMucGFnaW5hdGlvbiAmJiB0aGlzLl90b2dnbGVEaXNhYmxlU3RhdGUoKSwgdGhpcy5fcmVuZGVyUm93cygpLCB0aGlzLl9vcHRpb25zLm1heEhlaWdodCAmJiAodGhpcy5fcGVyZmVjdFNjcm9sbGJhci5lbGVtZW50LnNjcm9sbFRvcCA9IDAsIHRoaXMuX3BlcmZlY3RTY3JvbGxiYXIudXBkYXRlKCkpO1xuICB9XG4gIHNvcnQodCwgZSA9IFwiYXNjXCIpIHtcbiAgICB0aGlzLl9vcHRpb25zLnNvcnRPcmRlciA9IGUsIHR5cGVvZiB0ID09IFwic3RyaW5nXCIgPyB0aGlzLl9vcHRpb25zLnNvcnRGaWVsZCA9IHRoaXMuY29sdW1ucy5maW5kKFxuICAgICAgKG4pID0+IG4ubGFiZWwgPT09IHRcbiAgICApLmZpZWxkIDogdGhpcy5fb3B0aW9ucy5zb3J0RmllbGQgPSB0LmZpZWxkO1xuICAgIGNvbnN0IGkgPSBkLmZpbmRPbmUoXG4gICAgICBgW2RhdGEtdGUtc29ydD1cIiR7dGhpcy5fb3B0aW9ucy5zb3J0RmllbGR9XCJdYCxcbiAgICAgIHRoaXMuX2VsZW1lbnRcbiAgICApO1xuICAgIHRoaXMuX2FjdGl2ZVBhZ2UgPSAwLCB0aGlzLl90b2dnbGVEaXNhYmxlU3RhdGUoKSwgdGhpcy5fcmVuZGVyUm93cygpLCB0aGlzLl9zZXRBY3RpdmVTb3J0SWNvbihpKTtcbiAgfVxuICBzZXRBY3RpdmVQYWdlKHQpIHtcbiAgICB0IDwgdGhpcy5wYWdlcyAmJiB0aGlzLl9jaGFuZ2VBY3RpdmVQYWdlKHQpO1xuICB9XG4gIC8vIFByaXZhdGVcbiAgX2dldENsYXNzZXModCkge1xuICAgIGNvbnN0IGUgPSBoLmdldERhdGFDbGFzc0F0dHJpYnV0ZXModGhpcy5fZWxlbWVudCk7XG4gICAgcmV0dXJuIHQgPSB7XG4gICAgICAuLi5RVCxcbiAgICAgIC4uLmUsXG4gICAgICAuLi50XG4gICAgfSwgRChOaSwgdCwgSlQpLCB0O1xuICB9XG4gIF9jaGFuZ2VBY3RpdmVQYWdlKHQpIHtcbiAgICB0aGlzLl9hY3RpdmVQYWdlID0gdCwgdGhpcy5fdG9nZ2xlRGlzYWJsZVN0YXRlKCksIHRoaXMuX3JlbmRlclJvd3MoKTtcbiAgfVxuICBfY2xlYXJDbGFzc0xpc3QodCkge1xuICAgIFtcImhvdmVyXCIsIFwiYm9yZGVyZWRcIiwgXCJib3JkZXJsZXNzXCIsIFwic21cIiwgXCJzdHJpcGVkXCJdLmZvckVhY2goKGUpID0+IHtcbiAgICAgIHRoaXMuX29wdGlvbnNbZV0gJiYgIXRbZV0gJiYgaC5yZW1vdmVEYXRhQXR0cmlidXRlKGBkYXRhLXRlLSR7ZX1gKTtcbiAgICB9KTtcbiAgfVxuICBfZW1pdFNlbGVjdEV2ZW50KCkge1xuICAgIGMudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBHdiwge1xuICAgICAgc2VsZWN0ZWRSb3dzOiB0aGlzLnJvd3MuZmlsdGVyKFxuICAgICAgICAodCkgPT4gdGhpcy5fc2VsZWN0ZWQuaW5kZXhPZih0LnJvd0luZGV4KSAhPT0gLTFcbiAgICAgICksXG4gICAgICBzZWxlY3RlZEluZGV4ZXM6IHRoaXMuX3NlbGVjdGVkLFxuICAgICAgYWxsU2VsZWN0ZWQ6IHRoaXMuX3NlbGVjdGVkLmxlbmd0aCA9PT0gdGhpcy5yb3dzLmxlbmd0aFxuICAgIH0pO1xuICB9XG4gIF9nZXRSb3dzKHQgPSBbXSkge1xuICAgIGNvbnN0IGUgPSBkLmZpbmRPbmUoXCJ0Ym9keVwiLCB0aGlzLl9lbGVtZW50KTtcbiAgICByZXR1cm4gZSA/IFsuLi5kLmZpbmQoXCJ0clwiLCBlKS5tYXAoKG4pID0+IGQuZmluZChcInRkXCIsIG4pLm1hcCgobykgPT4gby5pbm5lckhUTUwpKSwgLi4udF0gOiB0O1xuICB9XG4gIF9nZXRDb2x1bW5zKHQgPSBbXSkge1xuICAgIGNvbnN0IGUgPSBkLmZpbmRPbmUoXCJ0aGVhZFwiLCB0aGlzLl9lbGVtZW50KTtcbiAgICBpZiAoIWUpXG4gICAgICByZXR1cm4gdDtcbiAgICBjb25zdCBpID0gZC5maW5kT25lKFwidHJcIiwgZSk7XG4gICAgcmV0dXJuIFsuLi5kLmZpbmQoXCJ0aFwiLCBpKS5tYXAoKG8pID0+ICh7XG4gICAgICBsYWJlbDogby5pbm5lckhUTUwsXG4gICAgICAuLi5oLmdldERhdGFBdHRyaWJ1dGVzKG8pXG4gICAgfSkpLCAuLi50XTtcbiAgfVxuICBfZ2V0Q1NTVmFsdWUodCkge1xuICAgIHJldHVybiB0eXBlb2YgdCA9PSBcInN0cmluZ1wiID8gdCA6IGAke3R9cHhgO1xuICB9XG4gIF9nZXRPcHRpb25zKHQpIHtcbiAgICBjb25zdCBlID0ge1xuICAgICAgLi4uR1QsXG4gICAgICAuLi5oLmdldERhdGFBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpLFxuICAgICAgLi4udFxuICAgIH07XG4gICAgcmV0dXJuIEQoTmksIGUsIFhUKSwgZTtcbiAgfVxuICBfc2V0QWN0aXZlUm93cygpIHtcbiAgICBkLmZpbmQoZmksIHRoaXMuX2VsZW1lbnQpLmZvckVhY2goKHQpID0+IHtcbiAgICAgIHRoaXMuX3NlbGVjdGVkLmluY2x1ZGVzKGguZ2V0RGF0YUF0dHJpYnV0ZSh0LCBcImluZGV4XCIpKSA/IGguYWRkQ2xhc3ModCwgYGFjdGl2ZSAke3RoaXMuX2NsYXNzZXMuc2VsZWN0YWJsZVJvd31gKSA6IGgucmVtb3ZlQ2xhc3ModCwgYGFjdGl2ZSAke3RoaXMuX2NsYXNzZXMuc2VsZWN0YWJsZVJvd31gKTtcbiAgICB9KTtcbiAgfVxuICBfc2V0RW50cmllcyh0KSB7XG4gICAgdGhpcy5fb3B0aW9ucyA9IHRoaXMuX2dldE9wdGlvbnMoe1xuICAgICAgLi4udGhpcy5fb3B0aW9ucyxcbiAgICAgIGVudHJpZXM6IHQudGFyZ2V0LnZhbHVlXG4gICAgfSksIHRoaXMuX2FjdGl2ZVBhZ2UgPiB0aGlzLnBhZ2VzIC0gMSAmJiAodGhpcy5fYWN0aXZlUGFnZSA9IHRoaXMucGFnZXMgLSAxKSwgdGhpcy5fdG9nZ2xlRGlzYWJsZVN0YXRlKCksIHRoaXMuX3JlbmRlclJvd3MoKTtcbiAgfVxuICBfc2V0U2VsZWN0ZWQoKSB7XG4gICAgZC5maW5kKGdvLCB0aGlzLl9lbGVtZW50KS5mb3JFYWNoKFxuICAgICAgKHQpID0+IHtcbiAgICAgICAgY29uc3QgZSA9IGguZ2V0RGF0YUF0dHJpYnV0ZSh0LCBcInJvd0luZGV4XCIpO1xuICAgICAgICB0LmNoZWNrZWQgPSB0aGlzLl9zZWxlY3RlZC5pbmNsdWRlcyhlKTtcbiAgICAgIH1cbiAgICApLCB0aGlzLl9zZXRBY3RpdmVSb3dzKCk7XG4gIH1cbiAgX3NldEFjdGl2ZVNvcnRJY29uKHQpIHtcbiAgICBkLmZpbmQobW8sIHRoaXMuX2VsZW1lbnQpLmZvckVhY2goKGUpID0+IHtcbiAgICAgIGNvbnN0IGkgPSB0aGlzLl9vcHRpb25zLnNvcnRPcmRlciA9PT0gXCJkZXNjXCIgJiYgZSA9PT0gdCA/IDE4MCA6IDA7XG4gICAgICBoLnN0eWxlKGUsIHtcbiAgICAgICAgdHJhbnNmb3JtOiBgcm90YXRlKCR7aX1kZWcpYFxuICAgICAgfSksIGUgPT09IHQgJiYgdGhpcy5fb3B0aW9ucy5zb3J0T3JkZXIgPyBoLmFkZENsYXNzKGUsIFwib3BhY2l0eS0xMDBcIikgOiBoLnJlbW92ZUNsYXNzKGUsIFwib3BhY2l0eS0xMDBcIik7XG4gICAgfSk7XG4gIH1cbiAgX3NldHVwKCkge1xuICAgIHRoaXMuX3JlbmRlclRhYmxlKCksIHRoaXMuX29wdGlvbnMucGFnaW5hdGlvbiAmJiB0aGlzLl9zZXR1cFBhZ2luYXRpb24oKSwgdGhpcy5fb3B0aW9ucy5lZGl0ICYmIHRoaXMuX3NldHVwRWRpdGFibGUoKSwgdGhpcy5fb3B0aW9ucy5jbGlja2FibGVSb3dzICYmIHRoaXMuX3NldHVwQ2xpY2thYmxlUm93cygpLCB0aGlzLl9vcHRpb25zLnNlbGVjdGFibGUgJiYgdGhpcy5fc2V0dXBTZWxlY3RhYmxlKCksIHRoaXMuX3NldHVwU2Nyb2xsKCksIHRoaXMuX3NldHVwU29ydCgpO1xuICB9XG4gIF9zZXR1cENsaWNrYWJsZVJvd3MoKSB7XG4gICAgZC5maW5kKGZpLCB0aGlzLl9lbGVtZW50KS5mb3JFYWNoKCh0KSA9PiB7XG4gICAgICBjb25zdCBlID0gaC5nZXREYXRhQXR0cmlidXRlKHQsIFwiaW5kZXhcIik7XG4gICAgICBoLmFkZENsYXNzKHQsIFwiY3Vyc29yLXBvaW50ZXJcIiksIGMub24odCwgXCJjbGlja1wiLCAoaSkgPT4ge1xuICAgICAgICBkLm1hdGNoZXMoaS50YXJnZXQsIGdvKSB8fCBjLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgcXYsIHtcbiAgICAgICAgICBpbmRleDogZSxcbiAgICAgICAgICByb3c6IHRoaXMucm93c1tlXVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIF9zZXR1cEVkaXRhYmxlKCkge1xuICAgIGQuZmluZChmaSwgdGhpcy5fZWxlbWVudCkuZm9yRWFjaCgodCkgPT4ge1xuICAgICAgY29uc3QgZSA9IGguZ2V0RGF0YUF0dHJpYnV0ZSh0LCBcImluZGV4XCIpO1xuICAgICAgZC5maW5kKGZvLCB0KS5mb3JFYWNoKChpKSA9PiB7XG4gICAgICAgIGMub24oaSwgXCJpbnB1dFwiLCAobikgPT4gdGhpcy5fdXBkYXRlUm93KG4sIGUpKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIF9zZXR1cFNjcm9sbCgpIHtcbiAgICBjb25zdCB0ID0gZC5maW5kT25lKFZ2LCB0aGlzLl9lbGVtZW50KSwgZSA9IHt9O1xuICAgIGlmICh0aGlzLl9vcHRpb25zLm1heEhlaWdodCAmJiAoZS5tYXhIZWlnaHQgPSB0aGlzLl9nZXRDU1NWYWx1ZSh0aGlzLl9vcHRpb25zLm1heEhlaWdodCkpLCB0aGlzLl9vcHRpb25zLm1heFdpZHRoKSB7XG4gICAgICBjb25zdCBpID0gdGhpcy5fZ2V0Q1NTVmFsdWUodGhpcy5fb3B0aW9ucy5tYXhXaWR0aCk7XG4gICAgICBlLm1heFdpZHRoID0gaSwgaC5zdHlsZSh0aGlzLl9lbGVtZW50LCB7IG1heFdpZHRoOiBpIH0pO1xuICAgIH1cbiAgICBpZiAoaC5zdHlsZSh0LCBlKSwgaC5hZGRDbGFzcyh0LCBgJHt0aGlzLl9jbGFzc2VzLnNjcm9sbH1gKSwgdGhpcy5fb3B0aW9ucy5maXhlZEhlYWRlcikge1xuICAgICAgbGV0IGkgPSBkLmZpbmQoV3YsIHRoaXMuX2VsZW1lbnQpO1xuICAgICAgdGhpcy5fb3B0aW9ucy5zZWxlY3RhYmxlICYmIChpID0gaS5maWx0ZXIoKG4sIG8pID0+IChoLmFkZENsYXNzKFxuICAgICAgICBuLFxuICAgICAgICBgJHt0aGlzLl9jbGFzc2VzLmZpeGVkSGVhZGVyfSAke3RoaXMuX2NsYXNzZXMuY29sb3J9YFxuICAgICAgKSwgbyAhPT0gMCkpKSwgaS5mb3JFYWNoKChuLCBvKSA9PiB7XG4gICAgICAgIGguYWRkQ2xhc3MoXG4gICAgICAgICAgbixcbiAgICAgICAgICBgJHt0aGlzLl9jbGFzc2VzLmZpeGVkSGVhZGVyfSAke3RoaXMuX2NsYXNzZXMuY29sb3J9YFxuICAgICAgICApLCB0aGlzLmNvbHVtbnNbb10uZml4ZWQgJiYgaC5hZGRDbGFzcyhuLCBcIiF6LTQwXCIpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMuX3BlcmZlY3RTY3JvbGxiYXIgPSBuZXcgbWgodCk7XG4gIH1cbiAgX3NldHVwU29ydCgpIHtcbiAgICBkLmZpbmQobW8sIHRoaXMuX2VsZW1lbnQpLmZvckVhY2goKHQpID0+IHtcbiAgICAgIGNvbnN0IGUgPSBoLmdldERhdGFBdHRyaWJ1dGUodCwgXCJzb3J0XCIpLCBbaV0gPSBkLnBhcmVudHModCwgXCJ0aFwiKTtcbiAgICAgIGlmICh0aGlzLmNvbHVtbnMuc29ydClcbiAgICAgICAgaC5hZGRDbGFzcyhpLCBcImN1cnNvci1wb2ludGVyXCIpO1xuICAgICAgZWxzZVxuICAgICAgICByZXR1cm47XG4gICAgICBlID09PSB0aGlzLl9vcHRpb25zLnNvcnRGaWVsZCAmJiB0aGlzLl9zZXRBY3RpdmVTb3J0SWNvbih0KSwgYy5vbihpLCBcImNsaWNrXCIsICgpID0+IHtcbiAgICAgICAgdGhpcy5fb3B0aW9ucy5zb3J0RmllbGQgPT09IGUgJiYgdGhpcy5fb3B0aW9ucy5zb3J0T3JkZXIgPT09IFwiYXNjXCIgPyB0aGlzLl9vcHRpb25zLnNvcnRPcmRlciA9IFwiZGVzY1wiIDogdGhpcy5fb3B0aW9ucy5zb3J0RmllbGQgPT09IGUgJiYgdGhpcy5fb3B0aW9ucy5zb3J0T3JkZXIgPT09IFwiZGVzY1wiID8gdGhpcy5fb3B0aW9ucy5zb3J0T3JkZXIgPSB0aGlzLl9vcHRpb25zLmZvcmNlU29ydCA/IFwiYXNjXCIgOiBudWxsIDogdGhpcy5fb3B0aW9ucy5zb3J0T3JkZXIgPSBcImFzY1wiLCB0aGlzLl9vcHRpb25zLnNvcnRGaWVsZCA9IGUsIHRoaXMuX2FjdGl2ZVBhZ2UgPSAwLCB0aGlzLl9wZXJmb3JtU29ydCgpLCB0aGlzLl9zZXRBY3RpdmVTb3J0SWNvbih0KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIF9wZXJmb3JtU29ydCgpIHtcbiAgICB0aGlzLl90b2dnbGVEaXNhYmxlU3RhdGUoKSwgdGhpcy5fcmVuZGVyUm93cygpO1xuICB9XG4gIF9zZXR1cFNlbGVjdGFibGUoKSB7XG4gICAgdGhpcy5fY2hlY2tib3hlcyA9IGQuZmluZChnbywgdGhpcy5fZWxlbWVudCksIHRoaXMuX2hlYWRlckNoZWNrYm94ID0gZC5maW5kT25lKFxuICAgICAgRnYsXG4gICAgICB0aGlzLl9lbGVtZW50XG4gICAgKSwgYy5vbihcbiAgICAgIHRoaXMuX2hlYWRlckNoZWNrYm94LFxuICAgICAgXCJpbnB1dFwiLFxuICAgICAgKHQpID0+IHRoaXMuX3RvZ2dsZVNlbGVjdEFsbCh0KVxuICAgICksIHRoaXMuX2NoZWNrYm94ZXMuZm9yRWFjaCgodCkgPT4ge1xuICAgICAgY29uc3QgZSA9IGguZ2V0RGF0YUF0dHJpYnV0ZSh0LCBcInJvd0luZGV4XCIpO1xuICAgICAgYy5vbihcbiAgICAgICAgdCxcbiAgICAgICAgXCJpbnB1dFwiLFxuICAgICAgICAoaSkgPT4gdGhpcy5fdG9nZ2xlU2VsZWN0Um93KGksIGUpXG4gICAgICApO1xuICAgIH0pO1xuICB9XG4gIF9zZXR1cFBhZ2luYXRpb24oKSB7XG4gICAgdGhpcy5fcGFnaW5hdGlvblJpZ2h0ID0gZC5maW5kT25lKFxuICAgICAgWXYsXG4gICAgICB0aGlzLl9lbGVtZW50XG4gICAgKSwgdGhpcy5fcGFnaW5hdGlvbkxlZnQgPSBkLmZpbmRPbmUoXG4gICAgICBqdixcbiAgICAgIHRoaXMuX2VsZW1lbnRcbiAgICApLCBjLm9uKFxuICAgICAgdGhpcy5fcGFnaW5hdGlvblJpZ2h0LFxuICAgICAgXCJjbGlja1wiLFxuICAgICAgKCkgPT4gdGhpcy5fY2hhbmdlQWN0aXZlUGFnZSh0aGlzLl9hY3RpdmVQYWdlICsgMSlcbiAgICApLCBjLm9uKFxuICAgICAgdGhpcy5fcGFnaW5hdGlvbkxlZnQsXG4gICAgICBcImNsaWNrXCIsXG4gICAgICAoKSA9PiB0aGlzLl9jaGFuZ2VBY3RpdmVQYWdlKHRoaXMuX2FjdGl2ZVBhZ2UgLSAxKVxuICAgICksIHRoaXMuX29wdGlvbnMuZnVsbFBhZ2luYXRpb24gJiYgKHRoaXMuX3BhZ2luYXRpb25TdGFydCA9IGQuZmluZE9uZShcbiAgICAgIEt2LFxuICAgICAgdGhpcy5fZWxlbWVudFxuICAgICksIHRoaXMuX3BhZ2luYXRpb25FbmQgPSBkLmZpbmRPbmUoXG4gICAgICB6dixcbiAgICAgIHRoaXMuX2VsZW1lbnRcbiAgICApLCBjLm9uKFxuICAgICAgdGhpcy5fcGFnaW5hdGlvblN0YXJ0LFxuICAgICAgXCJjbGlja1wiLFxuICAgICAgKCkgPT4gdGhpcy5fY2hhbmdlQWN0aXZlUGFnZSgwKVxuICAgICksIGMub24oXG4gICAgICB0aGlzLl9wYWdpbmF0aW9uRW5kLFxuICAgICAgXCJjbGlja1wiLFxuICAgICAgKCkgPT4gdGhpcy5fY2hhbmdlQWN0aXZlUGFnZSh0aGlzLnBhZ2VzIC0gMSlcbiAgICApKSwgdGhpcy5fdG9nZ2xlRGlzYWJsZVN0YXRlKCksIHRoaXMuX3NldHVwUGFnaW5hdGlvblNlbGVjdCgpO1xuICB9XG4gIF9zZXR1cFBhZ2luYXRpb25TZWxlY3QoKSB7XG4gICAgdGhpcy5fc2VsZWN0ID0gZC5maW5kT25lKFh2LCB0aGlzLl9lbGVtZW50KSwgdGhpcy5fc2VsZWN0SW5zdGFuY2UgPSBuZXcgX3IodGhpcy5fc2VsZWN0KSwgYy5vbihcbiAgICAgIHRoaXMuX3NlbGVjdCxcbiAgICAgIFwidmFsdWVDaGFuZ2UudGUuc2VsZWN0XCIsXG4gICAgICAodCkgPT4gdGhpcy5fc2V0RW50cmllcyh0KVxuICAgICk7XG4gIH1cbiAgX3JlbW92ZUV2ZW50TGlzdGVuZXJzKCkge1xuICAgIHRoaXMuX29wdGlvbnMucGFnaW5hdGlvbiAmJiAoYy5vZmYodGhpcy5fcGFnaW5hdGlvblJpZ2h0LCBcImNsaWNrXCIpLCBjLm9mZih0aGlzLl9wYWdpbmF0aW9uTGVmdCwgXCJjbGlja1wiKSwgYy5vZmYodGhpcy5fc2VsZWN0LCBcInZhbHVlQ2hhbmdlLnRlLnNlbGVjdFwiKSwgdGhpcy5fb3B0aW9ucy5mdWxsUGFnaW5hdGlvbiAmJiAoYy5vZmYodGhpcy5fcGFnaW5hdGlvblN0YXJ0LCBcImNsaWNrXCIpLCBjLm9mZih0aGlzLl9wYWdpbmF0aW9uRW5kLCBcImNsaWNrXCIpKSksIHRoaXMuX29wdGlvbnMuZWRpdCAmJiBkLmZpbmQoZm8sIHRoaXMuX2VsZW1lbnQpLmZvckVhY2goKHQpID0+IHtcbiAgICAgIGMub2ZmKHQsIFwiaW5wdXRcIik7XG4gICAgfSksIHRoaXMuX29wdGlvbnMuY2xpY2thYmxlUm93cyAmJiBkLmZpbmQoZmksIHRoaXMuX2VsZW1lbnQpLmZvckVhY2goKHQpID0+IHtcbiAgICAgIGMub2ZmKHQsIFwiY2xpY2tcIik7XG4gICAgfSksIGQuZmluZChtbywgdGhpcy5fZWxlbWVudCkuZm9yRWFjaCgodCkgPT4ge1xuICAgICAgY29uc3QgW2VdID0gZC5wYXJlbnRzKHQsIFwidGhcIik7XG4gICAgICBjLm9mZihlLCBcImNsaWNrXCIpO1xuICAgIH0pLCB0aGlzLl9vcHRpb25zLnNlbGVjdGFibGUgJiYgKGMub2ZmKHRoaXMuX2hlYWRlckNoZWNrYm94LCBcImlucHV0XCIpLCB0aGlzLl9jaGVja2JveGVzLmZvckVhY2goKHQpID0+IHtcbiAgICAgIGMub2ZmKHQsIFwiaW5wdXRcIik7XG4gICAgfSkpO1xuICB9XG4gIF9yZW5kZXJUYWJsZSgpIHtcbiAgICB0aGlzLl9lbGVtZW50LmlubmVySFRNTCA9IHdsKHRoaXMudGFibGVPcHRpb25zKS50YWJsZSwgdGhpcy5fZm9ybWF0Q2VsbHMoKSwgYy50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIHhsKTtcbiAgfVxuICBfcmVuZGVyUm93cygpIHtcbiAgICBjb25zdCB0ID0gZC5maW5kT25lKFwidGJvZHlcIiwgdGhpcy5fZWxlbWVudCk7XG4gICAgaWYgKHRoaXMuX29wdGlvbnMucGFnaW5hdGlvbikge1xuICAgICAgY29uc3QgZSA9IGQuZmluZE9uZShcbiAgICAgICAgVXYsXG4gICAgICAgIHRoaXMuX2VsZW1lbnRcbiAgICAgICk7XG4gICAgICBlLmlubmVyVGV4dCA9IHRoaXMubmF2aWdhdGlvblRleHQ7XG4gICAgfVxuICAgIHQuaW5uZXJIVE1MID0gd2wodGhpcy50YWJsZU9wdGlvbnMpLnJvd3MsIHRoaXMuX2Zvcm1hdENlbGxzKCksIHRoaXMuX29wdGlvbnMuZWRpdCAmJiB0aGlzLl9zZXR1cEVkaXRhYmxlKCksIHRoaXMuX29wdGlvbnMuc2VsZWN0YWJsZSAmJiAodGhpcy5fc2V0dXBTZWxlY3RhYmxlKCksIHRoaXMuX3NldFNlbGVjdGVkKCkpLCB0aGlzLl9vcHRpb25zLmNsaWNrYWJsZVJvd3MgJiYgdGhpcy5fc2V0dXBDbGlja2FibGVSb3dzKCksIGMudHJpZ2dlcih0aGlzLl9lbGVtZW50LCB4bCk7XG4gIH1cbiAgX2Zvcm1hdENlbGxzKCkge1xuICAgIGQuZmluZChmaSwgdGhpcy5fZWxlbWVudCkuZm9yRWFjaCgoZSkgPT4ge1xuICAgICAgY29uc3QgaSA9IGguZ2V0RGF0YUF0dHJpYnV0ZShlLCBcImluZGV4XCIpO1xuICAgICAgZC5maW5kKGZvLCBlKS5mb3JFYWNoKChvKSA9PiB7XG4gICAgICAgIGNvbnN0IHIgPSBoLmdldERhdGFBdHRyaWJ1dGUobywgXCJmaWVsZFwiKSwgYSA9IHRoaXMuY29sdW1ucy5maW5kKChsKSA9PiBsLmZpZWxkID09PSByKTtcbiAgICAgICAgYSAmJiBhLmZvcm1hdCAhPT0gbnVsbCAmJiBhLmZvcm1hdChvLCB0aGlzLnJvd3NbaV1bcl0pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgX3RvZ2dsZURpc2FibGVTdGF0ZSgpIHtcbiAgICB0aGlzLl9vcHRpb25zLnBhZ2luYXRpb24gIT09ICExICYmICh0aGlzLl9hY3RpdmVQYWdlID09PSAwIHx8IHRoaXMuX29wdGlvbnMubG9hZGluZyA/ICh0aGlzLl9wYWdpbmF0aW9uTGVmdC5zZXRBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiLCBcIlwiKSwgdGhpcy5fb3B0aW9ucy5mdWxsUGFnaW5hdGlvbiAmJiB0aGlzLl9wYWdpbmF0aW9uU3RhcnQuc2V0QXR0cmlidXRlKFwiZGlzYWJsZWRcIiwgXCJcIikpIDogKHRoaXMuX3BhZ2luYXRpb25MZWZ0LnJlbW92ZUF0dHJpYnV0ZShcImRpc2FibGVkXCIpLCB0aGlzLl9vcHRpb25zLmZ1bGxQYWdpbmF0aW9uICYmIHRoaXMuX3BhZ2luYXRpb25TdGFydC5yZW1vdmVBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiKSksIHRoaXMuX2FjdGl2ZVBhZ2UgPT09IHRoaXMucGFnZXMgLSAxIHx8IHRoaXMuX29wdGlvbnMubG9hZGluZyB8fCB0aGlzLnBhZ2VzID09PSAwID8gKHRoaXMuX3BhZ2luYXRpb25SaWdodC5zZXRBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiLCBcIlwiKSwgdGhpcy5fb3B0aW9ucy5mdWxsUGFnaW5hdGlvbiAmJiB0aGlzLl9wYWdpbmF0aW9uRW5kLnNldEF0dHJpYnV0ZShcImRpc2FibGVkXCIsIFwiXCIpKSA6ICh0aGlzLl9wYWdpbmF0aW9uUmlnaHQucmVtb3ZlQXR0cmlidXRlKFwiZGlzYWJsZWRcIiksIHRoaXMuX29wdGlvbnMuZnVsbFBhZ2luYXRpb24gJiYgdGhpcy5fcGFnaW5hdGlvbkVuZC5yZW1vdmVBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiKSkpO1xuICB9XG4gIF90b2dnbGVTZWxlY3RBbGwodCkge1xuICAgIHQudGFyZ2V0LmNoZWNrZWQgPyB0aGlzLl9zZWxlY3RlZCA9IHRoaXMucm93cy5tYXAoKGUpID0+IGUucm93SW5kZXgpIDogdGhpcy5fc2VsZWN0ZWQgPSBbXSwgdGhpcy5fc2V0U2VsZWN0ZWQoKSwgdGhpcy5fZW1pdFNlbGVjdEV2ZW50KCk7XG4gIH1cbiAgX3RvZ2dsZVNlbGVjdFJvdyh0LCBlKSB7XG4gICAgdC50YXJnZXQuY2hlY2tlZCA/IHRoaXMuX29wdGlvbnMubXVsdGkgJiYgIXRoaXMuX3NlbGVjdGVkLmluY2x1ZGVzKGUpID8gdGhpcy5fc2VsZWN0ZWQgPSBbLi4udGhpcy5fc2VsZWN0ZWQsIGVdIDogKHRoaXMuX3NlbGVjdGVkID0gW2VdLCB0aGlzLl9jaGVja2JveGVzLmZvckVhY2goKGkpID0+IHtcbiAgICAgIGkgIT09IHQudGFyZ2V0ICYmIChpLmNoZWNrZWQgPSAhMSk7XG4gICAgfSkpIDogdGhpcy5fc2VsZWN0ZWQgPSB0aGlzLl9zZWxlY3RlZC5maWx0ZXIoKGkpID0+IGkgIT09IGUpLCB0aGlzLl9vcHRpb25zLm11bHRpICYmICF0LnRhcmdldC5jaGVja2VkICYmICh0aGlzLl9oZWFkZXJDaGVja2JveC5jaGVja2VkID0gITEpLCB0aGlzLl9zZXRBY3RpdmVSb3dzKCksIHRoaXMuX2VtaXRTZWxlY3RFdmVudCgpO1xuICB9XG4gIF91cGRhdGVSb3codCwgZSkge1xuICAgIGNvbnN0IGkgPSBoLmdldERhdGFBdHRyaWJ1dGUodC50YXJnZXQsIFwiZmllbGRcIiksIG4gPSB0LnRhcmdldC50ZXh0Q29udGVudCwgbyA9IHRoaXMuX3Jvd3NbZV07XG4gICAgaWYgKEFycmF5LmlzQXJyYXkobykpIHtcbiAgICAgIGNvbnN0IGEgPSB0aGlzLmNvbHVtbnMuZmluZCgobCkgPT4gbC5maWVsZCA9PT0gaSkuY29sdW1uSW5kZXg7XG4gICAgICBvW2FdID0gbjtcbiAgICB9IGVsc2VcbiAgICAgIG9baV0gPSBuO1xuICAgIGMudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBadiwge1xuICAgICAgcm93czogdGhpcy5fcm93cyxcbiAgICAgIGNvbHVtbnM6IHRoaXMuX2NvbHVtbnNcbiAgICB9KTtcbiAgfVxuICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKHQsIGUsIGkpIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgbGV0IG4gPSB5LmdldERhdGEodGhpcywgRWkpO1xuICAgICAgY29uc3QgbyA9IHR5cGVvZiB0ID09IFwib2JqZWN0XCIgJiYgdDtcbiAgICAgIGlmICghKCFuICYmIC9kaXNwb3NlLy50ZXN0KHQpKSAmJiAobiB8fCAobiA9IG5ldyBnaCh0aGlzLCBvLCBlKSksIHR5cGVvZiB0ID09IFwic3RyaW5nXCIpKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygblt0XSA+IFwidVwiKVxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcIiR7dH1cImApO1xuICAgICAgICBuW3RdKGUsIGkpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHN0YXRpYyBnZXRJbnN0YW5jZSh0KSB7XG4gICAgcmV0dXJuIHkuZ2V0RGF0YSh0LCBFaSk7XG4gIH1cbiAgc3RhdGljIGdldE9yQ3JlYXRlSW5zdGFuY2UodCwgZSA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0SW5zdGFuY2UodCkgfHwgbmV3IHRoaXModCwgdHlwZW9mIGUgPT0gXCJvYmplY3RcIiA/IGUgOiBudWxsKTtcbiAgfVxufVxuY29uc3QgT2wgPSBcInJhdGluZ1wiLCBxcyA9IFwidGUucmF0aW5nXCIsIHRFID0gXCJkYXRhLXRlLXJhdGluZy1pbml0XCIsIGVFID0gXCJbZGF0YS10ZS1yYXRpbmctaWNvbi1yZWZdXCIsIG5pID0gYC4ke3FzfWAsIGlFID0gXCJBcnJvd0xlZnRcIiwgc0UgPSBcIkFycm93UmlnaHRcIiwgbkUgPSB7XG4gIHRvb2x0aXA6IFwic3RyaW5nXCIsXG4gIHZhbHVlOiBcIihzdHJpbmd8bnVtYmVyKVwiLFxuICByZWFkb25seTogXCJib29sZWFuXCIsXG4gIGFmdGVyOiBcInN0cmluZ1wiLFxuICBiZWZvcmU6IFwic3RyaW5nXCIsXG4gIGR5bmFtaWM6IFwiYm9vbGVhblwiLFxuICBhY3RpdmU6IFwic3RyaW5nXCJcbn0sIG9FID0ge1xuICB0b29sdGlwOiBcInRvcFwiLFxuICB2YWx1ZTogXCJcIixcbiAgcmVhZG9ubHk6ICExLFxuICBhZnRlcjogXCJcIixcbiAgYmVmb3JlOiBcIlwiLFxuICBkeW5hbWljOiAhMSxcbiAgYWN0aXZlOiBcImZpbGwtY3VycmVudFwiXG59LCBTbCA9IGBvblNlbGVjdCR7bml9YCwgckUgPSBgb25Ib3ZlciR7bml9YCwgSWwgPSBga2V5dXAke25pfWAsIERsID0gYGZvY3Vzb3V0JHtuaX1gLCAkbCA9IGBrZXlkb3duJHtuaX1gLCBMbCA9IGBtb3VzZWRvd24ke25pfWA7XG5jbGFzcyBxQyB7XG4gIGNvbnN0cnVjdG9yKHQsIGUpIHtcbiAgICB0aGlzLl9lbGVtZW50ID0gdCwgdGhpcy5faWNvbnMgPSBkLmZpbmQoZUUsIHRoaXMuX2VsZW1lbnQpLCB0aGlzLl9vcHRpb25zID0gdGhpcy5fZ2V0Q29uZmlnKGUpLCB0aGlzLl9pbmRleCA9IC0xLCB0aGlzLl9zYXZlZEluZGV4ID0gbnVsbCwgdGhpcy5fb3JpZ2luYWxDbGFzc0xpc3QgPSBbXSwgdGhpcy5fb3JpZ2luYWxJY29ucyA9IFtdLCB0aGlzLl9mbiA9IHt9LCB0aGlzLl90b29sdGlwcyA9IFtdLCB0aGlzLl9lbGVtZW50ICYmICh5LnNldERhdGEodCwgcXMsIHRoaXMpLCB0aGlzLl9pbml0KCkpO1xuICB9XG4gIC8vIEdldHRlcnNcbiAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgIHJldHVybiBPbDtcbiAgfVxuICBkaXNwb3NlKCkge1xuICAgIHkucmVtb3ZlRGF0YSh0aGlzLl9lbGVtZW50LCBxcyksIHRoaXMuX29wdGlvbnMucmVhZG9ubHkgfHwgKGMub2ZmKHRoaXMuX2VsZW1lbnQsIElsKSwgYy5vZmYodGhpcy5fZWxlbWVudCwgRGwpLCBjLm9mZih0aGlzLl9lbGVtZW50LCAkbCksIHRoaXMuX2VsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlbGVhdmVcIiwgdGhpcy5fZm4ubW91c2VsZWF2ZSksIHRoaXMuX2ljb25zLmZvckVhY2goKHQsIGUpID0+IHtcbiAgICAgIGMub2ZmKHQsIExsKSwgdC5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2VlbnRlclwiLCB0aGlzLl9mbi5tb3VzZWVudGVyW2VdKSwgaC5yZW1vdmVDbGFzcyh0LCBcImN1cnNvci1wb2ludGVyXCIpO1xuICAgIH0pLCB0aGlzLl90b29sdGlwcy5mb3JFYWNoKCh0KSA9PiB7XG4gICAgICB0Ll9lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSh0RSksIHQuZGlzcG9zZSgpO1xuICAgIH0pLCB0aGlzLl9pY29ucy5yZW1vdmVBdHRyaWJ1dGUoXCJ0YWJJbmRleFwiKSksIHRoaXMuX2VsZW1lbnQgPSBudWxsO1xuICB9XG4gIC8vIFByaXZhdGVcbiAgX2luaXQoKSB7XG4gICAgdGhpcy5fb3B0aW9ucy5yZWFkb25seSB8fCAodGhpcy5fYmluZE1vdXNlRW50ZXIoKSwgdGhpcy5fYmluZE1vdXNlTGVhdmUoKSwgdGhpcy5fYmluZE1vdXNlRG93bigpLCB0aGlzLl9iaW5kS2V5RG93bigpLCB0aGlzLl9iaW5kS2V5VXAoKSwgdGhpcy5fYmluZEZvY3VzTG9zdCgpLCB0aGlzLl9pY29ucy5mb3JFYWNoKCh0KSA9PiB7XG4gICAgICBoLmFkZENsYXNzKHQsIFwiY3Vyc29yLXBvaW50ZXJcIik7XG4gICAgfSkpLCB0aGlzLl9vcHRpb25zLmR5bmFtaWMgJiYgKHRoaXMuX3NhdmVPcmlnaW5hbENsYXNzTGlzdCgpLCB0aGlzLl9zYXZlT3JpZ2luYWxJY29ucygpKSwgdGhpcy5fc2V0Q3VzdG9tVGV4dCgpLCB0aGlzLl9zZXRUb29sVGlwcygpLCB0aGlzLl9vcHRpb25zLnZhbHVlICYmICh0aGlzLl9pbmRleCA9IHRoaXMuX29wdGlvbnMudmFsdWUgLSAxLCB0aGlzLl91cGRhdGVSYXRpbmcodGhpcy5faW5kZXgpKTtcbiAgfVxuICBfZ2V0Q29uZmlnKHQpIHtcbiAgICBjb25zdCBlID0gaC5nZXREYXRhQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KTtcbiAgICByZXR1cm4gdCA9IHtcbiAgICAgIC4uLm9FLFxuICAgICAgLi4uZSxcbiAgICAgIC4uLnRcbiAgICB9LCBEKE9sLCB0LCBuRSksIHQ7XG4gIH1cbiAgX2JpbmRNb3VzZUVudGVyKCkge1xuICAgIHRoaXMuX2ZuLm1vdXNlZW50ZXIgPSBbXSwgdGhpcy5faWNvbnMuZm9yRWFjaCgodCwgZSkgPT4ge1xuICAgICAgdC5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgICBcIm1vdXNlZW50ZXJcIixcbiAgICAgICAgLy8gdGhpcy5fZm4ubW91c2VlbnRlcltpXSBpcyBuZWVkZWQgdG8gY3JlYXRlIHJlZmVyZW5jZSBhbmQgdW5waW4gZXZlbnRzIGFmdGVyIGNhbGwgZGlzcG9zZVxuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgdGhpcy5fZm4ubW91c2VlbnRlcltlXSA9IChpKSA9PiB7XG4gICAgICAgICAgdGhpcy5faW5kZXggPSB0aGlzLl9pY29ucy5pbmRleE9mKGkudGFyZ2V0KSwgdGhpcy5fdXBkYXRlUmF0aW5nKHRoaXMuX2luZGV4KSwgdGhpcy5fdHJpZ2dlckV2ZW50cyh0LCByRSk7XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfSk7XG4gIH1cbiAgX2JpbmRNb3VzZUxlYXZlKCkge1xuICAgIHRoaXMuX2VsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgIFwibW91c2VsZWF2ZVwiLFxuICAgICAgLy8gdGhpcy5fZm4ubW91c2VsZWF2ZSBpcyBuZWVkZWQgdG8gY3JlYXRlIHJlZmVyZW5jZSBhbmQgdW5waW4gZXZlbnRzIGFmdGVyIGNhbGwgZGlzcG9zZVxuICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICB0aGlzLl9mbi5tb3VzZWxlYXZlID0gKCkgPT4ge1xuICAgICAgICB0aGlzLl9zYXZlZEluZGV4ICE9PSBudWxsID8gKHRoaXMuX3VwZGF0ZVJhdGluZyh0aGlzLl9zYXZlZEluZGV4KSwgdGhpcy5faW5kZXggPSB0aGlzLl9zYXZlZEluZGV4KSA6IHRoaXMuX29wdGlvbnMudmFsdWUgPyAodGhpcy5fdXBkYXRlUmF0aW5nKHRoaXMuX29wdGlvbnMudmFsdWUgLSAxKSwgdGhpcy5faW5kZXggPSB0aGlzLl9vcHRpb25zLnZhbHVlIC0gMSkgOiAodGhpcy5faW5kZXggPSAtMSwgdGhpcy5fY2xlYXJSYXRpbmcoKSk7XG4gICAgICB9XG4gICAgKTtcbiAgfVxuICBfYmluZE1vdXNlRG93bigpIHtcbiAgICB0aGlzLl9pY29ucy5mb3JFYWNoKCh0KSA9PiB7XG4gICAgICBjLm9uKHQsIExsLCAoKSA9PiB7XG4gICAgICAgIHRoaXMuX3NldEVsZW1lbnRPdXRsaW5lKFwibm9uZVwiKSwgdGhpcy5fc2F2ZWRJbmRleCA9IHRoaXMuX2luZGV4LCB0aGlzLl90cmlnZ2VyRXZlbnRzKHQsIFNsKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIF9iaW5kS2V5RG93bigpIHtcbiAgICB0aGlzLl9lbGVtZW50LnRhYkluZGV4ID0gMCwgYy5vbihcbiAgICAgIHRoaXMuX2VsZW1lbnQsXG4gICAgICAkbCxcbiAgICAgICh0KSA9PiB0aGlzLl91cGRhdGVBZnRlcktleURvd24odClcbiAgICApO1xuICB9XG4gIF9iaW5kS2V5VXAoKSB7XG4gICAgYy5vbihcbiAgICAgIHRoaXMuX2VsZW1lbnQsXG4gICAgICBJbCxcbiAgICAgICgpID0+IHRoaXMuX3NldEVsZW1lbnRPdXRsaW5lKFwiYXV0b1wiKVxuICAgICk7XG4gIH1cbiAgX2JpbmRGb2N1c0xvc3QoKSB7XG4gICAgYy5vbihcbiAgICAgIHRoaXMuX2VsZW1lbnQsXG4gICAgICBEbCxcbiAgICAgICgpID0+IHRoaXMuX3NldEVsZW1lbnRPdXRsaW5lKFwibm9uZVwiKVxuICAgICk7XG4gIH1cbiAgX3NldEVsZW1lbnRPdXRsaW5lKHQpIHtcbiAgICB0aGlzLl9lbGVtZW50LnN0eWxlLm91dGxpbmUgPSB0O1xuICB9XG4gIF90cmlnZ2VyRXZlbnRzKHQsIGUpIHtcbiAgICBjLnRyaWdnZXIodCwgZSwge1xuICAgICAgdmFsdWU6IHRoaXMuX2luZGV4ICsgMVxuICAgIH0pO1xuICB9XG4gIF91cGRhdGVBZnRlcktleURvd24odCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLl9pY29ucy5sZW5ndGggLSAxLCBpID0gdGhpcy5faW5kZXg7XG4gICAgdC5rZXkgPT09IHNFICYmIHRoaXMuX2luZGV4IDwgZSAmJiAodGhpcy5faW5kZXggKz0gMSksIHQua2V5ID09PSBpRSAmJiB0aGlzLl9pbmRleCA+IC0xICYmICh0aGlzLl9pbmRleCAtPSAxKSwgaSAhPT0gdGhpcy5faW5kZXggJiYgKHRoaXMuX3NhdmVkSW5kZXggPSB0aGlzLl9pbmRleCwgdGhpcy5fdXBkYXRlUmF0aW5nKHRoaXMuX3NhdmVkSW5kZXgpLCB0aGlzLl90cmlnZ2VyRXZlbnRzKHRoaXMuX2ljb25zW3RoaXMuX3NhdmVkSW5kZXhdLCBTbCkpO1xuICB9XG4gIF91cGRhdGVSYXRpbmcodCkge1xuICAgIHRoaXMuX2NsZWFyUmF0aW5nKCksIHRoaXMuX29wdGlvbnMuZHluYW1pYyAmJiB0aGlzLl9yZXN0b3JlT3JpZ2luYWxJY29uKHQpLCB0aGlzLl9pY29ucy5mb3JFYWNoKChlLCBpKSA9PiB7XG4gICAgICBpIDw9IHQgJiYgaC5hZGRDbGFzcyhlLnF1ZXJ5U2VsZWN0b3IoXCJzdmdcIiksIHRoaXMuX29wdGlvbnMuYWN0aXZlKTtcbiAgICB9KTtcbiAgfVxuICBfY2xlYXJSYXRpbmcoKSB7XG4gICAgdGhpcy5faWNvbnMuZm9yRWFjaCgodCwgZSkgPT4ge1xuICAgICAgY29uc3QgaSA9IHQucXVlcnlTZWxlY3RvcihcInN2Z1wiKTtcbiAgICAgIHRoaXMuX29wdGlvbnMuZHluYW1pYyAmJiAodC5jbGFzc0xpc3QgPSB0aGlzLl9vcmlnaW5hbENsYXNzTGlzdFtlXSwgaS5pbm5lckhUTUwgPSB0aGlzLl9vcmlnaW5hbEljb25zW2VdKSwgaC5yZW1vdmVDbGFzcyhpLCB0aGlzLl9vcHRpb25zLmFjdGl2ZSk7XG4gICAgfSk7XG4gIH1cbiAgX3NldFRvb2xUaXBzKCkge1xuICAgIHRoaXMuX2ljb25zLmZvckVhY2goKHQsIGUpID0+IHtcbiAgICAgIGNvbnN0IGkgPSBoLmdldERhdGFBdHRyaWJ1dGUodCwgXCJ0b2dnbGVcIik7XG4gICAgICB0LnRpdGxlICYmICFpICYmIChoLnNldERhdGFBdHRyaWJ1dGUodCwgXCJ0b2dnbGVcIiwgXCJ0b29sdGlwXCIpLCB0aGlzLl90b29sdGlwc1tlXSA9IG5ldyBpaSh0LCB7XG4gICAgICAgIHBsYWNlbWVudDogdGhpcy5fb3B0aW9ucy50b29sdGlwXG4gICAgICB9KSk7XG4gICAgfSk7XG4gIH1cbiAgX3NldEN1c3RvbVRleHQoKSB7XG4gICAgdGhpcy5faWNvbnMuZm9yRWFjaCgodCkgPT4ge1xuICAgICAgY29uc3QgZSA9IGguZ2V0RGF0YUF0dHJpYnV0ZSh0LCBcImFmdGVyXCIpLCBpID0gaC5nZXREYXRhQXR0cmlidXRlKHQsIFwiYmVmb3JlXCIpO1xuICAgICAgZSAmJiB0Lmluc2VydEFkamFjZW50SFRNTChcImFmdGVyRW5kXCIsIGUpLCBpICYmIHQuaW5zZXJ0QWRqYWNlbnRIVE1MKFwiYmVmb3JlQmVnaW5cIiwgaSk7XG4gICAgfSk7XG4gIH1cbiAgX3NhdmVPcmlnaW5hbENsYXNzTGlzdCgpIHtcbiAgICB0aGlzLl9pY29ucy5mb3JFYWNoKCh0KSA9PiB7XG4gICAgICBjb25zdCBlID0gdC5jbGFzc0xpc3QudmFsdWU7XG4gICAgICB0aGlzLl9vcmlnaW5hbENsYXNzTGlzdC5wdXNoKGUpO1xuICAgIH0pO1xuICB9XG4gIF9zYXZlT3JpZ2luYWxJY29ucygpIHtcbiAgICB0aGlzLl9pY29ucy5mb3JFYWNoKCh0KSA9PiB7XG4gICAgICBjb25zdCBlID0gdC5xdWVyeVNlbGVjdG9yKFwic3ZnXCIpLmlubmVySFRNTDtcbiAgICAgIHRoaXMuX29yaWdpbmFsSWNvbnMucHVzaChlKTtcbiAgICB9KTtcbiAgfVxuICBfcmVzdG9yZU9yaWdpbmFsSWNvbih0KSB7XG4gICAgY29uc3QgZSA9IHRoaXMuX29yaWdpbmFsQ2xhc3NMaXN0W3RdLCBpID0gdGhpcy5fb3JpZ2luYWxJY29uc1t0XTtcbiAgICB0aGlzLl9pY29ucy5mb3JFYWNoKChuLCBvKSA9PiB7XG4gICAgICBpZiAobyA8PSB0KSB7XG4gICAgICAgIGNvbnN0IHIgPSBuLnF1ZXJ5U2VsZWN0b3IoXCJzdmdcIik7XG4gICAgICAgIHIuaW5uZXJIVE1MID0gaSwgbi5jbGFzc0xpc3QgPSBlO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIC8vIFN0YXRpY1xuICBzdGF0aWMgZ2V0SW5zdGFuY2UodCkge1xuICAgIHJldHVybiB5LmdldERhdGEodCwgcXMpO1xuICB9XG4gIHN0YXRpYyBnZXRPckNyZWF0ZUluc3RhbmNlKHQsIGUgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLmdldEluc3RhbmNlKHQpIHx8IG5ldyB0aGlzKHQsIHR5cGVvZiBlID09IFwib2JqZWN0XCIgPyBlIDogbnVsbCk7XG4gIH1cbn1cbmNvbnN0IGJvID0gXCJwb3Bjb25maXJtXCIsIENpID0gXCJ0ZS5wb3Bjb25maXJtXCIsIGJoID0gYC4ke0NpfWAsIGFFID0gYGNhbmNlbCR7Ymh9YCwgbEUgPSBgY29uZmlybSR7Ymh9YCwgY0UgPSBcIltkYXRhLXRlLXBvcGNvbmZpcm0tYm9keV1cIiwgdm8gPSBcImRhdGEtdGUtcG9wY29uZmlybS1wb3BvdmVyXCIsIGhFID0gXCJkYXRhLXRlLXBvcGNvbmZpcm0tbW9kYWxcIiwgTmwgPSBcImRhdGEtdGUtcG9wY29uZmlybS1iYWNrZHJvcFwiLCBkRSA9IHtcbiAgcG9wY29uZmlybU1vZGU6IFwic3RyaW5nXCIsXG4gIG1lc3NhZ2U6IFwic3RyaW5nXCIsXG4gIGNhbmNlbFRleHQ6IFwiKG51bGx8c3RyaW5nKVwiLFxuICBva1RleHQ6IFwiKG51bGx8c3RyaW5nKVwiLFxuICBwb3Bjb25maXJtSWNvblRlbXBsYXRlOiBcInN0cmluZ1wiLFxuICBjYW5jZWxMYWJlbDogXCIobnVsbHxzdHJpbmcpXCIsXG4gIGNvbmZpcm1MYWJlbDogXCIobnVsbHxzdHJpbmcpXCIsXG4gIHBvc2l0aW9uOiBcIihudWxsfHN0cmluZylcIlxufSwgdUUgPSB7XG4gIHBvcGNvbmZpcm1Nb2RlOiBcImlubGluZVwiLFxuICBtZXNzYWdlOiBcIkFyZSB5b3Ugc3VyZT9cIixcbiAgY2FuY2VsVGV4dDogXCJDYW5jZWxcIixcbiAgb2tUZXh0OiBcIk9LXCIsXG4gIHBvcGNvbmZpcm1JY29uVGVtcGxhdGU6IFwiXCIsXG4gIGNhbmNlbExhYmVsOiBcIkNhbmNlbFwiLFxuICBjb25maXJtTGFiZWw6IFwiQ29uZmlybVwiLFxuICBwb3NpdGlvbjogXCJib3R0b21cIlxufSwgcEUgPSB7XG4gIGJhY2tkcm9wOiBcInN0cmluZ1wiLFxuICBib2R5OiBcInN0cmluZ1wiLFxuICBidG5DYW5jZWw6IFwic3RyaW5nXCIsXG4gIGJ0bkNvbmZpcm06IFwic3RyaW5nXCIsXG4gIGJ0bnNDb250YWluZXI6IFwic3RyaW5nXCIsXG4gIGZhZGU6IFwic3RyaW5nXCIsXG4gIGljb246IFwic3RyaW5nXCIsXG4gIG1lc3NhZ2U6IFwic3RyaW5nXCIsXG4gIG1lc3NhZ2VUZXh0OiBcInN0cmluZ1wiLFxuICBtb2RhbDogXCJzdHJpbmdcIixcbiAgcG9wb3ZlcjogXCJzdHJpbmdcIlxufSwgX0UgPSB7XG4gIGJhY2tkcm9wOiBcImgtZnVsbCB3LWZ1bGwgei1bMTA3MF0gZml4ZWQgdG9wLTAgbGVmdC0wIGJnLVsjMDAwMDAwNjZdIGZsZXgganVzdGlmeS1jZW50ZXIgaXRlbXMtY2VudGVyXCIsXG4gIGJvZHk6IFwicC1bMXJlbV0gYmctd2hpdGUgcm91bmRlZC1bMC41cmVtXSBvcGFjaXR5LTAgZGFyazpiZy1uZXV0cmFsLTcwMFwiLFxuICBidG5DYW5jZWw6IFwiaW5saW5lLWJsb2NrIHJvdW5kZWQgYmctcHJpbWFyeS0xMDAgcHgtNCBwYi1bNXB4XSBwdC1bNnB4XSB0ZXh0LXhzIGZvbnQtbWVkaXVtIHVwcGVyY2FzZSBsZWFkaW5nLW5vcm1hbCB0ZXh0LXByaW1hcnktNzAwIHRyYW5zaXRpb24gZHVyYXRpb24tMTUwIGVhc2UtaW4tb3V0IGhvdmVyOmJnLXByaW1hcnktYWNjZW50LTEwMCBmb2N1czpiZy1wcmltYXJ5LWFjY2VudC0xMDAgZm9jdXM6b3V0bGluZS1ub25lIGZvY3VzOnJpbmctMCBhY3RpdmU6YmctcHJpbWFyeS1hY2NlbnQtMjAwXCIsXG4gIGJ0bkNvbmZpcm06IFwiaW5saW5lLWJsb2NrIHJvdW5kZWQgYmctcHJpbWFyeSBweC00IHBiLVs1cHhdIHB0LVs2cHhdIHRleHQteHMgZm9udC1tZWRpdW0gdXBwZXJjYXNlIGxlYWRpbmctbm9ybWFsIHRleHQtd2hpdGUgc2hhZG93LVswXzRweF85cHhfLTRweF8jM2I3MWNhXSB0cmFuc2l0aW9uIGR1cmF0aW9uLTE1MCBlYXNlLWluLW91dCBob3ZlcjpiZy1wcmltYXJ5LTYwMCBob3ZlcjpzaGFkb3ctWzBfOHB4XzlweF8tNHB4X3JnYmEoNTksMTEzLDIwMiwwLjMpLDBfNHB4XzE4cHhfMF9yZ2JhKDU5LDExMywyMDIsMC4yKV0gZm9jdXM6YmctcHJpbWFyeS02MDAgZm9jdXM6c2hhZG93LVswXzhweF85cHhfLTRweF9yZ2JhKDU5LDExMywyMDIsMC4zKSwwXzRweF8xOHB4XzBfcmdiYSg1OSwxMTMsMjAyLDAuMildIGZvY3VzOm91dGxpbmUtbm9uZSBmb2N1czpyaW5nLTAgYWN0aXZlOmJnLXByaW1hcnktNzAwIGFjdGl2ZTpzaGFkb3ctWzBfOHB4XzlweF8tNHB4X3JnYmEoNTksMTEzLDIwMiwwLjMpLDBfNHB4XzE4cHhfMF9yZ2JhKDU5LDExMywyMDIsMC4yKV0gZGFyazpzaGFkb3ctWzBfNHB4XzlweF8tNHB4X3JnYmEoNTksMTEzLDIwMiwwLjUpXSBkYXJrOmhvdmVyOnNoYWRvdy1bMF84cHhfOXB4Xy00cHhfcmdiYSg1OSwxMTMsMjAyLDAuMiksMF80cHhfMThweF8wX3JnYmEoNTksMTEzLDIwMiwwLjEpXSBkYXJrOmZvY3VzOnNoYWRvdy1bMF84cHhfOXB4Xy00cHhfcmdiYSg1OSwxMTMsMjAyLDAuMiksMF80cHhfMThweF8wX3JnYmEoNTksMTEzLDIwMiwwLjEpXSBkYXJrOmFjdGl2ZTpzaGFkb3ctWzBfOHB4XzlweF8tNHB4X3JnYmEoNTksMTEzLDIwMiwwLjIpLDBfNHB4XzE4cHhfMF9yZ2JhKDU5LDExMywyMDIsMC4xKV1cIixcbiAgYnRuc0NvbnRhaW5lcjogXCJmbGV4IGp1c3RpZnktZW5kIHNwYWNlLXgtMlwiLFxuICBmYWRlOiBcInRyYW5zaXRpb24tb3BhY2l0eSBkdXJhdGlvbi1bMTUwbXNdIGVhc2UtbGluZWFyXCIsXG4gIGljb246IFwicHItMlwiLFxuICBtZXNzYWdlOiBcImZsZXggbWItM1wiLFxuICBtZXNzYWdlVGV4dDogXCJ0ZXh0LW5ldXRyYWwtNjAwIGRhcms6dGV4dC13aGl0ZVwiLFxuICBtb2RhbDogXCJhYnNvbHV0ZSB3LVszMDBweF0gei1bMTA4MF0gc2hhZG93LXNtIHJvdW5kZWQtWzAuNXJlbV1cIixcbiAgcG9wb3ZlcjogXCJ3LVszMDBweF0gYm9yZGVyLTAgcm91bmRlZC1bMC41cmVtXSB6LVsxMDgwXSBzaGFkb3ctc21cIlxufTtcbmNsYXNzIHZoIHtcbiAgY29uc3RydWN0b3IodCwgZSwgaSkge1xuICAgIHRoaXMuX2VsZW1lbnQgPSB0LCB0aGlzLl9vcHRpb25zID0gdGhpcy5fZ2V0Q29uZmlnKGUpLCB0aGlzLl9jbGFzc2VzID0gdGhpcy5fZ2V0Q2xhc3NlcyhpKSwgdGhpcy5fcG9wcGVyID0gbnVsbCwgdGhpcy5fY2FuY2VsQnV0dG9uID0gXCJcIiwgdGhpcy5fY29uZmlybUJ1dHRvbiA9IFwiXCIsIHRoaXMuX2lzT3BlbiA9ICExLCB0aGlzLl91aWQgPSB0aGlzLl9lbGVtZW50LmlkID8gYHBvcGNvbmZpcm0tJHt0aGlzLl9lbGVtZW50LmlkfWAgOiBydChcInBvcGNvbmZpcm0tXCIpLCB0ICYmIHkuc2V0RGF0YSh0LCBDaSwgdGhpcyksIHRoaXMuX2NsaWNrSGFuZGxlciA9IHRoaXMub3Blbi5iaW5kKHRoaXMpLCBjLm9uKHRoaXMuX2VsZW1lbnQsIFwiY2xpY2tcIiwgdGhpcy5fY2xpY2tIYW5kbGVyKTtcbiAgfVxuICAvLyBHZXR0ZXJzXG4gIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICByZXR1cm4gYm87XG4gIH1cbiAgZ2V0IGNvbnRhaW5lcigpIHtcbiAgICByZXR1cm4gZC5maW5kT25lKGAjJHt0aGlzLl91aWR9YCk7XG4gIH1cbiAgZ2V0IHBvcGNvbmZpcm1Cb2R5KCkge1xuICAgIHJldHVybiBkLmZpbmRPbmUoXG4gICAgICBjRSxcbiAgICAgIHRoaXMuY29udGFpbmVyXG4gICAgKTtcbiAgfVxuICAvLyBQdWJsaWNcbiAgZGlzcG9zZSgpIHtcbiAgICAodGhpcy5faXNPcGVuIHx8IHRoaXMuY29udGFpbmVyICE9PSBudWxsKSAmJiB0aGlzLmNsb3NlKCksIHkucmVtb3ZlRGF0YSh0aGlzLl9lbGVtZW50LCBDaSksIGMub2ZmKHRoaXMuX2VsZW1lbnQsIFwiY2xpY2tcIiwgdGhpcy5fY2xpY2tIYW5kbGVyKSwgdGhpcy5fZWxlbWVudCA9IG51bGw7XG4gIH1cbiAgb3BlbigpIHtcbiAgICB0aGlzLl9pc09wZW4gfHwgKHRoaXMuX29wdGlvbnMucG9wY29uZmlybU1vZGUgPT09IFwiaW5saW5lXCIgPyB0aGlzLl9vcGVuUG9wb3Zlcih0aGlzLl9nZXRQb3BvdmVyVGVtcGxhdGUoKSkgOiB0aGlzLl9vcGVuTW9kYWwodGhpcy5fZ2V0TW9kYWxUZW1wbGF0ZSgpKSwgdGhpcy5faGFuZGxlQ2FuY2VsQnV0dG9uQ2xpY2soKSwgdGhpcy5faGFuZGxlQ29uZmlybUJ1dHRvbkNsaWNrKCksIHRoaXMuX2xpc3RlblRvRXNjYXBlS2V5KCksIHRoaXMuX2xpc3RlblRvT3V0c2lkZUNsaWNrKCkpO1xuICB9XG4gIGNsb3NlKCkge1xuICAgIGlmICh0aGlzLl9pc09wZW4pIHtcbiAgICAgIGlmICh0aGlzLl9wb3BwZXIgIT09IG51bGwgfHwgZC5maW5kT25lKGBbJHt2b31dYCkgIT09IG51bGwpXG4gICAgICAgIGMub24oXG4gICAgICAgICAgdGhpcy5wb3Bjb25maXJtQm9keSxcbiAgICAgICAgICBcInRyYW5zaXRpb25lbmRcIixcbiAgICAgICAgICB0aGlzLl9oYW5kbGVQb3Bjb25maXJtVHJhbnNpdGlvbkVuZC5iaW5kKHRoaXMpXG4gICAgICAgICksIGgucmVtb3ZlQ2xhc3ModGhpcy5wb3Bjb25maXJtQm9keSwgXCJvcGFjaXR5LTEwMFwiKTtcbiAgICAgIGVsc2Uge1xuICAgICAgICBjb25zdCB0ID0gZC5maW5kT25lKFxuICAgICAgICAgIGBbJHtObH1dYFxuICAgICAgICApO1xuICAgICAgICBoLnJlbW92ZUNsYXNzKHRoaXMucG9wY29uZmlybUJvZHksIFwib3BhY2l0eS0xMDBcIiksIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQodCksIHRoaXMuX2lzT3BlbiA9ICExO1xuICAgICAgfVxuICAgICAgYy5vZmYoZG9jdW1lbnQsIFwiY2xpY2tcIiwgdGhpcy5faGFuZGxlT3V0c2lkZUNsaWNrLmJpbmQodGhpcykpLCBjLm9mZihkb2N1bWVudCwgXCJrZXlkb3duXCIsIHRoaXMuX2hhbmRsZUVzY2FwZUtleS5iaW5kKHRoaXMpKTtcbiAgICB9XG4gIH1cbiAgX2hhbmRsZVBvcGNvbmZpcm1UcmFuc2l0aW9uRW5kKHQpIHtcbiAgICBpZiAodC50YXJnZXQgIT09IHRoaXMucG9wY29uZmlybUJvZHkpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgZSA9IGQuZmluZE9uZShcbiAgICAgIGBbJHt2b31dYFxuICAgICk7XG4gICAgYy5vZmYodGhpcy5wb3Bjb25maXJtQm9keSwgXCJ0cmFuc2l0aW9uZW5kXCIpLCB0aGlzLl9pc09wZW4gJiYgdCAmJiB0LnByb3BlcnR5TmFtZSA9PT0gXCJvcGFjaXR5XCIgJiYgKHRoaXMuX3BvcHBlci5kZXN0cm95KCksIGUgJiYgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChlKSwgdGhpcy5faXNPcGVuID0gITEpO1xuICB9XG4gIC8vIFByaXZhdGVcbiAgX2dldFBvcG92ZXJUZW1wbGF0ZSgpIHtcbiAgICBjb25zdCB0ID0gJChcImRpdlwiKSwgZSA9IHRoaXMuX2dldFBvcGNvbmZpcm1UZW1wbGF0ZSgpO1xuICAgIHJldHVybiB0LnNldEF0dHJpYnV0ZSh2bywgXCJcIiksIGguYWRkQ2xhc3ModCwgdGhpcy5fY2xhc3Nlcy5wb3BvdmVyKSwgdC5pZCA9IHRoaXMuX3VpZCwgdC5pbm5lckhUTUwgPSBlLCB0O1xuICB9XG4gIF9nZXRNb2RhbFRlbXBsYXRlKCkge1xuICAgIGNvbnN0IHQgPSAkKFwiZGl2XCIpLCBlID0gdGhpcy5fZ2V0UG9wY29uZmlybVRlbXBsYXRlKCk7XG4gICAgcmV0dXJuIHQuc2V0QXR0cmlidXRlKGhFLCBcIlwiKSwgaC5hZGRDbGFzcyh0LCBgJHt0aGlzLl9jbGFzc2VzLm1vZGFsfWApLCB0LmlkID0gdGhpcy5fdWlkLCB0LmlubmVySFRNTCA9IGUsIHQ7XG4gIH1cbiAgX2dldFBvcGNvbmZpcm1UZW1wbGF0ZSgpIHtcbiAgICByZXR1cm4gYDxkaXYgZGF0YS10ZS1wb3Bjb25maXJtLWJvZHkgY2xhc3M9XCIke3RoaXMuX2NsYXNzZXMuYm9keX1cIj5cbiAgICAgIDxwIGNsYXNzPVwiJHt0aGlzLl9jbGFzc2VzLm1lc3NhZ2V9XCI+XG4gICAgICAke3RoaXMuX29wdGlvbnMucG9wY29uZmlybUljb25UZW1wbGF0ZSA/IGA8c3BhbiBjbGFzcz1cIiR7dGhpcy5fY2xhc3Nlcy5pY29ufVwiPiR7dGhpcy5fb3B0aW9ucy5wb3Bjb25maXJtSWNvblRlbXBsYXRlfTwvc3Bhbj5gIDogXCJcIn1cbiAgICAgIDxzcGFuIGNsYXNzPVwiJHt0aGlzLl9jbGFzc2VzLm1lc3NhZ2VUZXh0fVwiPiR7dGhpcy5fb3B0aW9ucy5tZXNzYWdlfTwvc3Bhbj5cbiAgICAgIDwvcD5cbiAgICAgIDxkaXYgY2xhc3M9XCIke3RoaXMuX2NsYXNzZXMuYnRuc0NvbnRhaW5lcn1cIj5cbiAgICAgICR7dGhpcy5fb3B0aW9ucy5jYW5jZWxUZXh0ID8gYDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGRhdGEtdGUtcmlwcGxlLWluaXQgZGF0YS10ZS1yaXBwbGUtY29sb3I9XCJsaWdodFwiIGlkPVwicG9wY29uZmlybS1idXR0b24tY2FuY2VsXCIgYXJpYS1sYWJlbD1cIiR7dGhpcy5fb3B0aW9ucy5jYW5jZWxMYWJlbH1cIlxuICAgICAgICBjbGFzcz1cIiR7dGhpcy5fY2xhc3Nlcy5idG5DYW5jZWx9XCI+JHt0aGlzLl9vcHRpb25zLmNhbmNlbFRleHR9PC9idXR0b24+YCA6IFwiXCJ9XG4gICAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBkYXRhLXRlLXJpcHBsZS1pbml0IGRhdGEtdGUtcmlwcGxlLWNvbG9yPVwibGlnaHRcIiBpZD1cInBvcGNvbmZpcm0tYnV0dG9uLWNvbmZpcm1cIlxuICAgICAgYXJpYS1sYWJlbD1cIiR7dGhpcy5fb3B0aW9ucy5jb25maXJtTGFiZWx9XCJcbiAgICAgIGNsYXNzPVwiJHt0aGlzLl9jbGFzc2VzLmJ0bkNvbmZpcm19XCI+JHt0aGlzLl9vcHRpb25zLm9rVGV4dCA/IHRoaXMuX29wdGlvbnMub2tUZXh0IDogXCJPa1wifTwvYnV0dG9uPlxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+YDtcbiAgfVxuICBfZ2V0Q29uZmlnKHQpIHtcbiAgICByZXR1cm4gdCA9IHtcbiAgICAgIC4uLnVFLFxuICAgICAgLi4uaC5nZXREYXRhQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KSxcbiAgICAgIC4uLnRcbiAgICB9LCBEKGJvLCB0LCBkRSksIHQ7XG4gIH1cbiAgX2dldENsYXNzZXModCkge1xuICAgIGNvbnN0IGUgPSBoLmdldERhdGFDbGFzc0F0dHJpYnV0ZXModGhpcy5fZWxlbWVudCk7XG4gICAgcmV0dXJuIHQgPSB7XG4gICAgICAuLi5fRSxcbiAgICAgIC4uLmUsXG4gICAgICAuLi50XG4gICAgfSwgRChibywgdCwgcEUpLCB0O1xuICB9XG4gIF9vcGVuUG9wb3Zlcih0KSB7XG4gICAgdGhpcy5fcG9wcGVyID0gQ2UodGhpcy5fZWxlbWVudCwgdCwge1xuICAgICAgcGxhY2VtZW50OiB0aGlzLl90cmFuc2xhdGVQb3NpdGlvblZhbHVlKCksXG4gICAgICBtb2RpZmllcnM6IFtcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6IFwib2Zmc2V0XCIsXG4gICAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgb2Zmc2V0OiBbMCwgNV1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIF1cbiAgICB9KSwgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0KSwgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBoLmFkZENsYXNzKFxuICAgICAgICB0aGlzLnBvcGNvbmZpcm1Cb2R5LFxuICAgICAgICBgJHt0aGlzLl9jbGFzc2VzLmZhZGV9IG9wYWNpdHktMTAwYFxuICAgICAgKSwgdGhpcy5faXNPcGVuID0gITA7XG4gICAgfSwgMCk7XG4gIH1cbiAgX29wZW5Nb2RhbCh0KSB7XG4gICAgY29uc3QgZSA9ICQoXCJkaXZcIik7XG4gICAgZS5zZXRBdHRyaWJ1dGUoTmwsIFwiXCIpLCBoLmFkZENsYXNzKGUsIHRoaXMuX2NsYXNzZXMuYmFja2Ryb3ApLCBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGUpLCBlLmFwcGVuZENoaWxkKHQpLCBoLmFkZENsYXNzKHRoaXMucG9wY29uZmlybUJvZHksIFwib3BhY2l0eS0xMDBcIiksIHRoaXMuX2lzT3BlbiA9ICEwO1xuICB9XG4gIF9oYW5kbGVDYW5jZWxCdXR0b25DbGljaygpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5jb250YWluZXI7XG4gICAgdGhpcy5fY2FuY2VsQnV0dG9uID0gZC5maW5kT25lKFxuICAgICAgXCIjcG9wY29uZmlybS1idXR0b24tY2FuY2VsXCIsXG4gICAgICB0XG4gICAgKSwgWmUuZ2V0T3JDcmVhdGVJbnN0YW5jZSh0aGlzLl9jYW5jZWxCdXR0b24sIHsgcmlwcGxlQ29sb3I6IFwibGlnaHRcIiB9KSwgdGhpcy5fY2FuY2VsQnV0dG9uICE9PSBudWxsICYmIGMub24odGhpcy5fY2FuY2VsQnV0dG9uLCBcImNsaWNrXCIsICgpID0+IHtcbiAgICAgIHRoaXMuY2xvc2UoKSwgYy50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIGFFKTtcbiAgICB9KTtcbiAgfVxuICBfaGFuZGxlQ29uZmlybUJ1dHRvbkNsaWNrKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLmNvbnRhaW5lcjtcbiAgICB0aGlzLl9jb25maXJtQnV0dG9uID0gZC5maW5kT25lKFxuICAgICAgXCIjcG9wY29uZmlybS1idXR0b24tY29uZmlybVwiLFxuICAgICAgdFxuICAgICksIFplLmdldE9yQ3JlYXRlSW5zdGFuY2UodGhpcy5fY29uZmlybUJ1dHRvbiwgeyByaXBwbGVDb2xvcjogXCJsaWdodFwiIH0pLCBjLm9uKHRoaXMuX2NvbmZpcm1CdXR0b24sIFwiY2xpY2tcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5jbG9zZSgpLCBjLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgbEUpO1xuICAgIH0pO1xuICB9XG4gIF9saXN0ZW5Ub0VzY2FwZUtleSgpIHtcbiAgICBjLm9uKGRvY3VtZW50LCBcImtleWRvd25cIiwgdGhpcy5faGFuZGxlRXNjYXBlS2V5LmJpbmQodGhpcykpO1xuICB9XG4gIF9oYW5kbGVFc2NhcGVLZXkodCkge1xuICAgIHQua2V5Q29kZSA9PT0gRmkgJiYgdGhpcy5jbG9zZSgpO1xuICB9XG4gIF9saXN0ZW5Ub091dHNpZGVDbGljaygpIHtcbiAgICBjLm9uKGRvY3VtZW50LCBcImNsaWNrXCIsIHRoaXMuX2hhbmRsZU91dHNpZGVDbGljay5iaW5kKHRoaXMpKTtcbiAgfVxuICBfaGFuZGxlT3V0c2lkZUNsaWNrKHQpIHtcbiAgICBjb25zdCBlID0gdGhpcy5jb250YWluZXIsIGkgPSB0LnRhcmdldCA9PT0gZSwgbiA9IGUgJiYgZS5jb250YWlucyh0LnRhcmdldCksIG8gPSB0LnRhcmdldCA9PT0gdGhpcy5fZWxlbWVudCwgciA9IHRoaXMuX2VsZW1lbnQgJiYgdGhpcy5fZWxlbWVudC5jb250YWlucyh0LnRhcmdldCk7XG4gICAgIWkgJiYgIW4gJiYgIW8gJiYgIXIgJiYgdGhpcy5jbG9zZSgpO1xuICB9XG4gIF90cmFuc2xhdGVQb3NpdGlvblZhbHVlKCkge1xuICAgIHN3aXRjaCAodGhpcy5fb3B0aW9ucy5wb3NpdGlvbikge1xuICAgICAgY2FzZSBcInRvcCBsZWZ0XCI6XG4gICAgICAgIHJldHVybiBcInRvcC1lbmRcIjtcbiAgICAgIGNhc2UgXCJ0b3BcIjpcbiAgICAgICAgcmV0dXJuIFwidG9wXCI7XG4gICAgICBjYXNlIFwidG9wIHJpZ2h0XCI6XG4gICAgICAgIHJldHVybiBcInRvcC1zdGFydFwiO1xuICAgICAgY2FzZSBcImJvdHRvbSBsZWZ0XCI6XG4gICAgICAgIHJldHVybiBcImJvdHRvbS1lbmRcIjtcbiAgICAgIGNhc2UgXCJib3R0b21cIjpcbiAgICAgICAgcmV0dXJuIFwiYm90dG9tXCI7XG4gICAgICBjYXNlIFwiYm90dG9tIHJpZ2h0XCI6XG4gICAgICAgIHJldHVybiBcImJvdHRvbS1zdGFydFwiO1xuICAgICAgY2FzZSBcImxlZnRcIjpcbiAgICAgICAgcmV0dXJuIFwibGVmdFwiO1xuICAgICAgY2FzZSBcImxlZnQgdG9wXCI6XG4gICAgICAgIHJldHVybiBcImxlZnQtZW5kXCI7XG4gICAgICBjYXNlIFwibGVmdCBib3R0b21cIjpcbiAgICAgICAgcmV0dXJuIFwibGVmdC1zdGFydFwiO1xuICAgICAgY2FzZSBcInJpZ2h0XCI6XG4gICAgICAgIHJldHVybiBcInJpZ2h0XCI7XG4gICAgICBjYXNlIFwicmlnaHQgdG9wXCI6XG4gICAgICAgIHJldHVybiBcInJpZ2h0LWVuZFwiO1xuICAgICAgY2FzZSBcInJpZ2h0IGJvdHRvbVwiOlxuICAgICAgICByZXR1cm4gXCJyaWdodC1zdGFydFwiO1xuICAgICAgY2FzZSB2b2lkIDA6XG4gICAgICAgIHJldHVybiBcImJvdHRvbVwiO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIFwiYm90dG9tXCI7XG4gICAgfVxuICB9XG4gIC8vIFN0YXRpY1xuICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKHQsIGUpIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgY29uc3QgaSA9IHkuZ2V0RGF0YSh0aGlzLCBDaSksIG4gPSB0eXBlb2YgdCA9PSBcIm9iamVjdFwiICYmIHQ7XG4gICAgICBpZiAoISghaSAmJiAvZGlzcG9zZS8udGVzdCh0KSkpIHtcbiAgICAgICAgaWYgKCFpKVxuICAgICAgICAgIHJldHVybiBuZXcgdmgodGhpcywgbik7XG4gICAgICAgIGlmICh0eXBlb2YgdCA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBpW3RdID4gXCJ1XCIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBObyBtZXRob2QgbmFtZWQgXCIke3R9XCJgKTtcbiAgICAgICAgICBpW3RdKGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgc3RhdGljIGdldEluc3RhbmNlKHQpIHtcbiAgICByZXR1cm4geS5nZXREYXRhKHQsIENpKTtcbiAgfVxuICBzdGF0aWMgZ2V0T3JDcmVhdGVJbnN0YW5jZSh0LCBlID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5nZXRJbnN0YW5jZSh0KSB8fCBuZXcgdGhpcyh0LCB0eXBlb2YgZSA9PSBcIm9iamVjdFwiID8gZSA6IG51bGwpO1xuICB9XG59XG5jb25zdCBUbyA9IFwibGlnaHRib3hcIiwgQWkgPSBcInRlLmxpZ2h0Ym94XCIsIGZFID0gYC4ke0FpfWAsIG1FID0gXCIuZGF0YS1hcGlcIiwgSWUgPSBgY2xpY2ske2ZFfSR7bUV9YCwgVGggPSBcIltkYXRhLXRlLWxpZ2h0Ym94LWluaXRdXCIsIGdFID0gYCR7VGh9IGltZzpub3QoW2RhdGEtdGUtbGlnaHRib3gtZGlzYWJsZWRdKWAsIE1sID0gXCJkYXRhLXRlLWxpZ2h0Ym94LWNhcHRpb25cIiwgYkUgPSBcImRhdGEtdGUtbGlnaHRib3gtZGlzYWJsZWRcIiwgSXQgPSBcImRhdGEtdGUtbGlnaHRib3gtYWN0aXZlXCIsIHZFID0gYDxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIGZpbGw9XCJjdXJyZW50Q29sb3JcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgc3Ryb2tlLXdpZHRoPVwiM1wiIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIGNsYXNzPVwidy00IGgtNFwiPlxuICA8cGF0aCBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIiBkPVwiTTE5LjUgMTJoLTE1bTAgMGw2Ljc1IDYuNzVNNC41IDEybDYuNzUtNi43NVwiIC8+XG48L3N2Zz5cbmAsIFRFID0gYDxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIGZpbGw9XCJjdXJyZW50Q29sb3JcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgc3Ryb2tlLXdpZHRoPVwiM1wiIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIGNsYXNzPVwidy00IGgtNFwiPlxuICA8cGF0aCBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIiBkPVwiTTQuNSAxMmgxNW0wIDBsLTYuNzUtNi43NU0xOS41IDEybC02Ljc1IDYuNzVcIiAvPlxuPC9zdmc+XG5gLCBFRSA9IGA8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiBmaWxsPVwibm9uZVwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBzdHJva2Utd2lkdGg9XCIzXCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgY2xhc3M9XCJ3LTQgaC00XCI+XG4gIDxwYXRoIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiIGQ9XCJNMy43NSAzLjc1djQuNW0wLTQuNWg0LjVtLTQuNSAwTDkgOU0zLjc1IDIwLjI1di00LjVtMCA0LjVoNC41bS00LjUgMEw5IDE1TTIwLjI1IDMuNzVoLTQuNW00LjUgMHY0LjVtMC00LjVMMTUgOW01LjI1IDExLjI1aC00LjVtNC41IDB2LTQuNW0wIDQuNUwxNSAxNVwiIC8+XG48L3N2Zz5cbmAsIENFID0gYDxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIGZpbGw9XCJub25lXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIHN0cm9rZS13aWR0aD1cIjNcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBjbGFzcz1cInctNCBoLTRcIj5cbiAgPHBhdGggc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCIgZD1cIk05IDlWNC41TTkgOUg0LjVNOSA5TDMuNzUgMy43NU05IDE1djQuNU05IDE1SDQuNU05IDE1bC01LjI1IDUuMjVNMTUgOWg0LjVNMTUgOVY0LjVNMTUgOWw1LjI1LTUuMjVNMTUgMTVoNC41TTE1IDE1djQuNW0wLTQuNWw1LjI1IDUuMjVcIiAvPlxuPC9zdmc+XG5gLCBBRSA9IGA8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiBmaWxsPVwibm9uZVwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBzdHJva2Utd2lkdGg9XCIzXCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgY2xhc3M9XCJ3LTQgaC00XCI+XG4gIDxwYXRoIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiIGQ9XCJNMjEgMjFsLTUuMTk3LTUuMTk3bTAgMEE3LjUgNy41IDAgMTA1LjE5NiA1LjE5NmE3LjUgNy41IDAgMDAxMC42MDcgMTAuNjA3ek0xMC41IDcuNXY2bTMtM2gtNlwiIC8+XG48L3N2Zz5cbmAsIHlFID0gYDxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIGZpbGw9XCJub25lXCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIHN0cm9rZS13aWR0aD1cIjNcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBjbGFzcz1cInctNCBoLTRcIj5cbjxwYXRoIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiIGQ9XCJNMjEgMjFsLTUuMTk3LTUuMTk3bTAgMEE3LjUgNy41IDAgMTA1LjE5NiA1LjE5NmE3LjUgNy41IDAgMDAxMC42MDcgMTAuNjA3ek0xMy41IDEwLjVoLTZcIiAvPlxuPC9zdmc+XG5gLCB3RSA9IGA8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiBmaWxsPVwibm9uZVwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBzdHJva2Utd2lkdGg9XCIzXCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgY2xhc3M9XCJ3LTQgaC00XCI+XG4gIDxwYXRoIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiIGQ9XCJNNiAxOEwxOCA2TTYgNmwxMiAxMlwiIC8+XG48L3N2Zz5cbmAsIGtFID0ge1xuICBjb250YWluZXI6IFwic3RyaW5nXCIsXG4gIHpvb21MZXZlbDogXCIobnVtYmVyfHN0cmluZylcIixcbiAgcHJldkljb25UZW1wbGF0ZTogXCJzdHJpbmdcIixcbiAgbmV4dEljb25UZW1wbGF0ZTogXCJzdHJpbmdcIixcbiAgc2hvd0Z1bGxzY3JlZW5JY29uVGVtcGxhdGU6IFwic3RyaW5nXCIsXG4gIGhpZGVGdWxsc2NyZWVuSWNvblRlbXBsYXRlOiBcInN0cmluZ1wiLFxuICB6b29tSW5JY29uVGVtcGxhdGU6IFwic3RyaW5nXCIsXG4gIGNsb3NlSWNvblRlbXBsYXRlOiBcInN0cmluZ1wiLFxuICB6b29tT3V0SWNvblRlbXBsYXRlOiBcInN0cmluZ1wiLFxuICBzcGlubmVyQ29udGVudDogXCJzdHJpbmdcIlxufSwgeEUgPSB7XG4gIGNvbnRhaW5lcjogXCJib2R5XCIsXG4gIHpvb21MZXZlbDogMSxcbiAgcHJldkljb25UZW1wbGF0ZTogdkUsXG4gIG5leHRJY29uVGVtcGxhdGU6IFRFLFxuICBzaG93RnVsbHNjcmVlbkljb25UZW1wbGF0ZTogRUUsXG4gIGhpZGVGdWxsc2NyZWVuSWNvblRlbXBsYXRlOiBDRSxcbiAgem9vbUluSWNvblRlbXBsYXRlOiBBRSxcbiAgem9vbU91dEljb25UZW1wbGF0ZTogeUUsXG4gIGNsb3NlSWNvblRlbXBsYXRlOiB3RSxcbiAgc3Bpbm5lckNvbnRlbnQ6IFwiTG9hZGluZy4uLlwiXG59LCBPRSA9IHtcbiAgY2FwdGlvbjogXCJ0ZXh0LXdoaXRlIHRleHQtZWxsaXBzaXMgb3ZlcmZsb3ctaGlkZGVuIHdoaXRlc3BhY2Utbm93cmFwIG14LVsxMHB4XSB0ZXh0LWNlbnRlclwiLFxuICBjYXB0aW9uV3JhcHBlcjogXCJmaXhlZCBsZWZ0LTAgYm90dG9tLTAgdy1mdWxsIGgtWzUwcHhdIGZsZXgganVzdGlmeS1jZW50ZXIgaXRlbXMtY2VudGVyXCIsXG4gIGNsb3NlQnRuOiBcImJvcmRlci1ub25lIGJnLXRyYW5zcGFyZW50IHctWzUwcHhdIGgtWzUwcHhdIHB4LTQgdGV4dC1bI2IzYjNiM10gdHJhbnNpdGlvbi1jb2xvcnMgZHVyYXRpb24tMjAwIGVhc2UtaW4tb3V0IGhvdmVyOnRleHQtd2hpdGUgZm9jdXM6dGV4dC13aGl0ZSBtb3Rpb24tcmVkdWNlOnRyYW5zaXRpb24tbm9uZSBvdXRsaW5lLW5vbmVcIixcbiAgZnVsbHNjcmVlbkJ0bjogXCJib3JkZXItbm9uZSBiZy10cmFuc3BhcmVudCB3LVs1MHB4XSBoLVs1MHB4XSBweC00IHRleHQtWyNiM2IzYjNdIHRyYW5zaXRpb24tY29sb3JzIGR1cmF0aW9uLTIwMCBlYXNlLWluLW91dCBob3Zlcjp0ZXh0LXdoaXRlIGZvY3VzOnRleHQtd2hpdGUgbW90aW9uLXJlZHVjZTp0cmFuc2l0aW9uLW5vbmUgb3V0bGluZS1ub25lXCIsXG4gIGdhbGxlcnk6IFwiaW52aXNpYmxlIGZpeGVkIGxlZnQtMCB0b3AtMCB3LWZ1bGwgaC1mdWxsIHotWzExMDBdIHBvaW50ZXItZXZlbnRzLW5vbmUgb3BhY2l0eS0wIGJnLVsjMDAwMDAwZTZdIHRyYW5zaXRpb24tYWxsIGR1cmF0aW9uLVs0MDBtc10gbW90aW9uLXJlZHVjZTp0cmFuc2l0aW9uLW5vbmVcIixcbiAgZ2FsbGVyeUNvbnRlbnQ6IFwiZml4ZWQgdG9wLVs1MHB4XSBsZWZ0LVs1MHB4XSB3LVtjYWxjKDEwMCUtMTAwcHgpXSBoLVtjYWxjKDEwMCUtMTAwcHgpXVwiLFxuICBnYWxsZXJ5Q291bnRlcjogXCJmbGV4IGp1c3RpZnktY2VudGVyIGl0ZW1zLWNlbnRlciBweC1bMTBweF0gbWItMCBoLWZ1bGwgdGV4dC1bI2IzYjNiM11cIixcbiAgaW1nOiBcImFic29sdXRlIGxlZnQtMCB0b3AtMCB3LWZ1bGwgbWF4LWgtZnVsbCBoLWF1dG8gY3Vyc29yLXBvaW50ZXIgcG9pbnRlci1ldmVudHMtYXV0b1wiLFxuICBpbWdXcmFwcGVyOiBcImFic29sdXRlIHRvcC0wIGxlZnQtMCB3LWZ1bGwgaC1mdWxsIG9wYWNpdHktMCB0cmFuc2Zvcm0gc2NhbGUtWzAuMjVdIHRyYW5zaXRpb24tYWxsIGR1cmF0aW9uLVs0MDBtc10gZWFzZS1vdXQgcG9pbnRlci1ldmVudHMtbm9uZSBtb3Rpb24tcmVkdWNlOnRyYW5zaXRpb24tbm9uZSBtb3Rpb24tcmVkdWNlOnRyYW5zZm9ybS1ub25lXCIsXG4gIGxlZnRUb29sczogXCJmbG9hdC1sZWZ0IGgtZnVsbFwiLFxuICBsb2FkZXI6IFwiZml4ZWQgbGVmdC0wIHRvcC0wIHotWzJdIHctZnVsbCBoLWZ1bGwgdGV4dC1uZXV0cmFsLTUwIG9wYWNpdHktMSBmbGV4IGp1c3RpZnktY2VudGVyIGl0ZW1zLWNlbnRlciBwb2ludGVyLWV2ZW50cy1ub25lIHRyYW5zaXRpb24tb3BhY2l0eSBkdXJhdGlvbi1bMTAwMG1zXSBtb3Rpb24tcmVkdWNlOnRyYW5zaXRpb24tbm9uZVwiLFxuICBuZXh0QnRuOiBcImJvcmRlci1ub25lIGJnLXRyYW5zcGFyZW50IHctZnVsbCBoLVs1MHB4XSBmbGV4IGp1c3RpZnktY2VudGVyIGl0ZW1zLWNlbnRlciB0ZXh0LVsjYjNiM2IzXSB0cmFuc2l0aW9uLWNvbG9ycyBkdXJhdGlvbi0yMDAgZWFzZS1pbi1vdXQgaG92ZXI6dGV4dC13aGl0ZSBmb2N1czp0ZXh0LXdoaXRlIG1vdGlvbi1yZWR1Y2U6dHJhbnNpdGlvbi1ub25lIG91dGxpbmUtbm9uZVwiLFxuICBuZXh0QnRuV3JhcHBlcjogXCJmaXhlZCByaWdodC0wIHRvcC0wIHctWzUwcHhdIGgtZnVsbCBmbGV4IGp1c3RpZnktY2VudGVyIGl0ZW1zLWNlbnRlciB0cmFuc2l0aW9uLW9wYWNpdHkgZHVyYXRpb24tWzQwMG1zXSBtb3Rpb24tcmVkdWNlOnRyYW5zaXRpb24tbm9uZVwiLFxuICBwcmV2QnRuOiBcImJvcmRlci1ub25lIGJnLXRyYW5zcGFyZW50IHctZnVsbCBoLVs1MHB4XSBmbGV4IGp1c3RpZnktY2VudGVyIGl0ZW1zLWNlbnRlciB0ZXh0LVsjYjNiM2IzXSB0cmFuc2l0aW9uLWNvbG9ycyBkdXJhdGlvbi0yMDAgZWFzZS1pbi1vdXQgaG92ZXI6dGV4dC13aGl0ZSBmb2N1czp0ZXh0LXdoaXRlIG1vdGlvbi1yZWR1Y2U6dHJhbnNpdGlvbi1ub25lIG91dGxpbmUtbm9uZVwiLFxuICBwcmV2QnRuV3JhcHBlcjogXCJmaXhlZCBsZWZ0LTAgdG9wLTAgdy1bNTBweF0gaC1mdWxsIGZsZXgganVzdGlmeS1jZW50ZXIgaXRlbXMtY2VudGVyIHRyYW5zaXRpb24tb3BhY2l0eSBkdXJhdGlvbi1bNDAwbXNdIG1vdGlvbi1yZWR1Y2U6dHJhbnNpdGlvbi1ub25lXCIsXG4gIHJpZ2h0VG9vbHM6IFwiZmxvYXQtcmlnaHRcIixcbiAgc3Bpbm5lcjogXCJpbmxpbmUtYmxvY2sgaC04IHctOCBhbmltYXRlLVtzcGlubmVyLWdyb3dfMC43NXNfbGluZWFyX2luZmluaXRlXSByb3VuZGVkLWZ1bGwgYmctY3VycmVudCBhbGlnbi1bLTAuMTI1ZW1dIG1vdGlvbi1yZWR1Y2U6YW5pbWF0ZS1bc3Bpbm5lci1ncm93XzEuNXNfbGluZWFyX2luZmluaXRlXVwiLFxuICBzcGlubmVyQ29udGVudDogXCIhYWJzb2x1dGUgIS1tLXB4ICFoLXB4ICF3LXB4ICFvdmVyZmxvdy1oaWRkZW4gIXdoaXRlc3BhY2Utbm93cmFwICFib3JkZXItMCAhcC0wICFbY2xpcDpyZWN0KDAsMCwwLDApXVwiLFxuICB0b29sYmFyOiBcImFic29sdXRlIHRvcC0wIGxlZnQtMCB3LWZ1bGwgaC1bNTBweF0gei0yMCB0cmFuc2l0aW9uLW9wYWNpdHkgZHVyYXRpb24tWzQwMG1zXSBtb3Rpb24tcmVkdWNlOnRyYW5zaXRpb24tbm9uZVwiLFxuICB2ZXJ0aWNhbDogXCJoLWZ1bGwgbWF4LWgtZnVsbCB3LWF1dG9cIixcbiAgem9vbUJ0bjogXCJib3JkZXItbm9uZSBiZy10cmFuc3BhcmVudCB3LVs1MHB4XSBoLVs1MHB4XSBweC00IHRleHQtWyNiM2IzYjNdIHRyYW5zaXRpb24tY29sb3JzIGR1cmF0aW9uLTIwMCBlYXNlLWluLW91dCBob3Zlcjp0ZXh0LXdoaXRlIGZvY3VzOnRleHQtd2hpdGUgbW90aW9uLXJlZHVjZTp0cmFuc2l0aW9uLW5vbmUgb3V0bGluZS1ub25lXCJcbn0sIFNFID0ge1xuICBjYXB0aW9uOiBcInN0cmluZ1wiLFxuICBjYXB0aW9uV3JhcHBlcjogXCJzdHJpbmdcIixcbiAgY2xvc2VCdG46IFwic3RyaW5nXCIsXG4gIGZ1bGxzY3JlZW5CdG46IFwic3RyaW5nXCIsXG4gIGdhbGxlcnk6IFwic3RyaW5nXCIsXG4gIGdhbGxlcnlDb250ZW50OiBcInN0cmluZ1wiLFxuICBnYWxsZXJ5Q291bnRlcjogXCJzdHJpbmdcIixcbiAgaW1nOiBcInN0cmluZ1wiLFxuICBpbWdXcmFwcGVyOiBcInN0cmluZ1wiLFxuICBsZWZ0VG9vbHM6IFwic3RyaW5nXCIsXG4gIGxvYWRlcjogXCJzdHJpbmdcIixcbiAgbmV4dEJ0bjogXCJzdHJpbmdcIixcbiAgbmV4dEJ0bldyYXBwZXI6IFwic3RyaW5nXCIsXG4gIHByZXZCdG46IFwic3RyaW5nXCIsXG4gIHByZXZCdG5XcmFwcGVyOiBcInN0cmluZ1wiLFxuICByaWdodFRvb2xzOiBcInN0cmluZ1wiLFxuICBzcGlubmVyOiBcInN0cmluZ1wiLFxuICBzcGlubmVyQ29udGVudDogXCJzdHJpbmdcIixcbiAgdG9vbGJhcjogXCJzdHJpbmdcIixcbiAgdmVydGljYWw6IFwic3RyaW5nXCIsXG4gIHpvb21CdG46IFwic3RyaW5nXCJcbn07XG5jbGFzcyBacyB7XG4gIGNvbnN0cnVjdG9yKHQsIGUgPSB7fSwgaSkge1xuICAgIHRoaXMuX2VsZW1lbnQgPSB0LCB0aGlzLl9vcHRpb25zID0gZSwgdGhpcy5fY2xhc3NlcyA9IHRoaXMuX2dldENsYXNzZXMoaSksIHRoaXMuX2dldENvbnRhaW5lcigpLCB0aGlzLl9pZCA9IGBsaWdodGJveC0ke01hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cigyLCA5KX1gLCB0aGlzLl9hY3RpdmVJbWcgPSAwLCB0aGlzLl9pbWFnZXMgPSBbXSwgdGhpcy5fem9vbSA9IDEsIHRoaXMuX2dhbGxlcnkgPSBudWxsLCB0aGlzLl9nYWxsZXJ5VG9vbGJhciA9IG51bGwsIHRoaXMuX2dhbGxlcnlDb250ZW50ID0gbnVsbCwgdGhpcy5fbG9hZGVyID0gbnVsbCwgdGhpcy5faW1nQ291bnRlciA9IG51bGwsIHRoaXMuX2FuaW1hdGluZyA9ICExLCB0aGlzLl9mdWxsc2NyZWVuID0gITEsIHRoaXMuX3pvb21CdG4gPSBudWxsLCB0aGlzLl9mdWxsc2NyZWVuQnRuID0gbnVsbCwgdGhpcy5fdG9vbHNUb2dnbGVUaW1lciA9IDAsIHRoaXMuX21vdXNlZG93biA9ICExLCB0aGlzLl9tb3VzZWRvd25Qb3NpdGlvblggPSAwLCB0aGlzLl9tb3VzZWRvd25Qb3NpdGlvblkgPSAwLCB0aGlzLl9vcmlnaW5hbFBvc2l0aW9uWCA9IDAsIHRoaXMuX29yaWdpbmFsUG9zaXRpb25ZID0gMCwgdGhpcy5fcG9zaXRpb25YID0gMCwgdGhpcy5fcG9zaXRpb25ZID0gMCwgdGhpcy5fem9vbVRpbWVyID0gMCwgdGhpcy5fdGFwQ291bnRlciA9IDAsIHRoaXMuX3RhcFRpbWUgPSAwLCB0aGlzLl9yaWdodEFycm93ID0gbnVsbCwgdGhpcy5fbGVmdEFycm93V3JhcHBlciA9IG51bGwsIHRoaXMuX3JpZ2h0QXJyb3dXcmFwcGVyID0gbnVsbCwgdGhpcy5faW5pdGlhdGVkID0gITEsIHRoaXMuX211bHRpdG91Y2ggPSAhMSwgdGhpcy5fdG91Y2hab29tUG9zaXRpb24gPSBbXSwgdGhpcy5fZWxlbWVudCAmJiAoeS5zZXREYXRhKHQsIEFpLCB0aGlzKSwgdGhpcy5pbml0KCkpO1xuICB9XG4gIC8vIEdldHRlcnNcbiAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgIHJldHVybiBUbztcbiAgfVxuICBnZXQgYWN0aXZlSW1nKCkge1xuICAgIHJldHVybiB0aGlzLl9hY3RpdmVJbWc7XG4gIH1cbiAgZ2V0IGN1cnJlbnRJbWcoKSB7XG4gICAgcmV0dXJuIGQuZmluZE9uZShcbiAgICAgIGBbJHtJdH1dYCxcbiAgICAgIHRoaXMuX2dhbGxlcnlDb250ZW50XG4gICAgKTtcbiAgfVxuICBnZXQgb3B0aW9ucygpIHtcbiAgICBjb25zdCB0ID0ge1xuICAgICAgLi4ueEUsXG4gICAgICAuLi5oLmdldERhdGFBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpLFxuICAgICAgLi4udGhpcy5fb3B0aW9uc1xuICAgIH07XG4gICAgcmV0dXJuIEQoVG8sIHQsIGtFKSwgdDtcbiAgfVxuICAvLyBQdWJsaWNcbiAgaW5pdCgpIHtcbiAgICB0aGlzLl9pbml0aWF0ZWQgfHwgKHRoaXMuX2FwcGVuZFRlbXBsYXRlKCksIHRoaXMuX2luaXRpYXRlZCA9ICEwKTtcbiAgfVxuICBvcGVuKHQgPSAwKSB7XG4gICAgdGhpcy5fZ2V0SW1hZ2VzKCksIHRoaXMuX3NldEFjdGl2ZUltZyh0KSwgdGhpcy5fc29ydEltYWdlcygpLCB0aGlzLl90cmlnZ2VyRXZlbnRzKFwib3BlblwiLCBcIm9wZW5lZFwiKSwgdGhpcy5fbG9hZEltYWdlcygpLnRoZW4oKGUpID0+IHtcbiAgICAgIHRoaXMuX3Jlc2l6ZUltYWdlcyhlKSwgdGhpcy5fdG9nZ2xlVGVtcGxhdGUoKSwgdGhpcy5fYWRkRXZlbnRzKCksIHRoaXMuX2ZvY3VzRnVsbHNjcmVlbkJ0bigpO1xuICAgIH0pO1xuICB9XG4gIGNsb3NlKCkge1xuICAgIHRoaXMucmVzZXQoKSwgdGhpcy5fcmVtb3ZlRXZlbnRzKCksIHRoaXMuX3RvZ2dsZVRlbXBsYXRlKCksIHRoaXMuX3RyaWdnZXJFdmVudHMoXCJjbG9zZVwiLCBcImNsb3NlZFwiKTtcbiAgfVxuICBzbGlkZSh0ID0gXCJyaWdodFwiKSB7XG4gICAgdGhpcy5fYW5pbWF0aW5nID09PSAhMCB8fCB0aGlzLl9pbWFnZXMubGVuZ3RoIDw9IDEgfHwgKHRoaXMuX3RyaWdnZXJFdmVudHMoXCJzbGlkZVwiLCBcInNsaWRlZFwiKSwgdGhpcy5fYmVmb3JlU2xpZGVFdmVudHMoKSwgdCA9PT0gXCJyaWdodFwiICYmIHRoaXMuX3NsaWRlSG9yaXpvbnRhbGx5KHQpLCB0ID09PSBcImxlZnRcIiAmJiB0aGlzLl9zbGlkZUhvcml6b250YWxseSh0KSwgdCA9PT0gXCJmaXJzdFwiICYmIHRoaXMuX3NsaWRlVG9UYXJnZXQodCksIHQgPT09IFwibGFzdFwiICYmIHRoaXMuX3NsaWRlVG9UYXJnZXQodCksIHRoaXMuX2FmdGVyU2xpZGVFdmVudHMoKSk7XG4gIH1cbiAgem9vbUluKCkge1xuICAgIHRoaXMuX3pvb20gPj0gMyB8fCAodGhpcy5fdHJpZ2dlckV2ZW50cyhcInpvb21JblwiLCBcInpvb21lZEluXCIpLCB0aGlzLl96b29tICs9IHBhcnNlRmxvYXQodGhpcy5vcHRpb25zLnpvb21MZXZlbCksIGguc3R5bGUodGhpcy5jdXJyZW50SW1nLnBhcmVudE5vZGUsIHtcbiAgICAgIHRyYW5zZm9ybTogYHNjYWxlKCR7dGhpcy5fem9vbX0pYFxuICAgIH0pLCB0aGlzLl91cGRhdGVab29tQnRuKCkpO1xuICB9XG4gIHpvb21PdXQoKSB7XG4gICAgdGhpcy5fem9vbSA8PSAxIHx8ICh0aGlzLl90cmlnZ2VyRXZlbnRzKFwiem9vbU91dFwiLCBcInpvb21lZE91dFwiKSwgdGhpcy5fem9vbSAtPSBwYXJzZUZsb2F0KHRoaXMub3B0aW9ucy56b29tTGV2ZWwpLCBoLnN0eWxlKHRoaXMuY3VycmVudEltZy5wYXJlbnROb2RlLCB7XG4gICAgICB0cmFuc2Zvcm06IGBzY2FsZSgke3RoaXMuX3pvb219KWBcbiAgICB9KSwgdGhpcy5fdXBkYXRlWm9vbUJ0bigpLCB0aGlzLl91cGRhdGVJbWdQb3NpdGlvbigpKTtcbiAgfVxuICB0b2dnbGVGdWxsc2NyZWVuKCkge1xuICAgIHRoaXMuX2Z1bGxzY3JlZW4gPT09ICExID8gKHRoaXMuX2Z1bGxzY3JlZW5CdG4uc2V0QXR0cmlidXRlKEl0LCBcIlwiKSwgdGhpcy5fZnVsbHNjcmVlbkJ0bi5pbm5lckhUTUwgPSB0aGlzLm9wdGlvbnMuaGlkZUZ1bGxzY3JlZW5JY29uVGVtcGxhdGUsIHRoaXMuX2dhbGxlcnkucmVxdWVzdEZ1bGxzY3JlZW4gJiYgdGhpcy5fZ2FsbGVyeS5yZXF1ZXN0RnVsbHNjcmVlbigpLCB0aGlzLl9mdWxsc2NyZWVuID0gITApIDogKHRoaXMuX2Z1bGxzY3JlZW5CdG4ucmVtb3ZlQXR0cmlidXRlKEl0KSwgZG9jdW1lbnQuZXhpdEZ1bGxzY3JlZW4gJiYgZG9jdW1lbnQuZXhpdEZ1bGxzY3JlZW4oKSwgdGhpcy5fZnVsbHNjcmVlbiA9ICExKTtcbiAgfVxuICByZXNldCgpIHtcbiAgICB0aGlzLl9yZXN0b3JlRGVmYXVsdEZ1bGxzY3JlZW4oKSwgdGhpcy5fcmVzdG9yZURlZmF1bHRQb3NpdGlvbigpLCB0aGlzLl9yZXN0b3JlRGVmYXVsdFpvb20oKSwgY2xlYXJUaW1lb3V0KHRoaXMuX3Rvb2xzVG9nZ2xlVGltZXIpLCBjbGVhclRpbWVvdXQodGhpcy5fZG91YmxlVGFwVGltZXIpO1xuICB9XG4gIGRpc3Bvc2UoKSB7XG4gICAgYy5vZmYoXG4gICAgICBkb2N1bWVudCxcbiAgICAgIEllLFxuICAgICAgZ0UsXG4gICAgICB0aGlzLnRvZ2dsZVxuICAgICksIHRoaXMuX2dhbGxlcnlDb250ZW50ICYmIHRoaXMuX3JlbW92ZUV2ZW50cygpLCB0aGlzLl9nYWxsZXJ5ICYmIHRoaXMuX2dhbGxlcnkucmVtb3ZlKCksIHkucmVtb3ZlRGF0YSh0aGlzLl9lbGVtZW50LCBBaSksIHRoaXMuX2VsZW1lbnQgPSBudWxsO1xuICB9XG4gIC8vIFByaXZhdGVcbiAgX2dldENsYXNzZXModCkge1xuICAgIGNvbnN0IGUgPSBoLmdldERhdGFDbGFzc0F0dHJpYnV0ZXModGhpcy5fZWxlbWVudCk7XG4gICAgcmV0dXJuIHQgPSB7XG4gICAgICAuLi5PRSxcbiAgICAgIC4uLmUsXG4gICAgICAuLi50XG4gICAgfSwgRChUbywgdCwgU0UpLCB0O1xuICB9XG4gIF9nZXRJbWFnZXMoKSB7XG4gICAgY29uc3QgZSA9IGQuZmluZChcImltZ1wiLCB0aGlzLl9lbGVtZW50KS5maWx0ZXIoXG4gICAgICAoaSkgPT4gIWkuaGFzQXR0cmlidXRlKGJFKVxuICAgICk7XG4gICAgdGhpcy5faW1hZ2VzID0gZTtcbiAgfVxuICBfZ2V0Q29udGFpbmVyKCkge1xuICAgIHRoaXMuX2NvbnRhaW5lciA9IGQuZmluZE9uZSh0aGlzLm9wdGlvbnMuY29udGFpbmVyKTtcbiAgfVxuICBfc2V0QWN0aXZlSW1nKHQpIHtcbiAgICB0aGlzLl9hY3RpdmVJbWcgPSB0eXBlb2YgdCA9PSBcIm51bWJlclwiID8gdCA6IHRoaXMuX2ltYWdlcy5pbmRleE9mKHQudGFyZ2V0KTtcbiAgfVxuICBfYXBwZW5kVGVtcGxhdGUoKSB7XG4gICAgdGhpcy5fZ2FsbGVyeSA9ICQoXCJkaXZcIiksIGguYWRkQ2xhc3ModGhpcy5fZ2FsbGVyeSwgYCR7dGhpcy5fY2xhc3Nlcy5nYWxsZXJ5fWApLCB0aGlzLl9lbGVtZW50LmRhdGFzZXQuaWQgPSB0aGlzLl9pZCwgdGhpcy5fZ2FsbGVyeS5pZCA9IHRoaXMuX2lkLCB0aGlzLl9hcHBlbmRMb2FkZXIoKSwgdGhpcy5fYXBwZW5kVG9vbGJhcigpLCB0aGlzLl9hcHBlbmRDb250ZW50KCksIHRoaXMuX2FwcGVuZEFycm93cygpLCB0aGlzLl9hcHBlbmRDYXB0aW9uKCksIHRoaXMuX2NvbnRhaW5lci5hcHBlbmQodGhpcy5fZ2FsbGVyeSk7XG4gIH1cbiAgX2FwcGVuZFRvb2xiYXIoKSB7XG4gICAgdGhpcy5fZ2FsbGVyeVRvb2xiYXIgPSAkKFwiZGl2XCIpLCB0aGlzLl9pbWdDb3VudGVyID0gJChcInBcIiksIHRoaXMuX2Z1bGxzY3JlZW5CdG4gPSAkKFwiYnV0dG9uXCIpLCB0aGlzLl96b29tQnRuID0gJChcImJ1dHRvblwiKTtcbiAgICBjb25zdCB0ID0gJChcImJ1dHRvblwiKSwgZSA9ICQoXCJkaXZcIiksIGkgPSAkKFwiZGl2XCIpO1xuICAgIGguYWRkQ2xhc3ModGhpcy5fZ2FsbGVyeVRvb2xiYXIsIGAke3RoaXMuX2NsYXNzZXMudG9vbGJhcn1gKSwgaC5hZGRDbGFzcyh0aGlzLl9pbWdDb3VudGVyLCBgJHt0aGlzLl9jbGFzc2VzLmdhbGxlcnlDb3VudGVyfWApLCBoLmFkZENsYXNzKHRoaXMuX2Z1bGxzY3JlZW5CdG4sIGAke3RoaXMuX2NsYXNzZXMuZnVsbHNjcmVlbkJ0bn1gKSwgaC5hZGRDbGFzcyh0aGlzLl96b29tQnRuLCBgJHt0aGlzLl9jbGFzc2VzLnpvb21JbkJ0bn1gKSwgaC5hZGRDbGFzcyh0aGlzLl96b29tQnRuLCB0aGlzLl9jbGFzc2VzLnpvb21CdG4pLCBoLmFkZENsYXNzKGUsIGAke3RoaXMuX2NsYXNzZXMubGVmdFRvb2xzfWApLCBoLmFkZENsYXNzKGksIGAke3RoaXMuX2NsYXNzZXMucmlnaHRUb29sc31gKSwgaC5hZGRDbGFzcyh0LCBgJHt0aGlzLl9jbGFzc2VzLmNsb3NlQnRufWApLCB0aGlzLl9mdWxsc2NyZWVuQnRuLmlubmVySFRNTCA9IHRoaXMub3B0aW9ucy5zaG93RnVsbHNjcmVlbkljb25UZW1wbGF0ZSwgdC5pbm5lckhUTUwgPSB0aGlzLm9wdGlvbnMuY2xvc2VJY29uVGVtcGxhdGUsIHRoaXMuX3pvb21CdG4uaW5uZXJIVE1MID0gdGhpcy5vcHRpb25zLnpvb21Jbkljb25UZW1wbGF0ZSwgdGhpcy5fZnVsbHNjcmVlbkJ0bi5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIsIFwiVG9nZ2xlIGZ1bGxzY3JlZW5cIiksIHRoaXMuX3pvb21CdG4uc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiLCBcIlpvb20gaW5cIiksIHQuc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiLCBcIkNsb3NlXCIpLCBjLm9uKFxuICAgICAgdGhpcy5fZnVsbHNjcmVlbkJ0bixcbiAgICAgIEllLFxuICAgICAgKCkgPT4gdGhpcy50b2dnbGVGdWxsc2NyZWVuKClcbiAgICApLCBjLm9uKFxuICAgICAgdGhpcy5fem9vbUJ0bixcbiAgICAgIEllLFxuICAgICAgKCkgPT4gdGhpcy5fdG9nZ2xlWm9vbSgpXG4gICAgKSwgYy5vbih0LCBJZSwgKCkgPT4gdGhpcy5jbG9zZSgpKSwgZS5hcHBlbmQodGhpcy5faW1nQ291bnRlciksIGkuYXBwZW5kKHRoaXMuX2Z1bGxzY3JlZW5CdG4pLCBpLmFwcGVuZCh0aGlzLl96b29tQnRuKSwgaS5hcHBlbmQodCksIHRoaXMuX2dhbGxlcnlUb29sYmFyLmFwcGVuZChlKSwgdGhpcy5fZ2FsbGVyeVRvb2xiYXIuYXBwZW5kKGkpLCB0aGlzLl9nYWxsZXJ5LmFwcGVuZCh0aGlzLl9nYWxsZXJ5VG9vbGJhcik7XG4gIH1cbiAgX2FwcGVuZENvbnRlbnQoKSB7XG4gICAgdGhpcy5fZ2FsbGVyeUNvbnRlbnQgPSAkKFwiZGl2XCIpLCBoLmFkZENsYXNzKFxuICAgICAgdGhpcy5fZ2FsbGVyeUNvbnRlbnQsXG4gICAgICBgJHt0aGlzLl9jbGFzc2VzLmdhbGxlcnlDb250ZW50fWBcbiAgICApLCB0aGlzLl9nYWxsZXJ5LmFwcGVuZCh0aGlzLl9nYWxsZXJ5Q29udGVudCk7XG4gIH1cbiAgX2FwcGVuZExvYWRlcigpIHtcbiAgICB0aGlzLl9sb2FkZXIgPSAkKFwiZGl2XCIpO1xuICAgIGNvbnN0IHQgPSAkKFwiZGl2XCIpLCBlID0gJChcInNwYW5cIik7XG4gICAgaC5hZGRDbGFzcyh0aGlzLl9sb2FkZXIsIGAke3RoaXMuX2NsYXNzZXMubG9hZGVyfWApLCBoLmFkZENsYXNzKHQsIGAke3RoaXMuX2NsYXNzZXMuc3Bpbm5lcn1gKSwgaC5hZGRDbGFzcyhlLCBgJHt0aGlzLl9jbGFzc2VzLnNwaW5uZXJDb250ZW50fWApLCB0LnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJzdGF0dXNcIiksIGUuaW5uZXJIVE1MID0gdGhpcy5vcHRpb25zLnNwaW5uZXJDb250ZW50LCB0LmFwcGVuZChlKSwgdGhpcy5fbG9hZGVyLmFwcGVuZCh0KSwgdGhpcy5fZ2FsbGVyeS5hcHBlbmQodGhpcy5fbG9hZGVyKTtcbiAgfVxuICBfYXBwZW5kQXJyb3dzKCkge1xuICAgIHRoaXMuX2xlZnRBcnJvd1dyYXBwZXIgPSAkKFwiZGl2XCIpLCBoLmFkZENsYXNzKFxuICAgICAgdGhpcy5fbGVmdEFycm93V3JhcHBlcixcbiAgICAgIGAke3RoaXMuX2NsYXNzZXMucHJldkJ0bldyYXBwZXJ9YFxuICAgICk7XG4gICAgY29uc3QgdCA9ICQoXCJidXR0b25cIik7XG4gICAgdC5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIsIFwiUHJldmlvdXNcIiksIGguYWRkQ2xhc3ModCwgYCR7dGhpcy5fY2xhc3Nlcy5wcmV2QnRufWApLCBjLm9uKHQsIEllLCAoKSA9PiB0aGlzLnNsaWRlKFwibGVmdFwiKSksIHRoaXMuX2xlZnRBcnJvd1dyYXBwZXIuYXBwZW5kKHQpLCB0aGlzLl9yaWdodEFycm93V3JhcHBlciA9ICQoXCJkaXZcIiksIGguYWRkQ2xhc3MoXG4gICAgICB0aGlzLl9yaWdodEFycm93V3JhcHBlcixcbiAgICAgIGAke3RoaXMuX2NsYXNzZXMubmV4dEJ0bldyYXBwZXJ9YFxuICAgICksIHRoaXMuX3JpZ2h0QXJyb3cgPSAkKFwiYnV0dG9uXCIpLCB0aGlzLl9yaWdodEFycm93LnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIiwgXCJOZXh0XCIpLCBoLmFkZENsYXNzKHRoaXMuX3JpZ2h0QXJyb3csIGAke3RoaXMuX2NsYXNzZXMubmV4dEJ0bn1gKSwgYy5vbih0aGlzLl9yaWdodEFycm93LCBJZSwgKCkgPT4gdGhpcy5zbGlkZSgpKSwgdGhpcy5fcmlnaHRBcnJvd1dyYXBwZXIuYXBwZW5kKHRoaXMuX3JpZ2h0QXJyb3cpLCB0aGlzLl9yaWdodEFycm93LmlubmVySFRNTCA9IHRoaXMub3B0aW9ucy5uZXh0SWNvblRlbXBsYXRlLCB0LmlubmVySFRNTCA9IHRoaXMub3B0aW9ucy5wcmV2SWNvblRlbXBsYXRlLCB0aGlzLl9nZXRJbWFnZXMoKSwgISh0aGlzLl9pbWFnZXMubGVuZ3RoIDw9IDEpICYmICh0aGlzLl9nYWxsZXJ5LmFwcGVuZCh0aGlzLl9sZWZ0QXJyb3dXcmFwcGVyKSwgdGhpcy5fZ2FsbGVyeS5hcHBlbmQodGhpcy5fcmlnaHRBcnJvd1dyYXBwZXIpKTtcbiAgfVxuICBfYXBwZW5kQ2FwdGlvbigpIHtcbiAgICBjb25zdCB0ID0gJChcImRpdlwiKSwgZSA9ICQoXCJwXCIpO1xuICAgIGUuc2V0QXR0cmlidXRlKE1sLCBcIlwiKSwgaC5hZGRDbGFzcyh0LCBgJHt0aGlzLl9jbGFzc2VzLmNhcHRpb25XcmFwcGVyfWApLCBoLmFkZENsYXNzKGUsIGAke3RoaXMuX2NsYXNzZXMuY2FwdGlvbn1gKSwgdC5hcHBlbmQoZSksIHRoaXMuX2dhbGxlcnkuYXBwZW5kKHQpO1xuICB9XG4gIF9zb3J0SW1hZ2VzKCkge1xuICAgIGZvciAobGV0IHQgPSAwOyB0IDwgdGhpcy5fYWN0aXZlSW1nOyB0KyspXG4gICAgICB0aGlzLl9pbWFnZXMucHVzaCh0aGlzLl9pbWFnZXMuc2hpZnQoKSk7XG4gIH1cbiAgYXN5bmMgX2xvYWRJbWFnZXMoKSB7XG4gICAgY29uc3QgdCA9IFtdLCBlID0gW107XG4gICAgdGhpcy5fZ2FsbGVyeUNvbnRlbnQuaW5uZXJIVE1MID0gXCJcIjtcbiAgICBsZXQgaSA9IDA7XG4gICAgcmV0dXJuIHRoaXMuX2ltYWdlcy5mb3JFYWNoKChuLCBvKSA9PiB7XG4gICAgICB0LnB1c2goXG4gICAgICAgIG5ldyBQcm9taXNlKChyKSA9PiB7XG4gICAgICAgICAgY29uc3QgYSA9IG5ldyBJbWFnZSgpLCBsID0gJChcImRpdlwiKTtcbiAgICAgICAgICBoLmFkZENsYXNzKGwsIGAke3RoaXMuX2NsYXNzZXMuaW1nV3JhcHBlcn1gKSwgaC5hZGRDbGFzcyhhLCBgJHt0aGlzLl9jbGFzc2VzLmltZ31gKSwgdGhpcy5fYWRkSW1nU3R5bGVzKGEsIGwsIGksIG8sIG4pLCBsLmFwcGVuZChhKSwgdGhpcy5fZ2FsbGVyeUNvbnRlbnQuYXBwZW5kKGwpLCBhLm9ubG9hZCA9IHIsIGEuc3JjID0gbi5kYXRhc2V0LnRlSW1nIHx8IG4uc3JjLCBlLnB1c2goYSksIGkgKz0gMTAwO1xuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9KSwgYXdhaXQgUHJvbWlzZS5hbGwodCksIGU7XG4gIH1cbiAgX2FkZEltZ1N0eWxlcyh0LCBlLCBpLCBuLCBvKSB7XG4gICAgdC5hbHQgPSBvLmFsdCwgdC5kcmFnZ2FibGUgPSAhMSwgaC5zdHlsZShlLCB7XG4gICAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxuICAgICAgbGVmdDogYCR7aX0lYCxcbiAgICAgIHRvcDogMFxuICAgIH0pLCAoby5kYXRhc2V0LnRlQ2FwdGlvbiB8fCBvLmRhdGFzZXQudGVDYXB0aW9uID09PSBcIlwiKSAmJiAodC5kYXRhc2V0LmNhcHRpb24gPSBvLmRhdGFzZXQudGVDYXB0aW9uKSwgaSA9PT0gMCA/IChvLndpZHRoIDwgby5oZWlnaHQgJiYgaC5hZGRDbGFzcyh0LCBgJHt0aGlzLl9jbGFzc2VzLnZlcnRpY2FsfWApLCBoLnN0eWxlKGUsIHsgb3BhY2l0eTogMSB9KSwgdC5zZXRBdHRyaWJ1dGUoSXQsIFwiXCIpKSA6IHQucmVtb3ZlQXR0cmlidXRlKEl0KSwgbiA9PT0gdGhpcy5faW1hZ2VzLmxlbmd0aCAtIDEgJiYgdGhpcy5faW1hZ2VzLmxlbmd0aCA+IDEgJiYgaC5zdHlsZShlLCB7IGxlZnQ6IFwiLTEwMCVcIiB9KTtcbiAgfVxuICBfcmVzaXplSW1hZ2VzKHQpIHtcbiAgICB0LmZvckVhY2goKGUpID0+IHtcbiAgICAgIHRoaXMuX2NhbGN1bGF0ZUltZ1NpemUoZSk7XG4gICAgfSk7XG4gIH1cbiAgX2NhbGN1bGF0ZUltZ1NpemUodCkge1xuICAgIHQud2lkdGggPj0gdC5oZWlnaHQgPyAodC5zdHlsZS53aWR0aCA9IFwiMTAwJVwiLCB0LnN0eWxlLm1heFdpZHRoID0gXCIxMDAlXCIsIHQuc3R5bGUuaGVpZ2h0ID0gXCJhdXRvXCIsIHQuc3R5bGUudG9wID0gYCR7KHQucGFyZW50Tm9kZS5vZmZzZXRIZWlnaHQgLSB0LmhlaWdodCkgLyAyfXB4YCwgdC5zdHlsZS5sZWZ0ID0gMCkgOiAodC5zdHlsZS5oZWlnaHQgPSBcIjEwMCVcIiwgdC5zdHlsZS5tYXhIZWlnaHQgPSBcIjEwMCVcIiwgdC5zdHlsZS53aWR0aCA9IFwiYXV0b1wiLCB0LnN0eWxlLmxlZnQgPSBgJHsodC5wYXJlbnROb2RlLm9mZnNldFdpZHRoIC0gdC53aWR0aCkgLyAyfXB4YCwgdC5zdHlsZS50b3AgPSAwKSwgdC53aWR0aCA+PSB0LnBhcmVudE5vZGUub2Zmc2V0V2lkdGggJiYgKHQuc3R5bGUud2lkdGggPSBgJHt0LnBhcmVudE5vZGUub2Zmc2V0V2lkdGh9cHhgLCB0LnN0eWxlLmhlaWdodCA9IFwiYXV0b1wiLCB0LnN0eWxlLmxlZnQgPSAwLCB0LnN0eWxlLnRvcCA9IGAkeyh0LnBhcmVudE5vZGUub2Zmc2V0SGVpZ2h0IC0gdC5oZWlnaHQpIC8gMn1weGApLCB0LmhlaWdodCA+PSB0LnBhcmVudE5vZGUub2Zmc2V0SGVpZ2h0ICYmICh0LnN0eWxlLmhlaWdodCA9IGAke3QucGFyZW50Tm9kZS5vZmZzZXRIZWlnaHR9cHhgLCB0LnN0eWxlLndpZHRoID0gXCJhdXRvXCIsIHQuc3R5bGUudG9wID0gMCwgdC5zdHlsZS5sZWZ0ID0gYCR7KHQucGFyZW50Tm9kZS5vZmZzZXRXaWR0aCAtIHQud2lkdGgpIC8gMn1weGApLCB0aGlzLl9wb3NpdGlvblggPSBwYXJzZUZsb2F0KHQuc3R5bGUubGVmdCkgfHwgMCwgdGhpcy5fcG9zaXRpb25ZID0gcGFyc2VGbG9hdCh0LnN0eWxlLnRvcCkgfHwgMDtcbiAgfVxuICBfb25SZXNpemUoKSB7XG4gICAgdGhpcy5faW1hZ2VzID0gZC5maW5kKFwiaW1nXCIsIHRoaXMuX2dhbGxlcnlDb250ZW50KSwgdGhpcy5faW1hZ2VzLmZvckVhY2goKHQpID0+IHtcbiAgICAgIHRoaXMuX2NhbGN1bGF0ZUltZ1NpemUodCk7XG4gICAgfSk7XG4gIH1cbiAgX29uRnVsbHNjcmVlbkNoYW5nZSgpIHtcbiAgICAoZG9jdW1lbnQud2Via2l0SXNGdWxsU2NyZWVuIHx8IGRvY3VtZW50Lm1vekZ1bGxTY3JlZW4gfHwgZG9jdW1lbnQubXNGdWxsc2NyZWVuRWxlbWVudCkgPT09IHZvaWQgMCAmJiAodGhpcy5fZnVsbHNjcmVlbiA9ICExLCB0aGlzLl9mdWxsc2NyZWVuQnRuLmlubmVySFRNTCA9IHRoaXMub3B0aW9ucy5zaG93RnVsbHNjcmVlbkljb25UZW1wbGF0ZSwgdGhpcy5fZnVsbHNjcmVlbkJ0bi5yZW1vdmVBdHRyaWJ1dGUoSXQpKTtcbiAgfVxuICBfYmVmb3JlU2xpZGVFdmVudHMoKSB7XG4gICAgdGhpcy5fYW5pbWF0aW9uU3RhcnQoKSwgdGhpcy5fcmVzdG9yZURlZmF1bHRab29tKCksIHRoaXMuX3Jlc3RvcmVEZWZhdWx0UG9zaXRpb24oKSwgdGhpcy5fcmVzZXREb3VibGVUYXAoKTtcbiAgfVxuICBfc2xpZGVIb3Jpem9udGFsbHkodCkge1xuICAgIHRoaXMuX2ltYWdlcyA9IGQuZmluZChcImltZ1wiLCB0aGlzLl9nYWxsZXJ5Q29udGVudCksIHRoaXMuX2ltYWdlcy5mb3JFYWNoKChlKSA9PiB7XG4gICAgICBsZXQgaTtcbiAgICAgIHQgPT09IFwicmlnaHRcIiA/IChpID0gcGFyc2VJbnQoZS5wYXJlbnROb2RlLnN0eWxlLmxlZnQsIDEwKSAtIDEwMCwgaSA8IC0xMDAgJiYgKGkgPSAodGhpcy5faW1hZ2VzLmxlbmd0aCAtIDIpICogMTAwKSkgOiAoaSA9IHBhcnNlSW50KGUucGFyZW50Tm9kZS5zdHlsZS5sZWZ0LCAxMCkgKyAxMDAsIGkgPT09ICh0aGlzLl9pbWFnZXMubGVuZ3RoIC0gMSkgKiAxMDAgJiYgKGkgPSAtMTAwKSksIHRoaXMuX3NsaWRlSW1nKGUsIGkpO1xuICAgIH0pLCB0aGlzLl91cGRhdGVBY3RpdmVJbWcodCk7XG4gIH1cbiAgX3NsaWRlSW1nKHQsIGUpIHtcbiAgICBlID09PSAwID8gKHQuc2V0QXR0cmlidXRlKEl0LCBcIlwiKSwgaC5zdHlsZSh0LnBhcmVudE5vZGUsIHsgb3BhY2l0eTogMSwgdHJhbnNmb3JtOiBcInNjYWxlKDEpXCIgfSkpIDogKHQucmVtb3ZlQXR0cmlidXRlKEl0KSwgaC5zdHlsZSh0LnBhcmVudE5vZGUsIHtcbiAgICAgIG9wYWNpdHk6IDAsXG4gICAgICB0cmFuc2Zvcm06IFwic2NhbGUoMC4yNSlcIlxuICAgIH0pKSwgdC5wYXJlbnROb2RlLnN0eWxlLmxlZnQgPSBgJHtlfSVgO1xuICB9XG4gIF9zbGlkZVRvVGFyZ2V0KHQpIHtcbiAgICB0ID09PSBcImZpcnN0XCIgJiYgdGhpcy5fYWN0aXZlSW1nID09PSAwIHx8IHQgPT09IFwibGFzdFwiICYmIHRoaXMuX2FjdGl2ZUltZyA9PT0gdGhpcy5faW1hZ2VzLmxlbmd0aCAtIDEgfHwgKHRoaXMucmVzZXQoKSwgdGhpcy5fcmVtb3ZlRXZlbnRzKCksIHRoaXMuX3Nob3dMb2FkZXIoKSwgdGhpcy5fZ2V0SW1hZ2VzKCksIHRoaXMuX2FjdGl2ZUltZyA9IHQgPT09IFwiZmlyc3RcIiA/IDAgOiB0aGlzLl9pbWFnZXMubGVuZ3RoIC0gMSwgdGhpcy5fc29ydEltYWdlcygpLCBoLnN0eWxlKHRoaXMuY3VycmVudEltZy5wYXJlbnROb2RlLCB7XG4gICAgICB0cmFuc2Zvcm06IFwic2NhbGUoMC4yNSlcIixcbiAgICAgIG9wYWNpdHk6IDBcbiAgICB9KSwgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLl9sb2FkSW1hZ2VzKCkudGhlbigoZSkgPT4ge1xuICAgICAgICB0aGlzLl9yZXNpemVJbWFnZXMoZSksIHRoaXMuX2FkZEV2ZW50cygpLCB0aGlzLl91cGRhdGVDYXB0aW9uKCksIHRoaXMuX2hpZGVMb2FkZXIoKSwgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgaC5zdHlsZSh0aGlzLmN1cnJlbnRJbWcucGFyZW50Tm9kZSwge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiBcInNjYWxlKDEpXCIsXG4gICAgICAgICAgICBvcGFjaXR5OiAxXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sIDEwKTtcbiAgICAgIH0pO1xuICAgIH0sIDQwMCkpO1xuICB9XG4gIF91cGRhdGVBY3RpdmVJbWcodCkge1xuICAgIHQgPT09IFwicmlnaHRcIiAmJiAodGhpcy5fYWN0aXZlSW1nID09PSB0aGlzLl9pbWFnZXMubGVuZ3RoIC0gMSA/IHRoaXMuX2FjdGl2ZUltZyA9IDAgOiB0aGlzLl9hY3RpdmVJbWcrKyksIHQgPT09IFwibGVmdFwiICYmICh0aGlzLl9hY3RpdmVJbWcgPT09IDAgPyB0aGlzLl9hY3RpdmVJbWcgPSB0aGlzLl9pbWFnZXMubGVuZ3RoIC0gMSA6IHRoaXMuX2FjdGl2ZUltZy0tKTtcbiAgfVxuICBfYWZ0ZXJTbGlkZUV2ZW50cygpIHtcbiAgICB0aGlzLl91cGRhdGVDb3VudGVyKCksIHRoaXMuX3VwZGF0ZUNhcHRpb24oKTtcbiAgfVxuICBfdXBkYXRlQ291bnRlcigpIHtcbiAgICB0aGlzLl9pbWFnZXMubGVuZ3RoIDw9IDEgfHwgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLl9pbWdDb3VudGVyLmlubmVySFRNTCA9IGAke3RoaXMuX2FjdGl2ZUltZyArIDF9IC8gJHt0aGlzLl9pbWFnZXMubGVuZ3RofWA7XG4gICAgfSwgMjAwKTtcbiAgfVxuICBfdXBkYXRlQ2FwdGlvbigpIHtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGxldCB0ID0gdGhpcy5jdXJyZW50SW1nLmFsdDtcbiAgICAgICh0aGlzLmN1cnJlbnRJbWcuZGF0YXNldC5jYXB0aW9uIHx8IHRoaXMuY3VycmVudEltZy5kYXRhc2V0LmNhcHRpb24gPT09IFwiXCIpICYmICh0ID0gdGhpcy5jdXJyZW50SW1nLmRhdGFzZXQuY2FwdGlvbiksIGQuZmluZE9uZShcbiAgICAgICAgYFske01sfV1gLFxuICAgICAgICB0aGlzLl9nYWxsZXJ5XG4gICAgICApLmlubmVySFRNTCA9IHQ7XG4gICAgfSwgMjAwKTtcbiAgfVxuICBfdG9nZ2xlVGVtcGxhdGUoKSB7XG4gICAgdGhpcy5fZ2FsbGVyeS5zdHlsZS52aXNpYmlsaXR5ID09PSBcInZpc2libGVcIiA/IChoLnN0eWxlKHRoaXMuY3VycmVudEltZy5wYXJlbnROb2RlLCB7XG4gICAgICB0cmFuc2Zvcm06IFwic2NhbGUoMC4yNSlcIlxuICAgIH0pLCBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuX2hpZGVHYWxsZXJ5KCksIHRoaXMuX2VuYWJsZVNjcm9sbCgpLCB0aGlzLl9zaG93TG9hZGVyKCk7XG4gICAgfSwgMTAwKSkgOiAodGhpcy5fc2hvd0dhbGxlcnkoKSwgdGhpcy5fZGlzYWJsZVNjcm9sbCgpLCB0aGlzLl91cGRhdGVDb3VudGVyKCksIHRoaXMuX3VwZGF0ZUNhcHRpb24oKSwgdGhpcy5fc2V0VG9vbHNUb2dnbGVUaW1vdXQoKSwgdGhpcy5faGlkZUxvYWRlcigpKTtcbiAgfVxuICBfc2hvd0xvYWRlcigpIHtcbiAgICBoLnN0eWxlKHRoaXMuX2xvYWRlciwgeyBvcGFjaXR5OiAxIH0pO1xuICB9XG4gIF9oaWRlTG9hZGVyKCkge1xuICAgIGguc3R5bGUodGhpcy5fbG9hZGVyLCB7IG9wYWNpdHk6IDAgfSk7XG4gIH1cbiAgX2hpZGVHYWxsZXJ5KCkge1xuICAgIGguc3R5bGUodGhpcy5fZ2FsbGVyeSwge1xuICAgICAgb3BhY2l0eTogMCxcbiAgICAgIHBvaW50ZXJFdmVudHM6IFwibm9uZVwiLFxuICAgICAgdmlzaWJpbGl0eTogXCJoaWRkZW5cIlxuICAgIH0pO1xuICB9XG4gIF9zaG93R2FsbGVyeSgpIHtcbiAgICBoLnN0eWxlKHRoaXMuX2dhbGxlcnksIHtcbiAgICAgIG9wYWNpdHk6IDEsXG4gICAgICBwb2ludGVyRXZlbnRzOiBcImluaXRpYWxcIixcbiAgICAgIHZpc2liaWxpdHk6IFwidmlzaWJsZVwiXG4gICAgfSksIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgaC5zdHlsZSh0aGlzLmN1cnJlbnRJbWcucGFyZW50Tm9kZSwgeyB0cmFuc2Zvcm06IFwic2NhbGUoMSlcIiB9KTtcbiAgICB9LCA1MCk7XG4gIH1cbiAgX3RvZ2dsZVpvb20oKSB7XG4gICAgdGhpcy5fem9vbSAhPT0gMSA/IHRoaXMuem9vbU91dCgpIDogdGhpcy56b29tSW4oKTtcbiAgfVxuICBfdXBkYXRlWm9vbUJ0bigpIHtcbiAgICB0aGlzLl96b29tID4gMSA/ICh0aGlzLl96b29tQnRuLnNldEF0dHJpYnV0ZShJdCwgXCJcIiksIHRoaXMuX3pvb21CdG4uc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiLCBcIlpvb20gb3V0XCIpLCB0aGlzLl96b29tQnRuLmlubmVySFRNTCA9IHRoaXMub3B0aW9ucy56b29tT3V0SWNvblRlbXBsYXRlKSA6ICh0aGlzLl96b29tQnRuLnJlbW92ZUF0dHJpYnV0ZShJdCksIHRoaXMuX3pvb21CdG4uc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiLCBcIlpvb20gaW5cIiksIHRoaXMuX3pvb21CdG4uaW5uZXJIVE1MID0gdGhpcy5vcHRpb25zLnpvb21Jbkljb25UZW1wbGF0ZSk7XG4gIH1cbiAgX3VwZGF0ZUltZ1Bvc2l0aW9uKCkge1xuICAgIHRoaXMuX3pvb20gPT09IDEgJiYgdGhpcy5fcmVzdG9yZURlZmF1bHRQb3NpdGlvbigpO1xuICB9XG4gIF9hZGRFdmVudHMoKSB7XG4gICAgY29uc3QgdCA9IGQuZmluZChcImltZ1wiLCB0aGlzLl9nYWxsZXJ5Q29udGVudCk7XG4gICAgdGhpcy5fb25XaW5kb3dUb3VjaG1vdmUgPSB0aGlzLl9vbldpbmRvd1RvdWNobW92ZS5iaW5kKHRoaXMpLCB0aGlzLl9vbldpbmRvd1RvdWNoc3RhcnQgPSB0aGlzLl9vbldpbmRvd1RvdWNoc3RhcnQuYmluZCh0aGlzKSwgdGhpcy5fb25JbWdNb3VzZWRvd24gPSB0aGlzLl9vbk1vdXNlZG93bi5iaW5kKHRoaXMpLCB0aGlzLl9vbkltZ01vdXNlbW92ZSA9IHRoaXMuX29uTW91c2Vtb3ZlLmJpbmQodGhpcyksIHRoaXMuX29uSW1nV2hlZWwgPSB0aGlzLl9vblpvb20uYmluZCh0aGlzKSwgdGhpcy5fb25JbWdNb3VzZXVwID0gdGhpcy5fb25Nb3VzZXVwLmJpbmQodGhpcyksIHRoaXMuX29uSW1nVG91Y2hlbmQgPSB0aGlzLl9vblRvdWNoZW5kLmJpbmQodGhpcyksIHRoaXMuX29uSW1nRG91YmxlQ2xpY2sgPSB0aGlzLl9vbkRvdWJsZUNsaWNrLmJpbmQodGhpcyksIHRoaXMuX29uV2luZG93UmVzaXplID0gdGhpcy5fb25SZXNpemUuYmluZCh0aGlzKSwgdGhpcy5fb25XaW5kb3dGdWxsc2NyZWVuQ2hhbmdlID0gdGhpcy5fb25GdWxsc2NyZWVuQ2hhbmdlLmJpbmQodGhpcyksIHRoaXMuX29uQW55SW1nQWN0aW9uID0gdGhpcy5fcmVzZXRUb29sc1RvZ2dsZXIuYmluZCh0aGlzKSwgdGhpcy5fb25HYWxsZXJ5Q2xpY2sgPSB0aGlzLl9vbkJhY2tkcm9wQ2xpY2suYmluZCh0aGlzKSwgdGhpcy5fb25LZXl1cEV2ZW50ID0gdGhpcy5fb25LZXl1cC5iaW5kKHRoaXMpLCB0aGlzLl9vblJpZ2h0QXJyb3dLZXlkb3duRXZlbnQgPSB0aGlzLl9vblJpZ2h0QXJyb3dLZXlkb3duLmJpbmQodGhpcyksIHRoaXMuX29uRnVsbHNjcmVlbkJ0bktleWRvd25FdmVudCA9IHRoaXMuX29uRnVsbHNjcmVlbkJ0bktleWRvd24uYmluZCh0aGlzKSwgdC5mb3JFYWNoKChlKSA9PiB7XG4gICAgICBjLm9uKGUsIFwibW91c2Vkb3duXCIsIHRoaXMuX29uSW1nTW91c2Vkb3duLCB7XG4gICAgICAgIHBhc3NpdmU6ICEwXG4gICAgICB9KSwgYy5vbihlLCBcInRvdWNoc3RhcnRcIiwgdGhpcy5fb25JbWdNb3VzZWRvd24sIHtcbiAgICAgICAgcGFzc2l2ZTogITBcbiAgICAgIH0pLCBjLm9uKGUsIFwibW91c2Vtb3ZlXCIsIHRoaXMuX29uSW1nTW91c2Vtb3ZlLCB7XG4gICAgICAgIHBhc3NpdmU6ICEwXG4gICAgICB9KSwgYy5vbihlLCBcInRvdWNobW92ZVwiLCB0aGlzLl9vbkltZ01vdXNlbW92ZSwge1xuICAgICAgICBwYXNzaXZlOiAhMFxuICAgICAgfSksIGMub24oZSwgXCJ3aGVlbFwiLCB0aGlzLl9vbkltZ1doZWVsLCB7IHBhc3NpdmU6ICEwIH0pLCBjLm9uKGUsIFwiZGJsY2xpY2tcIiwgdGhpcy5fb25JbWdEb3VibGVDbGljaywge1xuICAgICAgICBwYXNzaXZlOiAhMFxuICAgICAgfSk7XG4gICAgfSksIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaG1vdmVcIiwgdGhpcy5fb25XaW5kb3dUb3VjaG1vdmUsIHtcbiAgICAgIHBhc3NpdmU6ICExXG4gICAgfSksIGMub24od2luZG93LCBcInRvdWNoc3RhcnRcIiwgdGhpcy5fb25XaW5kb3dUb3VjaHN0YXJ0KSwgYy5vbih3aW5kb3csIFwibW91c2V1cFwiLCB0aGlzLl9vbkltZ01vdXNldXApLCBjLm9uKHdpbmRvdywgXCJ0b3VjaGVuZFwiLCB0aGlzLl9vbkltZ1RvdWNoZW5kKSwgYy5vbih3aW5kb3csIFwicmVzaXplXCIsIHRoaXMuX29uV2luZG93UmVzaXplKSwgYy5vbih3aW5kb3csIFwib3JpZW50YXRpb25jaGFuZ2VcIiwgdGhpcy5fb25XaW5kb3dSZXNpemUpLCBjLm9uKHdpbmRvdywgXCJrZXl1cFwiLCB0aGlzLl9vbktleXVwRXZlbnQpLCBjLm9uKHdpbmRvdywgXCJmdWxsc2NyZWVuY2hhbmdlXCIsIHRoaXMuX29uV2luZG93RnVsbHNjcmVlbkNoYW5nZSksIGMub24odGhpcy5fZ2FsbGVyeSwgXCJtb3VzZW1vdmVcIiwgdGhpcy5fb25BbnlJbWdBY3Rpb24pLCBjLm9uKHRoaXMuX2dhbGxlcnksIFwiY2xpY2tcIiwgdGhpcy5fb25HYWxsZXJ5Q2xpY2spLCBjLm9uKFxuICAgICAgdGhpcy5fcmlnaHRBcnJvdyxcbiAgICAgIFwia2V5ZG93blwiLFxuICAgICAgdGhpcy5fb25SaWdodEFycm93S2V5ZG93bkV2ZW50XG4gICAgKSwgYy5vbihcbiAgICAgIHRoaXMuX2Z1bGxzY3JlZW5CdG4sXG4gICAgICBcImtleWRvd25cIixcbiAgICAgIHRoaXMuX29uRnVsbHNjcmVlbkJ0bktleWRvd25FdmVudFxuICAgICk7XG4gIH1cbiAgX3JlbW92ZUV2ZW50cygpIHtcbiAgICBkLmZpbmQoXCJpbWdcIiwgdGhpcy5fZ2FsbGVyeUNvbnRlbnQpLmZvckVhY2goKGUpID0+IHtcbiAgICAgIGMub2ZmKGUsIFwibW91c2Vkb3duXCIsIHRoaXMuX29uSW1nTW91c2Vkb3duKSwgYy5vZmYoZSwgXCJ0b3VjaHN0YXJ0XCIsIHRoaXMuX29uSW1nTW91c2Vkb3duKSwgYy5vZmYoZSwgXCJtb3VzZW1vdmVcIiwgdGhpcy5fb25JbWdNb3VzZW1vdmUpLCBjLm9mZihlLCBcInRvdWNobW92ZVwiLCB0aGlzLl9vbkltZ01vdXNlbW92ZSksIGMub2ZmKGUsIFwid2hlZWxcIiwgdGhpcy5fb25JbWdXaGVlbCksIGMub2ZmKGUsIFwiZGJsY2xpY2tcIiwgdGhpcy5fb25JbWdEb3VibGVDbGljayk7XG4gICAgfSksIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaG1vdmVcIiwgdGhpcy5fb25XaW5kb3dUb3VjaG1vdmUsIHtcbiAgICAgIHBhc3NpdmU6ICExXG4gICAgfSksIGMub2ZmKHdpbmRvdywgXCJ0b3VjaHN0YXJ0XCIsIHRoaXMuX29uV2luZG93VG91Y2hzdGFydCksIGMub2ZmKHdpbmRvdywgXCJtb3VzZXVwXCIsIHRoaXMuX29uSW1nTW91c2V1cCksIGMub2ZmKHdpbmRvdywgXCJ0b3VjaGVuZFwiLCB0aGlzLl9vbkltZ1RvdWNoZW5kKSwgYy5vZmYod2luZG93LCBcInJlc2l6ZVwiLCB0aGlzLl9vbldpbmRvd1Jlc2l6ZSksIGMub2ZmKHdpbmRvdywgXCJvcmllbnRhdGlvbmNoYW5nZVwiLCB0aGlzLl9vbldpbmRvd1Jlc2l6ZSksIGMub2ZmKHdpbmRvdywgXCJrZXl1cFwiLCB0aGlzLl9vbktleXVwRXZlbnQpLCBjLm9mZihcbiAgICAgIHdpbmRvdyxcbiAgICAgIFwiZnVsbHNjcmVlbmNoYW5nZVwiLFxuICAgICAgdGhpcy5fb25XaW5kb3dGdWxsc2NyZWVuQ2hhbmdlXG4gICAgKSwgYy5vZmYodGhpcy5fZ2FsbGVyeSwgXCJtb3VzZW1vdmVcIiwgdGhpcy5fb25BbnlJbWdBY3Rpb24pLCBjLm9mZih0aGlzLl9nYWxsZXJ5LCBcImNsaWNrXCIsIHRoaXMuX29uR2FsbGVyeUNsaWNrKSwgYy5vZmYoXG4gICAgICB0aGlzLl9yaWdodEFycm93LFxuICAgICAgXCJrZXlkb3duXCIsXG4gICAgICB0aGlzLl9vblJpZ2h0QXJyb3dLZXlkb3duRXZlbnRcbiAgICApLCBjLm9mZihcbiAgICAgIHRoaXMuX2Z1bGxzY3JlZW5CdG4sXG4gICAgICBcImtleWRvd25cIixcbiAgICAgIHRoaXMuX29uRnVsbHNjcmVlbkJ0bktleWRvd25FdmVudFxuICAgICk7XG4gIH1cbiAgX29uTW91c2Vkb3duKHQpIHtcbiAgICBjb25zdCBlID0gdC50b3VjaGVzLCBpID0gZSA/IGVbMF0uY2xpZW50WCA6IHQuY2xpZW50WCwgbiA9IGUgPyBlWzBdLmNsaWVudFkgOiB0LmNsaWVudFk7XG4gICAgdGhpcy5fb3JpZ2luYWxQb3NpdGlvblggPSBwYXJzZUZsb2F0KHRoaXMuY3VycmVudEltZy5zdHlsZS5sZWZ0KSB8fCAwLCB0aGlzLl9vcmlnaW5hbFBvc2l0aW9uWSA9IHBhcnNlRmxvYXQodGhpcy5jdXJyZW50SW1nLnN0eWxlLnRvcCkgfHwgMCwgdGhpcy5fcG9zaXRpb25YID0gdGhpcy5fb3JpZ2luYWxQb3NpdGlvblgsIHRoaXMuX3Bvc2l0aW9uWSA9IHRoaXMuX29yaWdpbmFsUG9zaXRpb25ZLCB0aGlzLl9tb3VzZWRvd25Qb3NpdGlvblggPSBpICogKDEgLyB0aGlzLl96b29tKSAtIHRoaXMuX3Bvc2l0aW9uWCwgdGhpcy5fbW91c2Vkb3duUG9zaXRpb25ZID0gbiAqICgxIC8gdGhpcy5fem9vbSkgLSB0aGlzLl9wb3NpdGlvblksIHRoaXMuX21vdXNlZG93biA9ICEwLCB0LnR5cGUgPT09IFwidG91Y2hzdGFydFwiICYmIHQudG91Y2hlcy5sZW5ndGggPiAxICYmICh0aGlzLl9tdWx0aXRvdWNoID0gITAsIHRoaXMuX3RvdWNoWm9vbVBvc2l0aW9uID0gdC50b3VjaGVzKTtcbiAgfVxuICBfb25Nb3VzZW1vdmUodCkge1xuICAgIGlmICghdGhpcy5fbW91c2Vkb3duKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGUgPSB0LnRvdWNoZXMsIGkgPSBlID8gZVswXS5jbGllbnRYIDogdC5jbGllbnRYLCBuID0gZSA/IGVbMF0uY2xpZW50WSA6IHQuY2xpZW50WTtcbiAgICBpZiAoZSAmJiB0aGlzLl9yZXNldFRvb2xzVG9nZ2xlcigpLCAhdGhpcy5fbXVsdGl0b3VjaClcbiAgICAgIGlmICh0aGlzLl96b29tICE9PSAxKVxuICAgICAgICB0aGlzLl9wb3NpdGlvblggPSBpICogKDEgLyB0aGlzLl96b29tKSAtIHRoaXMuX21vdXNlZG93blBvc2l0aW9uWCwgdGhpcy5fcG9zaXRpb25ZID0gbiAqICgxIC8gdGhpcy5fem9vbSkgLSB0aGlzLl9tb3VzZWRvd25Qb3NpdGlvblksIGguc3R5bGUodGhpcy5jdXJyZW50SW1nLCB7XG4gICAgICAgICAgbGVmdDogYCR7dGhpcy5fcG9zaXRpb25YfXB4YCxcbiAgICAgICAgICB0b3A6IGAke3RoaXMuX3Bvc2l0aW9uWX1weGBcbiAgICAgICAgfSk7XG4gICAgICBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMuX2ltYWdlcy5sZW5ndGggPD0gMSlcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuX3Bvc2l0aW9uWCA9IGkgKiAoMSAvIHRoaXMuX3pvb20pIC0gdGhpcy5fbW91c2Vkb3duUG9zaXRpb25YLCBoLnN0eWxlKHRoaXMuY3VycmVudEltZywgeyBsZWZ0OiBgJHt0aGlzLl9wb3NpdGlvblh9cHhgIH0pO1xuICAgICAgfVxuICB9XG4gIF9vbk1vdXNldXAodCkge1xuICAgIHRoaXMuX21vdXNlZG93biA9ICExLCB0aGlzLl9tb3ZlSW1nKHQudGFyZ2V0KTtcbiAgfVxuICBfb25Ub3VjaGVuZCh0KSB7XG4gICAgdGhpcy5fbW91c2Vkb3duID0gITEsIHRoaXMuX211bHRpdG91Y2ggPyB0LnRhcmdldFRvdWNoZXMubGVuZ3RoID09PSAwICYmICh0aGlzLl9tdWx0aXRvdWNoID0gITEsIHRoaXMuX3RvdWNoWm9vbVBvc2l0aW9uID0gW10pIDogdGhpcy5fbXVsdGl0b3VjaCB8fCAodGhpcy5fY2hlY2tEb3VibGVUYXAodCksIHRoaXMuX21vdmVJbWcodC50YXJnZXQpKTtcbiAgfVxuICBfY2FsY3VsYXRlVG91Y2hab29tKHQpIHtcbiAgICBjb25zdCBlID0gTWF0aC5oeXBvdChcbiAgICAgIHRoaXMuX3RvdWNoWm9vbVBvc2l0aW9uWzFdLnBhZ2VYIC0gdGhpcy5fdG91Y2hab29tUG9zaXRpb25bMF0ucGFnZVgsXG4gICAgICB0aGlzLl90b3VjaFpvb21Qb3NpdGlvblsxXS5wYWdlWSAtIHRoaXMuX3RvdWNoWm9vbVBvc2l0aW9uWzBdLnBhZ2VZXG4gICAgKSwgaSA9IE1hdGguaHlwb3QoXG4gICAgICB0LnRvdWNoZXNbMV0ucGFnZVggLSB0LnRvdWNoZXNbMF0ucGFnZVgsXG4gICAgICB0LnRvdWNoZXNbMV0ucGFnZVkgLSB0LnRvdWNoZXNbMF0ucGFnZVlcbiAgICApLCBuID0gTWF0aC5hYnMoZSAtIGkpLCBvID0gdC52aWV3LnNjcmVlbi53aWR0aDtcbiAgICBuID4gbyAqIDAuMDMgJiYgKGUgPD0gaSA/IHRoaXMuem9vbUluKCkgOiB0aGlzLnpvb21PdXQoKSwgdGhpcy5fdG91Y2hab29tUG9zaXRpb24gPSB0LnRvdWNoZXMpO1xuICB9XG4gIF9vbldpbmRvd1RvdWNoc3RhcnQodCkge1xuICAgIHQudG91Y2hlcy5sZW5ndGggPiAxICYmICh0aGlzLl9tdWx0aXRvdWNoID0gITAsIHRoaXMuX3RvdWNoWm9vbVBvc2l0aW9uID0gdC50b3VjaGVzKTtcbiAgfVxuICBfb25XaW5kb3dUb3VjaG1vdmUodCkge1xuICAgIHQucHJldmVudERlZmF1bHQoKSwgdC50eXBlID09PSBcInRvdWNobW92ZVwiICYmIHQudGFyZ2V0VG91Y2hlcy5sZW5ndGggPiAxICYmIHRoaXMuX2NhbGN1bGF0ZVRvdWNoWm9vbSh0KTtcbiAgfVxuICBfb25SaWdodEFycm93S2V5ZG93bih0KSB7XG4gICAgc3dpdGNoICh0LmtleUNvZGUpIHtcbiAgICAgIGNhc2UgOTpcbiAgICAgICAgaWYgKHQuc2hpZnRLZXkpXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIHQucHJldmVudERlZmF1bHQoKSwgdGhpcy5fZm9jdXNGdWxsc2NyZWVuQnRuKCk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBfb25GdWxsc2NyZWVuQnRuS2V5ZG93bih0KSB7XG4gICAgc3dpdGNoICh0LmtleUNvZGUpIHtcbiAgICAgIGNhc2UgOTpcbiAgICAgICAgaWYgKCF0LnNoaWZ0S2V5KVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB0LnByZXZlbnREZWZhdWx0KCksIHRoaXMuX2ZvY3VzUmlnaHRBcnJvdygpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgX29uS2V5dXAodCkge1xuICAgIHN3aXRjaCAodGhpcy5fcmVzZXRUb29sc1RvZ2dsZXIoKSwgdC5rZXlDb2RlKSB7XG4gICAgICBjYXNlIDM5OlxuICAgICAgICB0aGlzLnNsaWRlKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzNzpcbiAgICAgICAgdGhpcy5zbGlkZShcImxlZnRcIik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyNzpcbiAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzY6XG4gICAgICAgIHRoaXMuc2xpZGUoXCJmaXJzdFwiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDM1OlxuICAgICAgICB0aGlzLnNsaWRlKFwibGFzdFwiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDM4OlxuICAgICAgICB0aGlzLnpvb21JbigpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgNDA6XG4gICAgICAgIHRoaXMuem9vbU91dCgpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgX2ZvY3VzRnVsbHNjcmVlbkJ0bigpIHtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuX2Z1bGxzY3JlZW5CdG4uZm9jdXMoKTtcbiAgICB9LCAxMDApO1xuICB9XG4gIF9mb2N1c1JpZ2h0QXJyb3coKSB7XG4gICAgdGhpcy5fcmlnaHRBcnJvdy5mb2N1cygpO1xuICB9XG4gIF9tb3ZlSW1nKHQpIHtcbiAgICBpZiAodGhpcy5fbXVsdGl0b3VjaCB8fCB0aGlzLl96b29tICE9PSAxIHx8IHQgIT09IHRoaXMuY3VycmVudEltZyB8fCB0aGlzLl9pbWFnZXMubGVuZ3RoIDw9IDEpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgZSA9IHRoaXMuX3Bvc2l0aW9uWCAtIHRoaXMuX29yaWdpbmFsUG9zaXRpb25YO1xuICAgIGUgPiAwID8gdGhpcy5zbGlkZShcImxlZnRcIikgOiBlIDwgMCAmJiB0aGlzLnNsaWRlKCk7XG4gIH1cbiAgX2NoZWNrRG91YmxlVGFwKHQpIHtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5fZG91YmxlVGFwVGltZXIpO1xuICAgIGNvbnN0IGkgPSAoLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCkpLmdldFRpbWUoKSAtIHRoaXMuX3RhcFRpbWU7XG4gICAgdGhpcy5fdGFwQ291bnRlciA+IDAgJiYgaSA8IDUwMCA/ICh0aGlzLl9vbkRvdWJsZUNsaWNrKHQpLCB0aGlzLl9kb3VibGVUYXBUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5fdGFwVGltZSA9ICgvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKSkuZ2V0VGltZSgpLCB0aGlzLl90YXBDb3VudGVyID0gMDtcbiAgICB9LCAzMDApKSA6ICh0aGlzLl90YXBDb3VudGVyKyssIHRoaXMuX3RhcFRpbWUgPSAoLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCkpLmdldFRpbWUoKSk7XG4gIH1cbiAgX3Jlc2V0RG91YmxlVGFwKCkge1xuICAgIHRoaXMuX3RhcFRpbWUgPSAwLCB0aGlzLl90YXBDb3VudGVyID0gMCwgY2xlYXJUaW1lb3V0KHRoaXMuX2RvdWJsZVRhcFRpbWVyKTtcbiAgfVxuICBfb25Eb3VibGVDbGljayh0KSB7XG4gICAgdGhpcy5fbXVsdGl0b3VjaCB8fCAodC50b3VjaGVzIHx8IHRoaXMuX3NldE5ld1Bvc2l0aW9uT25ab29tSW4odCksIHRoaXMuX3pvb20gIT09IDEgPyB0aGlzLl9yZXN0b3JlRGVmYXVsdFpvb20oKSA6IHRoaXMuem9vbUluKCkpO1xuICB9XG4gIF9vblpvb20odCkge1xuICAgIGlmICh0LmRlbHRhWSA+IDApXG4gICAgICB0aGlzLnpvb21PdXQoKTtcbiAgICBlbHNlIHtcbiAgICAgIGlmICh0aGlzLl96b29tID49IDMpXG4gICAgICAgIHJldHVybjtcbiAgICAgIHRoaXMuX3NldE5ld1Bvc2l0aW9uT25ab29tSW4odCksIHRoaXMuem9vbUluKCk7XG4gICAgfVxuICB9XG4gIF9vbkJhY2tkcm9wQ2xpY2sodCkge1xuICAgIHRoaXMuX3Jlc2V0VG9vbHNUb2dnbGVyKCksIHQudGFyZ2V0LnRhZ05hbWUgPT09IFwiRElWXCIgJiYgdGhpcy5jbG9zZSgpO1xuICB9XG4gIF9zZXROZXdQb3NpdGlvbk9uWm9vbUluKHQpIHtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5fem9vbVRpbWVyKSwgdGhpcy5fcG9zaXRpb25YID0gd2luZG93LmlubmVyV2lkdGggLyAyIC0gdC5vZmZzZXRYIC0gNTAsIHRoaXMuX3Bvc2l0aW9uWSA9IHdpbmRvdy5pbm5lckhlaWdodCAvIDIgLSB0Lm9mZnNldFkgLSA1MCwgdGhpcy5jdXJyZW50SW1nLnN0eWxlLnRyYW5zaXRpb24gPSBcImFsbCAwLjVzIGVhc2Utb3V0XCIsIHRoaXMuY3VycmVudEltZy5zdHlsZS5sZWZ0ID0gYCR7dGhpcy5fcG9zaXRpb25YfXB4YCwgdGhpcy5jdXJyZW50SW1nLnN0eWxlLnRvcCA9IGAke3RoaXMuX3Bvc2l0aW9uWX1weGAsIHRoaXMuX3pvb21UaW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5jdXJyZW50SW1nLnN0eWxlLnRyYW5zaXRpb24gPSBcIm5vbmVcIjtcbiAgICB9LCA1MDApO1xuICB9XG4gIF9yZXNldFRvb2xzVG9nZ2xlcigpIHtcbiAgICB0aGlzLl9zaG93VG9vbHMoKSwgY2xlYXJUaW1lb3V0KHRoaXMuX3Rvb2xzVG9nZ2xlVGltZXIpLCB0aGlzLl9zZXRUb29sc1RvZ2dsZVRpbW91dCgpO1xuICB9XG4gIF9zZXRUb29sc1RvZ2dsZVRpbW91dCgpIHtcbiAgICB0aGlzLl90b29sc1RvZ2dsZVRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLl9oaWRlVG9vbHMoKSwgY2xlYXJUaW1lb3V0KHRoaXMuX3Rvb2xzVG9nZ2xlVGltZXIpO1xuICAgIH0sIDRlMyk7XG4gIH1cbiAgX2hpZGVUb29scygpIHtcbiAgICBoLnN0eWxlKHRoaXMuX2dhbGxlcnlUb29sYmFyLCB7IG9wYWNpdHk6IDAgfSksIGguc3R5bGUodGhpcy5fbGVmdEFycm93V3JhcHBlciwgeyBvcGFjaXR5OiAwIH0pLCBoLnN0eWxlKHRoaXMuX3JpZ2h0QXJyb3dXcmFwcGVyLCB7IG9wYWNpdHk6IDAgfSk7XG4gIH1cbiAgX3Nob3dUb29scygpIHtcbiAgICBoLnN0eWxlKHRoaXMuX2dhbGxlcnlUb29sYmFyLCB7IG9wYWNpdHk6IDEgfSksIGguc3R5bGUodGhpcy5fbGVmdEFycm93V3JhcHBlciwgeyBvcGFjaXR5OiAxIH0pLCBoLnN0eWxlKHRoaXMuX3JpZ2h0QXJyb3dXcmFwcGVyLCB7IG9wYWNpdHk6IDEgfSk7XG4gIH1cbiAgX2Rpc2FibGVTY3JvbGwoKSB7XG4gICAgaC5hZGRDbGFzcyhkb2N1bWVudC5ib2R5LCBcIm92ZXJmbG93LXktaGlkZGVuIHJlbGF0aXZlXCIpLCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsSGVpZ2h0ID4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodCAmJiBoLmFkZENsYXNzKGRvY3VtZW50LmJvZHksIFwibWQ6cHItWzE3cHhdXCIpO1xuICB9XG4gIF9lbmFibGVTY3JvbGwoKSB7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBoLnJlbW92ZUNsYXNzKGRvY3VtZW50LmJvZHksIFwib3ZlcmZsb3cteS1oaWRkZW4gcmVsYXRpdmVcIiksIGgucmVtb3ZlQ2xhc3MoZG9jdW1lbnQuYm9keSwgXCJtZDpwci1bMTdweF1cIik7XG4gICAgfSwgMzAwKTtcbiAgfVxuICBfYW5pbWF0aW9uU3RhcnQoKSB7XG4gICAgdGhpcy5fYW5pbWF0aW5nID0gITAsIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5fYW5pbWF0aW5nID0gITE7XG4gICAgfSwgNDAwKTtcbiAgfVxuICBfcmVzdG9yZURlZmF1bHRab29tKCkge1xuICAgIHRoaXMuX3pvb20gIT09IDEgJiYgKHRoaXMuX3pvb20gPSAxLCBoLnN0eWxlKHRoaXMuY3VycmVudEltZy5wYXJlbnROb2RlLCB7XG4gICAgICB0cmFuc2Zvcm06IGBzY2FsZSgke3RoaXMuX3pvb219KWBcbiAgICB9KSwgdGhpcy5fdXBkYXRlWm9vbUJ0bigpLCB0aGlzLl91cGRhdGVJbWdQb3NpdGlvbigpKTtcbiAgfVxuICBfcmVzdG9yZURlZmF1bHRGdWxsc2NyZWVuKCkge1xuICAgIHRoaXMuX2Z1bGxzY3JlZW4gJiYgdGhpcy50b2dnbGVGdWxsc2NyZWVuKCk7XG4gIH1cbiAgX3Jlc3RvcmVEZWZhdWx0UG9zaXRpb24oKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuX3pvb21UaW1lcik7XG4gICAgY29uc3QgdCA9IHRoaXMuY3VycmVudEltZztcbiAgICBoLnN0eWxlKHRoaXMuY3VycmVudEltZy5wYXJlbnROb2RlLCB7IGxlZnQ6IDAsIHRvcDogMCB9KSwgaC5zdHlsZSh0aGlzLmN1cnJlbnRJbWcsIHtcbiAgICAgIHRyYW5zaXRpb246IFwiYWxsIDAuNXMgZWFzZS1vdXRcIixcbiAgICAgIGxlZnQ6IDAsXG4gICAgICB0b3A6IDBcbiAgICB9KSwgdGhpcy5fY2FsY3VsYXRlSW1nU2l6ZSh0KSwgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBoLnN0eWxlKHRoaXMuY3VycmVudEltZywgeyB0cmFuc2l0aW9uOiBcIm5vbmVcIiB9KTtcbiAgICB9LCA1MDApO1xuICB9XG4gIGFzeW5jIF90cmlnZ2VyRXZlbnRzKHQsIGUpIHtcbiAgICBjLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgYCR7dH0udGUubGlnaHRib3hgKSwgZSAmJiBhd2FpdCBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGMudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBgJHtlfS50ZS5saWdodGJveGApO1xuICAgIH0sIDUwNSk7XG4gIH1cbiAgc3RhdGljIGdldEluc3RhbmNlKHQpIHtcbiAgICByZXR1cm4geS5nZXREYXRhKHQsIEFpKTtcbiAgfVxuICBzdGF0aWMgZ2V0T3JDcmVhdGVJbnN0YW5jZSh0LCBlID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5nZXRJbnN0YW5jZSh0KSB8fCBuZXcgdGhpcyh0LCB0eXBlb2YgZSA9PSBcIm9iamVjdFwiID8gZSA6IG51bGwpO1xuICB9XG4gIHN0YXRpYyB0b2dnbGUoKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHQpIHtcbiAgICAgIGNvbnN0IGUgPSBkLmNsb3Nlc3QoXG4gICAgICAgIHQudGFyZ2V0LFxuICAgICAgICBgJHtUaH1gXG4gICAgICApO1xuICAgICAgKFpzLmdldEluc3RhbmNlKGUpIHx8IG5ldyBacyhlKSkub3Blbih0KTtcbiAgICB9O1xuICB9XG4gIHN0YXRpYyBqUXVlcnlJbnRlcmZhY2UodCwgZSkge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICBsZXQgaSA9IHkuZ2V0RGF0YSh0aGlzLCBBaSk7XG4gICAgICBjb25zdCBuID0gdHlwZW9mIHQgPT0gXCJvYmplY3RcIiAmJiB0O1xuICAgICAgaWYgKCEoIWkgJiYgL2Rpc3Bvc2UvLnRlc3QodCkpICYmIChpIHx8IChpID0gbmV3IFpzKHRoaXMsIG4pKSwgdHlwZW9mIHQgPT0gXCJzdHJpbmdcIikpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpW3RdID4gXCJ1XCIpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFwiJHt0fVwiYCk7XG4gICAgICAgIGlbdF0oZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cbmNvbnN0IElFID0ge1xuICBpc1JlcXVpcmVkOiBcIlRoaXMgaXMgcmVxdWlyZWRcIixcbiAgaXNFbWFpbDogXCJQbGVhc2UgZW50ZXIgYSB2YWxpZCBlbWFpbCBhZGRyZXNzXCIsXG4gIGlzTG9uZ2VyVGhhbjogXCJUaGlzIGZpZWxkIG11c3QgYmUgbG9uZ2VyIHRoYW4ge2xlbmd0aH0gY2hhcmFjdGVyc1wiLFxuICBpc1Nob3J0ZXJUaGFuOiBcIlRoaXMgZmllbGQgbXVzdCBiZSBzaG9ydGVyIHRoYW4ge2xlbmd0aH0gY2hhcmFjdGVyc1wiLFxuICBpc0NoZWNrZWQ6IFwiVGhpcyBpcyByZXF1aXJlZFwiLFxuICBpc1Bob25lOiBcIlBsZWFzZSBlbnRlciBhIHZhbGlkIHBob25lIG51bWJlclwiLFxuICBpc051bWJlcjogXCJFeHBlY3RlZCB2YWx1ZSB3aXRoIHR5cGUgTnVtYmVyXCIsXG4gIGlzU3RyaW5nOiBcIkV4cGVjdGVkIHZhbHVlIHdpdGggdHlwZSBTdHJpbmdcIixcbiAgaXNCb29sZWFuOiBcIkV4cGVjdGVkIHZhbHVlIHdpdGggdHlwZSBCb29sZWFuXCIsXG4gIGlzRGF0ZTogXCJQbGVhc2UgZW50ZXIgYSB2YWxpZCBkYXRlXCIsXG4gIGlzMTJoRm9ybWF0OiBcIlBsZWFzZSBlbnRlciBhIHZhbGlkIHRpbWUgaW4gMTJoIGZvcm1hdFwiLFxuICBpczI0aEZvcm1hdDogXCJQbGVhc2UgZW50ZXIgYSB2YWxpZCB0aW1lIGluIDI0aCBmb3JtYXRcIlxufSwgREUgPSB7XG4gIGlzUmVxdWlyZWQ6IChzLCB0KSA9PiAocyA9PSBudWxsID8gdm9pZCAwIDogcy50cmltKCkpID8gITAgOiB0LFxuICBpc0VtYWlsOiAocywgdCkgPT4gL15bYS16QS1aMC05Ll8lKy1dK0BbYS16QS1aMC05Li1dK1xcLlthLXpBLVpdezIsfSQvLnRlc3QocykgPyAhMCA6IHQsXG4gIGlzTG9uZ2VyVGhhbjogKHMsIHQsIGUpID0+IHMubGVuZ3RoID4gZSA/ICEwIDogdC5yZXBsYWNlKFwie2xlbmd0aH1cIiwgZSksXG4gIGlzU2hvcnRlclRoYW46IChzLCB0LCBlKSA9PiBzLmxlbmd0aCA8IGUgPyAhMCA6IHQucmVwbGFjZShcIntsZW5ndGh9XCIsIGUpLFxuICBpc0NoZWNrZWQ6IChzKSA9PiBzID8gITAgOiBcIlRoaXMgaXMgcmVxdWlyZWRcIixcbiAgaXNQaG9uZTogKHMsIHQpID0+IHMubGVuZ3RoID09PSA5ID8gITAgOiB0LFxuICBpc051bWJlcjogKHMsIHQpID0+IHMgJiYgIWlzTmFOKE51bWJlcihzKSkgPyAhMCA6IHQsXG4gIGlzU3RyaW5nOiAocywgdCkgPT4gdHlwZW9mIHMgPT0gXCJzdHJpbmdcIiA/ICEwIDogdCxcbiAgaXNCb29sZWFuOiAocywgdCkgPT4gdHlwZW9mIHMgPT0gXCJib29sZWFuXCIgPyAhMCA6IHQsXG4gIGlzRGF0ZTogKHMsIHQpID0+IHtcbiAgICBjb25zdCBlID0gL14oWzAtOV17MSwyfSlcXC8oWzAtOV17MSwyfSlcXC8oWzAtOV17NH0pJC87XG4gICAgcmV0dXJuIHMubWF0Y2goZSkgPyAhMCA6IHQ7XG4gIH0sXG4gIGlzMTJoRm9ybWF0OiAocywgdCkgPT4ge1xuICAgIGNvbnN0IGUgPSAvXigwP1sxLTldfDFbMC0yXSk6WzAtNV1bMC05XSBbQVBhcF1bbU1dJC87XG4gICAgcmV0dXJuIHMubWF0Y2goZSkgPyAhMCA6IHQ7XG4gIH0sXG4gIGlzMjRoRm9ybWF0OiAocywgdCkgPT4ge1xuICAgIGNvbnN0IGUgPSAvXig/OlswMV1cXGR8MlswLTNdKTpbMC01XVswLTldJC87XG4gICAgcmV0dXJuIHMubWF0Y2goZSkgPyAhMCA6IHQ7XG4gIH1cbn0sIEVvID0gXCJ2YWxpZGF0aW9uXCIsIGpvID0gXCJ0ZS52YWxpZGF0aW9uXCIsIGZuID0gYC4ke2pvfWAsIEVoID0gXCJkYXRhLXRlLXZhbGlkYXRlXCIsIE9zID0gXCJkYXRhLXRlLXZhbGlkYXRlZFwiLCBTcyA9IFwiZGF0YS10ZS12YWxpZGF0aW9uLXN0YXRlXCIsIElzID0gXCJkYXRhLXRlLXZhbGlkYXRpb24tZmVlZGJhY2tcIiwgQ28gPSBcImRhdGEtdGUtdmFsaWQtZmVlZGJhY2tcIiwgRHMgPSBcImRhdGEtdGUtaW52YWxpZC1mZWVkYmFja1wiLCBSbCA9IFwiZGF0YS10ZS12YWxpZGF0aW9uLXJ1bGVzZXRcIiwgJEUgPSBcImRhdGEtdGUtc3VibWl0LWJ0bi1yZWZcIiwgTEUgPSBgWyR7RWh9XWAsIE5FID0gXCJbZGF0YS10ZS1pbnB1dC1ub3RjaC1yZWZdIGRpdlwiLCBNRSA9IGBbJHskRX1dYCwgUkUgPSBgdmFsaWRhdGVkJHtmbn1gLCBQRSA9IGB2YWxpZCR7Zm59YCwgQkUgPSBgaW52YWxpZCR7Zm59YCwgSEUgPSBgY2hhbmdlZCR7Zm59YCwgVkUgPSB7XG4gIHZhbGlkRmVlZGJhY2s6IFwic3RyaW5nXCIsXG4gIGludmFsaWRGZWVkYmFjazogXCJzdHJpbmdcIixcbiAgZGlzYWJsZUZlZWRiYWNrOiBcImJvb2xlYW5cIixcbiAgY3VzdG9tUnVsZXM6IFwib2JqZWN0XCIsXG4gIGN1c3RvbUVycm9yTWVzc2FnZXM6IFwib2JqZWN0XCIsXG4gIGFjdGl2ZVZhbGlkYXRpb246IFwiYm9vbGVhblwiLFxuICBzdWJtaXRDYWxsYmFjazogXCIoZnVuY3Rpb258bnVsbClcIlxufSwgUGwgPSB7XG4gIHZhbGlkRmVlZGJhY2s6IFwiTG9va3MgZ29vZCFcIixcbiAgaW52YWxpZEZlZWRiYWNrOiBcIlNvbWV0aGluZyBpcyB3cm9uZyFcIixcbiAgZGlzYWJsZUZlZWRiYWNrOiAhMSxcbiAgY3VzdG9tUnVsZXM6IHt9LFxuICBjdXN0b21FcnJvck1lc3NhZ2VzOiB7fSxcbiAgYWN0aXZlVmFsaWRhdGlvbjogITEsXG4gIHN1Ym1pdENhbGxiYWNrOiBudWxsXG59LCBXRSA9IHtcbiAgLy8gZGVmYXVsdCBub3RjaFxuICBub3RjaExlYWRpbmdWYWxpZDogXCJib3JkZXItWyMxNGE0NGRdIGRhcms6Ym9yZGVyLVsjMTRhNDRkXSBncm91cC1kYXRhLVt0ZS1pbnB1dC1mb2N1c2VkXTpzaGFkb3ctWy0xcHhfMF8wXyMxNGE0NGQsXzBfMXB4XzBfMF8jMTRhNDRkLF8wXy0xcHhfMF8wXyMxNGE0NGRdIGdyb3VwLWRhdGEtW3RlLWlucHV0LWZvY3VzZWRdOmJvcmRlci1bIzE0YTQ0ZF1cIixcbiAgbm90Y2hNaWRkbGVWYWxpZDogXCJib3JkZXItWyMxNGE0NGRdIGRhcms6Ym9yZGVyLVsjMTRhNDRkXSBncm91cC1kYXRhLVt0ZS1pbnB1dC1mb2N1c2VkXTpzaGFkb3ctWzBfMXB4XzBfMF8jMTRhNDRkXSBncm91cC1kYXRhLVt0ZS1pbnB1dC1mb2N1c2VkXTpib3JkZXItWyMxNGE0NGRdXCIsXG4gIG5vdGNoVHJhaWxpbmdWYWxpZDogXCJib3JkZXItWyMxNGE0NGRdIGRhcms6Ym9yZGVyLVsjMTRhNDRkXSBncm91cC1kYXRhLVt0ZS1pbnB1dC1mb2N1c2VkXTpzaGFkb3ctWzFweF8wXzBfIzE0YTQ0ZCxfMF8tMXB4XzBfMF8jMTRhNDRkLF8wXzFweF8wXzBfIzE0YTQ0ZF0gZ3JvdXAtZGF0YS1bdGUtaW5wdXQtZm9jdXNlZF06Ym9yZGVyLVsjMTRhNDRkXVwiLFxuICBub3RjaExlYWRpbmdJbnZhbGlkOiBcImJvcmRlci1bI2RjNGM2NF0gZGFyazpib3JkZXItWyNkYzRjNjRdIGdyb3VwLWRhdGEtW3RlLWlucHV0LWZvY3VzZWRdOnNoYWRvdy1bLTFweF8wXzBfI2RjNGM2NCxfMF8xcHhfMF8wXyNkYzRjNjQsXzBfLTFweF8wXzBfI2RjNGM2NF0gZ3JvdXAtZGF0YS1bdGUtaW5wdXQtZm9jdXNlZF06Ym9yZGVyLVsjZGM0YzY0XVwiLFxuICBub3RjaE1pZGRsZUludmFsaWQ6IFwiYm9yZGVyLVsjZGM0YzY0XSBkYXJrOmJvcmRlci1bI2RjNGM2NF0gZ3JvdXAtZGF0YS1bdGUtaW5wdXQtZm9jdXNlZF06c2hhZG93LVswXzFweF8wXzBfI2RjNGM2NF0gZ3JvdXAtZGF0YS1bdGUtaW5wdXQtZm9jdXNlZF06Ym9yZGVyLVsjZGM0YzY0XVwiLFxuICBub3RjaFRyYWlsaW5nSW52YWxpZDogXCJib3JkZXItWyNkYzRjNjRdIGRhcms6Ym9yZGVyLVsjZGM0YzY0XSBncm91cC1kYXRhLVt0ZS1pbnB1dC1mb2N1c2VkXTpzaGFkb3ctWzFweF8wXzBfI2RjNGM2NCxfMF8tMXB4XzBfMF8jZGM0YzY0LF8wXzFweF8wXzBfI2RjNGM2NF0gZ3JvdXAtZGF0YS1bdGUtaW5wdXQtZm9jdXNlZF06Ym9yZGVyLVsjZGM0YzY0XVwiLFxuICAvLyBiYXNpYyBpbnB1dHNcbiAgYmFzaWNJbnB1dFZhbGlkOiBcIiFib3JkZXItWyMxNGE0NGRdIGZvY3VzOiFib3JkZXItWyMxNGE0NGRdIGZvY3VzOiFzaGFkb3ctW2luc2V0XzBfMF8wXzFweF8jMTRhNDRkXVwiLFxuICBiYXNpY0lucHV0SW52YWxpZDogXCIhYm9yZGVyLVsjZGM0YzY0XSBmb2N1czohYm9yZGVyLVsjZGM0YzY0XSBmb2N1czohc2hhZG93LVtpbnNldF8wXzBfMF8xcHhfI2RjNGM2NF1cIixcbiAgLy8gY2hlY2tib3hcbiAgY2hlY2tib3hWYWxpZDogXCJjaGVja2VkOiFib3JkZXItWyMxNGE0NGRdIGNoZWNrZWQ6IWJnLVsjMTRhNDRkXSBjaGVja2VkOmFmdGVyOiFiZy1bIzE0YTQ0ZF1cIixcbiAgY2hlY2tib3hJbnZhbGlkOiBcImNoZWNrZWQ6IWJvcmRlci1bI2RjNGM2NF0gY2hlY2tlZDohYmctWyNkYzRjNjRdIGNoZWNrZWQ6YWZ0ZXI6IWJnLVsjZGM0YzY0XVwiLFxuICByYWRpb1ZhbGlkOiBcImNoZWNrZWQ6IWJvcmRlci1bIzE0YTQ0ZF0gY2hlY2tlZDphZnRlcjohYmctWyMxNGE0NGRdXCIsXG4gIHJhZGlvSW52YWxpZDogXCJjaGVja2VkOiFib3JkZXItWyNkYzRjNjRdIGNoZWNrZWQ6YWZ0ZXI6IWJnLVsjZGM0YzY0XVwiLFxuICAvLyBsYWJlbHNcbiAgbGFiZWxWYWxpZDogXCIhdGV4dC1bIzE0YTQ0ZF1cIixcbiAgbGFiZWxJbnZhbGlkOiBcIiF0ZXh0LVsjZGM0YzY0XVwiLFxuICAvLyBmZWVkYmFja1xuICB2YWxpZEZlZWRiYWNrOiBcImFic29sdXRlIHRvcC1mdWxsIGxlZnQtMCBtLTEgdy1hdXRvIHRleHQtc20gdGV4dC1bIzE0YTQ0ZF0gYW5pbWF0ZS1bZmFkZS1pbl8wLjNzX2JvdGhdXCIsXG4gIGludmFsaWRGZWVkYmFjazogXCJhYnNvbHV0ZSB0b3AtZnVsbCBsZWZ0LTAgbS0xIHctYXV0byB0ZXh0LXNtIHRleHQtWyNkYzRjNjRdIGFuaW1hdGUtW2ZhZGUtaW5fMC4zc19ib3RoXVwiLFxuICAvLyBlbGVtZW50IHZhbGlkYXRlZFxuICBlbGVtZW50VmFsaWRhdGVkOiBcIm1iLThcIlxufSwgRkUgPSB7XG4gIG5vdGNoTGVhZGluZ1ZhbGlkOiBcInN0cmluZ1wiLFxuICBub3RjaE1pZGRsZVZhbGlkOiBcInN0cmluZ1wiLFxuICBub3RjaFRyYWlsaW5nVmFsaWQ6IFwic3RyaW5nXCIsXG4gIG5vdGNoTGVhZGluZ0ludmFsaWQ6IFwic3RyaW5nXCIsXG4gIG5vdGNoTWlkZGxlSW52YWxpZDogXCJzdHJpbmdcIixcbiAgbm90Y2hUcmFpbGluZ0ludmFsaWQ6IFwic3RyaW5nXCIsXG4gIGJhc2ljSW5wdXRWYWxpZDogXCJzdHJpbmdcIixcbiAgYmFzaWNJbnB1dEludmFsaWQ6IFwic3RyaW5nXCIsXG4gIGNoZWNrYm94VmFsaWQ6IFwic3RyaW5nXCIsXG4gIGNoZWNrYm94SW52YWxpZDogXCJzdHJpbmdcIixcbiAgcmFkaW9WYWxpZDogXCJzdHJpbmdcIixcbiAgcmFkaW9JbnZhbGlkOiBcInN0cmluZ1wiLFxuICBsYWJlbFZhbGlkOiBcInN0cmluZ1wiLFxuICBsYWJlbEludmFsaWQ6IFwic3RyaW5nXCIsXG4gIHZhbGlkRmVlZGJhY2s6IFwic3RyaW5nXCIsXG4gIGludmFsaWRGZWVkYmFjazogXCJzdHJpbmdcIixcbiAgZWxlbWVudFZhbGlkYXRlZDogXCJzdHJpbmdcIlxufTtcbmNsYXNzIENoIGV4dGVuZHMgZ3Qge1xuICBjb25zdHJ1Y3Rvcih0LCBlLCBpKSB7XG4gICAgc3VwZXIodCksIHRoaXMuX2VsZW1lbnQgPSB0LCB0aGlzLl9lbGVtZW50ICYmIHkuc2V0RGF0YSh0LCBqbywgdGhpcyksIHRoaXMuX2NvbmZpZyA9IHRoaXMuX2dldENvbmZpZyhlKSwgdGhpcy5fY2xhc3NlcyA9IHRoaXMuX2dldENsYXNzZXMoaSksIHRoaXMuX2lzVmFsaWQgPSAhMCwgdGhpcy5fc2hvdWxkQXBwbHlJbnB1dEV2ZW50cyA9ICEwLCB0aGlzLl9zdWJtaXRDYWxsYmFjayA9IG51bGwsIHRoaXMuX2Vycm9yTWVzc2FnZXMgPSB7XG4gICAgICAuLi5JRSxcbiAgICAgIC4uLnRoaXMuX2NvbmZpZy5jdXN0b21FcnJvck1lc3NhZ2VzXG4gICAgfSwgdGhpcy5fdmFsaWRhdGlvbkVsZW1lbnRzID0gdGhpcy5fZ2V0VmFsaWRhdGlvbkVsZW1lbnRzKCksIHRoaXMuX3ZhbGlkYXRpb25FbGVtZW50cy5mb3JFYWNoKCh7IGVsZW1lbnQ6IG4sIGlucHV0OiBvIH0pID0+IHtcbiAgICAgIHRoaXMuX2NyZWF0ZUZlZWRiYWNrV3JhcHBlcihuLCBvKTtcbiAgICB9KSwgdGhpcy5fdmFsaWRhdGlvbk9ic2VydmVyID0gdGhpcy5fd2F0Y2hGb3JWYWxpZGF0aW9uQ2hhbmdlcygpLCB0aGlzLl92YWxpZGF0aW9uT2JzZXJ2ZXIub2JzZXJ2ZSh0aGlzLl9lbGVtZW50LCB7IGF0dHJpYnV0ZXM6ICEwIH0pLCB0aGlzLl9zdWJtaXRCdXR0b24gPSBudWxsLCB0aGlzLl9oYW5kbGVTdWJtaXRCdXR0b24oKSwgdGhpcy5fdmFsaWRhdGlvblJlc3VsdCA9IFtdO1xuICB9XG4gIC8vIEdldHRlcnNcbiAgc3RhdGljIGdldCBEZWZhdWx0VHlwZSgpIHtcbiAgICByZXR1cm4gVkU7XG4gIH1cbiAgc3RhdGljIGdldCBEZWZhdWx0KCkge1xuICAgIHJldHVybiBQbDtcbiAgfVxuICBzdGF0aWMgZ2V0IE5BTUUoKSB7XG4gICAgcmV0dXJuIEVvO1xuICB9XG4gIC8vIFB1YmxpY1xuICBkaXNwb3NlKCkge1xuICAgIHZhciB0O1xuICAgICh0ID0gdGhpcy5fdmFsaWRhdGlvbk9ic2VydmVyKSA9PSBudWxsIHx8IHQuZGlzY29ubmVjdCgpLCB0aGlzLl92YWxpZGF0aW9uT2JzZXJ2ZXIgPSBudWxsLCB0aGlzLl9zdWJtaXRDYWxsYmFjayA9IG51bGwsIHRoaXMuX2VsZW1lbnQucmVtb3ZlQXR0cmlidXRlKE9zKSwgdGhpcy5fcmVtb3ZlVmFsaWRhdGlvblRyYWNlcygpLCB0aGlzLl92YWxpZGF0aW9uUmVzdWx0ID0gW10sIHRoaXMuX3N1Ym1pdEJ1dHRvbiAmJiBjLm9mZih0aGlzLl9zdWJtaXRCdXR0b24sIFwiY2xpY2tcIiksIHRoaXMuX2NvbmZpZy5hY3RpdmVWYWxpZGF0aW9uICYmICh0aGlzLl92YWxpZGF0aW9uRWxlbWVudHMuZm9yRWFjaCgoZSkgPT4ge1xuICAgICAgY29uc3QgeyBpbnB1dDogaSB9ID0gZTtcbiAgICAgIGMub2ZmKGksIFwiaW5wdXRcIik7XG4gICAgfSksIHRoaXMuX3Nob3VsZEFwcGx5SW5wdXRFdmVudHMgPSAhMCk7XG4gIH1cbiAgLy8gUHJpdmF0ZVxuICBfcmVtb3ZlVmFsaWRhdGlvblRyYWNlcygpIHtcbiAgICB0aGlzLl9yZW1vdmVGZWVkYmFja1dyYXBwZXIoKSwgdGhpcy5fdmFsaWRhdGlvbkVsZW1lbnRzLmZvckVhY2goKHsgZWxlbWVudDogdCwgY2xhc3NlczogZSwgaW5pdGlhbEhUTUw6IGkgfSkgPT4ge1xuICAgICAgdC5jbGFzc05hbWUgPSBlLCB0LmlubmVySFRNTCA9IGksIHQucmVtb3ZlQXR0cmlidXRlKFNzKSwgdC5yZW1vdmVBdHRyaWJ1dGUoRHMpLCB0LnJlbW92ZUF0dHJpYnV0ZShDbyk7XG4gICAgfSksIHRoaXMuX3ZhbGlkYXRpb25FbGVtZW50cyA9IFtdO1xuICB9XG4gIF9nZXRWYWxpZGF0aW9uRWxlbWVudHMoKSB7XG4gICAgcmV0dXJuIGQuZmluZChcbiAgICAgIExFLFxuICAgICAgdGhpcy5fZWxlbWVudFxuICAgICkubWFwKChlKSA9PiB7XG4gICAgICBjb25zdCBpID0gZC5maW5kT25lKFwiaW5wdXRcIiwgZSkgfHwgZC5maW5kT25lKFwidGV4dGFyZWFcIiwgZSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpZDogaS5uYW1lIHx8IGkuaWQgfHwgcnQoXCJ2YWxpZGF0aW9uLVwiKSxcbiAgICAgICAgZWxlbWVudDogZSxcbiAgICAgICAgdHlwZTogZS5nZXRBdHRyaWJ1dGUoRWgpLFxuICAgICAgICBpbnB1dDogaSxcbiAgICAgICAgdmFsaWRGZWVkYmFjazogZS5nZXRBdHRyaWJ1dGUoQ28pLFxuICAgICAgICBpbnZhbGlkRmVlZGJhY2s6IGUuZ2V0QXR0cmlidXRlKERzKSxcbiAgICAgICAgY2xhc3NlczogZS5jbGFzc05hbWUsXG4gICAgICAgIGluaXRpYWxIVE1MOiBlLmlubmVySFRNTCxcbiAgICAgICAgcnVsZXNldDogZS5nZXRBdHRyaWJ1dGUoUmwpXG4gICAgICB9O1xuICAgIH0pO1xuICB9XG4gIF9jcmVhdGVGZWVkYmFja1dyYXBwZXIodCwgZSkge1xuICAgIGlmICh0LnF1ZXJ5U2VsZWN0b3JBbGwoYFske0lzfV1gKS5sZW5ndGggPiAwKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICBpLnNldEF0dHJpYnV0ZShJcywgXCJcIiksIGUucGFyZW50Tm9kZS5hcHBlbmRDaGlsZChpKTtcbiAgfVxuICBfcmVtb3ZlRmVlZGJhY2tXcmFwcGVyKCkge1xuICAgIGQuZmluZChcbiAgICAgIGBbJHtJc31dYCxcbiAgICAgIHRoaXMuX2VsZW1lbnRcbiAgICApLmZvckVhY2goKGUpID0+IHtcbiAgICAgIGUucmVtb3ZlKCk7XG4gICAgfSk7XG4gIH1cbiAgX3dhdGNoRm9yVmFsaWRhdGlvbkNoYW5nZXMoKSB7XG4gICAgcmV0dXJuIG5ldyBNdXRhdGlvbk9ic2VydmVyKChlKSA9PiB7XG4gICAgICBlLmZvckVhY2goKGkpID0+IHtcbiAgICAgICAgY29uc3QgeyBhdHRyaWJ1dGVOYW1lOiBuIH0gPSBpO1xuICAgICAgICBuID09PSBPcyAmJiAodGhpcy5faGFuZGxlVmFsaWRhdGlvbigpLCB0aGlzLl9jb25maWcuYWN0aXZlVmFsaWRhdGlvbiAmJiB0aGlzLl9zaG91bGRBcHBseUlucHV0RXZlbnRzICYmIHRoaXMuX2FwcGx5SW5wdXRFdmVudHMoKSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBfaGFuZGxlVmFsaWRhdGlvbigpIHtcbiAgICB0aGlzLl9lbGVtZW50LmdldEF0dHJpYnV0ZShPcykgJiYgKHRoaXMuX3ZhbGlkYXRpb25SZXN1bHQgPSBbXSwgdGhpcy5faXNWYWxpZCA9ICEwLCB0aGlzLl92YWxpZGF0aW9uRWxlbWVudHMuZm9yRWFjaChcbiAgICAgICh0KSA9PiB0aGlzLl92YWxpZGF0ZVNpbmdsZUVsZW1lbnQodClcbiAgICApLCB0aGlzLl9lbWl0RXZlbnRzKHRoaXMuX2lzVmFsaWQpLCB0aGlzLl9zdWJtaXRDYWxsYmFjayAmJiB0aGlzLl9zdWJtaXRDYWxsYmFjayh0aGlzLl9pc1ZhbGlkKSk7XG4gIH1cbiAgX3ZhbGlkYXRlU2luZ2xlRWxlbWVudCh0KSB7XG4gICAgdmFyIHA7XG4gICAgY29uc3QgeyBlbGVtZW50OiBlLCB0eXBlOiBpLCBpbnB1dDogbiwgcnVsZXNldDogbywgaWQ6IHIgfSA9IHQ7XG4gICAgbyAmJiB0aGlzLl92YWxpZGF0ZUJ5UnVsZXNldCh0KTtcbiAgICBjb25zdCBhID0gZS5nZXRBdHRyaWJ1dGUoU3MpO1xuICAgIGlmIChhICE9PSBcInZhbGlkXCIgJiYgYSAhPT0gXCJpbnZhbGlkXCIpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgbCA9IGEucmVwbGFjZShcbiAgICAgIGEuY2hhckF0KDApLFxuICAgICAgYS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKVxuICAgICk7XG4gICAgaSA9PT0gXCJpbnB1dFwiICYmIHRoaXMuX3Jlc3R5bGVOb3RjaGVzKGUsIGwpLCBpID09PSBcImJhc2ljXCIgJiYgdGhpcy5fcmVzdHlsZUJhc2ljSW5wdXRzKG4sIGwpLCAoaSA9PT0gXCJjaGVja2JveFwiIHx8IGkgPT09IFwicmFkaW9cIikgJiYgdGhpcy5fcmVzdHlsZUNoZWNrYm94ZXMobiwgbCwgaSksIHRoaXMuX3Jlc3R5bGVMYWJlbHMoZSwgbCksIGEgPT09IFwiaW52YWxpZFwiICYmICh0aGlzLl9pc1ZhbGlkID0gITEpLCB0aGlzLl9jb25maWcuZGlzYWJsZUZlZWRiYWNrIHx8IHRoaXMuX2FwcGx5RmVlZGJhY2soZSwgYSksIGMudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBIRSwge1xuICAgICAgdmFsdWU6IHtcbiAgICAgICAgbmFtZTogcixcbiAgICAgICAgcmVzdWx0OiBhLFxuICAgICAgICB2YWxpZGF0aW9uOiAocCA9IHRoaXMuX3ZhbGlkYXRpb25SZXN1bHRbcl0pID09IG51bGwgPyB2b2lkIDAgOiBwLnZhbGlkYXRpb25cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBfdmFsaWRhdGVCeVJ1bGVzZXQoeyBlbGVtZW50OiB0LCB0eXBlOiBlLCBpbnZhbGlkRmVlZGJhY2s6IGksIGlucHV0OiBuLCBpZDogbyB9KSB7XG4gICAgY29uc3QgciA9IHRoaXMuX2dldFJ1bGVzZXQodCk7XG4gICAgaWYgKCFyLmxlbmd0aClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBhID0gZSA9PT0gXCJjaGVja2JveFwiIHx8IGUgPT09IFwicmFkaW9cIiA/IG4uY2hlY2tlZCA6IG4udmFsdWU7XG4gICAgbGV0IGwgPSBcIlwiLCBwID0gW107XG4gICAgZm9yIChjb25zdCB1IG9mIHIpIHtcbiAgICAgIGNvbnN0IF8gPSB1LmNhbGxiYWNrKFxuICAgICAgICBhLFxuICAgICAgICB0aGlzLl9lcnJvck1lc3NhZ2VzW3UubmFtZV0gfHwgdGhpcy5fY29uZmlnLmludmFsaWRGZWVkYmFjayxcbiAgICAgICAgdS5wYXJhbWV0ZXJcbiAgICAgICk7XG4gICAgICBwLnB1c2goe1xuICAgICAgICByZXN1bHQ6IF8gPT09ICEwLFxuICAgICAgICBuYW1lOiB1Lm5hbWUsXG4gICAgICAgIGZ1bGxOYW1lOiB1LmZ1bGxOYW1lXG4gICAgICB9KSwgdHlwZW9mIF8gPT0gXCJzdHJpbmdcIiAmJiAhbCAmJiAobCA9IF8pO1xuICAgIH1cbiAgICBpZiAodGhpcy5fdmFsaWRhdGlvblJlc3VsdFtvXSA9IHsgZWxlbWVudDogdCwgdmFsaWRhdGlvbjogcCB9LCAhbCkge1xuICAgICAgdC5zZXRBdHRyaWJ1dGUoU3MsIFwidmFsaWRcIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHQuc2V0QXR0cmlidXRlKFNzLCBcImludmFsaWRcIiksIGkgfHwgdC5zZXRBdHRyaWJ1dGUoRHMsIGwpO1xuICB9XG4gIF9oYW5kbGVJbnB1dENoYW5nZSh0KSB7XG4gICAgdGhpcy5fdmFsaWRhdGVTaW5nbGVFbGVtZW50KHQpO1xuICB9XG4gIF9nZXRSdWxlc2V0KHQpIHtcbiAgICBjb25zdCBpID0gdC5nZXRBdHRyaWJ1dGUoUmwpLnNwbGl0KFwifFwiKTtcbiAgICBsZXQgbiA9IFtdO1xuICAgIGNvbnN0IG8gPSB7XG4gICAgICAuLi5ERSxcbiAgICAgIC4uLnRoaXMuX2NvbmZpZy5jdXN0b21SdWxlc1xuICAgIH07XG4gICAgcmV0dXJuIGkuZm9yRWFjaCgocikgPT4ge1xuICAgICAgY29uc3QgYSA9IHRoaXMuX2dldFJ1bGVEYXRhKHIsIG8pO1xuICAgICAgYS5jYWxsYmFjayA/IG4ucHVzaChhKSA6IGNvbnNvbGUud2FybihgUnVsZSAke3J9IGRvZXMgbm90IGV4aXN0YCk7XG4gICAgfSksIG47XG4gIH1cbiAgX2dldFJ1bGVEYXRhKHQsIGUpIHtcbiAgICBjb25zdCBpID0gdC5zcGxpdChcIihcIik7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNhbGxiYWNrOiBlW2lbMF1dLFxuICAgICAgcGFyYW1ldGVyOiBpWzFdID8gaVsxXS5zcGxpdChcIilcIilbMF0gOiBudWxsLFxuICAgICAgbmFtZTogaVswXSxcbiAgICAgIGZ1bGxOYW1lOiB0XG4gICAgfTtcbiAgfVxuICBfYXBwbHlGZWVkYmFjayh0LCBlKSB7XG4gICAgY29uc3QgaSA9IGQuZmluZE9uZShcbiAgICAgIGBbJHtJc31dYCxcbiAgICAgIHRcbiAgICApLCBuID0gdC5nZXRBdHRyaWJ1dGUoQ28pIHx8IHRoaXMuX2NvbmZpZy52YWxpZEZlZWRiYWNrLCBvID0gdC5nZXRBdHRyaWJ1dGUoRHMpIHx8IHRoaXMuX2NvbmZpZy5pbnZhbGlkRmVlZGJhY2s7XG4gICAgaC5hZGRDbGFzcyh0LCB0aGlzLl9jbGFzc2VzLmVsZW1lbnRWYWxpZGF0ZWQpLCBpLnRleHRDb250ZW50ID0gZSA9PT0gXCJ2YWxpZFwiID8gbiA6IG8sIGkuY2xhc3NOYW1lID0gdGhpcy5fY2xhc3Nlc1tlID09PSBcInZhbGlkXCIgPyBcInZhbGlkRmVlZGJhY2tcIiA6IFwiaW52YWxpZEZlZWRiYWNrXCJdO1xuICB9XG4gIF9yZXN0eWxlQ2hlY2tib3hlcyh0LCBlLCBpKSB7XG4gICAgaC5yZW1vdmVDbGFzcyh0LCB0aGlzLl9jbGFzc2VzLmNoZWNrYm94VmFsaWQpLCBoLnJlbW92ZUNsYXNzKHQsIHRoaXMuX2NsYXNzZXMuY2hlY2tib3hJbnZhbGlkKSwgaC5hZGRDbGFzcyh0LCB0aGlzLl9jbGFzc2VzW2Ake2l9JHtlfWBdKTtcbiAgfVxuICBfcmVzdHlsZUJhc2ljSW5wdXRzKHQsIGUpIHtcbiAgICBoLnJlbW92ZUNsYXNzKHQsIHRoaXMuX2NsYXNzZXMuYmFzaWNJbnB1dFZhbGlkKSwgaC5yZW1vdmVDbGFzcyh0LCB0aGlzLl9jbGFzc2VzLmJhc2ljSW5wdXRJbnZhbGlkKSwgaC5hZGRDbGFzcyh0LCB0aGlzLl9jbGFzc2VzW2BiYXNpY0lucHV0JHtlfWBdKTtcbiAgfVxuICBfcmVzdHlsZU5vdGNoZXModCwgZSkge1xuICAgIGQuZmluZChORSwgdCkuZm9yRWFjaCgobiwgbykgPT4ge1xuICAgICAgbGV0IHIgPSBvID09PSAwID8gXCJub3RjaExlYWRpbmdcIiA6IG8gPT09IDEgPyBcIm5vdGNoTWlkZGxlXCIgOiBcIm5vdGNoVHJhaWxpbmdcIjtcbiAgICAgIG4uY2xhc3NOYW1lID0gXCJcIiwgaC5hZGRDbGFzcyhuLCBLY1tyXSksIHIgKz0gZSwgaC5hZGRDbGFzcyhuLCB0aGlzLl9jbGFzc2VzW3JdKTtcbiAgICB9KTtcbiAgfVxuICBfcmVzdHlsZUxhYmVscyh0LCBlKSB7XG4gICAgY29uc3QgaSA9IGQuZmluZChcImxhYmVsXCIsIHQpO1xuICAgIGkubGVuZ3RoICYmIGkuZm9yRWFjaCgobikgPT4ge1xuICAgICAgaC5yZW1vdmVDbGFzcyhuLCB0aGlzLl9jbGFzc2VzLmxhYmVsVmFsaWQpLCBoLnJlbW92ZUNsYXNzKG4sIHRoaXMuX2NsYXNzZXMubGFiZWxJbnZhbGlkKSwgaC5hZGRDbGFzcyhuLCB0aGlzLl9jbGFzc2VzW2BsYWJlbCR7ZX1gXSk7XG4gICAgfSk7XG4gIH1cbiAgX2VtaXRFdmVudHModCkge1xuICAgIGlmIChjLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgUkUpLCB0KSB7XG4gICAgICBjLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgUEUsIHtcbiAgICAgICAgdmFsdWU6IHRoaXMuX3ZhbGlkYXRpb25SZXN1bHRcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgQkUsIHtcbiAgICAgIHZhbHVlOiB0aGlzLl92YWxpZGF0aW9uUmVzdWx0XG4gICAgfSk7XG4gIH1cbiAgX2FwcGx5SW5wdXRFdmVudHMoKSB7XG4gICAgdGhpcy5fdmFsaWRhdGlvbkVsZW1lbnRzLmZvckVhY2goKHQpID0+IHtcbiAgICAgIGNvbnN0IHsgaW5wdXQ6IGUgfSA9IHQ7XG4gICAgICBjLm9uKFxuICAgICAgICBlLFxuICAgICAgICBcImlucHV0XCIsXG4gICAgICAgICgpID0+IHRoaXMuX2hhbmRsZUlucHV0Q2hhbmdlKHQpXG4gICAgICApO1xuICAgIH0pLCB0aGlzLl9zaG91bGRBcHBseUlucHV0RXZlbnRzID0gITE7XG4gIH1cbiAgX2hhbmRsZVN1Ym1pdEJ1dHRvbigpIHtcbiAgICB0aGlzLl9zdWJtaXRCdXR0b24gPSBkLmZpbmRPbmUoXG4gICAgICBNRSxcbiAgICAgIHRoaXMuX2VsZW1lbnRcbiAgICApLCB0aGlzLl9zdWJtaXRCdXR0b24gJiYgYy5vbihcbiAgICAgIHRoaXMuX3N1Ym1pdEJ1dHRvbixcbiAgICAgIFwiY2xpY2tcIixcbiAgICAgICh0KSA9PiB0aGlzLl9oYW5kbGVTdWJtaXRCdXR0b25DbGljayh0KVxuICAgICk7XG4gIH1cbiAgX2hhbmRsZVN1Ym1pdEJ1dHRvbkNsaWNrKHQpIHtcbiAgICBpZiAodGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoT3MsICEwKSwgdGhpcy5fY29uZmlnLnN1Ym1pdENhbGxiYWNrKSB7XG4gICAgICB0aGlzLl9zdWJtaXRDYWxsYmFjayA9IChlKSA9PiB0aGlzLl9jb25maWcuc3VibWl0Q2FsbGJhY2sodCwgZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gIF9nZXRDb25maWcodCkge1xuICAgIHJldHVybiB0ID0ge1xuICAgICAgLi4uUGwsXG4gICAgICAuLi5oLmdldERhdGFBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpLFxuICAgICAgLi4udHlwZW9mIHQgPT0gXCJvYmplY3RcIiAmJiB0ID8gdCA6IHt9XG4gICAgfSwgRChFbywgdCwgdGhpcy5jb25zdHJ1Y3Rvci5EZWZhdWx0VHlwZSksIHQ7XG4gIH1cbiAgX2dldENsYXNzZXModCkge1xuICAgIGNvbnN0IGUgPSBoLmdldERhdGFDbGFzc0F0dHJpYnV0ZXModGhpcy5fZWxlbWVudCk7XG4gICAgcmV0dXJuIHQgPSB7XG4gICAgICAuLi5XRSxcbiAgICAgIC4uLmUsXG4gICAgICAuLi50XG4gICAgfSwgRChFbywgdCwgRkUpLCB0O1xuICB9XG4gIC8vIFN0YXRpY1xuICBzdGF0aWMgZ2V0SW5zdGFuY2UodCkge1xuICAgIHJldHVybiB5LmdldERhdGEodCwgam8pO1xuICB9XG4gIHN0YXRpYyBnZXRPckNyZWF0ZUluc3RhbmNlKHQsIGUgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLmdldEluc3RhbmNlKHQpIHx8IG5ldyB0aGlzKHQsIHR5cGVvZiBlID09IFwib2JqZWN0XCIgPyBlIDogbnVsbCk7XG4gIH1cbiAgc3RhdGljIGpRdWVyeUludGVyZmFjZSh0KSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgIGNvbnN0IGUgPSBDaC5nZXRPckNyZWF0ZUluc3RhbmNlKHRoaXMpO1xuICAgICAgaWYgKHR5cGVvZiB0ID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgaWYgKGVbdF0gPT09IHZvaWQgMCB8fCB0LnN0YXJ0c1dpdGgoXCJfXCIpIHx8IHQgPT09IFwiY29uc3RydWN0b3JcIilcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBObyBtZXRob2QgbmFtZWQgXCIke3R9XCJgKTtcbiAgICAgICAgZVt0XSh0aGlzKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuY2xhc3MgWGkge1xuICBfZ2V0Q29vcmRpbmF0ZXModCkge1xuICAgIGNvbnN0IFtlXSA9IHQudG91Y2hlcztcbiAgICByZXR1cm4ge1xuICAgICAgeDogZS5jbGllbnRYLFxuICAgICAgeTogZS5jbGllbnRZXG4gICAgfTtcbiAgfVxuICBfZ2V0RGlyZWN0aW9uKHsgeDogdCwgeTogZSB9KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHtcbiAgICAgICAgZGlyZWN0aW9uOiB0IDwgMCA/IFwibGVmdFwiIDogXCJyaWdodFwiLFxuICAgICAgICB2YWx1ZTogTWF0aC5hYnModClcbiAgICAgIH0sXG4gICAgICB5OiB7XG4gICAgICAgIGRpcmVjdGlvbjogZSA8IDAgPyBcInVwXCIgOiBcImRvd25cIixcbiAgICAgICAgdmFsdWU6IE1hdGguYWJzKGUpXG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBfZ2V0T3JpZ2luKHsgeDogdCwgeTogZSB9LCB7IHg6IGksIHk6IG4gfSkge1xuICAgIHJldHVybiB7XG4gICAgICB4OiB0IC0gaSxcbiAgICAgIHk6IGUgLSBuXG4gICAgfTtcbiAgfVxuICBfZ2V0RGlzdGFuY2VCZXR3ZWVuVHdvUG9pbnRzKHQsIGUsIGksIG4pIHtcbiAgICByZXR1cm4gTWF0aC5oeXBvdChlIC0gdCwgbiAtIGkpO1xuICB9XG4gIF9nZXRNaWRQb2ludCh7IHgxOiB0LCB4MjogZSwgeTE6IGksIHkyOiBuIH0pIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDogKHQgKyBlKSAvIDIsXG4gICAgICB5OiAoaSArIG4pIC8gMlxuICAgIH07XG4gIH1cbiAgX2dldFZlY3Rvckxlbmd0aCh7IHgxOiB0LCB4MjogZSwgeTE6IGksIHkyOiBuIH0pIHtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KChlIC0gdCkgKiogMiArIChuIC0gaSkgKiogMik7XG4gIH1cbiAgX2dldFJpZ2h0TW9zdFRvdWNoKHQpIHtcbiAgICBsZXQgZSA9IG51bGw7XG4gICAgY29uc3QgaSA9IE51bWJlci5NSU5fVkFMVUU7XG4gICAgcmV0dXJuIHQuZm9yRWFjaCgobikgPT4ge1xuICAgICAgbi5jbGllbnRYID4gaSAmJiAoZSA9IG4pO1xuICAgIH0pLCBlO1xuICB9XG4gIF9nZXRBbmdsZSh0LCBlLCBpLCBuKSB7XG4gICAgcmV0dXJuIE1hdGguYXRhbjIobiAtIGUsIGkgLSB0KTtcbiAgfVxuICBfZ2V0QW5ndWxhckRpc3RhbmNlKHQsIGUpIHtcbiAgICByZXR1cm4gZSAtIHQ7XG4gIH1cbiAgX2dldENlbnRlclhZKHsgeDE6IHQsIHgyOiBlLCB5MTogaSwgeTI6IG4gfSkge1xuICAgIHJldHVybiB7XG4gICAgICB4OiB0ICsgKGUgLSB0KSAvIDIsXG4gICAgICB5OiBpICsgKG4gLSBpKSAvIDJcbiAgICB9O1xuICB9XG4gIF9nZXRQaW5jaFRvdWNoT3JpZ2luKHQpIHtcbiAgICBjb25zdCBbZSwgaV0gPSB0LCBuID0ge1xuICAgICAgeDE6IGUuY2xpZW50WCxcbiAgICAgIHgyOiBpLmNsaWVudFgsXG4gICAgICB5MTogZS5jbGllbnRZLFxuICAgICAgeTI6IGkuY2xpZW50WVxuICAgIH07XG4gICAgcmV0dXJuIFt0aGlzLl9nZXRWZWN0b3JMZW5ndGgobiksIHRoaXMuX2dldENlbnRlclhZKG4pXTtcbiAgfVxuICBfZ2V0UG9zaXRpb24oeyB4MTogdCwgeDI6IGUsIHkxOiBpLCB5MjogbiB9KSB7XG4gICAgcmV0dXJuIHsgeDE6IHQsIHgyOiBlLCB5MTogaSwgeTI6IG4gfTtcbiAgfVxufVxuY29uc3QgQW8gPSBcInByZXNzXCIsIFlFID0gXCJwcmVzc3VwXCIsIGpFID0ge1xuICB0aW1lOiBcIm51bWJlclwiLFxuICBwb2ludGVyczogXCJudW1iZXJcIlxufSwgS0UgPSB7XG4gIHRpbWU6IDI1MCxcbiAgcG9pbnRlcnM6IDFcbn07XG5jbGFzcyB6RSBleHRlbmRzIFhpIHtcbiAgY29uc3RydWN0b3IodCwgZSA9IHt9KSB7XG4gICAgc3VwZXIoKSwgdGhpcy5fZWxlbWVudCA9IHQsIHRoaXMuX29wdGlvbnMgPSB0aGlzLl9nZXRDb25maWcoZSksIHRoaXMuX3RpbWVyID0gbnVsbDtcbiAgfVxuICAvLyBHZXR0ZXJzXG4gIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICByZXR1cm4gQW87XG4gIH1cbiAgaGFuZGxlVG91Y2hTdGFydCh0KSB7XG4gICAgY29uc3QgeyB0aW1lOiBlLCBwb2ludGVyczogaSB9ID0gdGhpcy5fb3B0aW9ucztcbiAgICB0LnRvdWNoZXMubGVuZ3RoID09PSBpICYmICh0aGlzLl90aW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgYy50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEFvLCB7IHRvdWNoOiB0LCB0aW1lOiBlIH0pLCBjLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgWUUsIHsgdG91Y2g6IHQgfSk7XG4gICAgfSwgZSkpO1xuICB9XG4gIGhhbmRsZVRvdWNoRW5kKCkge1xuICAgIGNsZWFyVGltZW91dCh0aGlzLl90aW1lcik7XG4gIH1cbiAgX2dldENvbmZpZyh0KSB7XG4gICAgY29uc3QgZSA9IHtcbiAgICAgIC4uLktFLFxuICAgICAgLi4uaC5nZXREYXRhQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KSxcbiAgICAgIC4uLnRcbiAgICB9O1xuICAgIHJldHVybiBEKEFvLCBlLCBqRSksIGU7XG4gIH1cbn1cbmNvbnN0IFVFID0gXCJzd2lwZVwiLCBYRSA9IHtcbiAgdGhyZXNob2xkOiBcIm51bWJlclwiLFxuICBkaXJlY3Rpb246IFwic3RyaW5nXCJcbn0sIEdFID0ge1xuICB0aHJlc2hvbGQ6IDEwLFxuICBkaXJlY3Rpb246IFwiYWxsXCJcbn07XG5jbGFzcyBxRSB7XG4gIGNvbnN0cnVjdG9yKHQsIGUpIHtcbiAgICB0aGlzLl9lbGVtZW50ID0gdCwgdGhpcy5fc3RhcnRQb3NpdGlvbiA9IG51bGwsIHRoaXMuX29wdGlvbnMgPSB0aGlzLl9nZXRDb25maWcoZSk7XG4gIH1cbiAgaGFuZGxlVG91Y2hTdGFydCh0KSB7XG4gICAgdGhpcy5fc3RhcnRQb3NpdGlvbiA9IHRoaXMuX2dldENvb3JkaW5hdGVzKHQpO1xuICB9XG4gIGhhbmRsZVRvdWNoTW92ZSh0KSB7XG4gICAgaWYgKCF0aGlzLl9zdGFydFBvc2l0aW9uKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGUgPSB0aGlzLl9nZXRDb29yZGluYXRlcyh0KSwgaSA9IHtcbiAgICAgIHg6IGUueCAtIHRoaXMuX3N0YXJ0UG9zaXRpb24ueCxcbiAgICAgIHk6IGUueSAtIHRoaXMuX3N0YXJ0UG9zaXRpb24ueVxuICAgIH0sIG4gPSB0aGlzLl9nZXREaXJlY3Rpb24oaSk7XG4gICAgaWYgKHRoaXMuX29wdGlvbnMuZGlyZWN0aW9uID09PSBcImFsbFwiKSB7XG4gICAgICBpZiAobi55LnZhbHVlIDwgdGhpcy5fb3B0aW9ucy50aHJlc2hvbGQgJiYgbi54LnZhbHVlIDwgdGhpcy5fb3B0aW9ucy50aHJlc2hvbGQpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNvbnN0IHIgPSBuLnkudmFsdWUgPiBuLngudmFsdWUgPyBuLnkuZGlyZWN0aW9uIDogbi54LmRpcmVjdGlvbjtcbiAgICAgIGMudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBgc3dpcGUke3J9YCwgeyB0b3VjaDogdCB9KSwgYy50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIFwic3dpcGVcIiwgeyB0b3VjaDogdCwgZGlyZWN0aW9uOiByIH0pLCB0aGlzLl9zdGFydFBvc2l0aW9uID0gbnVsbDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbyA9IHRoaXMuX29wdGlvbnMuZGlyZWN0aW9uID09PSBcImxlZnRcIiB8fCB0aGlzLl9vcHRpb25zID09PSBcInJpZ2h0XCIgPyBcInhcIiA6IFwieVwiO1xuICAgIG5bb10uZGlyZWN0aW9uID09PSB0aGlzLl9vcHRpb25zLmRpcmVjdGlvbiAmJiBuW29dLnZhbHVlID4gdGhpcy5fb3B0aW9ucy50aHJlc2hvbGQgJiYgKGMudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBgc3dpcGUke25bb10uZGlyZWN0aW9ufWAsIHtcbiAgICAgIHRvdWNoOiB0XG4gICAgfSksIHRoaXMuX3N0YXJ0UG9zaXRpb24gPSBudWxsKTtcbiAgfVxuICBoYW5kbGVUb3VjaEVuZCgpIHtcbiAgICB0aGlzLl9zdGFydFBvc2l0aW9uID0gbnVsbDtcbiAgfVxuICBfZ2V0Q29vcmRpbmF0ZXModCkge1xuICAgIGNvbnN0IFtlXSA9IHQudG91Y2hlcztcbiAgICByZXR1cm4ge1xuICAgICAgeDogZS5jbGllbnRYLFxuICAgICAgeTogZS5jbGllbnRZXG4gICAgfTtcbiAgfVxuICBfZ2V0RGlyZWN0aW9uKHQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDoge1xuICAgICAgICBkaXJlY3Rpb246IHQueCA8IDAgPyBcImxlZnRcIiA6IFwicmlnaHRcIixcbiAgICAgICAgdmFsdWU6IE1hdGguYWJzKHQueClcbiAgICAgIH0sXG4gICAgICB5OiB7XG4gICAgICAgIGRpcmVjdGlvbjogdC55IDwgMCA/IFwidXBcIiA6IFwiZG93blwiLFxuICAgICAgICB2YWx1ZTogTWF0aC5hYnModC55KVxuICAgICAgfVxuICAgIH07XG4gIH1cbiAgX2dldENvbmZpZyh0KSB7XG4gICAgY29uc3QgZSA9IHtcbiAgICAgIC4uLkdFLFxuICAgICAgLi4uaC5nZXREYXRhQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KSxcbiAgICAgIC4uLnRcbiAgICB9O1xuICAgIHJldHVybiBEKFVFLCBlLCBYRSksIGU7XG4gIH1cbn1cbmNvbnN0IHF0ID0gXCJwYW5cIiwgWkUgPSBgJHtxdH1zdGFydGAsIFFFID0gYCR7cXR9ZW5kYCwgSkUgPSBgJHtxdH1tb3ZlYCwgdDAgPSBcImxlZnRcIiwgZTAgPSBcInJpZ2h0XCIsIGkwID0ge1xuICB0aHJlc2hvbGQ6IFwibnVtYmVyXCIsXG4gIGRpcmVjdGlvbjogXCJzdHJpbmdcIixcbiAgcG9pbnRlcnM6IFwibnVtYmVyXCJcbn0sIHMwID0ge1xuICB0aHJlc2hvbGQ6IDIwLFxuICBkaXJlY3Rpb246IFwiYWxsXCIsXG4gIHBvaW50ZXJzOiAxXG59O1xuY2xhc3MgbjAgZXh0ZW5kcyBYaSB7XG4gIGNvbnN0cnVjdG9yKHQsIGUgPSB7fSkge1xuICAgIHN1cGVyKCksIHRoaXMuX2VsZW1lbnQgPSB0LCB0aGlzLl9vcHRpb25zID0gdGhpcy5fZ2V0Q29uZmlnKGUpLCB0aGlzLl9zdGFydFRvdWNoID0gbnVsbDtcbiAgfVxuICAvLyBHZXR0ZXJzXG4gIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICByZXR1cm4gcXQ7XG4gIH1cbiAgaGFuZGxlVG91Y2hTdGFydCh0KSB7XG4gICAgdGhpcy5fc3RhcnRUb3VjaCA9IHRoaXMuX2dldENvb3JkaW5hdGVzKHQpLCB0aGlzLl9tb3ZlZFRvdWNoID0gdCwgYy50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIFpFLCB7IHRvdWNoOiB0IH0pO1xuICB9XG4gIGhhbmRsZVRvdWNoTW92ZSh0KSB7XG4gICAgdC50eXBlID09PSBcInRvdWNobW92ZVwiICYmIHQucHJldmVudERlZmF1bHQoKTtcbiAgICBjb25zdCB7IHRocmVzaG9sZDogZSwgZGlyZWN0aW9uOiBpIH0gPSB0aGlzLl9vcHRpb25zLCBuID0gdGhpcy5fZ2V0Q29vcmRpbmF0ZXModCksIG8gPSB0aGlzLl9nZXRDb29yZGluYXRlcyh0aGlzLl9tb3ZlZFRvdWNoKSwgciA9IHRoaXMuX2dldE9yaWdpbihuLCB0aGlzLl9zdGFydFRvdWNoKSwgYSA9IHRoaXMuX2dldE9yaWdpbihuLCBvKSwgbCA9IHRoaXMuX2dldERpcmVjdGlvbihyKSwgcCA9IHRoaXMuX2dldERpcmVjdGlvbihhKSwgeyB4OiB1LCB5OiBfIH0gPSBsO1xuICAgIGlmIChpID09PSBcImFsbFwiICYmIChfLnZhbHVlID4gZSB8fCB1LnZhbHVlID4gZSkpIHtcbiAgICAgIGNvbnN0IGcgPSBfLnZhbHVlID4gdS52YWx1ZSA/IF8uZGlyZWN0aW9uIDogdS5kaXJlY3Rpb247XG4gICAgICBjLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgYCR7cXR9JHtnfWAsIHsgdG91Y2g6IHQgfSksIGMudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBxdCwge1xuICAgICAgICAuLi5hLFxuICAgICAgICB0b3VjaDogdFxuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IGYgPSBpID09PSB0MCB8fCBpID09PSBlMCA/IFwieFwiIDogXCJ5XCI7XG4gICAgcFtmXS5kaXJlY3Rpb24gPT09IGkgJiYgbFtmXS52YWx1ZSA+IGUgJiYgYy50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIGAke3F0fSR7aX1gLCB7XG4gICAgICB0b3VjaDogdCxcbiAgICAgIFtmXTogbltmXSAtIG9bZl1cbiAgICB9KSwgdGhpcy5fbW92ZWRUb3VjaCA9IHQsIGMudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBKRSwgeyB0b3VjaDogdCB9KTtcbiAgfVxuICBoYW5kbGVUb3VjaEVuZCh0KSB7XG4gICAgdC50eXBlID09PSBcInRvdWNoZW5kXCIgJiYgdC5wcmV2ZW50RGVmYXVsdCgpLCB0aGlzLl9tb3ZlZFRvdWNoID0gbnVsbCwgdGhpcy5fc3RhcnRUb3VjaCA9IG51bGwsIGMudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBRRSwgeyB0b3VjaDogdCB9KTtcbiAgfVxuICBfZ2V0Q29uZmlnKHQpIHtcbiAgICBjb25zdCBlID0ge1xuICAgICAgLi4uczAsXG4gICAgICAuLi5oLmdldERhdGFBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpLFxuICAgICAgLi4udFxuICAgIH07XG4gICAgcmV0dXJuIEQocXQsIGUsIGkwKSwgZTtcbiAgfVxufVxuY29uc3QgWWUgPSBcInBpbmNoXCIsIG8wID0gYCR7WWV9ZW5kYCwgcjAgPSBgJHtZZX1zdGFydGAsIGEwID0gYCR7WWV9bW92ZWAsIGwwID0ge1xuICB0aHJlc2hvbGQ6IFwibnVtYmVyXCIsXG4gIHBvaW50ZXJzOiBcIm51bWJlclwiXG59LCBjMCA9IHtcbiAgdGhyZXNob2xkOiAxMCxcbiAgcG9pbnRlcnM6IDJcbn07XG5jbGFzcyBoMCBleHRlbmRzIFhpIHtcbiAgY29uc3RydWN0b3IodCwgZSA9IHt9KSB7XG4gICAgc3VwZXIoKSwgdGhpcy5fZWxlbWVudCA9IHQsIHRoaXMuX29wdGlvbnMgPSB0aGlzLl9nZXRDb25maWcoZSksIHRoaXMuX3N0YXJ0VG91Y2ggPSBudWxsLCB0aGlzLl9vcmlnaW4gPSBudWxsLCB0aGlzLl90b3VjaCA9IG51bGwsIHRoaXMuX21hdGggPSBudWxsLCB0aGlzLl9yYXRpbyA9IG51bGw7XG4gIH1cbiAgLy8gR2V0dGVyc1xuICBzdGF0aWMgZ2V0IE5BTUUoKSB7XG4gICAgcmV0dXJuIFllO1xuICB9XG4gIGdldCBpc051bWJlcigpIHtcbiAgICByZXR1cm4gdHlwZW9mIHRoaXMuX3N0YXJ0VG91Y2ggPT0gXCJudW1iZXJcIiAmJiB0eXBlb2YgdGhpcy5fdG91Y2ggPT0gXCJudW1iZXJcIiAmJiAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1nbG9iYWxzXG4gICAgIWlzTmFOKHRoaXMuX3N0YXJ0VG91Y2gpICYmIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLWdsb2JhbHNcbiAgICAhaXNOYU4odGhpcy5fdG91Y2gpO1xuICB9XG4gIGhhbmRsZVRvdWNoU3RhcnQodCkge1xuICAgIGlmICh0LnRvdWNoZXMubGVuZ3RoICE9PSB0aGlzLl9vcHRpb25zLnBvaW50ZXJzKVxuICAgICAgcmV0dXJuO1xuICAgIHQudHlwZSA9PT0gXCJ0b3VjaHN0YXJ0XCIgJiYgdC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGNvbnN0IFtlLCBpXSA9IHRoaXMuX2dldFBpbmNoVG91Y2hPcmlnaW4odC50b3VjaGVzKTtcbiAgICB0aGlzLl90b3VjaCA9IGUsIHRoaXMuX29yaWdpbiA9IGksIHRoaXMuX3N0YXJ0VG91Y2ggPSB0aGlzLl90b3VjaCwgYy50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIHIwLCB7XG4gICAgICB0b3VjaDogdCxcbiAgICAgIHJhdGlvOiB0aGlzLl9yYXRpbyxcbiAgICAgIG9yaWdpbjogdGhpcy5fb3JpZ2luXG4gICAgfSk7XG4gIH1cbiAgaGFuZGxlVG91Y2hNb3ZlKHQpIHtcbiAgICBjb25zdCB7IHRocmVzaG9sZDogZSwgcG9pbnRlcnM6IGkgfSA9IHRoaXMuX29wdGlvbnM7XG4gICAgdC50b3VjaGVzLmxlbmd0aCA9PT0gaSAmJiAodC50eXBlID09PSBcInRvdWNobW92ZVwiICYmIHQucHJldmVudERlZmF1bHQoKSwgdGhpcy5fdG91Y2ggPSB0aGlzLl9nZXRQaW5jaFRvdWNoT3JpZ2luKHQudG91Y2hlcylbMF0sIHRoaXMuX3JhdGlvID0gdGhpcy5fdG91Y2ggLyB0aGlzLl9zdGFydFRvdWNoLCB0aGlzLmlzTnVtYmVyICYmICh0aGlzLl9vcmlnaW4ueCA+IGUgfHwgdGhpcy5fb3JpZ2luLnkgPiBlKSAmJiAodGhpcy5fc3RhcnRUb3VjaCA9IHRoaXMuX3RvdWNoLCBjLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgWWUsIHtcbiAgICAgIHRvdWNoOiB0LFxuICAgICAgcmF0aW86IHRoaXMuX3JhdGlvLFxuICAgICAgb3JpZ2luOiB0aGlzLl9vcmlnaW5cbiAgICB9KSwgYy50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIGEwLCB7XG4gICAgICB0b3VjaDogdCxcbiAgICAgIHJhdGlvOiB0aGlzLl9yYXRpbyxcbiAgICAgIG9yaWdpbjogdGhpcy5fb3JpZ2luXG4gICAgfSkpKTtcbiAgfVxuICBoYW5kbGVUb3VjaEVuZCh0KSB7XG4gICAgdGhpcy5pc051bWJlciAmJiAodGhpcy5fc3RhcnRUb3VjaCA9IG51bGwsIGMudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBvMCwge1xuICAgICAgdG91Y2g6IHQsXG4gICAgICByYXRpbzogdGhpcy5fcmF0aW8sXG4gICAgICBvcmlnaW46IHRoaXMuX29yaWdpblxuICAgIH0pKTtcbiAgfVxuICBfZ2V0Q29uZmlnKHQpIHtcbiAgICBjb25zdCBlID0ge1xuICAgICAgLi4uYzAsXG4gICAgICAuLi5oLmdldERhdGFBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpLFxuICAgICAgLi4udFxuICAgIH07XG4gICAgcmV0dXJuIEQoWWUsIGUsIGwwKSwgZTtcbiAgfVxufVxuY29uc3QgeW8gPSBcInRhcFwiLCBkMCA9IHtcbiAgaW50ZXJ2YWw6IFwibnVtYmVyXCIsXG4gIHRpbWU6IFwibnVtYmVyXCIsXG4gIHRhcHM6IFwibnVtYmVyXCIsXG4gIHBvaW50ZXJzOiBcIm51bWJlclwiXG59LCB1MCA9IHtcbiAgaW50ZXJ2YWw6IDUwMCxcbiAgdGltZTogMjUwLFxuICB0YXBzOiAxLFxuICBwb2ludGVyczogMVxufTtcbmNsYXNzIHAwIGV4dGVuZHMgWGkge1xuICBjb25zdHJ1Y3Rvcih0LCBlKSB7XG4gICAgc3VwZXIoKSwgdGhpcy5fZWxlbWVudCA9IHQsIHRoaXMuX29wdGlvbnMgPSB0aGlzLl9nZXRDb25maWcoZSksIHRoaXMuX3RpbWVyID0gbnVsbCwgdGhpcy5fdGFwQ291bnQgPSAwO1xuICB9XG4gIC8vIEdldHRlcnNcbiAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgIHJldHVybiB5bztcbiAgfVxuICBoYW5kbGVUb3VjaFN0YXJ0KHQpIHtcbiAgICBjb25zdCB7IHg6IGUsIHk6IGkgfSA9IHRoaXMuX2dldENvb3JkaW5hdGVzKHQpLCB7IGludGVydmFsOiBuLCB0YXBzOiBvLCBwb2ludGVyczogciB9ID0gdGhpcy5fb3B0aW9ucztcbiAgICByZXR1cm4gdC50b3VjaGVzLmxlbmd0aCA9PT0gciAmJiAodGhpcy5fdGFwQ291bnQgKz0gMSwgdGhpcy5fdGFwQ291bnQgPT09IDEgJiYgKHRoaXMuX3RpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLl90YXBDb3VudCA9IDA7XG4gICAgfSwgbikpLCB0aGlzLl90YXBDb3VudCA9PT0gbyAmJiAoY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVyKSwgdGhpcy5fdGFwQ291bnQgPSAwLCBjLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgeW8sIHtcbiAgICAgIHRvdWNoOiB0LFxuICAgICAgb3JpZ2luOiB7XG4gICAgICAgIHg6IGUsXG4gICAgICAgIHk6IGlcbiAgICAgIH1cbiAgICB9KSkpLCB0O1xuICB9XG4gIGhhbmRsZVRvdWNoRW5kKCkge1xuICB9XG4gIGhhbmRsZVRvdWNoTW92ZSgpIHtcbiAgfVxuICBfZ2V0Q29uZmlnKHQpIHtcbiAgICBjb25zdCBlID0ge1xuICAgICAgLi4udTAsXG4gICAgICAuLi5oLmdldERhdGFBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpLFxuICAgICAgLi4udFxuICAgIH07XG4gICAgcmV0dXJuIEQoeW8sIGUsIGQwKSwgZTtcbiAgfVxufVxuY29uc3QgTWkgPSBcInJvdGF0ZVwiLCBfMCA9IGAke01pfWVuZGAsIGYwID0gYCR7TWl9c3RhcnRgLCBtMCA9IHtcbiAgYW5nbGU6IFwibnVtYmVyXCIsXG4gIHBvaW50ZXJzOiBcIm51bWJlclwiXG59LCBnMCA9IHtcbiAgYW5nbGU6IDAsXG4gIHBvaW50ZXJzOiAyXG59O1xuY2xhc3MgYjAgZXh0ZW5kcyBYaSB7XG4gIGNvbnN0cnVjdG9yKHQsIGUpIHtcbiAgICBzdXBlcigpLCB0aGlzLl9lbGVtZW50ID0gdCwgdGhpcy5fb3B0aW9ucyA9IHRoaXMuX2dldENvbmZpZyhlKSwgdGhpcy5fb3JpZ2luID0ge307XG4gIH1cbiAgLy8gR2V0dGVyc1xuICBzdGF0aWMgZ2V0IE5BTUUoKSB7XG4gICAgcmV0dXJuIE1pO1xuICB9XG4gIGhhbmRsZVRvdWNoU3RhcnQodCkge1xuICAgIHQudHlwZSA9PT0gXCJ0b3VjaHN0YXJ0XCIgJiYgdC5wcmV2ZW50RGVmYXVsdCgpLCAhKHQudG91Y2hlcy5sZW5ndGggPCAyKSAmJiAodGhpcy5fc3RhcnRUb3VjaCA9IHQsIHRoaXMuX29yaWdpbiA9IHt9LCBjLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgZjAsIHsgdG91Y2g6IHQgfSkpO1xuICB9XG4gIGhhbmRsZVRvdWNoTW92ZSh0KSB7XG4gICAgdC50eXBlID09PSBcInRvdWNobW92ZVwiICYmIHQucHJldmVudERlZmF1bHQoKTtcbiAgICBsZXQgZSwgaTtcbiAgICBjb25zdCBuID0gdC50b3VjaGVzO1xuICAgIGlmIChuLmxlbmd0aCA9PT0gMSAmJiB0aGlzLl9vcHRpb25zLnBvaW50ZXJzID09PSAxKSB7XG4gICAgICBjb25zdCB7IGxlZnQ6IG8sIHRvcDogciwgd2lkdGg6IGEsIGhlaWdodDogbCB9ID0gdGhpcy5fZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIGUgPSB7XG4gICAgICAgIHg6IG8gKyBhIC8gMixcbiAgICAgICAgeTogciArIGwgLyAyXG4gICAgICB9LCBpID0gblswXTtcbiAgICB9IGVsc2UgaWYgKHQudG91Y2hlcy5sZW5ndGggPT09IDIgJiYgdGhpcy5fb3B0aW9ucy5wb2ludGVycyA9PT0gMikge1xuICAgICAgY29uc3QgW28sIHJdID0gdC50b3VjaGVzLCBhID0ge1xuICAgICAgICB4MTogci5jbGllbnRYLFxuICAgICAgICB4Mjogby5jbGllbnRYLFxuICAgICAgICB5MTogci5jbGllbnRZLFxuICAgICAgICB5Mjogby5jbGllbnRZXG4gICAgICB9O1xuICAgICAgZSA9IHRoaXMuX2dldE1pZFBvaW50KGEpLCBpID0gdGhpcy5fZ2V0UmlnaHRNb3N0VG91Y2godC50b3VjaGVzKTtcbiAgICB9IGVsc2VcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLmN1cnJlbnRBbmdsZSA9IHRoaXMuX2dldEFuZ2xlKFxuICAgICAgZS54LFxuICAgICAgZS55LFxuICAgICAgaS5jbGllbnRYLFxuICAgICAgaS5jbGllbnRZXG4gICAgKSwgdGhpcy5fb3JpZ2luLmluaXRpYWxBbmdsZSA/ICh0aGlzLl9vcmlnaW4uY2hhbmdlID0gdGhpcy5fZ2V0QW5ndWxhckRpc3RhbmNlKFxuICAgICAgdGhpcy5fb3JpZ2luLnByZXZpb3VzQW5nbGUsXG4gICAgICB0aGlzLmN1cnJlbnRBbmdsZVxuICAgICksIHRoaXMuX29yaWdpbi5kaXN0YW5jZSArPSB0aGlzLl9vcmlnaW4uY2hhbmdlKSA6ICh0aGlzLl9vcmlnaW4uaW5pdGlhbEFuZ2xlID0gdGhpcy5fb3JpZ2luLnByZXZpb3VzQW5nbGUgPSB0aGlzLmN1cnJlbnRBbmdsZSwgdGhpcy5fb3JpZ2luLmRpc3RhbmNlID0gdGhpcy5fb3JpZ2luLmNoYW5nZSA9IDApLCB0aGlzLl9vcmlnaW4ucHJldmlvdXNBbmdsZSA9IHRoaXMuY3VycmVudEFuZ2xlLCB0aGlzLnJvdGF0ZSA9IHtcbiAgICAgIGN1cnJlbnRBbmdsZTogdGhpcy5jdXJyZW50QW5nbGUsXG4gICAgICBkaXN0YW5jZTogdGhpcy5fb3JpZ2luLmRpc3RhbmNlLFxuICAgICAgY2hhbmdlOiB0aGlzLl9vcmlnaW4uY2hhbmdlXG4gICAgfSwgYy50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIE1pLCB7IC4uLnRoaXMucm90YXRlLCB0b3VjaDogdCB9KTtcbiAgfVxuICBoYW5kbGVUb3VjaEVuZCh0KSB7XG4gICAgdC50eXBlID09PSBcInRvdWNoZW5kXCIgJiYgdC5wcmV2ZW50RGVmYXVsdCgpLCB0aGlzLl9vcmlnaW4gPSB7fSwgYy50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIF8wLCB7IHRvdWNoOiB0IH0pO1xuICB9XG4gIF9nZXRDb25maWcodCkge1xuICAgIGNvbnN0IGUgPSB7XG4gICAgICAuLi5nMCxcbiAgICAgIC4uLmguZ2V0RGF0YUF0dHJpYnV0ZXModGhpcy5fZWxlbWVudCksXG4gICAgICAuLi50XG4gICAgfTtcbiAgICByZXR1cm4gRChNaSwgZSwgbTApLCBlO1xuICB9XG59XG5jb25zdCBLbyA9IFwidG91Y2hcIiwgd28gPSBgdGUuJHtLb31gLCB2MCA9IHtcbiAgZXZlbnQ6IFwic3RyaW5nXCJcbn0sIFQwID0ge1xuICBldmVudDogXCJzd2lwZVwiXG59O1xuY2xhc3MgQWgge1xuICBjb25zdHJ1Y3Rvcih0LCBlID0ge30pIHtcbiAgICB0aGlzLl9lbGVtZW50ID0gdCwgdGhpcy5fb3B0aW9ucyA9IHRoaXMuX2dldENvbmZpZyhlKSwgdGhpcy5fZXZlbnQgPSB0aGlzLl9vcHRpb25zLmV2ZW50LCB0aGlzLnN3aXBlID0gdGhpcy5fZXZlbnQgPT09IFwic3dpcGVcIiA/IG5ldyBxRSh0LCBlKSA6IG51bGwsIHRoaXMucHJlc3MgPSB0aGlzLl9ldmVudCA9PT0gXCJwcmVzc1wiID8gbmV3IHpFKHQsIGUpIDogbnVsbCwgdGhpcy5wYW4gPSB0aGlzLl9ldmVudCA9PT0gXCJwYW5cIiA/IG5ldyBuMCh0LCBlKSA6IG51bGwsIHRoaXMucGluY2ggPSB0aGlzLl9ldmVudCA9PT0gXCJwaW5jaFwiID8gbmV3IGgwKHQsIGUpIDogbnVsbCwgdGhpcy50YXAgPSB0aGlzLl9ldmVudCA9PT0gXCJ0YXBcIiA/IG5ldyBwMCh0LCBlKSA6IG51bGwsIHRoaXMucm90YXRlID0gdGhpcy5fZXZlbnQgPT09IFwicm90YXRlXCIgPyBuZXcgYjAodCwgZSkgOiBudWxsLCB0aGlzLl90b3VjaFN0YXJ0SGFuZGxlciA9IChpKSA9PiB0aGlzLl9oYW5kbGVUb3VjaFN0YXJ0KGkpLCB0aGlzLl90b3VjaE1vdmVIYW5kbGVyID0gKGkpID0+IHRoaXMuX2hhbmRsZVRvdWNoTW92ZShpKSwgdGhpcy5fdG91Y2hFbmRIYW5kbGVyID0gKGkpID0+IHRoaXMuX2hhbmRsZVRvdWNoRW5kKGkpLCBjLm9uKHRoaXMuX2VsZW1lbnQsIFwidG91Y2hzdGFydFwiLCB0aGlzLl90b3VjaFN0YXJ0SGFuZGxlciksIGMub24odGhpcy5fZWxlbWVudCwgXCJ0b3VjaG1vdmVcIiwgdGhpcy5fdG91Y2hNb3ZlSGFuZGxlciksIGMub24odGhpcy5fZWxlbWVudCwgXCJ0b3VjaGVuZFwiLCB0aGlzLl90b3VjaEVuZEhhbmRsZXIpLCB0aGlzLl9lbGVtZW50ICYmIHkuc2V0RGF0YSh0LCB3bywgdGhpcyk7XG4gIH1cbiAgLy8gR2V0dGVyc1xuICBzdGF0aWMgZ2V0IE5BTUUoKSB7XG4gICAgcmV0dXJuIEtvO1xuICB9XG4gIGRpc3Bvc2UoKSB7XG4gICAgYy5vZmYodGhpcy5fZWxlbWVudCwgXCJ0b3VjaHN0YXJ0XCIsIHRoaXMuX3RvdWNoU3RhcnRIYW5kbGVyKSwgYy5vZmYodGhpcy5fZWxlbWVudCwgXCJ0b3VjaG1vdmVcIiwgdGhpcy5fdG91Y2hNb3ZlSGFuZGxlciksIGMub2ZmKHRoaXMuX2VsZW1lbnQsIFwidG91Y2hlbmRcIiwgdGhpcy5fdG91Y2hFbmRIYW5kbGVyKSwgdGhpcy5zd2lwZSA9IG51bGwsIHRoaXMucHJlc3MgPSBudWxsLCB0aGlzLnBhbiA9IG51bGwsIHRoaXMucGluY2ggPSBudWxsLCB0aGlzLnRhcCA9IG51bGwsIHRoaXMucm90YXRlID0gbnVsbDtcbiAgfVxuICBfZ2V0Q29uZmlnKHQpIHtcbiAgICBjb25zdCBlID0ge1xuICAgICAgLi4uVDAsXG4gICAgICAuLi5oLmdldERhdGFBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpLFxuICAgICAgLi4udFxuICAgIH07XG4gICAgcmV0dXJuIEQoS28sIGUsIHYwKSwgZTtcbiAgfVxuICBfaGFuZGxlVG91Y2hTdGFydCh0KSB7XG4gICAgdGhpc1t0aGlzLl9ldmVudF0uaGFuZGxlVG91Y2hTdGFydCh0KTtcbiAgfVxuICBfaGFuZGxlVG91Y2hNb3ZlKHQpIHtcbiAgICB0aGlzW3RoaXMuX2V2ZW50XS5oYW5kbGVUb3VjaE1vdmUgJiYgdGhpc1t0aGlzLl9ldmVudF0uaGFuZGxlVG91Y2hNb3ZlKHQpO1xuICB9XG4gIF9oYW5kbGVUb3VjaEVuZCh0KSB7XG4gICAgdGhpc1t0aGlzLl9ldmVudF0uaGFuZGxlVG91Y2hFbmQodCk7XG4gIH1cbiAgc3RhdGljIGpRdWVyeUludGVyZmFjZSh0KSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgIGxldCBlID0geS5nZXREYXRhKHRoaXMsIHdvKTtcbiAgICAgIGNvbnN0IGkgPSB0eXBlb2YgdCA9PSBcIm9iamVjdFwiICYmIHQ7XG4gICAgICBpZiAoISghZSAmJiAvZGlzcG9zZS8udGVzdCh0KSkgJiYgKGUgfHwgKGUgPSBuZXcgQWgodGhpcywgaSkpLCB0eXBlb2YgdCA9PSBcInN0cmluZ1wiKSkge1xuICAgICAgICBpZiAodHlwZW9mIGVbdF0gPiBcInVcIilcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBObyBtZXRob2QgbmFtZWQgXCIke3R9XCJgKTtcbiAgICAgICAgcmV0dXJuIGVbdF07XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgc3RhdGljIGdldEluc3RhbmNlKHQpIHtcbiAgICByZXR1cm4geS5nZXREYXRhKHQsIHdvKTtcbiAgfVxuICBzdGF0aWMgZ2V0T3JDcmVhdGVJbnN0YW5jZSh0LCBlID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5nZXRJbnN0YW5jZSh0KSB8fCBuZXcgdGhpcyh0LCB0eXBlb2YgZSA9PSBcIm9iamVjdFwiID8gZSA6IG51bGwpO1xuICB9XG59XG5jb25zdCB6byA9IFwic21vb3RoU2Nyb2xsXCIsIHlpID0gYHRlLiR7em99YCwgbXIgPSBgLiR7eWl9YCwgRTAgPSB7XG4gIGNvbnRhaW5lcjogXCJzdHJpbmdcIixcbiAgb2Zmc2V0OiBcIm51bWJlclwiLFxuICBlYXNpbmc6IFwic3RyaW5nXCIsXG4gIGR1cmF0aW9uOiBcIm51bWJlclwiXG59LCBDMCA9IHtcbiAgY29udGFpbmVyOiBcImJvZHlcIixcbiAgb2Zmc2V0OiAwLFxuICBlYXNpbmc6IFwibGluZWFyXCIsXG4gIGR1cmF0aW9uOiA1MDBcbn0sIEEwID0gYHNjcm9sbFN0YXJ0JHttcn1gLCB5MCA9IGBzY3JvbGxFbmQke21yfWAsIHcwID0gYHNjcm9sbENhbmNlbCR7bXJ9YDtcbmNsYXNzIHloIHtcbiAgY29uc3RydWN0b3IodCwgZSA9IHt9KSB7XG4gICAgdGhpcy5fZWxlbWVudCA9IHQsIHRoaXMuX29wdGlvbnMgPSB0aGlzLl9nZXRDb25maWcoZSksIHRoaXMuX2hyZWYgPSB0aGlzLl9lbGVtZW50LmdldEF0dHJpYnV0ZShcImhyZWZcIiksIHRoaXMuaXNDYW5jZWwgPSAhMSwgdGhpcy5fZWxlbWVudCAmJiAoeS5zZXREYXRhKHQsIHlpLCB0aGlzKSwgdGhpcy5fc2V0dXAoKSk7XG4gIH1cbiAgLy8gZ2V0dGVyc1xuICBzdGF0aWMgZ2V0IE5BTUUoKSB7XG4gICAgcmV0dXJuIHpvO1xuICB9XG4gIGdldCBpc1dpbmRvdygpIHtcbiAgICByZXR1cm4gdGhpcy5fb3B0aW9ucy5jb250YWluZXIgPT09IFwiYm9keVwiO1xuICB9XG4gIGdldCBjb250YWluZXJUb1Njcm9sbCgpIHtcbiAgICByZXR1cm4gdGhpcy5pc1dpbmRvdyA/IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCA6IGQuZmluZE9uZShcbiAgICAgIHRoaXMuX29wdGlvbnMuY29udGFpbmVyLFxuICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50XG4gICAgKTtcbiAgfVxuICBnZXQgZWxGcm9tSHJlZkV4aXN0KCkge1xuICAgIHJldHVybiAhIWQuZmluZE9uZSh0aGlzLl9ocmVmLCB0aGlzLmNvbnRhaW5lclRvU2Nyb2xsKTtcbiAgfVxuICBnZXQgb2Zmc2V0RnJvbUVsKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLmNvbnRhaW5lclRvU2Nyb2xsLnNjcm9sbFRvcCwgZSA9IGQuZmluZE9uZSh0aGlzLl9ocmVmLCB0aGlzLmNvbnRhaW5lclRvU2Nyb2xsKTtcbiAgICBpZiAodGhpcy5pc1dpbmRvdylcbiAgICAgIHJldHVybiBoLm9mZnNldChlKS50b3AgLSB0aGlzLl9vcHRpb25zLm9mZnNldCArIHQ7XG4gICAgY29uc3QgaSA9IGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkueSwgbiA9IHRoaXMuY29udGFpbmVyVG9TY3JvbGwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkueTtcbiAgICByZXR1cm4gaSAtIG4gLSB0aGlzLl9vcHRpb25zLm9mZnNldCArIHQ7XG4gIH1cbiAgZ2V0IGVhc2luZ0Z1bmN0aW9uKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLl9vcHRpb25zLmVhc2luZywgZSA9IGBfbW90aW9uJHt0WzBdLnRvVXBwZXJDYXNlKCl9JHt0LnNsaWNlKDEpfWA7XG4gICAgcmV0dXJuIHRoaXNbZV0gPyB0aGlzW2VdIDogdGhpcy5fbW90aW9uTGluZWFyO1xuICB9XG4gIC8vIHB1YmxpY1xuICBkaXNwb3NlKCkge1xuICAgIGMub2ZmKHRoaXMuX2VsZW1lbnQsIFwiY2xpY2tcIiwgdGhpcy5faGFuZGxlQ2xpY2spLCB5LnJlbW92ZURhdGEodGhpcy5fZWxlbWVudCwgeWkpLCB0aGlzLl9lbGVtZW50ID0gbnVsbDtcbiAgfVxuICBjYW5jZWxTY3JvbGwoKSB7XG4gICAgdGhpcy5pc0NhbmNlbCA9ICEwO1xuICB9XG4gIC8vIHByaXZhdGVcbiAgX2dldENvbmZpZyh0KSB7XG4gICAgY29uc3QgZSA9IHtcbiAgICAgIC4uLkMwLFxuICAgICAgLi4uaC5nZXREYXRhQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KSxcbiAgICAgIC4uLnRcbiAgICB9O1xuICAgIHJldHVybiBEKHpvLCBlLCBFMCksIGU7XG4gIH1cbiAgX2luVmlld3BvcnQoKSB7XG4gICAgaWYgKHRoaXMuaXNXaW5kb3cpXG4gICAgICByZXR1cm4gITA7XG4gICAgY29uc3QgdCA9IHRoaXMuY29udGFpbmVyVG9TY3JvbGwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgcmV0dXJuIHQudG9wID49IDAgJiYgdC5ib3R0b20gPD0gKHdpbmRvdy5pbm5lckhlaWdodCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0KTtcbiAgfVxuICBfc2V0dXAoKSB7XG4gICAgY29uc3QgdCA9IHR5cGVvZiB0aGlzLl9ocmVmIDwgXCJ1XCIsIGUgPSB0aGlzLl9ocmVmLmluY2x1ZGVzKFwiI1wiKTtcbiAgICB0ICYmIGUgJiYgdGhpcy5lbEZyb21IcmVmRXhpc3QgJiYgKHRoaXMuX3Njcm9sbE9uQ2xpY2tFdmVudCgpLCB0aGlzLl9wcmV2ZW50TmF0aXZlU2Nyb2xsKCkpO1xuICB9XG4gIF9zY3JvbGxPbkNsaWNrRXZlbnQoKSB7XG4gICAgYy5vbih0aGlzLl9lbGVtZW50LCBcImNsaWNrXCIsICh0KSA9PiB7XG4gICAgICB0aGlzLl9oYW5kbGVDbGljayh0KTtcbiAgICB9KTtcbiAgfVxuICBfaGFuZGxlQ2xpY2sodCkge1xuICAgIHQucHJldmVudERlZmF1bHQoKSwgdGhpcy5pc0NhbmNlbCA9ICExLCBjLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgQTApO1xuICAgIGNvbnN0IGUgPSB0aGlzLmNvbnRhaW5lclRvU2Nyb2xsLCBpID0gdGhpcy5jb250YWluZXJUb1Njcm9sbC5zY3JvbGxUb3AsIG4gPSB0aGlzLm9mZnNldEZyb21FbCwgbyA9IDAsIHIgPSAxIC8gdGhpcy5fb3B0aW9ucy5kdXJhdGlvbiwgYSA9IDQuMjUsIGwgPSB0aGlzLmVhc2luZ0Z1bmN0aW9uO1xuICAgIHRoaXMuX2luVmlld3BvcnQoKSA/IHRoaXMuX3Njcm9sbE9uTmV4dFRpY2soXG4gICAgICBlLFxuICAgICAgaSxcbiAgICAgIG4sXG4gICAgICBvLFxuICAgICAgcixcbiAgICAgIGEsXG4gICAgICBsXG4gICAgKSA6ICh0aGlzLl9zY3JvbGxPbk5leHRUaWNrKFxuICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LFxuICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcCxcbiAgICAgIHRoaXMuY29udGFpbmVyVG9TY3JvbGwub2Zmc2V0VG9wLFxuICAgICAgbyxcbiAgICAgIHIsXG4gICAgICBhLFxuICAgICAgbFxuICAgICksIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5fc2Nyb2xsT25OZXh0VGljayhcbiAgICAgICAgZSxcbiAgICAgICAgaSxcbiAgICAgICAgbixcbiAgICAgICAgbyxcbiAgICAgICAgcixcbiAgICAgICAgYSxcbiAgICAgICAgbFxuICAgICAgKSwgdGhpcy5pc0NhbmNlbCA9ICExO1xuICAgIH0sIHRoaXMuX29wdGlvbnMuZHVyYXRpb24pKTtcbiAgfVxuICBfc2Nyb2xsT25OZXh0VGljayh0LCBlLCBpLCBuLCBvLCByLCBhKSB7XG4gICAgY29uc3QgbCA9IG4gPCAwLCBwID0gbiA+IDEsIHUgPSBvIDw9IDA7XG4gICAgaWYgKGwgfHwgcCB8fCB1IHx8IHRoaXMuaXNDYW5jZWwpIHtcbiAgICAgIGlmICh0aGlzLmlzQ2FuY2VsKSB7XG4gICAgICAgIHRoaXMuaXNJblZpZXdwb3J0ICYmICh0aGlzLmlzQ2FuY2VsID0gITEpLCBjLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgdzApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgeTApLCB0LnNjcm9sbFRvcCA9IGk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHQuc2Nyb2xsVG8oe1xuICAgICAgdG9wOiBlIC0gKGUgLSBpKSAqIGEobilcbiAgICB9KSwgbiArPSBvICogciwgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLl9zY3JvbGxPbk5leHRUaWNrKFxuICAgICAgICB0LFxuICAgICAgICBlLFxuICAgICAgICBpLFxuICAgICAgICBuLFxuICAgICAgICBvLFxuICAgICAgICByLFxuICAgICAgICBhXG4gICAgICApO1xuICAgIH0pO1xuICB9XG4gIF9wcmV2ZW50RGVmYXVsdCh0KSB7XG4gICAgdC5wcmV2ZW50RGVmYXVsdCgpO1xuICB9XG4gIF9wcmV2ZW50TmF0aXZlU2Nyb2xsKCkge1xuICAgIGxldCB0ID0gITE7XG4gICAgdHJ5IHtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgICBcInRlc3RcIixcbiAgICAgICAgbnVsbCxcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCBcInBhc3NpdmVcIiwge1xuICAgICAgICAgIGdldDogKCkgPT4gdCA9ICEwXG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH0gY2F0Y2ggKG4pIHtcbiAgICAgIHRoaXMuX3Njcm9sbEVycm9yID0gbjtcbiAgICB9XG4gICAgY29uc3QgZSA9IHQgPyB7IHBhc3NpdmU6ICExIH0gOiAhMSwgaSA9IFwib253aGVlbFwiIGluICQoXCJkaXZcIikgPyBcIndoZWVsXCIgOiBcIm1vdXNld2hlZWxcIjtcbiAgICB0aGlzLmlzV2luZG93ICYmICh0aGlzLl9kZWxldGVTY3JvbGxPblN0YXJ0KGUsIGkpLCB0aGlzLl9hZGRTY3JvbGxPbkVuZChlLCBpKSwgdGhpcy5fYWRkU2Nyb2xsT25DYW5jZWwoZSwgaSkpO1xuICB9XG4gIF9kZWxldGVTY3JvbGxPblN0YXJ0KHQsIGUpIHtcbiAgICBjLm9uKHRoaXMuX2VsZW1lbnQsIFwic2Nyb2xsU3RhcnQudGUuc21vb3RoU2Nyb2xsXCIsICgpID0+IHtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKGUsIHRoaXMuX3ByZXZlbnREZWZhdWx0LCB0KSwgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaG1vdmVcIiwgdGhpcy5fcHJldmVudERlZmF1bHQsIHQpO1xuICAgIH0pO1xuICB9XG4gIF9hZGRTY3JvbGxPbkVuZCh0LCBlKSB7XG4gICAgYy5vbih0aGlzLl9lbGVtZW50LCBcInNjcm9sbEVuZC50ZS5zbW9vdGhTY3JvbGxcIiwgKCkgPT4ge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoZSwgdGhpcy5fcHJldmVudERlZmF1bHQsIHQpLCB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNobW92ZVwiLCB0aGlzLl9wcmV2ZW50RGVmYXVsdCwgdCk7XG4gICAgfSk7XG4gIH1cbiAgX2FkZFNjcm9sbE9uQ2FuY2VsKHQsIGUpIHtcbiAgICBjLm9uKHRoaXMuX2VsZW1lbnQsIFwic2Nyb2xsQ2FuY2VsLnRlLnNtb290aFNjcm9sbFwiLCAoKSA9PiB7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihlLCB0aGlzLl9wcmV2ZW50RGVmYXVsdCwgdCksIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2htb3ZlXCIsIHRoaXMuX3ByZXZlbnREZWZhdWx0LCB0KTtcbiAgICB9KTtcbiAgfVxuICAvLyBNb3Rpb25zXG4gIC8vIExpbmVhclxuICBfbW90aW9uTGluZWFyKHQpIHtcbiAgICByZXR1cm4gdDtcbiAgfVxuICAvLyBFYXNlLUluXG4gIF9tb3Rpb25FYXNlSW5RdWFkKHQpIHtcbiAgICByZXR1cm4gdCAqIHQ7XG4gIH1cbiAgX21vdGlvbkVhc2VJbkN1YmljKHQpIHtcbiAgICByZXR1cm4gdCAqIHQgKiB0O1xuICB9XG4gIF9tb3Rpb25FYXNlSW5RdWFydCh0KSB7XG4gICAgcmV0dXJuIHQgKiB0ICogdCAqIHQ7XG4gIH1cbiAgX21vdGlvbkVhc2VJblF1aW50KHQpIHtcbiAgICByZXR1cm4gdCAqIHQgKiB0ICogdCAqIHQ7XG4gIH1cbiAgLy8gRWFzZS1Jbi1PdXRcbiAgX21vdGlvbkVhc2VJbk91dFF1YWQodCkge1xuICAgIHJldHVybiB0IDwgMC41ID8gMiAqIHQgKiB0IDogLTEgKyAoNCAtIDIgKiB0KSAqIHQ7XG4gIH1cbiAgX21vdGlvbkVhc2VJbk91dEN1YmljKHQpIHtcbiAgICByZXR1cm4gdCAvPSAwLjUsIHQgPCAxID8gdCAqIHQgKiB0IC8gMiA6ICh0IC09IDIsICh0ICogdCAqIHQgKyAyKSAvIDIpO1xuICB9XG4gIF9tb3Rpb25FYXNlSW5PdXRRdWFydCh0KSB7XG4gICAgcmV0dXJuIHQgLz0gMC41LCB0IDwgMSA/IDAuNSAqIHQgKiB0ICogdCAqIHQgOiAodCAtPSAyLCAtKHQgKiB0ICogdCAqIHQgLSAyKSAvIDIpO1xuICB9XG4gIF9tb3Rpb25FYXNlSW5PdXRRdWludCh0KSB7XG4gICAgcmV0dXJuIHQgLz0gMC41LCB0IDwgMSA/IHQgKiB0ICogdCAqIHQgKiB0IC8gMiA6ICh0IC09IDIsICh0ICogdCAqIHQgKiB0ICogdCArIDIpIC8gMik7XG4gIH1cbiAgLy8gRWFzZS1PdXRcbiAgX21vdGlvbkVhc2VPdXRRdWFkKHQpIHtcbiAgICByZXR1cm4gLXQgKiAodCAtIDIpO1xuICB9XG4gIF9tb3Rpb25FYXNlT3V0Q3ViaWModCkge1xuICAgIHJldHVybiB0LS0sIHQgKiB0ICogdCArIDE7XG4gIH1cbiAgX21vdGlvbkVhc2VPdXRRdWFydCh0KSB7XG4gICAgcmV0dXJuIHQtLSwgLSh0ICogdCAqIHQgKiB0IC0gMSk7XG4gIH1cbiAgX21vdGlvbkVhc2VPdXRRdWludCh0KSB7XG4gICAgcmV0dXJuIHQtLSwgdCAqIHQgKiB0ICogdCAqIHQgKyAxO1xuICB9XG4gIC8vIHN0YXRpY1xuICBzdGF0aWMgZ2V0SW5zdGFuY2UodCkge1xuICAgIHJldHVybiB5LmdldERhdGEodCwgeWkpO1xuICB9XG4gIHN0YXRpYyBnZXRPckNyZWF0ZUluc3RhbmNlKHQsIGUgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLmdldEluc3RhbmNlKHQpIHx8IG5ldyB0aGlzKHQsIHR5cGVvZiBlID09IFwib2JqZWN0XCIgPyBlIDogbnVsbCk7XG4gIH1cbiAgc3RhdGljIGpRdWVyeUludGVyZmFjZSh0KSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgIGxldCBlID0geS5nZXREYXRhKHRoaXMsIHlpKTtcbiAgICAgIGNvbnN0IGkgPSB0eXBlb2YgdCA9PSBcIm9iamVjdFwiICYmIHQ7XG4gICAgICBpZiAoZSB8fCAoZSA9IG5ldyB5aCh0aGlzLCBpKSksIHR5cGVvZiB0ID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBlW3RdID4gXCJ1XCIpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFwiJHt0fVwiYCk7XG4gICAgICAgIGVbdF0odGhpcyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cbmNvbnN0IEJsID0gXCJsYXp5TG9hZFwiLCAkcyA9IFwidGUubGF6eUxvYWRcIiwgazAgPSBcIltkYXRhLXRlLWxhenktbG9hZC1pbml0XVwiLCBIbCA9IFwiZGF0YS10ZS1sYXp5LWxvYWRcIiwgeDAgPSBcIm9uTG9hZC50ZS5sYXp5XCIsIE8wID0gXCJvbkVycm9yLnRlLmxhenlcIiwgVmwgPSBbXCJpbWdcIiwgXCJ2aWRlb1wiXSwgUzAgPSB7XG4gIGxhenlTcmM6IFwiKHN0cmluZ3xudWxsKVwiLFxuICBsYXp5RGVsYXk6IFwibnVtYmVyXCIsXG4gIGxhenlBbmltYXRpb246IFwic3RyaW5nXCIsXG4gIGxhenlPZmZzZXQ6IFwibnVtYmVyXCIsXG4gIGxhenlQbGFjZWhvbGRlcjogXCIoc3RyaW5nfHVuZGVmaW5lZClcIixcbiAgbGF6eUVycm9yOiBcIihzdHJpbmd8dW5kZWZpbmVkKVwiXG59LCBJMCA9IHtcbiAgbGF6eVNyYzogbnVsbCxcbiAgbGF6eURlbGF5OiA1MDAsXG4gIGxhenlBbmltYXRpb246IFwiW2ZhZGUtaW5fMXNfZWFzZS1pbi1vdXRdXCIsXG4gIGxhenlPZmZzZXQ6IDBcbn07XG5jbGFzcyBVbyB7XG4gIGNvbnN0cnVjdG9yKHQsIGUpIHtcbiAgICB0aGlzLl9lbGVtZW50ID0gdCwgdGhpcy5fZWxlbWVudCAmJiB5LnNldERhdGEodCwgJHMsIHRoaXMpLCB0aGlzLl9vcHRpb25zID0gdGhpcy5fZ2V0Q29uZmlnKGUpLCB0aGlzLnNjcm9sbEhhbmRsZXIgPSB0aGlzLl9zY3JvbGxIYW5kbGVyLmJpbmQodGhpcyksIHRoaXMuZXJyb3JIYW5kbGVyID0gdGhpcy5fc2V0RWxlbWVudEVycm9yLmJpbmQodGhpcyksIHRoaXMuX2NoaWxkcmVuSW5zdGFuY2VzID0gbnVsbCwgdGhpcy5faW5pdCgpO1xuICB9XG4gIC8vIEdldHRlcnNcbiAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgIHJldHVybiBCbDtcbiAgfVxuICBnZXQgb2Zmc2V0VmFsdWVzKCkge1xuICAgIHJldHVybiB0aGlzLl9lbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICB9XG4gIGdldCBpblZpZXdwb3J0KCkge1xuICAgIGlmICh0aGlzLnBhcmVudCkge1xuICAgICAgY29uc3QgdCA9IHRoaXMucGFyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgcmV0dXJuIHQueSA+IDAgJiYgdC55IDwgd2luZG93LmlubmVySGVpZ2h0ICYmIHRoaXMub2Zmc2V0VmFsdWVzLnkgPj0gdC55ICYmIHRoaXMub2Zmc2V0VmFsdWVzLnkgPD0gdC55ICsgdC5oZWlnaHQgJiYgdGhpcy5vZmZzZXRWYWx1ZXMueSA8PSB3aW5kb3cuaW5uZXJIZWlnaHQ7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLm9mZnNldFZhbHVlcy50b3AgKyB0aGlzLl9vcHRpb25zLmxhenlPZmZzZXQgPD0gd2luZG93LmlubmVySGVpZ2h0ICYmIHRoaXMub2Zmc2V0VmFsdWVzLmJvdHRvbSA+PSAwO1xuICB9XG4gIGdldCBwYXJlbnQoKSB7XG4gICAgY29uc3QgW3RdID0gZC5wYXJlbnRzKFxuICAgICAgdGhpcy5fZWxlbWVudCxcbiAgICAgIGswXG4gICAgKTtcbiAgICByZXR1cm4gdDtcbiAgfVxuICBnZXQgbm9kZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZWxlbWVudC5ub2RlTmFtZTtcbiAgfVxuICBnZXQgaXNDb250YWluZXIoKSB7XG4gICAgcmV0dXJuICFkLm1hdGNoZXModGhpcy5fZWxlbWVudCwgVmwpO1xuICB9XG4gIC8vIFB1YmxpY1xuICBkaXNwb3NlKCkge1xuICAgIHkucmVtb3ZlRGF0YSh0aGlzLl9lbGVtZW50LCAkcyksIHRoaXMuX2FuaW1hdGlvbiAmJiAodGhpcy5fYW5pbWF0aW9uLmRpc3Bvc2UoKSwgdGhpcy5fYW5pbWF0aW9uID0gbnVsbCksIHRoaXMuX2VsZW1lbnQgPSBudWxsLCB0aGlzLl9jaGlsZHJlbkluc3RhbmNlcyAmJiB0aGlzLl9jaGlsZHJlbkluc3RhbmNlcy5mb3JFYWNoKCh0KSA9PiB0LmRpc3Bvc2UoKSk7XG4gIH1cbiAgLy8gUHJpdmF0ZVxuICBfaW5pdCgpIHtcbiAgICBpZiAodGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoSGwsIFwiXCIpLCB0aGlzLmlzQ29udGFpbmVyKSB7XG4gICAgICB0aGlzLl9zZXR1cENvbnRhaW5lcigpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9zZXR1cEVsZW1lbnQoKTtcbiAgfVxuICBfc2V0dXBFbGVtZW50KCkge1xuICAgIGMub25lKHRoaXMuX2VsZW1lbnQsIFwiZXJyb3JcIiwgdGhpcy5lcnJvckhhbmRsZXIpLCB0aGlzLl9vcHRpb25zLmxhenlQbGFjZWhvbGRlciAmJiB0aGlzLl9zZXRQbGFjZWhvbGRlcigpLCB0aGlzLl9hbmltYXRpb24gPSBuZXcgcHIodGhpcy5fZWxlbWVudCwge1xuICAgICAgYW5pbWF0aW9uOiBgJHt0aGlzLl9vcHRpb25zLmxhenlBbmltYXRpb259YCxcbiAgICAgIGFuaW1hdGlvblN0YXJ0OiBcIm9uTG9hZFwiXG4gICAgfSksIGMub25lKHRoaXMuX2VsZW1lbnQsIFwibG9hZFwiLCAoKSA9PiB0aGlzLl9zY3JvbGxIYW5kbGVyKCkpLCB0aGlzLnBhcmVudCAmJiBjLm9uKHRoaXMucGFyZW50LCBcInNjcm9sbFwiLCB0aGlzLnNjcm9sbEhhbmRsZXIpLCBjLm9uKHdpbmRvdywgXCJzY3JvbGxcIiwgdGhpcy5zY3JvbGxIYW5kbGVyKTtcbiAgfVxuICBfc2Nyb2xsSGFuZGxlcigpIHtcbiAgICB0aGlzLmluVmlld3BvcnQgJiYgKHRoaXMuX3RpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuX3NldFNyYygpLCB0aGlzLl9lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShIbCksIHRoaXMuX3JlbW92ZUF0dHJzKCksIHRoaXMuX2FuaW1hdGlvbi5pbml0KCk7XG4gICAgfSwgdGhpcy5fb3B0aW9ucy5sYXp5RGVsYXkpLCB0aGlzLnBhcmVudCAmJiBjLm9mZih0aGlzLnBhcmVudCwgXCJzY3JvbGxcIiwgdGhpcy5zY3JvbGxIYW5kbGVyKSwgYy5vZmYod2luZG93LCBcInNjcm9sbFwiLCB0aGlzLnNjcm9sbEhhbmRsZXIpKTtcbiAgfVxuICBfc2V0RWxlbWVudEVycm9yKCkge1xuICAgICF0aGlzLl9vcHRpb25zLmxhenlFcnJvciB8fCB0aGlzLl9lbGVtZW50LnNyYyA9PT0gdGhpcy5fb3B0aW9ucy5sYXp5RXJyb3IgPyB0aGlzLl9lbGVtZW50LmFsdCA9IFwiNDA0IG5vdCBmb3VuZFwiIDogdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJzcmNcIiwgdGhpcy5fb3B0aW9ucy5sYXp5RXJyb3IpLCBjLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgTzApO1xuICB9XG4gIF9zZXRTcmMoKSB7XG4gICAgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJzcmNcIiwgdGhpcy5fb3B0aW9ucy5sYXp5U3JjKSwgYy50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIHgwKTtcbiAgfVxuICBfc2V0UGxhY2Vob2xkZXIoKSB7XG4gICAgdGhpcy5ub2RlID09PSBcIklNR1wiID8gdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJzcmNcIiwgdGhpcy5fb3B0aW9ucy5sYXp5UGxhY2Vob2xkZXIpIDogdGhpcy5ub2RlID09PSBcIlZJREVPXCIgJiYgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJwb3N0ZXJcIiwgdGhpcy5fb3B0aW9ucy5sYXp5UGxhY2Vob2xkZXIpO1xuICB9XG4gIF9yZW1vdmVBdHRycygpIHtcbiAgICBbXCJzcmNcIiwgXCJkZWxheVwiLCBcImFuaW1hdGlvblwiLCBcInBsYWNlaG9sZGVyXCIsIFwib2Zmc2V0XCIsIFwiZXJyb3JcIl0uZm9yRWFjaChcbiAgICAgICh0KSA9PiB7XG4gICAgICAgIGgucmVtb3ZlRGF0YUF0dHJpYnV0ZSh0aGlzLl9lbGVtZW50LCBgbGF6eS0ke3R9YCk7XG4gICAgICB9XG4gICAgKTtcbiAgfVxuICBfc2V0dXBDb250YWluZXIoKSB7XG4gICAgdGhpcy5fY2hpbGRyZW5JbnN0YW5jZXMgPSBkLmNoaWxkcmVuKFxuICAgICAgdGhpcy5fZWxlbWVudCxcbiAgICAgIFZsXG4gICAgKS5tYXAoKHQpID0+IG5ldyBVbyh0LCB0aGlzLl9vcHRpb25zKSk7XG4gIH1cbiAgX2dldENvbmZpZyh0KSB7XG4gICAgY29uc3QgZSA9IHtcbiAgICAgIC4uLkkwLFxuICAgICAgLi4udCxcbiAgICAgIC4uLmguZ2V0RGF0YUF0dHJpYnV0ZXModGhpcy5fZWxlbWVudClcbiAgICB9O1xuICAgIHJldHVybiBEKEJsLCBlLCBTMCksIGU7XG4gIH1cbiAgLy8gU3RhdGljXG4gIHN0YXRpYyBnZXRJbnN0YW5jZSh0KSB7XG4gICAgcmV0dXJuIHkuZ2V0RGF0YSh0LCAkcyk7XG4gIH1cbiAgc3RhdGljIGdldE9yQ3JlYXRlSW5zdGFuY2UodCwgZSA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0SW5zdGFuY2UodCkgfHwgbmV3IHRoaXModCwgdHlwZW9mIGUgPT0gXCJvYmplY3RcIiA/IGUgOiBudWxsKTtcbiAgfVxuICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKHQpIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgbGV0IGUgPSB5LmdldERhdGEodGhpcywgJHMpO1xuICAgICAgY29uc3QgaSA9IHR5cGVvZiB0ID09IFwib2JqZWN0XCIgJiYgdDtcbiAgICAgIGlmIChlIHx8IChlID0gbmV3IFVvKHRoaXMsIGkpKSwgdHlwZW9mIHQgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICBpZiAodHlwZW9mIGVbdF0gPiBcInVcIilcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBObyBtZXRob2QgbmFtZWQgXCIke3R9XCJgKTtcbiAgICAgICAgZVt0XSh0aGlzKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuY29uc3QgV2wgPSBcImNsaXBib2FyZFwiLCB3aSA9IFwidGUuY2xpcGJvYXJkXCIsIEQwID0gYC4ke3dpfWAsICQwID0ge1xuICBjbGlwYm9hcmRUYXJnZXQ6IG51bGxcbn0sIEwwID0ge1xuICBjbGlwYm9hcmRUYXJnZXQ6IFwibnVsbHxzdHJpbmdcIlxufSwgTjAgPSBgY29weSR7RDB9YDtcbmNsYXNzIHdoIHtcbiAgY29uc3RydWN0b3IodCwgZSA9IHt9KSB7XG4gICAgdGhpcy5fZWxlbWVudCA9IHQsIHRoaXMuX29wdGlvbnMgPSBlLCB0aGlzLl9lbGVtZW50ICYmICh5LnNldERhdGEodCwgd2ksIHRoaXMpLCB0aGlzLl9pbml0Q29weSA9IHRoaXMuX2luaXRDb3B5LmJpbmQodGhpcyksIHRoaXMuX3NldHVwKCkpO1xuICB9XG4gIC8vIEdldHRlcnNcbiAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgIHJldHVybiBXbDtcbiAgfVxuICBnZXQgb3B0aW9ucygpIHtcbiAgICBjb25zdCB0ID0ge1xuICAgICAgLi4uJDAsXG4gICAgICAuLi5oLmdldERhdGFBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpLFxuICAgICAgLi4udGhpcy5fb3B0aW9uc1xuICAgIH07XG4gICAgcmV0dXJuIEQoV2wsIHQsIEwwKSwgdDtcbiAgfVxuICBnZXQgY2xpcGJvYXJkVGFyZ2V0KCkge1xuICAgIHJldHVybiBkLmZpbmRPbmUodGhpcy5vcHRpb25zLmNsaXBib2FyZFRhcmdldCk7XG4gIH1cbiAgZ2V0IGNvcHlUZXh0KCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLmNsaXBib2FyZFRhcmdldC5oYXNBdHRyaWJ1dGUoXG4gICAgICBcImRhdGEtdGUtY2xpcGJvYXJkLXRleHRcIlxuICAgICksIGUgPSB0aGlzLmNsaXBib2FyZFRhcmdldC52YWx1ZSwgaSA9IHRoaXMuY2xpcGJvYXJkVGFyZ2V0LnRleHRDb250ZW50O1xuICAgIHJldHVybiB0ID8gdGhpcy5jbGlwYm9hcmRUYXJnZXQuZ2V0QXR0cmlidXRlKFwiZGF0YS10ZS1jbGlwYm9hcmQtdGV4dFwiKSA6IGUgfHwgaTtcbiAgfVxuICAvLyBQdWJsaWNcbiAgZGlzcG9zZSgpIHtcbiAgICBjLm9mZih0aGlzLl9lbGVtZW50LCBcImNsaWNrXCIsIHRoaXMuX2luaXRDb3B5KSwgeS5yZW1vdmVEYXRhKHRoaXMuX2VsZW1lbnQsIHdpKSwgdGhpcy5fZWxlbWVudCA9IG51bGw7XG4gIH1cbiAgLy8gUHJpdmF0ZVxuICBfc2V0dXAoKSB7XG4gICAgYy5vbih0aGlzLl9lbGVtZW50LCBcImNsaWNrXCIsIHRoaXMuX2luaXRDb3B5KTtcbiAgfVxuICBfaW5pdENvcHkoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuX2NyZWF0ZU5ld0lucHV0KCk7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0KSwgdGhpcy5fc2VsZWN0SW5wdXQodCksIGMudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBOMCwge1xuICAgICAgY29weVRleHQ6IHRoaXMuY29weVRleHRcbiAgICB9KSwgdC5yZW1vdmUoKTtcbiAgfVxuICBfY3JlYXRlTmV3SW5wdXQoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuY2xpcGJvYXJkVGFyZ2V0LnRhZ05hbWUgPT09IFwiVEVYVEFSRUFcIiA/IFwidGV4dGFyZWFcIiA6IFwiaW5wdXRcIiwgZSA9ICQodCk7XG4gICAgcmV0dXJuIGUudmFsdWUgPSB0aGlzLmNvcHlUZXh0LCBoLmFkZENsYXNzKGUsIFwiLWxlZnQtWzk5OTlweF0gYWJzb2x1dGVcIiksIGU7XG4gIH1cbiAgX3NlbGVjdElucHV0KHQpIHtcbiAgICB0LnNlbGVjdCgpLCB0LmZvY3VzKCksIHQuc2V0U2VsZWN0aW9uUmFuZ2UoMCwgOTk5OTkpLCBkb2N1bWVudC5leGVjQ29tbWFuZChcImNvcHlcIik7XG4gIH1cbiAgLy8gU3RhdGljXG4gIHN0YXRpYyBqUXVlcnlJbnRlcmZhY2UodCkge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICBsZXQgZSA9IHkuZ2V0RGF0YSh0aGlzLCB3aSk7XG4gICAgICBjb25zdCBpID0gdHlwZW9mIHQgPT0gXCJvYmplY3RcIiAmJiB0O1xuICAgICAgaWYgKGUgfHwgKGUgPSBuZXcgd2godGhpcywgaSkpLCB0eXBlb2YgdCA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZVt0XSA+IFwidVwiKVxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcIiR7dH1cImApO1xuICAgICAgICBlW3RdKHRoaXMpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHN0YXRpYyBnZXRJbnN0YW5jZSh0KSB7XG4gICAgcmV0dXJuIHkuZ2V0RGF0YSh0LCB3aSk7XG4gIH1cbiAgc3RhdGljIGdldE9yQ3JlYXRlSW5zdGFuY2UodCwgZSA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0SW5zdGFuY2UodCkgfHwgbmV3IHRoaXModCwgdHlwZW9mIGUgPT0gXCJvYmplY3RcIiA/IGUgOiBudWxsKTtcbiAgfVxufVxuY29uc3QgWG8gPSBcImluZmluaXRlU2Nyb2xsXCIsIExzID0gYHRlLiR7WG99YCwgTTAgPSB7XG4gIGluZmluaXRlRGlyZWN0aW9uOiBcInlcIlxufSwgUjAgPSB7XG4gIGluZmluaXRlRGlyZWN0aW9uOiBcInN0cmluZ1wiXG59O1xuY2xhc3Mga2gge1xuICBjb25zdHJ1Y3Rvcih0LCBlKSB7XG4gICAgdGhpcy5fZWxlbWVudCA9IHQsIHRoaXMuX2VsZW1lbnQgJiYgeS5zZXREYXRhKHQsIExzLCB0aGlzKSwgdGhpcy5fb3B0aW9ucyA9IHRoaXMuX2dldENvbmZpZyhlKSwgdGhpcy5zY3JvbGxIYW5kbGVyID0gdGhpcy5fc2Nyb2xsSGFuZGxlci5iaW5kKHRoaXMpLCB0aGlzLl9pbml0KCk7XG4gIH1cbiAgLy8gR2V0dGVyc1xuICBzdGF0aWMgZ2V0IE5BTUUoKSB7XG4gICAgcmV0dXJuIFhvO1xuICB9XG4gIGdldCByZWN0KCkge1xuICAgIHJldHVybiB0aGlzLl9lbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICB9XG4gIGdldCBjb25kaXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2VsZW1lbnQgPT09IHdpbmRvdyA/IE1hdGguYWJzKFxuICAgICAgd2luZG93LnNjcm9sbFkgKyB3aW5kb3cuaW5uZXJIZWlnaHQgLSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsSGVpZ2h0XG4gICAgKSA8IDEgOiB0aGlzLl9vcHRpb25zLmluZmluaXRlRGlyZWN0aW9uID09PSBcInhcIiA/IHRoaXMucmVjdC53aWR0aCArIHRoaXMuX2VsZW1lbnQuc2Nyb2xsTGVmdCArIDEwID49IHRoaXMuX2VsZW1lbnQuc2Nyb2xsV2lkdGggOiBNYXRoLmNlaWwodGhpcy5yZWN0LmhlaWdodCArIHRoaXMuX2VsZW1lbnQuc2Nyb2xsVG9wKSA+PSB0aGlzLl9lbGVtZW50LnNjcm9sbEhlaWdodDtcbiAgfVxuICAvLyBQdWJsaWNcbiAgZGlzcG9zZSgpIHtcbiAgICBjLm9mZih0aGlzLl9lbGVtZW50LCBcInNjcm9sbFwiLCB0aGlzLnNjcm9sbEhhbmRsZXIpLCB5LnJlbW92ZURhdGEodGhpcy5fZWxlbWVudCwgTHMpLCB0aGlzLl9lbGVtZW50ID0gbnVsbDtcbiAgfVxuICAvLyBQcml2YXRlXG4gIF9pbml0KCkge1xuICAgIGMub24odGhpcy5fZWxlbWVudCwgXCJzY3JvbGxcIiwgKCkgPT4gdGhpcy5fc2Nyb2xsSGFuZGxlcigpKTtcbiAgfVxuICBfc2Nyb2xsSGFuZGxlcigpIHtcbiAgICB0aGlzLmNvbmRpdGlvbiAmJiBjLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgXCJjb21wbGV0ZS50ZS5pbmZpbml0ZVNjcm9sbFwiKSwgYy5vZmYodGhpcy5fZWxlbWVudCwgXCJzY3JvbGxcIiwgdGhpcy5zY3JvbGxIYW5kbGVyKTtcbiAgfVxuICBfZ2V0Q29uZmlnKHQpIHtcbiAgICBjb25zdCBlID0ge1xuICAgICAgLi4uTTAsXG4gICAgICAuLi50aGlzLl9lbGVtZW50ICE9PSB3aW5kb3cgPyBoLmdldERhdGFBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpIDoge30sXG4gICAgICAuLi50XG4gICAgfTtcbiAgICByZXR1cm4gRChYbywgZSwgUjApLCBlO1xuICB9XG4gIC8vIFN0YXRpY1xuICBzdGF0aWMgZ2V0SW5zdGFuY2UodCkge1xuICAgIHJldHVybiB5LmdldERhdGEodCwgTHMpO1xuICB9XG4gIHN0YXRpYyBnZXRPckNyZWF0ZUluc3RhbmNlKHQsIGUgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLmdldEluc3RhbmNlKHQpIHx8IG5ldyB0aGlzKHQsIHR5cGVvZiBlID09IFwib2JqZWN0XCIgPyBlIDogbnVsbCk7XG4gIH1cbiAgc3RhdGljIGpRdWVyeUludGVyZmFjZSh0KSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgIGxldCBlID0geS5nZXREYXRhKHRoaXMsIExzKTtcbiAgICAgIGNvbnN0IGkgPSB0eXBlb2YgdCA9PSBcIm9iamVjdFwiICYmIHQ7XG4gICAgICBpZiAoZSB8fCAoZSA9IG5ldyBraCh0aGlzLCBpKSksIHR5cGVvZiB0ID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBlW3RdID4gXCJ1XCIpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFwiJHt0fVwiYCk7XG4gICAgICAgIGVbdF0odGhpcyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIFAwKHsgYmFja2Ryb3BJRDogcyB9LCB0KSB7XG4gIGNvbnN0IGUgPSAkKFwiZGl2XCIpO1xuICByZXR1cm4gaC5hZGRDbGFzcyhcbiAgICBlLFxuICAgIGAke3QuYmFja2Ryb3B9ICR7dC5iYWNrZHJvcENvbG9yfWBcbiAgKSwgZS5pZCA9IHMsIGU7XG59XG5jb25zdCBSaSA9IFwibG9hZGluZ01hbmFnZW1lbnRcIiwgTnMgPSBgdGUuJHtSaX1gLCBCMCA9IFwiW2RhdGEtdGUtbG9hZGluZy1pY29uLXJlZl1cIiwgSDAgPSBcIltkYXRhLXRlLWxvYWRpbmctdGV4dC1yZWZdXCIsIFYwID0gYHNob3cudGUuJHtSaX1gLCBXMCA9IHtcbiAgYmFja2Ryb3A6IFwiKG51bGx8Ym9vbGVhbilcIixcbiAgYmFja2Ryb3BJRDogXCIobnVsbHxzdHJpbmd8bnVtYmVyKVwiLFxuICBkZWxheTogXCIobnVsbHxudW1iZXIpXCIsXG4gIGxvYWRlcjogXCIobnVsbHxzdHJpbmd8bnVtYmVyKVwiLFxuICBwYXJlbnRTZWxlY3RvcjogXCIobnVsbHxzdHJpbmcpXCIsXG4gIGxvYWRpbmdJY29uOiBcImJvb2xlYW5cIixcbiAgbG9hZGluZ1RleHQ6IFwiYm9vbGVhblwiLFxuICBzY3JvbGw6IFwiYm9vbGVhblwiXG59LCBGMCA9IHtcbiAgYmFja2Ryb3A6ICEwLFxuICBiYWNrZHJvcElEOiBudWxsLFxuICBkZWxheTogMCxcbiAgbG9hZGVyOiBcIlwiLFxuICBwYXJlbnRTZWxlY3RvcjogbnVsbCxcbiAgc2Nyb2xsOiAhMCxcbiAgbG9hZGluZ1RleHQ6ICEwLFxuICBsb2FkaW5nSWNvbjogITBcbn0sIFkwID0ge1xuICBsb2FkaW5nU3Bpbm5lcjogXCJhYnNvbHV0ZSB0b3AtWzUwJV0gbGVmdC1bNTAlXSAtdHJhbnNsYXRlLXgtWzUwJV0gLXRyYW5zbGF0ZS15LVs1MCVdIGZsZXggZmxleC1jb2wganVzdGlmeS1jZW50ZXIgaXRlbXMtY2VudGVyIHotNDBcIixcbiAgc3Bpbm5lckNvbG9yOiBcInRleHQtcHJpbWFyeSBkYXJrOnRleHQtcHJpbWFyeS00MDBcIixcbiAgYmFja2Ryb3A6IFwidy1mdWxsIGgtZnVsbCBmaXhlZCB0b3AtMCBsZWZ0LTAgYm90dG9tLTAgcmlnaHQtMCB6LTMwXCIsXG4gIGJhY2tkcm9wQ29sb3I6IFwiYmctW3JnYmEoMCwwLDAsMC40KV1cIlxufSwgajAgPSB7XG4gIGxvYWRpbmdTcGlubmVyOiBcInN0cmluZ1wiLFxuICBzcGlubmVyQ29sb3I6IFwic3RyaW5nXCIsXG4gIGJhY2tkcm9wOiBcInN0cmluZ1wiLFxuICBiYWNrZHJvcENvbG9yOiBcInN0cmluZ1wiXG59O1xuY2xhc3MgeGgge1xuICBjb25zdHJ1Y3Rvcih0LCBlID0ge30sIGkpIHtcbiAgICB0aGlzLl9lbGVtZW50ID0gdCwgdGhpcy5fb3B0aW9ucyA9IHRoaXMuX2dldENvbmZpZyhlKSwgdGhpcy5fY2xhc3NlcyA9IHRoaXMuX2dldENsYXNzZXMoaSksIHRoaXMuX2VsZW1lbnQgJiYgeS5zZXREYXRhKHQsIE5zLCB0aGlzKSwgdGhpcy5fYmFja2Ryb3BFbGVtZW50ID0gbnVsbCwgdGhpcy5fcGFyZW50RWxlbWVudCA9IGQuZmluZE9uZSh0aGlzLl9vcHRpb25zLnBhcmVudFNlbGVjdG9yKSwgdGhpcy5fbG9hZGluZ0ljb24gPSBkLmZpbmRPbmUoXG4gICAgICBCMCxcbiAgICAgIHRoaXMuX2VsZW1lbnRcbiAgICApLCB0aGlzLl9sb2FkaW5nVGV4dCA9IGQuZmluZE9uZShcbiAgICAgIEgwLFxuICAgICAgdGhpcy5fZWxlbWVudFxuICAgICksIHRoaXMuaW5pdCgpO1xuICB9XG4gIC8vIEdldHRlcnNcbiAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgIHJldHVybiBSaTtcbiAgfVxuICAvLyBQdWJsaWNcbiAgaW5pdCgpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5fbG9hZGluZ0ljb24uY2xvbmVOb2RlKCEwKSwgZSA9IHRoaXMuX2xvYWRpbmdUZXh0LmNsb25lTm9kZSghMCk7XG4gICAgdGhpcy5fcmVtb3ZlRWxlbWVudHNPblN0YXJ0KCksIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgaC5hZGRDbGFzcyhcbiAgICAgICAgdGhpcy5fZWxlbWVudCxcbiAgICAgICAgYCR7dGhpcy5fY2xhc3Nlcy5sb2FkaW5nU3Bpbm5lcn0gJHt0aGlzLl9jbGFzc2VzLnNwaW5uZXJDb2xvcn1gXG4gICAgICApLCB0aGlzLl9zZXRCYWNrZHJvcCgpLCB0aGlzLl9zZXRMb2FkaW5nSWNvbih0KSwgdGhpcy5fc2V0TG9hZGluZ1RleHQoZSksIHRoaXMuX3NldFNjcm9sbE9wdGlvbigpLCBjLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgVjApO1xuICAgIH0sIHRoaXMuX29wdGlvbnMuZGVsYXkpO1xuICB9XG4gIGRpc3Bvc2UoKSB7XG4gICAgeS5yZW1vdmVEYXRhKHRoaXMuX2VsZW1lbnQsIE5zKSwgaC5yZW1vdmVDbGFzcyhcbiAgICAgIHRoaXMuX2VsZW1lbnQsXG4gICAgICBgJHt0aGlzLl9jbGFzc2VzLmxvYWRpbmdTcGlubmVyfSAke3RoaXMuX2NsYXNzZXMuc3Bpbm5lckNvbG9yfWBcbiAgICApO1xuICAgIGNvbnN0IHQgPSB0aGlzLl9vcHRpb25zLmRlbGF5O1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5fcmVtb3ZlQmFja2Ryb3AoKSwgdGhpcy5fYmFja2Ryb3BFbGVtZW50ID0gbnVsbCwgdGhpcy5fZWxlbWVudCA9IG51bGwsIHRoaXMuX29wdGlvbnMgPSBudWxsO1xuICAgIH0sIHQpO1xuICB9XG4gIC8vIFByaXZhdGVcbiAgX3NldEJhY2tkcm9wKCkge1xuICAgIGNvbnN0IHsgYmFja2Ryb3A6IHQgfSA9IHRoaXMuX29wdGlvbnM7XG4gICAgdCAmJiAodGhpcy5fYmFja2Ryb3BFbGVtZW50ID0gUDAodGhpcy5fb3B0aW9ucywgdGhpcy5fY2xhc3NlcyksIHRoaXMuX3BhcmVudEVsZW1lbnQgIT09IG51bGwgPyAoaC5hZGRDbGFzcyh0aGlzLl9lbGVtZW50LCBcImFic29sdXRlXCIpLCBoLmFkZENsYXNzKHRoaXMuX3BhcmVudEVsZW1lbnQsIFwicmVsYXRpdmVcIiksIGguYWRkQ2xhc3ModGhpcy5fYmFja2Ryb3BFbGVtZW50LCBcImFic29sdXRlXCIpLCB0aGlzLl9wYXJlbnRFbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuX2JhY2tkcm9wRWxlbWVudCkpIDogKGguYWRkQ2xhc3ModGhpcy5fZWxlbWVudCwgXCIhZml4ZWRcIiksIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5fYmFja2Ryb3BFbGVtZW50KSwgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLl9lbGVtZW50KSkpO1xuICB9XG4gIF9yZW1vdmVCYWNrZHJvcCgpIHtcbiAgICBjb25zdCB7IGJhY2tkcm9wOiB0IH0gPSB0aGlzLl9vcHRpb25zO1xuICAgIHQgJiYgKHRoaXMuX3BhcmVudEVsZW1lbnQgIT09IG51bGwgPyAoaC5yZW1vdmVDbGFzcyh0aGlzLl9lbGVtZW50LCBcImFic29sdXRlXCIpLCBoLnJlbW92ZUNsYXNzKHRoaXMuX3BhcmVudEVsZW1lbnQsIFwicmVsYXRpdmVcIiksIHRoaXMuX2JhY2tkcm9wRWxlbWVudC5yZW1vdmUoKSkgOiAodGhpcy5fYmFja2Ryb3BFbGVtZW50LnJlbW92ZSgpLCB0aGlzLl9lbGVtZW50LnJlbW92ZSgpKSk7XG4gIH1cbiAgX3NldExvYWRpbmdJY29uKHQpIHtcbiAgICBpZiAoIXRoaXMuX29wdGlvbnMubG9hZGluZ0ljb24pIHtcbiAgICAgIHQucmVtb3ZlKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2VsZW1lbnQuYXBwZW5kQ2hpbGQodCksIHQuaWQgPSB0aGlzLl9vcHRpb25zLmxvYWRlcjtcbiAgfVxuICBfc2V0TG9hZGluZ1RleHQodCkge1xuICAgIGlmICghdGhpcy5fb3B0aW9ucy5sb2FkaW5nVGV4dCkge1xuICAgICAgdC5yZW1vdmUoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fZWxlbWVudC5hcHBlbmRDaGlsZCh0KTtcbiAgfVxuICBfcmVtb3ZlRWxlbWVudHNPblN0YXJ0KCkge1xuICAgIHRoaXMuX2VsZW1lbnQgIT09IG51bGwgJiYgKHRoaXMuX2xvYWRpbmdJY29uLnJlbW92ZSgpLCB0aGlzLl9sb2FkaW5nVGV4dC5yZW1vdmUoKSk7XG4gIH1cbiAgX3NldFNjcm9sbE9wdGlvbigpIHtcbiAgICBpZiAodGhpcy5fb3B0aW9ucy5zY3JvbGwpIHtcbiAgICAgIGlmICh0aGlzLl9wYXJlbnRFbGVtZW50ID09PSBudWxsKSB7XG4gICAgICAgIGguYWRkQ2xhc3MoZG9jdW1lbnQuYm9keSwgXCJvdmVyZmxvdy1hdXRvXCIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBoLmFkZENsYXNzKHRoaXMuX3BhcmVudEVsZW1lbnQsIFwib3ZlcmZsb3ctYXV0b1wiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHRoaXMuX3BhcmVudEVsZW1lbnQgPT09IG51bGwpIHtcbiAgICAgICAgaC5hZGRDbGFzcyhkb2N1bWVudC5ib2R5LCBcIm92ZXJmbG93LWhpZGRlblwiKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaC5hZGRDbGFzcyh0aGlzLl9wYXJlbnRFbGVtZW50LCBcIm92ZXJmbG93LWhpZGRlblwiKTtcbiAgICB9XG4gIH1cbiAgX2dldENvbmZpZyh0KSB7XG4gICAgY29uc3QgZSA9IHtcbiAgICAgIC4uLkYwLFxuICAgICAgLi4uaC5nZXREYXRhQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KSxcbiAgICAgIC4uLnRcbiAgICB9O1xuICAgIHJldHVybiBEKFJpLCBlLCBXMCksIGU7XG4gIH1cbiAgX2dldENsYXNzZXModCkge1xuICAgIGNvbnN0IGUgPSBoLmdldERhdGFDbGFzc0F0dHJpYnV0ZXModGhpcy5fZWxlbWVudCk7XG4gICAgcmV0dXJuIHQgPSB7XG4gICAgICAuLi5ZMCxcbiAgICAgIC4uLmUsXG4gICAgICAuLi50XG4gICAgfSwgRChSaSwgdCwgajApLCB0O1xuICB9XG4gIC8vIFN0YXRpY1xuICBzdGF0aWMgZ2V0SW5zdGFuY2UodCkge1xuICAgIHJldHVybiB5LmdldERhdGEodCwgTnMpO1xuICB9XG4gIHN0YXRpYyBnZXRPckNyZWF0ZUluc3RhbmNlKHQsIGUgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLmdldEluc3RhbmNlKHQpIHx8IG5ldyB0aGlzKHQsIHR5cGVvZiBlID09IFwib2JqZWN0XCIgPyBlIDogbnVsbCk7XG4gIH1cbiAgc3RhdGljIGpRdWVyeUludGVyZmFjZSh0KSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgIGxldCBlID0geS5nZXREYXRhKHRoaXMsIE5zKTtcbiAgICAgIGNvbnN0IGkgPSB0eXBlb2YgdCA9PSBcIm9iamVjdFwiICYmIHQ7XG4gICAgICBpZiAoZSB8fCAoZSA9IG5ldyB4aCh0aGlzLCBpKSksIHR5cGVvZiB0ID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBlW3RdID4gXCJ1XCIpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFwiJHt0fVwiYCk7XG4gICAgICAgIGVbdF0odGhpcyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cbmNvbnN0IEswID0gKHMpID0+IHtcbiAgY29uc3QgdCA9IC9eKDA/WzEtOV18MVswMTJdKSg6WzAtNV1cXGQpIFtBUGFwXVttTV0kLywgZSA9IC9eKFswLTldfDBbMC05XXwxWzAtOV18MlswLTNdKTpbMC01XVswLTldKDpbMC01XVswLTldKT8kLztcbiAgcmV0dXJuIHMubWF0Y2godCkgfHwgcy5tYXRjaChlKTtcbn0sIHowID0gKHMpID0+IHMgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHMpID09PSBcIltvYmplY3QgRGF0ZV1cIiAmJiAhaXNOYU4ocyksIFUwID0gKHMpID0+IHMuZ2V0TW9udGgoKSwgWDAgPSAocykgPT4gcy5nZXRGdWxsWWVhcigpLCBHMCA9IChzKSA9PiBzLm1hdGNoKC9bXihkbXkpXXsxLH0vZyksIHEwID0gKHMsIHQsIGUsIGkpID0+IHtcbiAgbGV0IG47XG4gIGVbMF0gIT09IGVbMV0gPyBuID0gZVswXSArIGVbMV0gOiBuID0gZVswXTtcbiAgY29uc3QgbyA9IG5ldyBSZWdFeHAoYFske259XWApLCByID0gcy5zcGxpdChvKSwgYSA9IHQuc3BsaXQobyksIGwgPSB0LmluZGV4T2YoXCJtbW1cIikgIT09IC0xLCBwID0gW107XG4gIGZvciAobGV0IGIgPSAwOyBiIDwgYS5sZW5ndGg7IGIrKylcbiAgICBhW2JdLmluZGV4T2YoXCJ5eVwiKSAhPT0gLTEgJiYgKHBbMF0gPSB7IHZhbHVlOiByW2JdLCBmb3JtYXQ6IGFbYl0gfSksIGFbYl0uaW5kZXhPZihcIm1cIikgIT09IC0xICYmIChwWzFdID0geyB2YWx1ZTogcltiXSwgZm9ybWF0OiBhW2JdIH0pLCBhW2JdLmluZGV4T2YoXCJkXCIpICE9PSAtMSAmJiBhW2JdLmxlbmd0aCA8PSAyICYmIChwWzJdID0geyB2YWx1ZTogcltiXSwgZm9ybWF0OiBhW2JdIH0pO1xuICBsZXQgdTtcbiAgdC5pbmRleE9mKFwibW1tbVwiKSAhPT0gLTEgPyB1ID0gaS5tb250aHNGdWxsIDogdSA9IGkubW9udGhzU2hvcnQ7XG4gIGNvbnN0IF8gPSBOdW1iZXIocFswXS52YWx1ZSksIGYgPSBsID8gWjAocFsxXS52YWx1ZSwgdSkgOiBOdW1iZXIocFsxXS52YWx1ZSkgLSAxLCBnID0gTnVtYmVyKHBbMl0udmFsdWUpO1xuICByZXR1cm4gRXQoXywgZiwgZyk7XG59LCBaMCA9IChzLCB0KSA9PiB0LmZpbmRJbmRleCgoZSkgPT4gZSA9PT0gcyksIFEwID0gKHMsIHQsIGUpID0+IGBcbiAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCIke2UucGlja2VySWNvbn1cIiBkYXRhLXRlLWRhdGVwaWNrZXItdG9nZ2xlLWJ1dHRvbi1yZWY+XG4gICAgJHtzfVxuICA8L2J1dHRvbj5cbiAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCIke2UucGlja2VySWNvbn1cIiBkYXRhLXRlLXRpbWVwaWNrZXItdG9nZ2xlLWJ1dHRvbi1yZWY+XG4gICAgJHt0fVxuICA8L2J1dHRvbj5cbmAsIEowID0gKHMsIHQpID0+IGBcbiAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCIke3QudG9nZ2xlQnV0dG9ufVwiIGRhdGEtdGUtZGF0ZS10aW1lcGlja2VyLXRvZ2dsZS1yZWY+XG4gICAgJHtzfSBcbiAgPC9idXR0b24+XG5gLCBRcyA9IFwiZGF0ZXRpbWVwaWNrZXJcIiwga2kgPSBgdGUuJHtRc31gLCBnciA9IGAuJHtraX1gLCBPaCA9IFwiZGF0YS10ZS1kYXRlcGlja2VyLWluaXRcIiwgU2ggPSBcImRhdGEtdGUtdGltZXBpY2tlci1pbml0XCIsIHRDID0gXCJkYXRhLXRlLWRhdGVwaWNrZXItaGVhZGVyXCIsIGVDID0gXCJkYXRhLXRlLWRhdGVwaWNrZXItY2FuY2VsLWJ1dHRvbi1yZWZcIiwgaUMgPSBcImRhdGEtdGUtZGF0ZXBpY2tlci1vay1idXR0b24tcmVmXCIsIGtvID0gXCJkYXRhLXRlLXRpbWVwaWNrZXItd3JhcHBlclwiLCBGbCA9IFwiZGF0YS10ZS10aW1lcGlja2VyLWNhbmNlbFwiLCBzQyA9IFwiZGF0YS10ZS10aW1lcGlja2VyLXN1Ym1pdFwiLCBuQyA9IFwiZGF0YS10ZS10aW1lcGlja2VyLWNsZWFyXCIsIFlsID0gXCJkYXRhLXRlLWJ1dHRvbnMtdGltZXBpY2tlclwiLCBvQyA9IFwiZGF0YS10ZS1kYXRlLXRpbWVwaWNrZXItdG9nZ2xlLXJlZlwiLCByQyA9IFwiZGF0YS10ZS1kYXRlcGlja2VyLXRvZ2dsZS1idXR0b24tcmVmXCIsIGFDID0gXCJkYXRhLXRlLXRpbWVwaWNrZXItdG9nZ2xlLWJ1dHRvbi1yZWZcIiwgbEMgPSBgWyR7U2h9XWAsIGNDID0gYFske09ofV1gLCBoQyA9IGBbJHtvQ31dYCwgZEMgPSBgWyR7YUN9XWAsIHVDID0gXCJbZGF0YS10ZS1pbnB1dC1ub3RjaC1yZWZdXCIsIHBDID0gXCJbZGF0YS10ZS1kYXRlLXRpbWVwaWNrZXItdG9nZ2xlLXJlZl1cIiwgX0MgPSBcIltkYXRhLXRlLXRpbWVwaWNrZXItZWxlbWVudHMtd3JhcHBlcl1cIiwgZkMgPSBcIltkYXRhLXRlLXRpbWVwaWNrZXItY2xvY2std3JhcHBlcl1cIiwgbUMgPSBgb3BlbiR7Z3J9YCwgZ0MgPSBgY2xvc2Uke2dyfWAsIGJDID0gYGRhdGV0aW1lQ2hhbmdlJHtncn1gLCBqbCA9IFwiY2xvc2UudGUuZGF0ZXBpY2tlclwiLCBLbCA9IFwiaW5wdXQudGUudGltZXBpY2tlclwiLCBEZSA9ICQoXCJkaXZcIiksIHpsID0ge1xuICBpbmxpbmU6ICExLFxuICB0b2dnbGVCdXR0b246ICEwLFxuICBjb250YWluZXI6IFwiYm9keVwiLFxuICBkaXNhYmxlZDogITEsXG4gIGRpc2FibGVQYXN0OiAhMSxcbiAgZGlzYWJsZUZ1dHVyZTogITEsXG4gIGRlZmF1bHRUaW1lOiBcIlwiLFxuICBkZWZhdWx0RGF0ZTogXCJcIixcbiAgdGltZXBpY2tlcjoge30sXG4gIGRhdGVwaWNrZXI6IHt9LFxuICBzaG93Rm9ybWF0OiAhMSxcbiAgZGF0ZVRpbWVwaWNrZXJUb2dnbGVJY29uVGVtcGxhdGU6IGA8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgZmlsbD1cImN1cnJlbnRDb2xvclwiPlxuICA8cGF0aCBmaWxsLXJ1bGU9XCJldmVub2RkXCIgZD1cIk02Ljc1IDIuMjVBLjc1Ljc1IDAgMDE3LjUgM3YxLjVoOVYzQS43NS43NSAwIDAxMTggM3YxLjVoLjc1YTMgMyAwIDAxMyAzdjExLjI1YTMgMyAwIDAxLTMgM0g1LjI1YTMgMyAwIDAxLTMtM1Y3LjVhMyAzIDAgMDEzLTNINlYzYS43NS43NSAwIDAxLjc1LS43NXptMTMuNSA5YTEuNSAxLjUgMCAwMC0xLjUtMS41SDUuMjVhMS41IDEuNSAwIDAwLTEuNSAxLjV2Ny41YTEuNSAxLjUgMCAwMDEuNSAxLjVoMTMuNWExLjUgMS41IDAgMDAxLjUtMS41di03LjV6XCIgY2xpcC1ydWxlPVwiZXZlbm9kZFwiIC8+XG4gIDwvc3ZnPmAsXG4gIGRhdGVwaWNrZXJUb2dnbGVJY29uVGVtcGxhdGU6IGA8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgZmlsbD1cImN1cnJlbnRDb2xvclwiPlxuICA8cGF0aCBmaWxsLXJ1bGU9XCJldmVub2RkXCIgZD1cIk02Ljc1IDIuMjVBLjc1Ljc1IDAgMDE3LjUgM3YxLjVoOVYzQS43NS43NSAwIDAxMTggM3YxLjVoLjc1YTMgMyAwIDAxMyAzdjExLjI1YTMgMyAwIDAxLTMgM0g1LjI1YTMgMyAwIDAxLTMtM1Y3LjVhMyAzIDAgMDEzLTNINlYzYS43NS43NSAwIDAxLjc1LS43NXptMTMuNSA5YTEuNSAxLjUgMCAwMC0xLjUtMS41SDUuMjVhMS41IDEuNSAwIDAwLTEuNSAxLjV2Ny41YTEuNSAxLjUgMCAwMDEuNSAxLjVoMTMuNWExLjUgMS41IDAgMDAxLjUtMS41di03LjV6XCIgY2xpcC1ydWxlPVwiZXZlbm9kZFwiIC8+XG4gIDwvc3ZnPmAsXG4gIHRpbWVwaWNrZXJUb2dnbGVJY29uVGVtcGxhdGU6IGA8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiBmaWxsPVwibm9uZVwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBzdHJva2Utd2lkdGg9XCIxLjVcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIj5cbiAgPHBhdGggc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCIgZD1cIk0xMiA2djZoNC41bTQuNSAwYTkgOSAwIDExLTE4IDAgOSA5IDAgMDExOCAwelwiIC8+XG4gIDwvc3ZnPmBcbn0sIHZDID0ge1xuICBpbmxpbmU6IFwiYm9vbGVhblwiLFxuICB0b2dnbGVCdXR0b246IFwiYm9vbGVhblwiLFxuICBjb250YWluZXI6IFwic3RyaW5nXCIsXG4gIGRpc2FibGVkOiBcImJvb2xlYW5cIixcbiAgZGlzYWJsZVBhc3Q6IFwiYm9vbGVhblwiLFxuICBkaXNhYmxlRnV0dXJlOiBcImJvb2xlYW5cIixcbiAgZGVmYXVsdFRpbWU6IFwiKHN0cmluZ3xkYXRlfG51bWJlcilcIixcbiAgZGVmYXVsdERhdGU6IFwiKHN0cmluZ3xkYXRlfG51bWJlcilcIixcbiAgdGltZXBpY2tlcjogXCJvYmplY3RcIixcbiAgZGF0ZXBpY2tlcjogXCJvYmplY3RcIixcbiAgc2hvd0Zvcm1hdDogXCJib29sZWFuXCIsXG4gIGRhdGVUaW1lcGlja2VyVG9nZ2xlSWNvblRlbXBsYXRlOiBcInN0cmluZ1wiLFxuICBkYXRlcGlja2VyVG9nZ2xlSWNvblRlbXBsYXRlOiBcInN0cmluZ1wiLFxuICB0aW1lcGlja2VyVG9nZ2xlSWNvblRlbXBsYXRlOiBcInN0cmluZ1wiXG59LCBUQyA9IHtcbiAgdG9nZ2xlQnV0dG9uOiBcImZsZXggaXRlbXMtY2VudGVyIGp1c3RpZnktY29udGVudC1jZW50ZXIgWyY+c3ZnXTp3LTUgWyY+c3ZnXTpoLTUgYWJzb2x1dGUgb3V0bGluZS1ub25lIGJvcmRlci1ub25lIGJnLXRyYW5zcGFyZW50IHJpZ2h0LTAuNSB0b3AtMS8yIC10cmFuc2xhdGUteC0xLzIgLXRyYW5zbGF0ZS15LTEvMiBob3Zlcjp0ZXh0LXByaW1hcnkgZm9jdXM6dGV4dC1wcmltYXJ5IGRhcms6aG92ZXI6dGV4dC1wcmltYXJ5LTQwMCBkYXJrOmZvY3VzOnRleHQtcHJpbWFyeS00MDAgZGFyazp0ZXh0LW5ldXRyYWwtMjAwXCIsXG4gIHBpY2tlckljb246IFwiWyY+c3ZnXTp3LTYgWyY+c3ZnXTpoLTYgWyY+c3ZnXTpteC1hdXRvIFsmPnN2Z106cG9pbnRlci1ldmVudHMtbm9uZSB3LTEvMiBweC0xLjUgcHktWzFweF0gcm91bmRlZC1bMTBweF0gbWluLWgtWzQwcHhdIGN1cnNvci1wb2ludGVyIG91dGxpbmUtbm9uZSBib3JkZXItbm9uZSB0ZXh0LXdoaXRlIGhvdmVyOmJnLXByaW1hcnktNjAwIGRhcms6aG92ZXI6YmctbmV1dHJhbC02MDBcIixcbiAgYnV0dG9uc0NvbnRhaW5lcjogXCJmbGV4IGp1c3RpZnktZXZlbmx5IGl0ZW1zLWVuZCBiZy1wcmltYXJ5IGRhcms6YmctemluYy04MDAgZGFyazpkYXRhLVt0ZS1idXR0b25zLXRpbWVwaWNrZXJdOmJnLXppbmMtNzAwXCIsXG4gIHRpbWVwaWNrZXI6IHt9LFxuICBkYXRlcGlja2VyOiB7fVxufSwgRUMgPSB7XG4gIHRvZ2dsZUJ1dHRvbjogXCJzdHJpbmdcIixcbiAgcGlja2VySWNvbjogXCJzdHJpbmdcIixcbiAgYnV0dG9uc0NvbnRhaW5lcjogXCJzdHJpbmdcIixcbiAgdGltZXBpY2tlcjogXCJvYmplY3RcIixcbiAgZGF0ZXBpY2tlcjogXCJvYmplY3RcIlxufTtcbmNsYXNzIEloIHtcbiAgY29uc3RydWN0b3IodCwgZSwgaSkge1xuICAgIHRoaXMuX2VsZW1lbnQgPSB0LCB0aGlzLl9pbnB1dCA9IGQuZmluZE9uZShcImlucHV0XCIsIHRoaXMuX2VsZW1lbnQpLCB0aGlzLl9vcHRpb25zID0gdGhpcy5fZ2V0Q29uZmlnKGUpLCB0aGlzLl9jbGFzc2VzID0gdGhpcy5fZ2V0Q2xhc3NlcyhpKSwgdGhpcy5fdGltZXBpY2tlciA9IG51bGwsIHRoaXMuX2RhdGVwaWNrZXIgPSBudWxsLCB0aGlzLl9kYXRlVmFsdWUgPSB0aGlzLl9vcHRpb25zLmRlZmF1bHREYXRlID8gdGhpcy5fb3B0aW9ucy5kZWZhdWx0RGF0ZSA6IFwiXCIsIHRoaXMuX3RpbWVWYWx1ZSA9IHRoaXMuX29wdGlvbnMuZGVmYXVsdFRpbWUgPyB0aGlzLl9vcHRpb25zLmRlZmF1bHRUaW1lIDogXCJcIiwgdGhpcy5faXNJbnZhbGlkVGltZUZvcm1hdCA9ICExLCB0aGlzLl9mb3JtYXQgPSB0aGlzLl9vcHRpb25zLmRhdGVwaWNrZXIuZm9ybWF0ID8gdGhpcy5fb3B0aW9ucy5kYXRlcGlja2VyLmZvcm1hdCA6IFwiZGQvbW0veXl5eVwiLCB0aGlzLl9jYW5jZWwgPSAhMSwgdGhpcy5fc2Nyb2xsQmFyID0gbmV3IHFlKCksIHRoaXMuX2VsZW1lbnQgJiYgeS5zZXREYXRhKHQsIGtpLCB0aGlzKSwgdGhpcy5faW5pdCgpO1xuICB9XG4gIC8vIEdldHRlcnNcbiAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgIHJldHVybiBRcztcbiAgfVxuICBnZXQgdG9nZ2xlQnV0dG9uKCkge1xuICAgIHJldHVybiBkLmZpbmRPbmUoaEMsIHRoaXMuX2VsZW1lbnQpO1xuICB9XG4gIGdldCBub3RjaCgpIHtcbiAgICByZXR1cm4gZC5maW5kT25lKHVDLCB0aGlzLl9lbGVtZW50KTtcbiAgfVxuICBkaXNwb3NlKCkge1xuICAgIGMub2ZmKHRoaXMuX2VsZW1lbnQsIFwiY2xpY2tcIiwgdGhpcy5fb3BlbkRhdGVQaWNrZXIpLCBjLm9mZih0aGlzLl9pbnB1dCwgXCJpbnB1dFwiLCB0aGlzLl9oYW5kbGVJbnB1dCksIGMub2ZmKHRoaXMuX2VsZW1lbnQsIFwiY2xpY2tcIiksIHkucmVtb3ZlRGF0YSh0aGlzLl9lbGVtZW50LCBraSksIHRoaXMuX3JlbW92ZVRpbWVQaWNrZXIoKSwgdGhpcy5fcmVtb3ZlRGF0ZXBpY2tlcigpLCB0aGlzLnRvZ2dsZUJ1dHRvbi5yZW1vdmUoKSwgdGhpcy5fb3B0aW9ucyA9IHpsLCB0aGlzLl90aW1lcGlja2VyID0gbnVsbCwgdGhpcy5fZGF0ZXBpY2tlciA9IG51bGwsIHRoaXMuX2RhdGVWYWx1ZSA9IG51bGwsIHRoaXMuX3RpbWVWYWx1ZSA9IG51bGwsIHRoaXMuX2lzSW52YWxpZFRpbWVGb3JtYXQgPSBudWxsO1xuICB9XG4gIHVwZGF0ZSh0ID0ge30pIHtcbiAgICBjb25zdCBlID0gdGhpcy5fZ2V0Q29uZmlnKHsgLi4udGhpcy5fb3B0aW9ucywgLi4udCB9KTtcbiAgICB0aGlzLmRpc3Bvc2UoKSwgdGhpcy5fb3B0aW9ucyA9IGUsIHRoaXMuX2luaXQoKTtcbiAgfVxuICAvLyBQcml2YXRlXG4gIF9pbml0KCkge1xuICAgIHRoaXMuX2FkZERhdGVwaWNrZXIoKSwgdGhpcy5fYWRkVGltZVBpY2tlcigpLCB0aGlzLl9hcHBlbmRUb2dnbGVCdXR0b24oKSwgdGhpcy5fbGlzdGVuVG9Ub2dnbGVDbGljaygpLCB0aGlzLl9saXN0ZW5Ub1VzZXJJbnB1dCgpLCB0aGlzLl9kaXNhYmxlSW5wdXQoKSwgdGhpcy5fc2V0SW5pdGlhbERlZmF1bHRJbnB1dCgpLCB0aGlzLl9hcHBseUZvcm1hdFBsYWNlaG9sZGVyKCksIHRoaXMuX29wdGlvbnMuZGlzYWJsZVBhc3QgJiYgdGhpcy5faGFuZGxlVGltZXBpY2tlckRpc2FibGVQYXN0KCksIHRoaXMuX29wdGlvbnMuZGlzYWJsZUZ1dHVyZSAmJiB0aGlzLl9oYW5kbGVUaW1lcGlja2VyRGlzYWJsZUZ1dHVyZSgpO1xuICB9XG4gIF9yZW1vdmVEYXRlcGlja2VyKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLl9lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoY0MpO1xuICAgIHQgJiYgdC5yZW1vdmUoKTtcbiAgfVxuICBfYWRkRGF0ZXBpY2tlcigpIHtcbiAgICBjb25zdCB0ID0gJChcImRpdlwiKTtcbiAgICB0LmlkID0gdGhpcy5fZWxlbWVudC5pZCA/IGBkYXRlcGlja2VyLSR7dGhpcy5fZWxlbWVudC5pZH1gIDogcnQoXCJkYXRlcGlja2VyLVwiKTtcbiAgICBjb25zdCBlID0gJzxpbnB1dCB0eXBlPVwidGV4dFwiPic7XG4gICAgdC5pbm5lckhUTUwgPSBlLCB0LnNldEF0dHJpYnV0ZShPaCwgXCJcIiksIHRoaXMuX2VsZW1lbnQuYXBwZW5kQ2hpbGQodCksIGguYWRkQ2xhc3ModCwgXCJoaWRkZW5cIik7XG4gICAgbGV0IGkgPSB7XG4gICAgICAuLi50aGlzLl9vcHRpb25zLmRhdGVwaWNrZXIsXG4gICAgICBjb250YWluZXI6IHRoaXMuX29wdGlvbnMuY29udGFpbmVyLFxuICAgICAgZGlzYWJsZVBhc3Q6IHRoaXMuX29wdGlvbnMuZGlzYWJsZVBhc3QsXG4gICAgICBkaXNhYmxlRnV0dXJlOiB0aGlzLl9vcHRpb25zLmRpc2FibGVGdXR1cmVcbiAgICB9O1xuICAgICh0aGlzLl9vcHRpb25zLmlubGluZSB8fCB0aGlzLl9vcHRpb25zLmRhdGVwaWNrZXIuaW5saW5lKSAmJiAoaSA9IHsgLi4uaSwgaW5saW5lOiAhMCB9KSwgdGhpcy5fZGF0ZXBpY2tlciA9IG5ldyBObSh0LCBpLCB7XG4gICAgICAuLi50aGlzLl9jbGFzc2VzLmRhdGVwaWNrZXJcbiAgICB9KSwgdGhpcy5fZGF0ZXBpY2tlci5faW5wdXQudmFsdWUgPSB0aGlzLl9kYXRlVmFsdWU7XG4gIH1cbiAgX3JlbW92ZVRpbWVQaWNrZXIoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuX2VsZW1lbnQucXVlcnlTZWxlY3RvcihsQyk7XG4gICAgdCAmJiAodC5yZW1vdmUoKSwgdGhpcy5fc2Nyb2xsQmFyLnJlc2V0KCkpO1xuICB9XG4gIF9hZGRUaW1lUGlja2VyKCkge1xuICAgIGNvbnN0IHQgPSAkKFwiZGl2XCIpO1xuICAgIHQuaWQgPSB0aGlzLl9lbGVtZW50LmlkID8gYHRpbWVwaWNrZXItJHt0aGlzLl9lbGVtZW50LmlkfWAgOiBydChcInRpbWVwaWNrZXItXCIpO1xuICAgIGNvbnN0IGUgPSAnPGlucHV0IHR5cGU9XCJ0ZXh0XCI+JztcbiAgICB0LmlubmVySFRNTCA9IGUsIHQuc2V0QXR0cmlidXRlKFNoLCBcIlwiKSwgdGhpcy5fZWxlbWVudC5hcHBlbmRDaGlsZCh0KSwgaC5hZGRDbGFzcyh0LCBcImhpZGRlblwiKTtcbiAgICBsZXQgaSA9IHtcbiAgICAgIC4uLnRoaXMuX29wdGlvbnMudGltZXBpY2tlcixcbiAgICAgIGNvbnRhaW5lcjogdGhpcy5fb3B0aW9ucy5jb250YWluZXJcbiAgICB9O1xuICAgICh0aGlzLl9vcHRpb25zLmlubGluZSB8fCB0aGlzLl9vcHRpb25zLnRpbWVwaWNrZXIuaW5saW5lKSAmJiAoaSA9IHsgdGltZXBpY2tlck9wdGlvbnM6IGksIGlubGluZTogITAgfSksIHRoaXMuX3RpbWVwaWNrZXIgPSBuZXcgbmcodCwgaSwge1xuICAgICAgLi4udGhpcy5fY2xhc3Nlcy50aW1lcGlja2VyXG4gICAgfSksIHRoaXMuX3RpbWVwaWNrZXIuaW5wdXQudmFsdWUgPSB0aGlzLl90aW1lVmFsdWU7XG4gIH1cbiAgX2FkZEljb25CdXR0b25zKCkge1xuICAgIGlmIChoLmFkZENsYXNzKERlLCB0aGlzLl9jbGFzc2VzLmJ1dHRvbnNDb250YWluZXIpLCBEZS5pbm5lckhUTUwgPSBRMChcbiAgICAgIHRoaXMuX29wdGlvbnMuZGF0ZXBpY2tlclRvZ2dsZUljb25UZW1wbGF0ZSxcbiAgICAgIHRoaXMuX29wdGlvbnMudGltZXBpY2tlclRvZ2dsZUljb25UZW1wbGF0ZSxcbiAgICAgIHRoaXMuX2NsYXNzZXNcbiAgICApLCBEZS5yZW1vdmVBdHRyaWJ1dGUoWWwpLCAhKHRoaXMuX29wdGlvbnMuaW5saW5lIHx8IHRoaXMuX29wdGlvbnMuZGF0ZXBpY2tlci5pbmxpbmUpKSB7XG4gICAgICBpZiAodGhpcy5fc2Nyb2xsQmFyLmhpZGUoKSwgdGhpcy5fZGF0ZXBpY2tlci5faXNPcGVuKVxuICAgICAgICBkLmZpbmRPbmUoXG4gICAgICAgICAgYFske3RDfV1gLFxuICAgICAgICAgIGRvY3VtZW50LmJvZHlcbiAgICAgICAgKS5hcHBlbmRDaGlsZChEZSk7XG4gICAgICBlbHNlIGlmICh0aGlzLl90aW1lcGlja2VyLl9tb2RhbCAmJiAhdGhpcy5fb3B0aW9ucy50aW1lcGlja2VyLmlubGluZSkge1xuICAgICAgICBjb25zdCB0ID0gZC5maW5kT25lKFxuICAgICAgICAgIF9DLFxuICAgICAgICAgIGRvY3VtZW50LmJvZHlcbiAgICAgICAgKSwgZSA9IGQuZmluZE9uZShcbiAgICAgICAgICBmQyxcbiAgICAgICAgICBkb2N1bWVudC5ib2R5XG4gICAgICAgICk7XG4gICAgICAgIERlLnNldEF0dHJpYnV0ZShZbCwgXCJcIiksIHQuaW5zZXJ0QmVmb3JlKERlLCBlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgX2VuYWJsZU9yRGlzYWJsZVRvZ2dsZUJ1dHRvbigpIHtcbiAgICB0aGlzLl9vcHRpb25zLmRpc2FibGVkID8gKHRoaXMudG9nZ2xlQnV0dG9uLmRpc2FibGVkID0gITAsIGguYWRkQ2xhc3ModGhpcy50b2dnbGVCdXR0b24sIFwicG9pbnRlci1ldmVudHMtbm9uZVwiKSkgOiAodGhpcy50b2dnbGVCdXR0b24uZGlzYWJsZWQgPSAhMSwgaC5yZW1vdmVDbGFzcyh0aGlzLnRvZ2dsZUJ1dHRvbiwgXCJwb2ludGVyLWV2ZW50cy1ub25lXCIpKTtcbiAgfVxuICBfYXBwZW5kVG9nZ2xlQnV0dG9uKCkge1xuICAgIHRoaXMuX29wdGlvbnMudG9nZ2xlQnV0dG9uICYmICh0aGlzLl9lbGVtZW50Lmluc2VydEFkamFjZW50SFRNTChcbiAgICAgIFwiYmVmb3JlZW5kXCIsXG4gICAgICBKMChcbiAgICAgICAgdGhpcy5fb3B0aW9ucy5kYXRlVGltZXBpY2tlclRvZ2dsZUljb25UZW1wbGF0ZSxcbiAgICAgICAgdGhpcy5fY2xhc3Nlc1xuICAgICAgKVxuICAgICksIHRoaXMuX2VuYWJsZU9yRGlzYWJsZVRvZ2dsZUJ1dHRvbigpKTtcbiAgfVxuICBfYXBwbHlGb3JtYXRQbGFjZWhvbGRlcigpIHtcbiAgICB0aGlzLl9vcHRpb25zLnNob3dGb3JtYXQgJiYgKHRoaXMuX2lucHV0LnBsYWNlaG9sZGVyID0gdGhpcy5fZm9ybWF0KTtcbiAgfVxuICBfbGlzdGVuVG9DYW5jZWxDbGljaygpIHtcbiAgICBjb25zdCB0ID0gZC5maW5kT25lKFxuICAgICAgYFske2VDfV1gLFxuICAgICAgZG9jdW1lbnQuYm9keVxuICAgICk7XG4gICAgYy5vbmUodCwgXCJtb3VzZWRvd25cIiwgKCkgPT4ge1xuICAgICAgdGhpcy5fY2FuY2VsID0gITAsIHRoaXMuX3Njcm9sbEJhci5yZXNldCgpLCBjLm9mZih0LCBcIm1vdXNlZG93blwiKTtcbiAgICB9KTtcbiAgfVxuICBfbGlzdGVuVG9Ub2dnbGVDbGljaygpIHtcbiAgICBjLm9uKHRoaXMuX2VsZW1lbnQsIFwiY2xpY2tcIiwgcEMsICh0KSA9PiB7XG4gICAgICB0LnByZXZlbnREZWZhdWx0KCksIHRoaXMuX29wZW5EYXRlUGlja2VyKCk7XG4gICAgfSk7XG4gIH1cbiAgX2xpc3RlblRvVXNlcklucHV0KCkge1xuICAgIGMub24odGhpcy5faW5wdXQsIFwiaW5wdXRcIiwgKHQpID0+IHtcbiAgICAgIHRoaXMuX2hhbmRsZUlucHV0KHQudGFyZ2V0LnZhbHVlKTtcbiAgICB9KTtcbiAgfVxuICBfZGlzYWJsZUlucHV0KCkge1xuICAgIHRoaXMuX29wdGlvbnMuZGlzYWJsZWQgJiYgKHRoaXMuX2lucHV0LmRpc2FibGVkID0gXCJ0cnVlXCIpO1xuICB9XG4gIF9nZXRDb25maWcodCkge1xuICAgIGNvbnN0IGUgPSBoLmdldERhdGFBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpO1xuICAgIHJldHVybiB0ID0ge1xuICAgICAgLi4uemwsXG4gICAgICAuLi5lLFxuICAgICAgLi4udFxuICAgIH0sIEQoUXMsIHQsIHZDKSwgdDtcbiAgfVxuICBfZ2V0Q2xhc3Nlcyh0KSB7XG4gICAgY29uc3QgZSA9IGguZ2V0RGF0YUNsYXNzQXR0cmlidXRlcyh0aGlzLl9lbGVtZW50KTtcbiAgICByZXR1cm4gdCA9IHtcbiAgICAgIC4uLlRDLFxuICAgICAgLi4uZSxcbiAgICAgIC4uLnRcbiAgICB9LCBEKFFzLCB0LCBFQyksIHQ7XG4gIH1cbiAgX2hhbmRsZUlucHV0KHQpIHtcbiAgICBjb25zdCBlID0gdC5zcGxpdChcIiwgXCIpLCBpID0gRzAodGhpcy5fZm9ybWF0KSwgbiA9IGVbMF0sIG8gPSBlWzFdIHx8IFwiXCIsIHIgPSBxMChcbiAgICAgIG4sXG4gICAgICB0aGlzLl9mb3JtYXQsXG4gICAgICBpLFxuICAgICAgdGhpcy5fZGF0ZXBpY2tlci5fb3B0aW9uc1xuICAgICk7XG4gICAgZS5sZW5ndGggPT09IDIgJiYgKHowKHIpICYmIEswKG8pID8gKHRoaXMuX2RhdGVWYWx1ZSA9IG4sIHRoaXMuX3RpbWVWYWx1ZSA9IG8sIHRoaXMuX2RhdGVwaWNrZXIuX2lucHV0LnZhbHVlID0gdGhpcy5fZGF0ZVZhbHVlLCB0aGlzLl9kYXRlcGlja2VyLl9hY3RpdmVEYXRlID0gdGhpcy5fZGF0ZVZhbHVlLCB0aGlzLl9kYXRlcGlja2VyLl9zZWxlY3RlZFllYXIgPSBYMChyKSwgdGhpcy5fZGF0ZXBpY2tlci5fc2VsZWN0ZWRNb250aCA9IFUwKHIpLCB0aGlzLl9kYXRlcGlja2VyLl9oZWFkZXJEYXRlID0gciwgdGhpcy5fdGltZXBpY2tlci5pbnB1dC52YWx1ZSA9IHRoaXMuX3RpbWVWYWx1ZSwgdGhpcy5fdGltZXBpY2tlci5faXNJbnZhbGlkVGltZUZvcm1hdCA9ICExKSA6ICh0aGlzLl9kYXRlcGlja2VyLl9hY3RpdmVEYXRlID0gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCksIHRoaXMuX2RhdGVwaWNrZXIuX3NlbGVjdGVkRGF0ZSA9IG51bGwsIHRoaXMuX2RhdGVwaWNrZXIuX3NlbGVjdGVkTW9udGggPSBudWxsLCB0aGlzLl9kYXRlcGlja2VyLl9zZWxlY3RlZFllYXIgPSBudWxsLCB0aGlzLl9kYXRlcGlja2VyLl9oZWFkZXJEYXRlID0gbnVsbCwgdGhpcy5fZGF0ZXBpY2tlci5faGVhZGVyTW9udGggPSBudWxsLCB0aGlzLl9kYXRlcGlja2VyLl9oZWFkZXJZZWFyID0gbnVsbCwgdGhpcy5fdGltZXBpY2tlci5faXNJbnZhbGlkVGltZUZvcm1hdCA9ICEwKSk7XG4gIH1cbiAgX29wZW5EYXRlUGlja2VyKCkge1xuICAgIGlmIChjLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgbUMpLmRlZmF1bHRQcmV2ZW50ZWQpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5fZGF0ZXBpY2tlci5vcGVuKCksIHRoaXMuX29wdGlvbnMuaW5saW5lIHx8IHRoaXMuX3Njcm9sbEJhci5oaWRlKCksICh0aGlzLl9vcHRpb25zLmlubGluZSB8fCB0aGlzLl9vcHRpb25zLmRhdGVwaWNrZXIuaW5saW5lKSAmJiB0aGlzLl9vcGVuRHJvcGRvd25EYXRlKCksIHRoaXMuX2FkZEljb25CdXR0b25zKCksIHRoaXMuX2xpc3RlblRvQ2FuY2VsQ2xpY2soKSwgdGhpcy5fb3B0aW9ucy5pbmxpbmUgJiYgdGhpcy5fZGF0ZXBpY2tlci5faXNPcGVuICYmIGguYWRkQ2xhc3ModGhpcy50b2dnbGVCdXR0b24sIFwicG9pbnRlci1ldmVudHMtbm9uZVwiKSwgYy5vbmUodGhpcy5fZGF0ZXBpY2tlci5fZWxlbWVudCwgamwsICgpID0+IHtcbiAgICAgIGlmICh0aGlzLl9kYXRlVmFsdWUgPSB0aGlzLl9kYXRlcGlja2VyLl9pbnB1dC52YWx1ZSwgdGhpcy5fdXBkYXRlSW5wdXRWYWx1ZSgpLCB0aGlzLl9jYW5jZWwpIHtcbiAgICAgICAgdGhpcy5fY2FuY2VsID0gITE7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGMub24odGhpcy5fZGF0ZXBpY2tlci5jb250YWluZXIsIFwiY2xpY2tcIiwgKGkpID0+IHtcbiAgICAgICAgIXRoaXMuX2RhdGVwaWNrZXIuX3NlbGVjdGVkRGF0ZSAmJiBpLnRhcmdldC5oYXNBdHRyaWJ1dGUoaUMpIHx8IHRoaXMuX29wZW5UaW1lUGlja2VyKCk7XG4gICAgICB9KSwgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGQuZmluZE9uZShcbiAgICAgICAgICBgWyR7a299XWAsXG4gICAgICAgICAgZG9jdW1lbnQuYm9keVxuICAgICAgICApIHx8IHRoaXMuX3Njcm9sbEJhci5yZXNldCgpO1xuICAgICAgfSwgMTApLCB0aGlzLl9vcHRpb25zLmlubGluZSAmJiBoLnJlbW92ZUNsYXNzKHRoaXMudG9nZ2xlQnV0dG9uLCBcInBvaW50ZXItZXZlbnRzLW5vbmVcIik7XG4gICAgfSk7XG4gICAgY29uc3QgZSA9IGQuZmluZE9uZShcbiAgICAgIGRDLFxuICAgICAgZG9jdW1lbnQuYm9keVxuICAgICk7XG4gICAgYy5vbihlLCBcImNsaWNrXCIsICgpID0+IHtcbiAgICAgIHRoaXMuX2RhdGVwaWNrZXIuY2xvc2UoKSwgdGhpcy5fc2Nyb2xsQmFyLmhpZGUoKSwgYy50cmlnZ2VyKHRoaXMuX2RhdGVwaWNrZXIuX2VsZW1lbnQsIGpsKTtcbiAgICB9KTtcbiAgfVxuICBfaGFuZGxlVGltZXBpY2tlckRpc2FibGVQYXN0KCkge1xuICAgIGNvbnN0IHQgPSAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKTtcbiAgICB0LnNldEhvdXJzKDAsIDAsIDAsIDApLCBjLm9uKFxuICAgICAgdGhpcy5fZGF0ZXBpY2tlci5fZWxlbWVudCxcbiAgICAgIFwiZGF0ZUNoYW5nZS50ZS5kYXRlcGlja2VyXCIsXG4gICAgICAoKSA9PiB7XG4gICAgICAgIHRoaXMuX2RhdGVwaWNrZXIuX3NlbGVjdGVkRGF0ZS5nZXRUaW1lKCkgPT09IHQuZ2V0VGltZSgpID8gdGhpcy5fdGltZXBpY2tlci51cGRhdGUoeyBkaXNhYmxlUGFzdDogITAgfSkgOiB0aGlzLl90aW1lcGlja2VyLnVwZGF0ZSh7IGRpc2FibGVQYXN0OiAhMSB9KTtcbiAgICAgIH1cbiAgICApO1xuICB9XG4gIF9oYW5kbGVUaW1lcGlja2VyRGlzYWJsZUZ1dHVyZSgpIHtcbiAgICBjb25zdCB0ID0gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCk7XG4gICAgdC5zZXRIb3VycygwLCAwLCAwLCAwKSwgYy5vbihcbiAgICAgIHRoaXMuX2RhdGVwaWNrZXIuX2VsZW1lbnQsXG4gICAgICBcImRhdGVDaGFuZ2UudGUuZGF0ZXBpY2tlclwiLFxuICAgICAgKCkgPT4ge1xuICAgICAgICB0aGlzLl9kYXRlcGlja2VyLl9zZWxlY3RlZERhdGUuZ2V0VGltZSgpID09PSB0LmdldFRpbWUoKSA/IHRoaXMuX3RpbWVwaWNrZXIudXBkYXRlKHsgZGlzYWJsZUZ1dHVyZTogITAgfSkgOiB0aGlzLl90aW1lcGlja2VyLnVwZGF0ZSh7IGRpc2FibGVGdXR1cmU6ICExIH0pO1xuICAgICAgfVxuICAgICk7XG4gIH1cbiAgX2hhbmRsZUVzY2FwZUtleSgpIHtcbiAgICBjLm9uZShkb2N1bWVudC5ib2R5LCBcImtleXVwXCIsICgpID0+IHtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBkLmZpbmRPbmUoXG4gICAgICAgICAgYFske2tvfV1gLFxuICAgICAgICAgIGRvY3VtZW50LmJvZHlcbiAgICAgICAgKSB8fCB0aGlzLl9zY3JvbGxCYXIucmVzZXQoKTtcbiAgICAgIH0sIDI1MCk7XG4gICAgfSk7XG4gIH1cbiAgX2hhbmRsZUNhbmNlbEJ1dHRvbigpIHtcbiAgICBjb25zdCB0ID0gZC5maW5kT25lKFxuICAgICAgYFske0ZsfV1gLFxuICAgICAgZG9jdW1lbnQuYm9keVxuICAgICk7XG4gICAgYy5vbmUodCwgXCJtb3VzZWRvd25cIiwgKCkgPT4ge1xuICAgICAgdGhpcy5fc2Nyb2xsQmFyLnJlc2V0KCk7XG4gICAgfSk7XG4gIH1cbiAgX29wZW5Ecm9wZG93bkRhdGUoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuX2RhdGVwaWNrZXIuX3BvcHBlcjtcbiAgICB0LnN0YXRlLmVsZW1lbnRzLnJlZmVyZW5jZSA9IHRoaXMuX2lucHV0LCB0aGlzLl9zY3JvbGxCYXIucmVzZXQoKTtcbiAgfVxuICBfb3BlblRpbWVQaWNrZXIoKSB7XG4gICAgYy50cmlnZ2VyKHRoaXMuX3RpbWVwaWNrZXIuZWxlbWVudFRvZ2dsZSwgXCJjbGlja1wiKSwgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBpZiAodGhpcy5fYWRkSWNvbkJ1dHRvbnMoKSwgKHRoaXMuX29wdGlvbnMuaW5saW5lIHx8IHRoaXMuX29wdGlvbnMudGltZXBpY2tlci5pbmxpbmUpICYmIHRoaXMuX29wZW5Ecm9wZG93blRpbWUoKSwgdGhpcy5fdGltZXBpY2tlci5fbW9kYWwpIHtcbiAgICAgICAgY29uc3QgdCA9IGQuZmluZE9uZShcbiAgICAgICAgICBgWyR7Rmx9XWAsXG4gICAgICAgICAgZG9jdW1lbnQuYm9keVxuICAgICAgICApO1xuICAgICAgICB0aGlzLl9oYW5kbGVFc2NhcGVLZXkoKSwgdGhpcy5faGFuZGxlQ2FuY2VsQnV0dG9uKCksIGMub24odGhpcy5fdGltZXBpY2tlci5fbW9kYWwsIFwiY2xpY2tcIiwgKGUpID0+IHtcbiAgICAgICAgICAoZS50YXJnZXQuaGFzQXR0cmlidXRlKGtvKSB8fCBlLnRhcmdldC5oYXNBdHRyaWJ1dGUoc0MpKSAmJiBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX3Njcm9sbEJhci5yZXNldCgpO1xuICAgICAgICAgIH0sIDIwMCksIGUudGFyZ2V0Lmhhc0F0dHJpYnV0ZShuQykgJiYgYy50cmlnZ2VyKFxuICAgICAgICAgICAgdGhpcy5fdGltZXBpY2tlci5fZWxlbWVudCxcbiAgICAgICAgICAgIEtsXG4gICAgICAgICAgKSwgZS50YXJnZXQuaGFzQXR0cmlidXRlKHJDKSAmJiAoYy50cmlnZ2VyKHQsIFwiY2xpY2tcIiksIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fb3BlbkRhdGVQaWNrZXIoKSwgdGhpcy5fc2Nyb2xsQmFyLmhpZGUoKTtcbiAgICAgICAgICB9LCAyMDApKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSksIGMub25lKHRoaXMuX3RpbWVwaWNrZXIuX2VsZW1lbnQsIEtsLCAoKSA9PiB7XG4gICAgICB0aGlzLl90aW1lVmFsdWUgPSB0aGlzLl90aW1lcGlja2VyLmlucHV0LnZhbHVlLCB0aGlzLl91cGRhdGVJbnB1dFZhbHVlKCksIGMudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBnQyk7XG4gICAgfSk7XG4gIH1cbiAgX29wZW5Ecm9wZG93blRpbWUoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuX3RpbWVwaWNrZXIuX3BvcHBlcjtcbiAgICB0LnN0YXRlLmVsZW1lbnRzLnJlZmVyZW5jZSA9IHRoaXMuX2lucHV0LCB0LnVwZGF0ZSgpLCB0aGlzLl9zY3JvbGxCYXIucmVzZXQoKTtcbiAgfVxuICBfc2V0SW5pdGlhbERlZmF1bHRJbnB1dCgpIHtcbiAgICAodGhpcy5fb3B0aW9ucy5kZWZhdWx0RGF0ZSB8fCB0aGlzLl9vcHRpb25zLmRlZmF1bHRUaW1lKSAmJiB0aGlzLl91cGRhdGVJbnB1dFZhbHVlKCk7XG4gIH1cbiAgX3VwZGF0ZUlucHV0VmFsdWUoKSB7XG4gICAgdGhpcy5fdGltZVZhbHVlICYmIHRoaXMuX2RhdGVWYWx1ZSAmJiAodGhpcy5faW5wdXQudmFsdWUgPSBgJHt0aGlzLl9kYXRlVmFsdWV9LCAke3RoaXMuX3RpbWVWYWx1ZX1gLCBjLnRyaWdnZXIoXG4gICAgICB0aGlzLl9lbGVtZW50LFxuICAgICAgYkNcbiAgICApLmRlZmF1bHRQcmV2ZW50ZWQpIHx8IChjLnRyaWdnZXIodGhpcy5faW5wdXQsIFwiZm9jdXNcIiksIHRoaXMubm90Y2ggJiYgdGhpcy5ub3RjaC5yZW1vdmVBdHRyaWJ1dGUoXCJkYXRhLXRlLWlucHV0LWZvY3VzZWRcIikpO1xuICB9XG4gIC8vIHN0YXRpY1xuICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKHQsIGUpIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgbGV0IGkgPSB5LmdldERhdGEodGhpcywga2kpO1xuICAgICAgY29uc3QgbiA9IHR5cGVvZiB0ID09IFwib2JqZWN0XCIgJiYgdDtcbiAgICAgIGlmICghKCFpICYmIC9kaXNwb3NlLy50ZXN0KHQpKSAmJiAoaSB8fCAoaSA9IG5ldyBJaCh0aGlzLCBuKSksIHR5cGVvZiB0ID09IFwic3RyaW5nXCIpKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaVt0XSA+IFwidVwiKVxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcIiR7dH1cImApO1xuICAgICAgICBpW3RdKGUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHN0YXRpYyBnZXRJbnN0YW5jZSh0KSB7XG4gICAgcmV0dXJuIHkuZ2V0RGF0YSh0LCBraSk7XG4gIH1cbiAgc3RhdGljIGdldE9yQ3JlYXRlSW5zdGFuY2UodCwgZSA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0SW5zdGFuY2UodCkgfHwgbmV3IHRoaXModCwgdHlwZW9mIGUgPT0gXCJvYmplY3RcIiA/IGUgOiBudWxsKTtcbiAgfVxufVxuY29uc3QgSnMgPSBcInN0aWNreVwiLCB4aSA9IGB0ZS4ke0pzfWAsIERoID0gYC4ke3hpfWAsIENDID0gYGFjdGl2ZSR7RGh9YCwgQUMgPSBgaW5hY3RpdmUke0RofWAsIHlDID0ge1xuICBzdGlja3lBbmltYXRpb25TdGlja3k6IFwiXCIsXG4gIHN0aWNreUFuaW1hdGlvblVuc3RpY2t5OiBcIlwiLFxuICBzdGlja3lCb3VuZGFyeTogITEsXG4gIHN0aWNreURlbGF5OiAwLFxuICBzdGlja3lEaXJlY3Rpb246IFwiZG93blwiLFxuICBzdGlja3lNZWRpYTogMCxcbiAgc3RpY2t5T2Zmc2V0OiAwLFxuICBzdGlja3lQb3NpdGlvbjogXCJ0b3BcIixcbiAgc3RpY2t5WkluZGV4OiAxMDBcbn0sIHdDID0ge1xuICBzdGlja3lBbmltYXRpb25TdGlja3k6IFwic3RyaW5nXCIsXG4gIHN0aWNreUFuaW1hdGlvblVuc3RpY2t5OiBcInN0cmluZ1wiLFxuICBzdGlja3lCb3VuZGFyeTogXCIoYm9vbGVhbnxzdHJpbmcpXCIsXG4gIHN0aWNreURlbGF5OiBcIm51bWJlclwiLFxuICBzdGlja3lEaXJlY3Rpb246IFwic3RyaW5nXCIsXG4gIHN0aWNreU1lZGlhOiBcIm51bWJlclwiLFxuICBzdGlja3lPZmZzZXQ6IFwibnVtYmVyXCIsXG4gIHN0aWNreVBvc2l0aW9uOiBcInN0cmluZ1wiLFxuICBzdGlja3laSW5kZXg6IFwiKHN0cmluZ3xudW1iZXIpXCJcbn0sIGtDID0ge1xuICBzdGlja3lBY3RpdmU6IFwiXCJcbn0sIHhDID0ge1xuICBzdGlja3lBY3RpdmU6IFwic3RyaW5nXCJcbn07XG5jbGFzcyAkaCB7XG4gIGNvbnN0cnVjdG9yKHQsIGUsIGkpIHtcbiAgICB0aGlzLl9lbGVtZW50ID0gdCwgdGhpcy5faGlkZGVuRWxlbWVudCA9IG51bGwsIHRoaXMuX2VsZW1lbnRQb3NpdGlvblN0eWxlcyA9IHt9LCB0aGlzLl9zY3JvbGxEaXJlY3Rpb24gPSBcIlwiLCB0aGlzLl9pc1N0aWNrZWQgPSAhMSwgdGhpcy5fZWxlbWVudE9mZnNldFRvcCA9IG51bGwsIHRoaXMuX3Njcm9sbFRvcCA9IDAsIHRoaXMuX3B1c2hQb2ludCA9IFwiXCIsIHRoaXMuX21hbnVhbGx5RGVhY3RpdmF0ZWQgPSAhMSwgdGhpcy5fZWxlbWVudCAmJiAodGhpcy5fb3B0aW9ucyA9IHRoaXMuX2dldENvbmZpZyhlKSwgdGhpcy5fY2xhc3NlcyA9IHRoaXMuX2dldENsYXNzZXMoaSksIHkuc2V0RGF0YSh0LCB4aSwgdGhpcyksIHRoaXMuX2luaXQoKSk7XG4gIH1cbiAgLy8gR2V0dGVyc1xuICBzdGF0aWMgZ2V0IE5BTUUoKSB7XG4gICAgcmV0dXJuIEpzO1xuICB9XG4gIC8vIFB1YmxpY1xuICBkaXNwb3NlKCkge1xuICAgIGNvbnN0IHsgc3RpY2t5QW5pbWF0aW9uVW5zdGlja3k6IHQgfSA9IHRoaXMuX29wdGlvbnM7XG4gICAgbGV0IHsgYW5pbWF0aW9uRHVyYXRpb246IGUgfSA9IGdldENvbXB1dGVkU3R5bGUodGhpcy5fZWxlbWVudCk7XG4gICAgZSA9IHQgIT09IFwiXCIgPyBwYXJzZUZsb2F0KGUpICogMWUzIDogMCwgdGhpcy5fZGlzYWJsZVN0aWNreSgpLCBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHkucmVtb3ZlRGF0YSh0aGlzLl9lbGVtZW50LCB4aSksIHRoaXMuX2VsZW1lbnQgPSBudWxsLCB0aGlzLl9vcHRpb25zID0gbnVsbCwgdGhpcy5faGlkZGVuRWxlbWVudCA9IG51bGwsIHRoaXMuX2VsZW1lbnRQb3NpdGlvblN0eWxlcyA9IG51bGwsIHRoaXMuX3Njcm9sbERpcmVjdGlvbiA9IG51bGwsIHRoaXMuX2lzU3RpY2tlZCA9IG51bGwsIHRoaXMuX2VsZW1lbnRPZmZzZXRUb3AgPSBudWxsLCB0aGlzLl9zY3JvbGxUb3AgPSBudWxsLCB0aGlzLl9wdXNoUG9pbnQgPSBudWxsLCB0aGlzLl9tYW51YWxseURlYWN0aXZhdGVkID0gbnVsbDtcbiAgICB9LCBlKTtcbiAgfVxuICBhY3RpdmUoKSB7XG4gICAgdGhpcy5faXNTdGlja2VkIHx8ICh0aGlzLl9jcmVhdGVIaWRkZW5FbGVtZW50KCksIHRoaXMuX2VuYWJsZVN0aWNreSgpLCB0aGlzLl9jaGFuZ2VCb3VuZGFyeVBvc2l0aW9uKCksIHRoaXMuX2lzU3RpY2tlZCA9ICEwLCB0aGlzLl9tYW51YWxseURlYWN0aXZhdGVkID0gITEpO1xuICB9XG4gIGluYWN0aXZlKCkge1xuICAgIHRoaXMuX2lzU3RpY2tlZCAmJiAodGhpcy5fZGlzYWJsZVN0aWNreSgpLCB0aGlzLl9pc1N0aWNrZWQgPSAhMSwgdGhpcy5fbWFudWFsbHlEZWFjdGl2YXRlZCA9ICEwKTtcbiAgfVxuICAvLyBQcml2YXRlXG4gIF9pbml0KCkge1xuICAgIHRoaXMuX3VzZXJBY3Rpdml0eUxpc3RlbmVyKCk7XG4gIH1cbiAgX3VzZXJBY3Rpdml0eUxpc3RlbmVyKCkge1xuICAgIGMub24od2luZG93LCBcInJlc2l6ZVwiLCAoKSA9PiB7XG4gICAgICB0aGlzLl91cGRhdGVFbGVtZW50UG9zaXRpb24oKSwgdGhpcy5fdXBkYXRlRWxlbWVudE9mZnNldCgpO1xuICAgIH0pLCBjLm9uKHdpbmRvdywgXCJzY3JvbGxcIiwgKCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLl9lbGVtZW50IHx8IHdpbmRvdy5pbm5lcldpZHRoIDw9IHRoaXMuX29wdGlvbnMuc3RpY2t5TWVkaWEgfHwgdGhpcy5fbWFudWFsbHlEZWFjdGl2YXRlZClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY29uc3QgdCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgeyBzdGlja3lEaXJlY3Rpb246IGUgfSA9IHRoaXMuX29wdGlvbnMsIGkgPSB3aW5kb3cucGFnZVlPZmZzZXQgfHwgdC5zY3JvbGxUb3A7XG4gICAgICB0aGlzLl91cGRhdGVFbGVtZW50T2Zmc2V0KCksIHRoaXMuX3VwZGF0ZVB1c2hQb2ludCgpLCB0aGlzLl91cGRhdGVTY3JvbGxEaXJlY3Rpb24oaSksIHRoaXMuX2NsZWFySW5Qcm9ncmVzc0FuaW1hdGlvbnMoKTtcbiAgICAgIGNvbnN0IG4gPSBbdGhpcy5fc2Nyb2xsRGlyZWN0aW9uLCBcImJvdGhcIl0uaW5jbHVkZXMoXG4gICAgICAgIGVcbiAgICAgICksIG8gPSB0aGlzLl9wdXNoUG9pbnQgPD0gaSwgciA9IG8gJiYgIXRoaXMuX2lzU3RpY2tlZCAmJiBuLCBhID0gKCFvIHx8ICFuKSAmJiB0aGlzLl9pc1N0aWNrZWQ7XG4gICAgICByICYmICh0aGlzLl9jcmVhdGVIaWRkZW5FbGVtZW50KCksIHRoaXMuX2VuYWJsZVN0aWNreSgpLCB0aGlzLl9jaGFuZ2VCb3VuZGFyeVBvc2l0aW9uKCksIHRoaXMuX2lzU3RpY2tlZCA9ICEwKSwgYSAmJiAodGhpcy5fZGlzYWJsZVN0aWNreSgpLCB0aGlzLl9pc1N0aWNrZWQgPSAhMSksIHRoaXMuX2lzU3RpY2tlZCAmJiAodGhpcy5fdXBkYXRlUG9zaXRpb24oeyBzdHlsZXM6IHRoaXMuX2VsZW1lbnRQb3NpdGlvblN0eWxlcyB9KSwgdGhpcy5fY2hhbmdlQm91bmRhcnlQb3NpdGlvbigpKSwgdGhpcy5fc2Nyb2xsVG9wID0gaSA8PSAwID8gMCA6IGk7XG4gICAgfSk7XG4gIH1cbiAgX3VwZGF0ZVB1c2hQb2ludCgpIHtcbiAgICB0aGlzLl9vcHRpb25zLnN0aWNreVBvc2l0aW9uID09PSBcInRvcFwiID8gdGhpcy5fcHVzaFBvaW50ID0gdGhpcy5fZWxlbWVudE9mZnNldFRvcCAtIHRoaXMuX29wdGlvbnMuc3RpY2t5RGVsYXkgOiB0aGlzLl9wdXNoUG9pbnQgPSB0aGlzLl9lbGVtZW50T2Zmc2V0VG9wICsgdGhpcy5fZWxlbWVudC5oZWlnaHQgLSBkb2N1bWVudC5ib2R5LnNjcm9sbEhlaWdodCArIHRoaXMuX29wdGlvbnMuc3RpY2t5RGVsYXk7XG4gIH1cbiAgX3VwZGF0ZUVsZW1lbnRPZmZzZXQoKSB7XG4gICAgdGhpcy5faGlkZGVuRWxlbWVudCA/IHRoaXMuX2VsZW1lbnRPZmZzZXRUb3AgPSB0aGlzLl9oaWRkZW5FbGVtZW50Lm9mZnNldFRvcCA6IHRoaXMuX2VsZW1lbnRPZmZzZXRUb3AgPSB0aGlzLl9lbGVtZW50Lm9mZnNldFRvcCwgdGhpcy5fb3B0aW9ucy5zdGlja3lBbmltYXRpb25VbnN0aWNreSAmJiAodGhpcy5fZWxlbWVudE9mZnNldFRvcCArPSB0aGlzLl9lbGVtZW50LmhlaWdodCB8fCAwKTtcbiAgfVxuICBfdXBkYXRlRWxlbWVudFBvc2l0aW9uKCkge1xuICAgIGlmICh0aGlzLl9oaWRkZW5FbGVtZW50KSB7XG4gICAgICBjb25zdCB7IGxlZnQ6IHQgfSA9IHRoaXMuX2hpZGRlbkVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICB0aGlzLl9lbGVtZW50UG9zaXRpb25TdHlsZXMgPSB7XG4gICAgICAgIGxlZnQ6IGAke3R9cHhgXG4gICAgICB9O1xuICAgIH0gZWxzZVxuICAgICAgdGhpcy5fZWxlbWVudFBvc2l0aW9uU3R5bGVzID0ge307XG4gICAgdGhpcy5fc2V0U3R5bGUodGhpcy5fZWxlbWVudCwgdGhpcy5fZWxlbWVudFBvc2l0aW9uU3R5bGVzKTtcbiAgfVxuICBfdXBkYXRlU2Nyb2xsRGlyZWN0aW9uKHQpIHtcbiAgICB0ID4gdGhpcy5fc2Nyb2xsVG9wID8gdGhpcy5fc2Nyb2xsRGlyZWN0aW9uID0gXCJkb3duXCIgOiB0aGlzLl9zY3JvbGxEaXJlY3Rpb24gPSBcInVwXCI7XG4gIH1cbiAgX2NsZWFySW5Qcm9ncmVzc0FuaW1hdGlvbnMoKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuX3Njcm9sbERpcmVjdGlvbiA9PT0gXCJ1cFwiLCBlID0gdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoXG4gICAgICB0aGlzLl9vcHRpb25zLnN0aWNreUFuaW1hdGlvblVuc3RpY2t5XG4gICAgKSwgaSA9IHdpbmRvdy5zY3JvbGxZIDw9IHRoaXMuX2VsZW1lbnRPZmZzZXRUb3AgLSB0aGlzLl9lbGVtZW50LmhlaWdodDtcbiAgICB0ICYmIGUgJiYgaSAmJiAodGhpcy5fcmVtb3ZlVW5zdGlja3lBbmltYXRpb24oKSwgdGhpcy5fcmVzZXRTdHlsZXMoKSwgdGhpcy5fcmVtb3ZlSGlkZGVuRWxlbWVudCgpKTtcbiAgfVxuICBfZW5hYmxlU3RpY2t5KCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHN0aWNreUFuaW1hdGlvblN0aWNreTogdCxcbiAgICAgIHN0aWNreUFuaW1hdGlvblVuc3RpY2t5OiBlLFxuICAgICAgc3RpY2t5T2Zmc2V0OiBpLFxuICAgICAgc3RpY2t5UG9zaXRpb246IG4sXG4gICAgICBzdGlja3laSW5kZXg6IG9cbiAgICB9ID0gdGhpcy5fb3B0aW9ucywgeyBoZWlnaHQ6IHIsIGxlZnQ6IGEsIHdpZHRoOiBsIH0gPSB0aGlzLl9lbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHQgIT09IFwiXCIgJiYgdGhpcy5fdG9nZ2xlQ2xhc3MoXG4gICAgICB0LFxuICAgICAgZSxcbiAgICAgIHRoaXMuX2VsZW1lbnRcbiAgICApLCB0aGlzLl90b2dnbGVDbGFzcyh0aGlzLl9jbGFzc2VzLnN0aWNreUFjdGl2ZSwgXCJcIiwgdGhpcy5fZWxlbWVudCksIHRoaXMuX3NldFN0eWxlKHRoaXMuX2VsZW1lbnQsIHtcbiAgICAgIHRvcDogbiA9PT0gXCJ0b3BcIiAmJiBgJHswICsgaX1weGAsXG4gICAgICBib3R0b206IG4gPT09IFwiYm90dG9tXCIgJiYgYCR7MCArIGl9cHhgLFxuICAgICAgaGVpZ2h0OiBgJHtyfXB4YCxcbiAgICAgIHdpZHRoOiBgJHtsfXB4YCxcbiAgICAgIGxlZnQ6IGAke2F9cHhgLFxuICAgICAgekluZGV4OiBgJHtvfWAsXG4gICAgICBwb3NpdGlvbjogXCJmaXhlZFwiXG4gICAgfSksIHRoaXMuX2hpZGRlbkVsZW1lbnQuaGlkZGVuID0gITEsIGMudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBDQyk7XG4gIH1cbiAgX2NoYW5nZUJvdW5kYXJ5UG9zaXRpb24oKSB7XG4gICAgY29uc3QgeyBzdGlja3lQb3NpdGlvbjogdCwgc3RpY2t5Qm91bmRhcnk6IGUsIHN0aWNreU9mZnNldDogaSB9ID0gdGhpcy5fb3B0aW9ucywgeyBoZWlnaHQ6IG4gfSA9IHRoaXMuX2VsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIG8gPSB7XG4gICAgICBoZWlnaHQ6IHRoaXMuX2VsZW1lbnQucGFyZW50RWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQsXG4gICAgICAuLi50aGlzLl9nZXRPZmZzZXQodGhpcy5fZWxlbWVudC5wYXJlbnRFbGVtZW50KVxuICAgIH07XG4gICAgbGV0IHI7XG4gICAgY29uc3QgYSA9IGQuZmluZE9uZShlKTtcbiAgICBhID8gciA9IHRoaXMuX2dldE9mZnNldChhKS50b3AgLSBuIC0gaSA6IHIgPSBvLmhlaWdodCArIG9bdF0gLSBuIC0gaTtcbiAgICBjb25zdCBsID0gdCA9PT0gXCJ0b3BcIiwgcCA9IHQgPT09IFwiYm90dG9tXCIsIHUgPSBlLCBfID0gciA8IDAsIGYgPSByID4gby5oZWlnaHQgLSBuO1xuICAgIGxldCBnO1xuICAgIGwgJiYgKF8gJiYgdSA/IGcgPSB7IHRvcDogYCR7aSArIHJ9cHhgIH0gOiBnID0geyB0b3A6IGAke2kgKyAwfXB4YCB9KSwgcCAmJiAoXyAmJiB1ID8gZyA9IHsgYm90dG9tOiBgJHtpICsgcn1weGAgfSA6IGYgJiYgdSA/IGcgPSB7IGJvdHRvbTogYCR7aSArIG8uYm90dG9tfXB4YCB9IDogZyA9IHsgYm90dG9tOiBgJHtpICsgMH1weGAgfSksIHRoaXMuX3NldFN0eWxlKHRoaXMuX2VsZW1lbnQsIGcpO1xuICB9XG4gIF9kaXNhYmxlU3RpY2t5KCkge1xuICAgIGNvbnN0IHsgc3RpY2t5QW5pbWF0aW9uVW5zdGlja3k6IHQsIHN0aWNreUFuaW1hdGlvblN0aWNreTogZSB9ID0gdGhpcy5fb3B0aW9ucztcbiAgICBsZXQgeyBhbmltYXRpb25EdXJhdGlvbjogaSB9ID0gZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLl9lbGVtZW50KTtcbiAgICBpID0gdCAhPT0gXCJcIiA/IHBhcnNlRmxvYXQoaSkgKiAxZTMgOiAwLCB0aGlzLl9vcHRpb25zLnN0aWNreUFuaW1hdGlvblVuc3RpY2t5ICE9PSBcIlwiICYmIHRoaXMuX3RvZ2dsZUNsYXNzKFxuICAgICAgdCxcbiAgICAgIGUsXG4gICAgICB0aGlzLl9lbGVtZW50XG4gICAgKSwgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhlKSB8fCAodGhpcy5fcmVtb3ZlVW5zdGlja3lBbmltYXRpb24oKSwgdGhpcy5fcmVzZXRTdHlsZXMoKSwgdGhpcy5fcmVtb3ZlSGlkZGVuRWxlbWVudCgpLCB0aGlzLl90b2dnbGVDbGFzcyhcIlwiLCB0aGlzLl9jbGFzc2VzLnN0aWNreUFjdGl2ZSwgdGhpcy5fZWxlbWVudCksIGMudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBBQykpO1xuICAgIH0sIGkpO1xuICB9XG4gIF9jcmVhdGVIaWRkZW5FbGVtZW50KCkge1xuICAgIHRoaXMuX2hpZGRlbkVsZW1lbnQgfHwgKHRoaXMuX2hpZGRlbkVsZW1lbnQgPSB0aGlzLl9jb3B5RWxlbWVudCh0aGlzLl9lbGVtZW50KSk7XG4gIH1cbiAgX3JlbW92ZUhpZGRlbkVsZW1lbnQoKSB7XG4gICAgdGhpcy5faGlkZGVuRWxlbWVudCAmJiAodGhpcy5faGlkZGVuRWxlbWVudC5yZW1vdmUoKSwgdGhpcy5faGlkZGVuRWxlbWVudCA9IG51bGwpO1xuICB9XG4gIF9yZW1vdmVVbnN0aWNreUFuaW1hdGlvbigpIHtcbiAgICB0aGlzLl90b2dnbGVDbGFzcyhcIlwiLCB0aGlzLl9vcHRpb25zLnN0aWNreUFuaW1hdGlvblVuc3RpY2t5LCB0aGlzLl9lbGVtZW50KTtcbiAgfVxuICBfcmVzZXRTdHlsZXMoKSB7XG4gICAgdGhpcy5fc2V0U3R5bGUodGhpcy5fZWxlbWVudCwge1xuICAgICAgdG9wOiBudWxsLFxuICAgICAgYm90dG9tOiBudWxsLFxuICAgICAgcG9zaXRpb246IG51bGwsXG4gICAgICBsZWZ0OiBudWxsLFxuICAgICAgekluZGV4OiBudWxsLFxuICAgICAgd2lkdGg6IG51bGwsXG4gICAgICBoZWlnaHQ6IG51bGxcbiAgICB9KTtcbiAgfVxuICBfdXBkYXRlUG9zaXRpb24oeyBzdHlsZXM6IHQgfSkge1xuICAgIHRoaXMuX3NldFN0eWxlKHRoaXMuX2VsZW1lbnQsIHQpO1xuICB9XG4gIF90b2dnbGVDbGFzcyh0LCBlLCBpKSB7XG4gICAgdCAmJiBoLmFkZENsYXNzKGksIHQpLCBlICYmIGgucmVtb3ZlQ2xhc3MoaSwgZSk7XG4gIH1cbiAgX2dldE9mZnNldCh0KSB7XG4gICAgY29uc3QgZSA9IGgub2Zmc2V0KHQpLCBpID0gdC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgbiA9IGUubGVmdCA9PT0gMCAmJiBlLnRvcCA9PT0gMCA/IDAgOiB3aW5kb3cuaW5uZXJIZWlnaHQgLSBpLmJvdHRvbTtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uZSxcbiAgICAgIGJvdHRvbTogblxuICAgIH07XG4gIH1cbiAgX2NvcHlFbGVtZW50KHQpIHtcbiAgICBjb25zdCB7IGhlaWdodDogZSwgd2lkdGg6IGkgfSA9IHQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIG4gPSB0LmNsb25lTm9kZSghMSk7XG4gICAgcmV0dXJuIG4uaGlkZGVuID0gITAsIHRoaXMuX3NldFN0eWxlKG4sIHtcbiAgICAgIGhlaWdodDogYCR7ZX1weGAsXG4gICAgICB3aWR0aDogYCR7aX1weGAsXG4gICAgICBvcGFjaXR5OiBcIjBcIlxuICAgIH0pLCB0LnBhcmVudEVsZW1lbnQuaW5zZXJ0QmVmb3JlKG4sIHQpLCBuO1xuICB9XG4gIF9nZXRDb25maWcodCA9IHt9KSB7XG4gICAgY29uc3QgZSA9IGguZ2V0RGF0YUF0dHJpYnV0ZXModGhpcy5fZWxlbWVudCk7XG4gICAgcmV0dXJuIHQgPSB7XG4gICAgICAuLi55QyxcbiAgICAgIC4uLmUsXG4gICAgICAuLi50XG4gICAgfSwgRChKcywgdCwgd0MpLCB0O1xuICB9XG4gIF9nZXRDbGFzc2VzKHQpIHtcbiAgICBjb25zdCBlID0gaC5nZXREYXRhQ2xhc3NBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpO1xuICAgIHJldHVybiB0ID0ge1xuICAgICAgLi4ua0MsXG4gICAgICAuLi5lLFxuICAgICAgLi4udFxuICAgIH0sIEQoSnMsIHQsIHhDKSwgdDtcbiAgfVxuICBfc2V0U3R5bGUodCwgZSkge1xuICAgIE9iamVjdC5rZXlzKGUpLmZvckVhY2goKGkpID0+IHtcbiAgICAgIHQuc3R5bGVbaV0gPSBlW2ldO1xuICAgIH0pO1xuICB9XG4gIHN0YXRpYyBqUXVlcnlJbnRlcmZhY2UodCwgZSkge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICBsZXQgaSA9IHkuZ2V0RGF0YSh0aGlzLCB4aSk7XG4gICAgICBjb25zdCBuID0gdHlwZW9mIHQgPT0gXCJvYmplY3RcIiAmJiB0O1xuICAgICAgaWYgKCEoIWkgJiYgL2Rpc3Bvc2V8aGlkZS8udGVzdCh0KSkgJiYgKGkgfHwgKGkgPSBuZXcgJGgodGhpcywgbikpLCB0eXBlb2YgdCA9PSBcInN0cmluZ1wiKSkge1xuICAgICAgICBpZiAodHlwZW9mIGlbdF0gPiBcInVcIilcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBObyBtZXRob2QgbmFtZWQgXCIke3R9XCJgKTtcbiAgICAgICAgaVt0XShlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBzdGF0aWMgZ2V0SW5zdGFuY2UodCkge1xuICAgIHJldHVybiB5LmdldERhdGEodCwgeGkpO1xuICB9XG4gIHN0YXRpYyBnZXRPckNyZWF0ZUluc3RhbmNlKHQsIGUgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLmdldEluc3RhbmNlKHQpIHx8IG5ldyB0aGlzKHQsIHR5cGVvZiBlID09IFwib2JqZWN0XCIgPyBlIDogbnVsbCk7XG4gIH1cbn1cbmNvbnN0IE9DID0gKHMpID0+IHtcbiAgWmwoKCkgPT4ge1xuICAgIGNvbnN0IHQgPSBxbCgpO1xuICAgIGlmICh0KSB7XG4gICAgICBjb25zdCBlID0gcy5OQU1FLCBpID0gdC5mbltlXTtcbiAgICAgIHQuZm5bZV0gPSBzLmpRdWVyeUludGVyZmFjZSwgdC5mbltlXS5Db25zdHJ1Y3RvciA9IHMsIHQuZm5bZV0ubm9Db25mbGljdCA9ICgpID0+ICh0LmZuW2VdID0gaSwgcy5qUXVlcnlJbnRlcmZhY2UpO1xuICAgIH1cbiAgfSk7XG59LCBTQyA9IChzLCB0KSA9PiB7XG4gIGMub24oXG4gICAgZG9jdW1lbnQsXG4gICAgYGNsaWNrLnRlLiR7cy5OQU1FfWAsXG4gICAgdCxcbiAgICBmdW5jdGlvbihlKSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCksIHMuZ2V0T3JDcmVhdGVJbnN0YW5jZSh0aGlzKS50b2dnbGUoKTtcbiAgICB9XG4gICk7XG59LCBJQyA9IChzLCB0KSA9PiB7XG4gIGMub24oXG4gICAgZG9jdW1lbnQsXG4gICAgYGNsaWNrLnRlLiR7cy5OQU1FfS5kYXRhLWFwaWAsXG4gICAgdCxcbiAgICBmdW5jdGlvbihlKSB7XG4gICAgICBpZiAoW1wiQVwiLCBcIkFSRUFcIl0uaW5jbHVkZXModGhpcy50YWdOYW1lKSAmJiBlLnByZXZlbnREZWZhdWx0KCksIGdlKHRoaXMpKVxuICAgICAgICByZXR1cm47XG4gICAgICBzLmdldE9yQ3JlYXRlSW5zdGFuY2UodGhpcykuc2hvdygpO1xuICAgIH1cbiAgKTtcbn0sIERDID0gKHMsIHQpID0+IHtcbiAgYy5vbihcbiAgICBkb2N1bWVudCxcbiAgICBgY2xpY2sudGUuJHtzLk5BTUV9LmRhdGEtYXBpYCxcbiAgICB0LFxuICAgIGZ1bmN0aW9uKGUpIHtcbiAgICAgIGNvbnN0IGkgPSBKdCh0aGlzKTtcbiAgICAgIGlmIChbXCJBXCIsIFwiQVJFQVwiXS5pbmNsdWRlcyh0aGlzLnRhZ05hbWUpICYmIGUucHJldmVudERlZmF1bHQoKSwgZ2UodGhpcykpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGMub25lKGksIHMuRVZFTlRfSElEREVOLCAoKSA9PiB7XG4gICAgICAgIE50KHRoaXMpICYmIHRoaXMuZm9jdXMoKTtcbiAgICAgIH0pO1xuICAgICAgY29uc3QgbiA9IGQuZmluZE9uZShzLk9QRU5fU0VMRUNUT1IpO1xuICAgICAgbiAmJiBuICE9PSBpICYmIHMuZ2V0SW5zdGFuY2UobikuaGlkZSgpLCBzLmdldE9yQ3JlYXRlSW5zdGFuY2UoaSkudG9nZ2xlKHRoaXMpO1xuICAgIH1cbiAgKTtcbn0sICRDID0gKHMsIHQpID0+IHtcbiAgYy5vbihcbiAgICBkb2N1bWVudCxcbiAgICBgY2xpY2sudGUuJHtzLk5BTUV9YCxcbiAgICB0LFxuICAgIChlKSA9PiB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBjb25zdCBpID0gZS50YXJnZXQuY2xvc2VzdCh0KTtcbiAgICAgIHMuZ2V0T3JDcmVhdGVJbnN0YW5jZShpKS50b2dnbGUoKTtcbiAgICB9XG4gICk7XG59LCBMQyA9IChzLCB0KSA9PiB7XG4gIGMub24oXG4gICAgZG9jdW1lbnQsXG4gICAgYGNsaWNrLnRlLiR7cy5OQU1FfWAsXG4gICAgdCxcbiAgICBmdW5jdGlvbihlKSB7XG4gICAgICBjb25zdCBpID0gSnQodGhpcyk7XG4gICAgICBbXCJBXCIsIFwiQVJFQVwiXS5pbmNsdWRlcyh0aGlzLnRhZ05hbWUpICYmIGUucHJldmVudERlZmF1bHQoKSwgYy5vbmUoaSwgcy5FVkVOVF9TSE9XLCAocikgPT4ge1xuICAgICAgICByLmRlZmF1bHRQcmV2ZW50ZWQgfHwgYy5vbmUoaSwgcy5FVkVOVF9ISURERU4sICgpID0+IHtcbiAgICAgICAgICBOdCh0aGlzKSAmJiB0aGlzLmZvY3VzKCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICBjb25zdCBuID0gZC5maW5kT25lKFxuICAgICAgICBgWyR7cy5PUEVOX1NFTEVDVE9SfT1cInRydWVcIl1gXG4gICAgICApO1xuICAgICAgbiAmJiBzLmdldEluc3RhbmNlKG4pLmhpZGUoKSwgcy5nZXRPckNyZWF0ZUluc3RhbmNlKGkpLnRvZ2dsZSh0aGlzKTtcbiAgICB9XG4gICk7XG59LCBOQyA9IChzLCB0KSA9PiB7XG4gIGMub25lKFxuICAgIGRvY3VtZW50LFxuICAgIFwibW91c2Vkb3duXCIsXG4gICAgdCxcbiAgICBzLmF1dG9Jbml0aWFsKG5ldyBzKCkpXG4gICk7XG59LCBNQyA9IChzLCB0KSA9PiB7XG4gIGMub24oXG4gICAgZG9jdW1lbnQsXG4gICAgYGNsaWNrLnRlLiR7cy5OQU1FfS5kYXRhLWFwaWAsXG4gICAgdCxcbiAgICBmdW5jdGlvbihlKSB7XG4gICAgICAoZS50YXJnZXQudGFnTmFtZSA9PT0gXCJBXCIgfHwgZS5kZWxlZ2F0ZVRhcmdldCAmJiBlLmRlbGVnYXRlVGFyZ2V0LnRhZ05hbWUgPT09IFwiQVwiKSAmJiBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBjb25zdCBpID0gcW8odGhpcyk7XG4gICAgICBkLmZpbmQoaSkuZm9yRWFjaCgobykgPT4ge1xuICAgICAgICBzLmdldE9yQ3JlYXRlSW5zdGFuY2UobywgeyB0b2dnbGU6ICExIH0pLnRvZ2dsZSgpO1xuICAgICAgfSk7XG4gICAgfVxuICApO1xufSwgUkMgPSAocywgdCkgPT4ge1xuICBbXS5zbGljZS5jYWxsKFxuICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwodClcbiAgKS5tYXAoZnVuY3Rpb24oaSkge1xuICAgIHJldHVybiBuZXcgcyhpKTtcbiAgfSk7XG59LCBQQyA9IChzLCB0KSA9PiB7XG4gIFtdLnNsaWNlLmNhbGwoXG4gICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCh0KVxuICApLm1hcChmdW5jdGlvbihpKSB7XG4gICAgcmV0dXJuIG5ldyBzKGkpO1xuICB9KTtcbn0sIEJDID0gKHMsIHQpID0+IHtcbiAgZC5maW5kKHQpLmZvckVhY2goKGUpID0+IHtcbiAgICBuZXcgcyhlKTtcbiAgfSksIGMub24oXG4gICAgZG9jdW1lbnQsXG4gICAgYGNsaWNrLnRlLiR7cy5OQU1FfS5kYXRhLWFwaWAsXG4gICAgYCR7dH0gaW1nOm5vdChbZGF0YS10ZS1saWdodGJveC1kaXNhYmxlZF0pYCxcbiAgICBzLnRvZ2dsZSgpXG4gICk7XG59LCBIQyA9IChzLCB0KSA9PiB7XG4gIGNvbnN0IGUgPSAobykgPT4gb1swXSA9PT0gXCJ7XCIgJiYgb1tvLmxlbmd0aCAtIDFdID09PSBcIn1cIiB8fCBvWzBdID09PSBcIltcIiAmJiBvW28ubGVuZ3RoIC0gMV0gPT09IFwiXVwiLCBpID0gKG8pID0+IHR5cGVvZiBvICE9IFwic3RyaW5nXCIgPyBvIDogZShvKSA/IEpTT04ucGFyc2Uoby5yZXBsYWNlKC8nL2csICdcIicpKSA6IG8sIG4gPSAobykgPT4ge1xuICAgIGNvbnN0IHIgPSB7fTtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMobykuZm9yRWFjaCgoYSkgPT4ge1xuICAgICAgaWYgKGEubWF0Y2goL2RhdGFzZXQuKi8pKSB7XG4gICAgICAgIGNvbnN0IGwgPSBhLnNsaWNlKDcsIDgpLnRvTG93ZXJDYXNlKCkuY29uY2F0KGEuc2xpY2UoOCkpO1xuICAgICAgICByW2xdID0gaShvW2FdKTtcbiAgICAgIH1cbiAgICB9KSwgcjtcbiAgfTtcbiAgZC5maW5kKHQpLmZvckVhY2goKG8pID0+IHtcbiAgICBpZiAoaC5nZXREYXRhQXR0cmlidXRlKG8sIFwiY2hhcnRcIikgIT09IFwiYnViYmxlXCIgJiYgaC5nZXREYXRhQXR0cmlidXRlKG8sIFwiY2hhcnRcIikgIT09IFwic2NhdHRlclwiKSB7XG4gICAgICBjb25zdCByID0gaC5nZXREYXRhQXR0cmlidXRlcyhvKSwgYSA9IHtcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIGRhdGFzZXRzOiBbbihyKV1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHJldHVybiByLmNoYXJ0ICYmIChhLnR5cGUgPSByLmNoYXJ0KSwgci5sYWJlbHMgJiYgKGEuZGF0YS5sYWJlbHMgPSBKU09OLnBhcnNlKHIubGFiZWxzLnJlcGxhY2UoLycvZywgJ1wiJykpKSwgbmV3IHMobywge1xuICAgICAgICAuLi5hLFxuICAgICAgICAuLi5UaVthLnR5cGVdXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH0pO1xufTtcbmNsYXNzIFZDIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5pbml0cyA9IFtdO1xuICB9XG4gIGdldCBpbml0aWFsaXplZCgpIHtcbiAgICByZXR1cm4gdGhpcy5pbml0cztcbiAgfVxuICBpc0luaXRlZCh0KSB7XG4gICAgcmV0dXJuIHRoaXMuaW5pdHMuaW5jbHVkZXModCk7XG4gIH1cbiAgYWRkKHQpIHtcbiAgICB0aGlzLmlzSW5pdGVkKHQpIHx8IHRoaXMuaW5pdHMucHVzaCh0KTtcbiAgfVxufVxuY29uc3QgR28gPSBuZXcgVkMoKSwgT2kgPSB7XG4gIGFsZXJ0OiB7XG4gICAgbmFtZTogXCJBbGVydFwiLFxuICAgIHNlbGVjdG9yOiBcIltkYXRhLXRlLWFsZXJ0LWluaXRdXCIsXG4gICAgaXNUb2dnbGVyOiAhMVxuICB9LFxuICBhbmltYXRpb246IHtcbiAgICBuYW1lOiBcIkFuaW1hdGVcIixcbiAgICBzZWxlY3RvcjogXCJbZGF0YS10ZS1hbmltYXRpb24taW5pdF1cIixcbiAgICBpc1RvZ2dsZXI6ICExXG4gIH0sXG4gIGNhcm91c2VsOiB7XG4gICAgbmFtZTogXCJDYXJvdXNlbFwiLFxuICAgIHNlbGVjdG9yOiBcIltkYXRhLXRlLWNhcm91c2VsLWluaXRdXCIsXG4gICAgaXNUb2dnbGVyOiAhMVxuICB9LFxuICBjaGlwczoge1xuICAgIG5hbWU6IFwiQ2hpcHNJbnB1dFwiLFxuICAgIHNlbGVjdG9yOiBcIltkYXRhLXRlLWNoaXBzLWlucHV0LWluaXRdXCIsXG4gICAgaXNUb2dnbGVyOiAhMVxuICB9LFxuICBjaGlwOiB7XG4gICAgbmFtZTogXCJDaGlwXCIsXG4gICAgc2VsZWN0b3I6IFwiW2RhdGEtdGUtY2hpcC1pbml0XVwiLFxuICAgIGlzVG9nZ2xlcjogITEsXG4gICAgb25Jbml0OiBcImluaXRcIlxuICB9LFxuICBkYXRlcGlja2VyOiB7XG4gICAgbmFtZTogXCJEYXRlcGlja2VyXCIsXG4gICAgc2VsZWN0b3I6IFwiW2RhdGEtdGUtZGF0ZXBpY2tlci1pbml0XVwiLFxuICAgIGlzVG9nZ2xlcjogITFcbiAgfSxcbiAgZGF0ZXRpbWVwaWNrZXI6IHtcbiAgICBuYW1lOiBcIkRhdGV0aW1lcGlja2VyXCIsXG4gICAgc2VsZWN0b3I6IFwiW2RhdGEtdGUtZGF0ZS10aW1lcGlja2VyLWluaXRdXCIsXG4gICAgaXNUb2dnbGVyOiAhMVxuICB9LFxuICBpbnB1dDoge1xuICAgIG5hbWU6IFwiSW5wdXRcIixcbiAgICBzZWxlY3RvcjogXCJbZGF0YS10ZS1pbnB1dC13cmFwcGVyLWluaXRdXCIsXG4gICAgaXNUb2dnbGVyOiAhMVxuICB9LFxuICBwZXJmZWN0U2Nyb2xsYmFyOiB7XG4gICAgbmFtZTogXCJQZXJmZWN0U2Nyb2xsYmFyXCIsXG4gICAgc2VsZWN0b3I6IFwiW2RhdGEtdGUtcGVyZmVjdC1zY3JvbGxiYXItaW5pdF1cIixcbiAgICBpc1RvZ2dsZXI6ICExXG4gIH0sXG4gIHJhdGluZzoge1xuICAgIG5hbWU6IFwiUmF0aW5nXCIsXG4gICAgc2VsZWN0b3I6IFwiW2RhdGEtdGUtcmF0aW5nLWluaXRdXCIsXG4gICAgaXNUb2dnbGVyOiAhMVxuICB9LFxuICBzY3JvbGxzcHk6IHtcbiAgICBuYW1lOiBcIlNjcm9sbFNweVwiLFxuICAgIHNlbGVjdG9yOiBcIltkYXRhLXRlLXNweT0nc2Nyb2xsJ11cIixcbiAgICBpc1RvZ2dsZXI6ICExXG4gIH0sXG4gIHNlbGVjdDoge1xuICAgIG5hbWU6IFwiU2VsZWN0XCIsXG4gICAgc2VsZWN0b3I6IFwiW2RhdGEtdGUtc2VsZWN0LWluaXRdXCIsXG4gICAgaXNUb2dnbGVyOiAhMVxuICB9LFxuICBzaWRlbmF2OiB7XG4gICAgbmFtZTogXCJTaWRlbmF2XCIsXG4gICAgc2VsZWN0b3I6IFwiW2RhdGEtdGUtc2lkZW5hdi1pbml0XVwiLFxuICAgIGlzVG9nZ2xlcjogITFcbiAgfSxcbiAgc3RlcHBlcjoge1xuICAgIG5hbWU6IFwiU3RlcHBlclwiLFxuICAgIHNlbGVjdG9yOiBcIltkYXRhLXRlLXN0ZXBwZXItaW5pdF1cIixcbiAgICBpc1RvZ2dsZXI6ICExXG4gIH0sXG4gIHRpbWVwaWNrZXI6IHtcbiAgICBuYW1lOiBcIlRpbWVwaWNrZXJcIixcbiAgICBzZWxlY3RvcjogXCJbZGF0YS10ZS10aW1lcGlja2VyLWluaXRdXCIsXG4gICAgaXNUb2dnbGVyOiAhMVxuICB9LFxuICB0b2FzdDoge1xuICAgIG5hbWU6IFwiVG9hc3RcIixcbiAgICBzZWxlY3RvcjogXCJbZGF0YS10ZS10b2FzdC1pbml0XVwiLFxuICAgIGlzVG9nZ2xlcjogITFcbiAgfSxcbiAgZGF0YXRhYmxlOiB7XG4gICAgbmFtZTogXCJEYXRhdGFibGVcIixcbiAgICBzZWxlY3RvcjogXCJbZGF0YS10ZS1kYXRhdGFibGUtaW5pdF1cIlxuICB9LFxuICBwb3Bjb25maXJtOiB7XG4gICAgbmFtZTogXCJQb3Bjb25maXJtXCIsXG4gICAgc2VsZWN0b3I6IFwiW2RhdGEtdGUtdG9nZ2xlPSdwb3Bjb25maXJtJ11cIlxuICB9LFxuICB2YWxpZGF0aW9uOiB7XG4gICAgbmFtZTogXCJWYWxpZGF0aW9uXCIsXG4gICAgc2VsZWN0b3I6IFwiW2RhdGEtdGUtdmFsaWRhdGlvbi1pbml0XVwiXG4gIH0sXG4gIHNtb290aFNjcm9sbDoge1xuICAgIG5hbWU6IFwiU21vb3RoU2Nyb2xsXCIsXG4gICAgc2VsZWN0b3I6IFwiYVtkYXRhLXRlLXNtb290aC1zY3JvbGwtaW5pdF1cIlxuICB9LFxuICBsYXp5TG9hZDoge1xuICAgIG5hbWU6IFwiTGF6eUxvYWRcIixcbiAgICBzZWxlY3RvcjogXCJbZGF0YS10ZS1sYXp5LWxvYWQtaW5pdF1cIlxuICB9LFxuICBjbGlwYm9hcmQ6IHtcbiAgICBuYW1lOiBcIkNsaXBib2FyZFwiLFxuICAgIHNlbGVjdG9yOiBcIltkYXRhLXRlLWNsaXBib2FyZC1pbml0XVwiXG4gIH0sXG4gIGluZmluaXRlU2Nyb2xsOiB7XG4gICAgbmFtZTogXCJJbmZpbml0ZVNjcm9sbFwiLFxuICAgIHNlbGVjdG9yOiBcIltkYXRhLXRlLWluZmluaXRlLXNjcm9sbC1pbml0XVwiXG4gIH0sXG4gIGxvYWRpbmdNYW5hZ2VtZW50OiB7XG4gICAgbmFtZTogXCJMb2FkaW5nTWFuYWdlbWVudFwiLFxuICAgIHNlbGVjdG9yOiBcIltkYXRhLXRlLWxvYWRpbmctbWFuYWdlbWVudC1pbml0XVwiXG4gIH0sXG4gIHN0aWNreToge1xuICAgIG5hbWU6IFwiU3RpY2t5XCIsXG4gICAgc2VsZWN0b3I6IFwiW2RhdGEtdGUtc3RpY2t5LWluaXRdXCJcbiAgfSxcbiAgLy8gYWR2YW5jZWRJbml0c1xuICBjaGFydDoge1xuICAgIG5hbWU6IFwiQ2hhcnRcIixcbiAgICBzZWxlY3RvcjogXCJbZGF0YS10ZS1jaGFydF1cIixcbiAgICBpc1RvZ2dsZXI6ICExLFxuICAgIGFkdmFuY2VkOiBIQ1xuICB9LFxuICAvLyB0b2dnbGVyc1xuICBidXR0b246IHtcbiAgICBuYW1lOiBcIkJ1dHRvblwiLFxuICAgIHNlbGVjdG9yOiBcIltkYXRhLXRlLXRvZ2dsZT0nYnV0dG9uJ11cIixcbiAgICBpc1RvZ2dsZXI6ICEwLFxuICAgIGNhbGxiYWNrOiAkQ1xuICB9LFxuICBjb2xsYXBzZToge1xuICAgIG5hbWU6IFwiQ29sbGFwc2VcIixcbiAgICBzZWxlY3RvcjogXCJbZGF0YS10ZS1jb2xsYXBzZS1pbml0XVwiLFxuICAgIGlzVG9nZ2xlcjogITAsXG4gICAgY2FsbGJhY2s6IE1DXG4gIH0sXG4gIGRyb3Bkb3duOiB7XG4gICAgbmFtZTogXCJEcm9wZG93blwiLFxuICAgIHNlbGVjdG9yOiBcIltkYXRhLXRlLWRyb3Bkb3duLXRvZ2dsZS1yZWZdXCIsXG4gICAgaXNUb2dnbGVyOiAhMCxcbiAgICBjYWxsYmFjazogU0NcbiAgfSxcbiAgbW9kYWw6IHtcbiAgICBuYW1lOiBcIk1vZGFsXCIsXG4gICAgc2VsZWN0b3I6IFwiW2RhdGEtdGUtdG9nZ2xlPSdtb2RhbCddXCIsXG4gICAgaXNUb2dnbGVyOiAhMCxcbiAgICBjYWxsYmFjazogTENcbiAgfSxcbiAgcmlwcGxlOiB7XG4gICAgbmFtZTogXCJSaXBwbGVcIixcbiAgICBzZWxlY3RvcjogXCJbZGF0YS10ZS1yaXBwbGUtaW5pdF1cIixcbiAgICBpc1RvZ2dsZXI6ICEwLFxuICAgIGNhbGxiYWNrOiBOQ1xuICB9LFxuICBvZmZjYW52YXM6IHtcbiAgICBuYW1lOiBcIk9mZmNhbnZhc1wiLFxuICAgIHNlbGVjdG9yOiBcIltkYXRhLXRlLW9mZmNhbnZhcy10b2dnbGVdXCIsXG4gICAgaXNUb2dnbGVyOiAhMCxcbiAgICBjYWxsYmFjazogRENcbiAgfSxcbiAgdGFiOiB7XG4gICAgbmFtZTogXCJUYWJcIixcbiAgICBzZWxlY3RvcjogXCJbZGF0YS10ZS10b2dnbGU9J3RhYiddLCBbZGF0YS10ZS10b2dnbGU9J3BpbGwnXSwgW2RhdGEtdGUtdG9nZ2xlPSdsaXN0J11cIixcbiAgICBpc1RvZ2dsZXI6ICEwLFxuICAgIGNhbGxiYWNrOiBJQ1xuICB9LFxuICB0b29sdGlwOiB7XG4gICAgbmFtZTogXCJUb29sdGlwXCIsXG4gICAgc2VsZWN0b3I6IFwiW2RhdGEtdGUtdG9nZ2xlPSd0b29sdGlwJ11cIixcbiAgICBpc1RvZ2dsZXI6ICExLFxuICAgIGNhbGxiYWNrOiBSQ1xuICB9LFxuICBwb3BvdmVyOiB7XG4gICAgbmFtZTogXCJQb3BvdmVyXCIsXG4gICAgc2VsZWN0b3I6IFwiW2RhdGEtdGUtdG9nZ2xlPSdwb3BvdmVyJ11cIixcbiAgICBpc1RvZ2dsZXI6ICEwLFxuICAgIGNhbGxiYWNrOiBQQ1xuICB9LFxuICBsaWdodGJveDoge1xuICAgIG5hbWU6IFwiTGlnaHRib3hcIixcbiAgICBzZWxlY3RvcjogXCJbZGF0YS10ZS1saWdodGJveC1pbml0XVwiLFxuICAgIGlzVG9nZ2xlcjogITAsXG4gICAgY2FsbGJhY2s6IEJDXG4gIH0sXG4gIHRvdWNoOiB7XG4gICAgbmFtZTogXCJUb3VjaFwiLFxuICAgIHNlbGVjdG9yOiBcIltkYXRhLXRlLXRvdWNoLWluaXRdXCJcbiAgfVxufSwgV0MgPSAocykgPT4gT2lbcy5OQU1FXSB8fCBudWxsLCBGQyA9IChzLCB0KSA9PiB7XG4gIGlmICghcyB8fCAhdC5hbGxvd1JlaW5pdHMgJiYgR28uaXNJbml0ZWQocy5OQU1FKSlcbiAgICByZXR1cm47XG4gIEdvLmFkZChzLk5BTUUpO1xuICBjb25zdCBlID0gV0MocyksIGkgPSAoZSA9PSBudWxsID8gdm9pZCAwIDogZS5pc1RvZ2dsZXIpIHx8ICExO1xuICBpZiAoT0MocyksIGUgIT0gbnVsbCAmJiBlLmFkdmFuY2VkKSB7XG4gICAgZSA9PSBudWxsIHx8IGUuYWR2YW5jZWQocywgZSA9PSBudWxsID8gdm9pZCAwIDogZS5zZWxlY3Rvcik7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChpKSB7XG4gICAgZSA9PSBudWxsIHx8IGUuY2FsbGJhY2socywgZSA9PSBudWxsID8gdm9pZCAwIDogZS5zZWxlY3Rvcik7XG4gICAgcmV0dXJuO1xuICB9XG4gIGQuZmluZChlID09IG51bGwgPyB2b2lkIDAgOiBlLnNlbGVjdG9yKS5mb3JFYWNoKChuKSA9PiB7XG4gICAgbGV0IG8gPSBzLmdldEluc3RhbmNlKG4pO1xuICAgIG8gfHwgKG8gPSBuZXcgcyhuKSwgZSAhPSBudWxsICYmIGUub25Jbml0ICYmIG9bZS5vbkluaXRdKCkpO1xuICB9KTtcbn0sIFlDID0gKHMsIHQpID0+IHtcbiAgcy5mb3JFYWNoKChlKSA9PiBGQyhlLCB0KSk7XG59LCBqQyA9IHtcbiAgYWxsb3dSZWluaXRzOiAhMSxcbiAgY2hlY2tPdGhlckltcG9ydHM6ICExXG59LCBaQyA9IChzLCB0ID0ge30pID0+IHtcbiAgdCA9IHsgLi4uakMsIC4uLnQgfTtcbiAgY29uc3QgZSA9IE9iamVjdC5rZXlzKE9pKS5tYXAoKGkpID0+IHtcbiAgICBpZiAoISFkb2N1bWVudC5xdWVyeVNlbGVjdG9yKE9pW2ldLnNlbGVjdG9yKSkge1xuICAgICAgY29uc3QgbyA9IHNbT2lbaV0ubmFtZV07XG4gICAgICByZXR1cm4gIW8gJiYgIUdvLmlzSW5pdGVkKGkpICYmIHQuY2hlY2tPdGhlckltcG9ydHMgJiYgY29uc29sZS53YXJuKFxuICAgICAgICBgUGxlYXNlIGltcG9ydCAke09pW2ldLm5hbWV9IGZyb20gXCJ0dy1lbGVtZW50c1wiIHBhY2thZ2UgYW5kIGFkZCBpdCB0byBhIG9iamVjdCBwYXJhbWV0ZXIgaW5zaWRlIFwiaW5pdFRFXCIgZnVuY3Rpb25gXG4gICAgICApLCBvO1xuICAgIH1cbiAgfSk7XG4gIFlDKGUsIHQpO1xufTtcbmV4cG9ydCB7XG4gIExvIGFzIEFsZXJ0LFxuICBwciBhcyBBbmltYXRlLFxuICByYyBhcyBCdXR0b24sXG4gIFV0IGFzIENhcm91c2VsLFxuICBkaCBhcyBDaGFydCxcbiAgX2kgYXMgQ2hpcCxcbiAgR0MgYXMgQ2hpcHNJbnB1dCxcbiAgd2ggYXMgQ2xpcGJvYXJkLFxuICBadCBhcyBDb2xsYXBzZSxcbiAgZ2ggYXMgRGF0YXRhYmxlLFxuICBObSBhcyBEYXRlcGlja2VyLFxuICBJaCBhcyBEYXRldGltZXBpY2tlcixcbiAgRHQgYXMgRHJvcGRvd24sXG4gIGtoIGFzIEluZmluaXRlU2Nyb2xsLFxuICBWIGFzIElucHV0LFxuICBVbyBhcyBMYXp5TG9hZCxcbiAgWnMgYXMgTGlnaHRib3gsXG4gIHhoIGFzIExvYWRpbmdNYW5hZ2VtZW50LFxuICBObyBhcyBNb2RhbCxcbiAgQnMgYXMgT2ZmY2FudmFzLFxuICBtaCBhcyBQZXJmZWN0U2Nyb2xsYmFyLFxuICB2aCBhcyBQb3Bjb25maXJtLFxuICBSYyBhcyBQb3BvdmVyLFxuICBxQyBhcyBSYXRpbmcsXG4gIFplIGFzIFJpcHBsZSxcbiAgSGMgYXMgU2Nyb2xsU3B5LFxuICBfciBhcyBTZWxlY3QsXG4gIGdpIGFzIFNpZGVuYXYsXG4gIHloIGFzIFNtb290aFNjcm9sbCxcbiAgWEMgYXMgU3RlcHBlcixcbiAgJGggYXMgU3RpY2t5LFxuICBWYyBhcyBUYWIsXG4gIG5nIGFzIFRpbWVwaWNrZXIsXG4gIFJvIGFzIFRvYXN0LFxuICBpaSBhcyBUb29sdGlwLFxuICBBaCBhcyBUb3VjaCxcbiAgQ2ggYXMgVmFsaWRhdGlvbixcbiAgWkMgYXMgaW5pdFRFXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHctZWxlbWVudHMuZXMubWluLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/tw-elements/dist/js/tw-elements.es.min.js\n"));

/***/ })

}]);